(*
Created:
Wed Feb 11 22:42:55 EST 2004

 The object identifier assigned to this schema is:
                { 1 0 10303 210 wd1_48 1 1 }

 Using part 21 of ISO 10303, the file_schema entity will be as follows:

    FILE_SCHEMA (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN { 1 0 10303 210 wd1_48 1 1 }'));
*)
(* ************************************************************************** *)


SCHEMA electronic_assembly_interconnect_and_packaging_design '{ 1 0 10303 210 wd1_48 1 1 }';



(* ***********************************
Constants in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   CONSTANT
      dummy_tri : topological_representation_item := representation_item('') || topological_representation_item();
      dummy_gri : geometric_representation_item := representation_item('') || geometric_representation_item();
      the_reals : elementary_space := make_elementary_space(es_reals);
      the_complex_numbers : elementary_space := make_elementary_space(es_complex_numbers);
      the_empty_space : finite_space := make_finite_space([]);
      the_generics : elementary_space := make_elementary_space(es_generics);
      the_integer_tuples : extended_tuple_space := make_extended_tuple_space(the_zero_tuple_space,

 the_integers);
      schema_prefix : STRING := 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.';
      the_booleans : elementary_space := make_elementary_space(es_booleans);
      the_empty_maths_tuple : maths_tuple := [];
      the_integers : elementary_space := make_elementary_space(es_integers);
      the_logicals : elementary_space := make_elementary_space(es_logicals);
      the_strings : elementary_space := make_elementary_space(es_strings);
      the_numbers : elementary_space := make_elementary_space(es_numbers);
      the_zero_tuple_space : listed_product_space := make_listed_product_space([]);
      the_real_tuples : extended_tuple_space := make_extended_tuple_space(the_zero_tuple_space,

 the_reals);
      the_nonnegative_reals : real_interval_from_min := make_real_interval_from_min(0.00000,

 closed);
      the_neg1_one_interval : finite_real_interval := make_finite_real_interval(-1.00000,

 closed,

 1.00000,

 closed);
      the_complex_tuples : extended_tuple_space := make_extended_tuple_space(the_zero_tuple_space,

 the_complex_numbers);
      the_maths_spaces : elementary_space := make_elementary_space(es_maths_spaces);
      the_binarys : elementary_space := make_elementary_space(es_binarys);
      the_tuples : extended_tuple_space := make_extended_tuple_space(the_zero_tuple_space,

 the_generics);
   END_CONSTANT;


(* ***********************************
Entities in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   ENTITY SQL_mappable_defined_function
   ABSTRACT SUPERTYPE
   SUBTYPE OF (defined_function);
   END_ENTITY;



   ENTITY abs_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY absorbed_dose_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\absorbed_dose_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = gray;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY abstracted_expression_function
   SUBTYPE OF (maths_function,

 quantifier_expression);
   DERIVE
      SELF\quantifier_expression.variables : LIST [1:?] OF UNIQUE generic_variable := remove_first(SELF\multiple_arity_generic_expression.operands);
      expr : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
   WHERE
      WR1:
         SIZEOF(QUERY (operand <* SELF\multiple_arity_generic_expression.operands| NOT has_values_space(operand))) = 0;
   END_ENTITY;



   ENTITY acos_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY across_port_variable
   SUBTYPE OF (port_variable);
   END_ENTITY;



   ENTITY action;
      name : label;
      description : OPTIONAL text;
      chosen_method : action_method;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY action_assignment
   ABSTRACT SUPERTYPE;
      assigned_action : action;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY action_directive;
      name : label;
      description : OPTIONAL text;
      analysis : text;
      comment : text;
      requests : SET [1:?] OF versioned_action_request;
   END_ENTITY;



   ENTITY action_method;
      name : label;
      description : OPTIONAL text;
      consequence : text;
      purpose : text;
   END_ENTITY;



   ENTITY action_method_relationship;
      name : label;
      description : OPTIONAL text;
      relating_method : action_method;
      related_method : action_method;
   END_ENTITY;



   ENTITY action_property;
      name : label;
      description : text;
      definition : characterized_action_definition;
   END_ENTITY;



   ENTITY action_relationship;
      name : label;
      description : OPTIONAL text;
      relating_action : action;
      related_action : action;
   END_ENTITY;



   ENTITY action_request_assignment
   ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY action_request_solution;
      method : action_method;
      request : versioned_action_request;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY action_request_status;
      status : label;
      assigned_request : versioned_action_request;
   END_ENTITY;



   ENTITY action_resource;
      name : label;
      description : OPTIONAL text;
      usage : SET [1:?] OF supported_item;
      kind : action_resource_type;
   END_ENTITY;



   ENTITY action_resource_relationship;
      name : label;
      description : OPTIONAL text;
      relating_resource : action_resource;
      related_resource : action_resource;
   END_ENTITY;



   ENTITY action_resource_requirement;
      name : label;
      description : text;
      kind : resource_requirement_type;
      operations : SET [1:?] OF characterized_action_definition;
   END_ENTITY;



   ENTITY action_resource_requirement_relationship;
      name : label;
      description : text;
      relating_action_resource_requirement : action_resource_requirement;
      related_action_resource_requirement : action_resource_requirement;
   WHERE
      WR1:
         relating_action_resource_requirement :<>: related_action_resource_requirement;
   END_ENTITY;



   ENTITY action_resource_type;
      name : label;
   END_ENTITY;



   ENTITY action_status;
      status : label;
      assigned_action : executed_action;
   END_ENTITY;



   ENTITY activity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\activity_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = becquerel;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY add_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object addition'))) = 1;
   END_ENTITY;



   ENTITY add_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object addition'))) = 1;
   END_ENTITY;



   ENTITY address;
      internal_location : OPTIONAL label;
      street_number : OPTIONAL label;
      street : OPTIONAL label;
      postal_box : OPTIONAL label;
      town : OPTIONAL label;
      region : OPTIONAL label;
      postal_code : OPTIONAL label;
      country : OPTIONAL label;
      facsimile_number : OPTIONAL label;
      telephone_number : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number : OPTIONAL label;
   DERIVE
      name : label := get_name_value(SELF);
      url : identifier := get_id_value(SELF);
   WHERE
      WR1:
         ((((((((((EXISTS(internal_location) OR EXISTS(street_number)) OR EXISTS(street)) OR EXISTS(postal_box)) OR EXISTS(town)) OR EXISTS(region)) OR EXISTS(postal_code)) OR EXISTS(country)) OR EXISTS(facsimile_number)) OR EXISTS(telephone_number)) OR EXISTS(electronic_mail_address)) OR EXISTS(telex_number);
   END_ENTITY;



   ENTITY advanced_brep_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fcs)))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (msb <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\manifold_solid_brep.outer)))) = 0;
      WR5:
         SIZEOF(QUERY (brv <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation)) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (mi <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
   END_ENTITY;



   ENTITY advanced_face
   SUBTYPE OF (face_surface);
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' ] * TYPEOF(face_geometry)) = 1;
      WR2:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe.edge_start\vertex_point.vertex_geometry))) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_end)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe.edge_end\vertex_point.vertex_geometry)))))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' IN TYPEOF(elp_fbnds.bound)))) = 0;
      WR6:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' ] * TYPEOF(face_geometry\swept_surface.swept_curve)) = 1);
      WR7:
         SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) = 0;
      WR8:
         SIZEOF(QUERY (bnd <* SELF.bounds| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' ] * TYPEOF(bnd.bound)) = 1))) = 0;
      WR9:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(QUERY (sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(sc_ag)))) = 0))) = 0))) = 0;
      WR10:
         (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(face_geometry\swept_surface.swept_curve)) OR (SIZEOF(face_geometry\swept_surface.swept_curve\polyline.points) < 3))) AND (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(oe.edge_element\edge_curve.edge_geometry\polyline.points) < 3))) = 0))) = 0);
   END_ENTITY;



   ENTITY altered_package_terminal
   ABSTRACT SUPERTYPE OF ((shape_formed_terminal ANDOR

 surface_prepped_terminal) ANDOR

 length_trimmed_terminal)
   SUBTYPE OF (package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'terminal to be altered'))) = 1;
      WR2:
         SELF.of_shape.definition\product_definition.description = 'altered package';
   END_ENTITY;



   ENTITY alternate_product_relationship;
      name : label;
      definition : OPTIONAL text;
      alternate : product;
      base : product;
      basis : text;
   UNIQUE
      UR1 : alternate,

 base;
   WHERE
      WR1:
         alternate :<>: base;
   END_ENTITY;



   ENTITY amount_of_substance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY amount_of_substance_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY analog_analytical_model_port
   SUBTYPE OF (analytical_model_port);
   END_ENTITY;



   ENTITY analytical_model
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 2;
      WR2:
         SIZEOF(QUERY (dr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (dr.assigned_document.kind\document_type.product_data_type = 'language reference manual'))) = 1;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER' IN TYPEOF(it)))) = 0;
      WR4:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr\representation_relationship.name = 'access mechanism') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(rr.rep_2)))) >= 1;
   END_ENTITY;



   ENTITY analytical_model_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\analytical_model_definition)) = 0;
   END_ENTITY;



   ENTITY analytical_model_make_from_relationship
   SUBTYPE OF (representation,

 representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,

 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL') ] * TYPEOF(SELF.rep_1)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL') ] * TYPEOF(SELF.rep_2)) = 1;
      WR3:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2)))) = 0;
      WR4:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT ((rr\representation_relationship.name = 'associated make from') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2))))) = 0;
      WR5:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL') ] * TYPEOF(SELF)) = 0;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\analytical_model_make_from_relationship)) = 0;
   END_ENTITY;



   ENTITY analytical_model_parameter
   SUBTYPE OF (model_parameter);
   WHERE
      WR1:
         SIZEOF(QUERY (cri <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(cri)))) = 1;
   END_ENTITY;



   ENTITY analytical_model_port
   SUPERTYPE OF (analytical_model_vector_port ANDOR

 ONEOF(analog_analytical_model_port,

 digital_analytical_model_port))
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (am <* QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr\representation_relationship.name = 'access mechanism'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(am.rep_1)))) = 1;
   END_ENTITY;



   ENTITY analytical_model_scalar_port
   SUBTYPE OF (analytical_model_vector_port);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'size')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COUNT_MEASURE' IN TYPEOF(it\measure_with_unit.value_component))) AND (it\measure_with_unit.value_component = 1))) = 1;
   END_ENTITY;



   ENTITY analytical_model_vector_port
   SUBTYPE OF (analytical_model_port);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'size')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COUNT_MEASURE' IN TYPEOF(it\measure_with_unit.value_component))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONTEXT_DEPENDENT_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 1;
   END_ENTITY;



   ENTITY analytical_representation
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))) >= 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1)))) = 1;
   END_ENTITY;



   ENTITY and_expression
   SUBTYPE OF (multiple_arity_Boolean_expression);
   END_ENTITY;



   ENTITY angular_dimension_with_orientation
   SUBTYPE OF (dimensional_location);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.description = 'angular';
   END_ENTITY;



   ENTITY angular_location
   SUBTYPE OF (dimensional_location);
      angle_selection : angle_relator;
   END_ENTITY;



   ENTITY angular_size
   SUBTYPE OF (dimensional_size);
      angle_selection : angle_relator;
   END_ENTITY;



   ENTITY angularity_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'angularity';
   END_ENTITY;



   ENTITY annotation_curve_occurrence
   SUBTYPE OF (annotation_occurrence);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(SELF\styled_item.item);
   END_ENTITY;



   ENTITY annotation_fill_area
   SUBTYPE OF (geometric_representation_item);
      boundaries : SET [1:?] OF curve;
   END_ENTITY;



   ENTITY annotation_fill_area_occurrence
   SUBTYPE OF (annotation_occurrence);
      fill_style_target : point;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_FILL_AREA' IN TYPEOF(SELF.item);
   END_ENTITY;



   ENTITY annotation_occurrence
   SUPERTYPE OF (ONEOF(annotation_curve_occurrence,

 annotation_fill_area_occurrence,

 annotation_text_occurrence,

 annotation_symbol_occurrence))
   SUBTYPE OF (styled_item);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_symbol
   SUBTYPE OF (mapped_item);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_REPRESENTATION_MAP' IN TYPEOF(SELF\mapped_item.mapping_source);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_TARGET' IN TYPEOF(SELF\mapped_item.mapping_target);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_symbol_occurrence
   SUBTYPE OF (annotation_occurrence);
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_SYMBOL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_SYMBOL' ] * TYPEOF(SELF\styled_item.item)) > 0;
   END_ENTITY;



   ENTITY annotation_text
   SUBTYPE OF (mapped_item);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(SELF\mapped_item.mapping_target);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_STRING_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_text_character
   SUBTYPE OF (mapped_item);
      alignment : text_alignment;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTER_GLYPH_SYMBOL' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(SELF\mapped_item.mapping_target);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_text_occurrence
   SUBTYPE OF (annotation_occurrence);
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT' ] * TYPEOF(SELF\styled_item.item)) > 0;
   END_ENTITY;



   ENTITY apex
   SUBTYPE OF (derived_shape_aspect);
   END_ENTITY;



   ENTITY application_context;
      application : label;
   DERIVE
      description : text := get_description_value(SELF);
      id : identifier := get_id_value(SELF);
   INVERSE
      context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY application_context_element
   SUPERTYPE OF (ONEOF(product_concept_context,

 product_context,

 product_definition_context));
      name : label;
      frame_of_reference : application_context;
   END_ENTITY;



   ENTITY application_defined_function
   SUBTYPE OF (maths_function);
      explicit_domain : tuple_space;
      explicit_range : tuple_space;
      parameters : LIST OF maths_value;
   WHERE
      WR1:
         expression_is_constant(explicit_domain);
      WR2:
         expression_is_constant(explicit_range);
   END_ENTITY;



   ENTITY application_protocol_definition;
      status : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year : year_number;
      application : application_context;
   END_ENTITY;



   ENTITY applied_action_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_assigned_item;
   END_ENTITY;



   ENTITY applied_approval_assignment
   SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_assigned_item;
   END_ENTITY;



   ENTITY applied_certification_assignment
   SUBTYPE OF (certification_assignment);
      items : SET [1:?] OF certification_assigned_item;
   END_ENTITY;



   ENTITY applied_classification_assignment
   SUBTYPE OF (group_assignment);
      items : SET [1:?] OF classification_assigned_item;
   END_ENTITY;



   ENTITY applied_contract_assignment
   SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contract_assigned_item;
   END_ENTITY;



   ENTITY applied_date_and_time_assignment
   SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_assigned_item;
   WHERE
      WR1:
         applied_date_time_correlation(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
      WR2:
         NOT (SELF.role\date_time_role.name = 'participant date and time') OR (SIZEOF(QUERY (ra <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION' IN TYPEOF(it)))| NOT (SIZEOF(USEDIN(ra,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')) = 1))) = 0);
   END_ENTITY;



   ENTITY applied_date_assignment
   SUBTYPE OF (date_assignment);
      items : SET [1:?] OF date_assigned_item;
   WHERE
      WR1:
         applied_date_correlation(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
   END_ENTITY;



   ENTITY applied_document_reference
   SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_assigned_item;
   END_ENTITY;



   ENTITY applied_group_assignment
   SUBTYPE OF (group_assignment);
      items : SET [1:?] OF group_assigned_item;
   END_ENTITY;



   ENTITY applied_identification_assignment
   SUBTYPE OF (identification_assignment);
      items : SET [1:?] OF identification_item;
   END_ENTITY;



   ENTITY applied_organization_assignment
   SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_assigned_item;
   END_ENTITY;



   ENTITY applied_person_and_organization_assignment
   SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_assigned_item;
   END_ENTITY;



   ENTITY applied_person_assignment
   SUBTYPE OF (person_assignment);
      items : SET [1:?] OF person_assigned_item;
   END_ENTITY;



   ENTITY applied_promissory_usage_in_product_model_assignment
   SUBTYPE OF (group_assignment);
      items : SET [1:?] OF promissory_usage_in_product_model_assigned_item;
   WHERE
      WR1:
         SIZEOF(QUERY (pm <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_CONCEPT' IN TYPEOF(pm)))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(pd)))) = 1;
      WR3:
         SIZEOF(items) = 2;
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROMISSORY_USAGE_IN_PRODUCT_MODEL' IN TYPEOF(SELF\group_assignment.assigned_group);
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) <= 1;
   END_ENTITY;



   ENTITY applied_security_classification_assignment
   SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF security_classification_assigned_item;
   END_ENTITY;



   ENTITY approval;
      status : approval_status;
      level : label;
   END_ENTITY;



   ENTITY approval_assignment
   ABSTRACT SUPERTYPE;
      assigned_approval : approval;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY approval_date_time;
      date_time : date_time_select;
      dated_approval : approval;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role : approval_role;
   END_ENTITY;



   ENTITY approval_relationship;
      name : label;
      description : OPTIONAL text;
      relating_approval : approval;
      related_approval : approval;
   END_ENTITY;



   ENTITY approval_role;
      role : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY approval_status;
      name : label;
   END_ENTITY;



   ENTITY area_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY area_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 2.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY array_placement_group_component_definition
   SUPERTYPE OF (ONEOF(linear_array_placement_group_component_definition,

 rectangular_array_placement_group_component_definition))
   SUBTYPE OF (assembly_group_component_definition);
   END_ENTITY;



   ENTITY array_placement_group_component_shape_aspect
   SUPERTYPE OF (ONEOF(linear_array_placement_group_component_shape_aspect,

 rectangular_array_placement_group_component_shape_aspect))
   SUBTYPE OF (assembly_group_component_shape_aspect);
   END_ENTITY;



   ENTITY asin_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY assembly_bond_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
      WR2:
         SIZEOF(QUERY (aga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BOND_CATEGORY' IN TYPEOF(aga.assigned_group)))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 1'))) = 1;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 2'))) = 1;
      WR5:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SIZEOF(QUERY (prpc <* USEDIN(SELF.of_shape.definition.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'technology specific model'))) >= 1);
      WR6:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.name = 'assembly bond model');
   END_ENTITY;



   ENTITY assembly_component_usage
   SUPERTYPE OF (ONEOF(next_assembly_usage_occurrence,

 specified_higher_usage_occurrence,

 promissory_usage_occurrence))
   SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
   END_ENTITY;



   ENTITY assembly_component_usage_substitute;
      name : label;
      definition : OPTIONAL text;
      base : assembly_component_usage;
      substitute : assembly_component_usage;
   UNIQUE
      UR1 : base,

 substitute;
   WHERE
      WR1:
         base.relating_product_definition :=: substitute.relating_product_definition;
      WR2:
         base :<>: substitute;
   END_ENTITY;



   ENTITY assembly_definition
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'assembly module');
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'assembly module'))) = 1);
      WR4:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
   END_ENTITY;



   ENTITY assembly_group_component_definition
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         (SIZEOF(QUERY (gc <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'group component'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(gc.related_product_definition)))) >= 1) OR (SIZEOF(QUERY (agcsa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(agcsa)))) = 0);
      WR2:
         (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (acu <* USEDIN(aj\shape_aspect_relationship.relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) >= 1))) >= 1);
      WR3:
         (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (acu <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) = 0))) = 0);
      WR4:
         (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (cl <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION' IN TYPEOF(cl)) AND (aj IN cl\representation.items))) = 0))) = 0);
   END_ENTITY;



   ENTITY assembly_group_component_definition_placement_link
   SUBTYPE OF (product_definition,

 product_definition_relationship);
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\assembly_group_component_definition_placement_link)) = 0;
      WR5:
         SELF\product_definition.name = '';
      WR6:
         SELF\product_definition_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
   END_ENTITY;



   ENTITY assembly_group_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (gc <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'group component'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(gc.related_shape_aspect)))) >= 1;
   END_ENTITY;



   ENTITY assembly_group_component_shape_aspect_placement_link
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\assembly_group_component_shape_aspect_placement_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY assembly_joint
   SUBTYPE OF (shape_aspect_relationship,

 shape_aspect);
   WHERE
      WR1:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect)) AND (SELF.relating_shape_aspect\shape_aspect.description IN [ 'assembly module component terminal',

 'bare die component terminal',

 'interconnect component join terminal',

 'interconnect module component terminal',

 'package terminal occurrence',

 'packaged component join terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN TYPEOF(SELF.relating_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
      WR2:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description IN [ 'assembly module component terminal',

 'bare die component terminal',

 'interconnect component join terminal',

 'interconnect module component terminal',

 'package terminal occurrence',

 'packaged component join terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN TYPEOF(SELF.relating_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(SELF.related_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
      WR3:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with bonding') OR (SIZEOF(QUERY (ddu <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'default definition usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect)))) = 1);
      WR4:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with bonding') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'bond assembly position') AND (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'assembly position'))) = 1))) = 1))) <= 1);
      WR5:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with fasteners') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
      WR6:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) OR is_assembly_module_design(SELF.of_shape.definition);
      WR7:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with bonding') OR (SIZEOF(QUERY (ddu <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'default definition usage'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect)) AND (SIZEOF(QUERY (sar <* USEDIN(ddu.relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 1'))) = 1)) AND (SIZEOF(QUERY (sar <* USEDIN(ddu.relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 1'))) = 1))) = 1);
      WR8:
         acyclic_shape_aspect_relationship(SELF,

 [ SELF\shape_aspect_relationship.related_shape_aspect ],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT');
   END_ENTITY;



   ENTITY assembly_module_interface_terminal
   SUBTYPE OF (assembly_module_terminal);
   END_ENTITY;



   ENTITY assembly_module_join_terminal
   SUBTYPE OF (assembly_module_terminal);
   END_ENTITY;



   ENTITY assembly_module_macro_component_join_terminal
   SUBTYPE OF (component_terminal);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'bare die component terminal',

 'component termination passage join terminal',

 'conductive interconnect element terminal',

 'interconnect component join terminal',

 'interconnect module component terminal',

 'land join terminal',

 'minimally defined component terminal',

 'non functional land join terminal',

 'packaged component join terminal',

 'printed component join terminal',

 'package terminal occurrence',

 'via terminal' ]);
   END_ENTITY;



   ENTITY assembly_module_terminal
   SUPERTYPE OF (ONEOF(assembly_module_interface_terminal,

 assembly_module_join_terminal))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR (SELF.of_shape.definition\product_definition.name = 'assembly module');
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR4:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR5:
         NOT (SELF\shape_aspect.description = 'pca terminal') OR (SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION') ]) >= 1) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design usage');
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
      WR7:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'interface terminal'))) <= 1;
   END_ENTITY;



   ENTITY atan_function
   SUBTYPE OF (binary_function_call);
   END_ENTITY;



   ENTITY atom_based_literal
   SUBTYPE OF (generic_literal);
      lit_value : atom_based_value;
   END_ENTITY;



   ENTITY auxiliary_characteristic_dimension_representation
   SUBTYPE OF (dimensional_characteristic_representation);
   END_ENTITY;



   ENTITY axis1_placement
   SUBTYPE OF (placement);
      axis : OPTIONAL direction;
   DERIVE
      z : direction := NVL(normalise(axis),

 dummy_gri || direction([ 0.00000,

 0.00000,

 1.00000 ]));
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
   DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
      axis : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
   DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,

 ref_direction);
   WHERE
      WR1:
         SELF\placement.location.dim = 3;
      WR2:
         NOT EXISTS(axis) OR (axis.dim = 3);
      WR3:
         NOT EXISTS(ref_direction) OR (ref_direction.dim = 3);
      WR4:
         (NOT EXISTS(axis) OR NOT EXISTS(ref_direction)) OR (cross_product(axis,

 ref_direction).magnitude > 0.00000);
   END_ENTITY;



   ENTITY b_spline_basis
   SUBTYPE OF (maths_function,

 generic_literal);
      degree : nonnegative_integer;
      repeated_knots : LIST [2:?] OF REAL;
   DERIVE
      order : positive_integer := degree + 1;
      num_basis : positive_integer := SIZEOF(repeated_knots) - order;
   WHERE
      WR1:
         num_basis >= order;
      WR2:
         nondecreasing(repeated_knots);
      WR3:
         repeated_knots[order] < repeated_knots[(num_basis + 1)];
   END_ENTITY;



   ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF(uniform_curve,

 b_spline_curve_with_knots,

 quasi_uniform_curve,

 bezier_curve) ANDOR

 rational_b_spline_curve)
   SUBTYPE OF (bounded_curve);
      degree : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form : b_spline_curve_form;
      closed_curve : LOGICAL;
      self_intersect : LOGICAL;
   DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(control_points_list) - 1;
      control_points : ARRAY [0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,

 0,

 upper_index_on_control_points);
   WHERE
      WR1:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BEZIER_CURVE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots : LIST [2:?] OF parameter_value;
      knot_spec : knot_type;
   DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
   WHERE
      WR1:
         constraints_param_b_spline(degree,

 upper_index_on_knots,

 upper_index_on_control_points,

 knot_multiplicities,

 knots);
      WR2:
         SIZEOF(knot_multiplicities) = upper_index_on_knots;
   END_ENTITY;



   ENTITY b_spline_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      basis : LIST [1:?] OF b_spline_basis;
   DERIVE
      coef : maths_function := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         function_is_table(coef);
      WR2:
         (space_dimension(coef.range) = 1) AND (number_superspace_of(factor1(coef.range)) = the_reals);
      WR3:
         SIZEOF(basis) <= SIZEOF(shape_of_array(coef));
      WR4:
         compare_basis_and_coef(basis,

 coef);
   END_ENTITY;



   ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF(b_spline_surface_with_knots,

 uniform_surface,

 quasi_uniform_surface,

 bezier_surface) ANDOR

 rational_b_spline_surface)
   SUBTYPE OF (bounded_surface);
      u_degree : INTEGER;
      v_degree : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form : b_spline_surface_form;
      u_closed : LOGICAL;
      v_closed : LOGICAL;
      self_intersect : LOGICAL;
   DERIVE
      u_upper : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF cartesian_point := make_array_of_array(control_points_list,

 0,

 u_upper,

 0,

 v_upper);
   WHERE
      WR1:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots : LIST [2:?] OF parameter_value;
      v_knots : LIST [2:?] OF parameter_value;
      knot_spec : knot_type;
   DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
   WHERE
      WR1:
         constraints_param_b_spline(SELF\b_spline_surface.u_degree,

 knot_u_upper,

 SELF\b_spline_surface.u_upper,

 u_multiplicities,

 u_knots);
      WR2:
         constraints_param_b_spline(SELF\b_spline_surface.v_degree,

 knot_v_upper,

 SELF\b_spline_surface.v_upper,

 v_multiplicities,

 v_knots);
      WR3:
         SIZEOF(u_multiplicities) = knot_u_upper;
      WR4:
         SIZEOF(v_multiplicities) = knot_v_upper;
   END_ENTITY;



   ENTITY banded_matrix
   SUBTYPE OF (linearized_table_function);
      default_entry : maths_value;
      below : INTEGER;
      above : INTEGER;
      order : ordering_type;
   WHERE
      WR1:
         SIZEOF(SELF\explicit_table_function.shape) = 2;
      WR2:
         -below <= above;
      WR3:
         member_of(default_entry,

 factor1(SELF\linearized_table_function.source.range));
   END_ENTITY;



   ENTITY bare_die
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (ifdu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\property_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition)) AND (ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'device unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0;
   END_ENTITY;



   ENTITY bare_die_bottom_surface
   SUBTYPE OF (bare_die_surface);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\bare_die_bottom_surface || SELF\part_mounting_feature || SELF\bare_die_surface)) = 0;
   END_ENTITY;



   ENTITY bare_die_edge_segment_surface
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect)))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\bare_die_edge_segment_surface)) = 0;
   END_ENTITY;



   ENTITY bare_die_edge_surface
   SUBTYPE OF (bare_die_surface);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\part_mounting_feature || SELF\bare_die_edge_surface || SELF\bare_die_surface)) = 0;
   END_ENTITY;



   ENTITY bare_die_surface
   ABSTRACT SUPERTYPE OF (ONEOF(bare_die_bottom_surface,

 bare_die_top_surface,

 bare_die_edge_surface))
   SUBTYPE OF (part_mounting_feature);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
   END_ENTITY;



   ENTITY bare_die_terminal
   SUBTYPE OF (minimally_defined_bare_die_terminal);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'external connection area'))| (eca.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
      WR4:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'seating plane zone'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY bare_die_top_surface
   SUBTYPE OF (bare_die_surface);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\part_mounting_feature || SELF\bare_die_top_surface || SELF\bare_die_surface)) = 0;
   END_ENTITY;



   ENTITY basic_sparse_matrix
   SUBTYPE OF (explicit_table_function,

 multiple_arity_generic_expression);
      SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
      default_entry : maths_value;
      order : ordering_type;
   DERIVE
      index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
      loc : maths_function := SELF\multiple_arity_generic_expression.operands[2];
      val : maths_function := SELF\multiple_arity_generic_expression.operands[3];
   WHERE
      WR1:
         function_is_1d_table(index);
      WR2:
         function_is_1d_table(loc);
      WR3:
         function_is_1d_table(val);
      WR4:
         check_sparse_index_domain(index.domain,

 index_base,

 shape,

 order);
      WR5:
         check_sparse_index_to_loc(index.range,

 loc.domain);
      WR6:
         loc.domain = val.domain;
      WR7:
         check_sparse_loc_range(loc.range,

 index_base,

 shape,

 order);
      WR8:
         member_of(default_entry,

 val.range);
   END_ENTITY;



   ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY binary_boolean_expression
   ABSTRACT SUPERTYPE OF (ONEOF(xor_expression,

 equals_expression))
   SUBTYPE OF (boolean_expression,

 binary_generic_expression);
   END_ENTITY;



   ENTITY binary_function_call
   ABSTRACT SUPERTYPE OF (atan_function)
   SUBTYPE OF (binary_numeric_expression);
   END_ENTITY;



   ENTITY binary_generic_expression
   ABSTRACT SUPERTYPE
   SUBTYPE OF (generic_expression);
      operands : LIST [2:2] OF generic_expression;
   END_ENTITY;



   ENTITY binary_literal
   SUBTYPE OF (generic_literal);
      lit_value : BINARY;
   END_ENTITY;



   ENTITY binary_numeric_expression
   ABSTRACT SUPERTYPE OF (ONEOF(minus_expression,

 div_expression,

 mod_expression,

 slash_expression,

 power_expression,

 binary_function_call))
   SUBTYPE OF (numeric_expression,

 binary_generic_expression);
      SELF\binary_generic_expression.operands : LIST [2:2] OF numeric_expression;
   END_ENTITY;



   ENTITY block
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x : positive_length_measure;
      y : positive_length_measure;
      z : positive_length_measure;
   END_ENTITY;



   ENTITY bond_category
   SUBTYPE OF (group,

 external_definition);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY boolean_defined_function
   ABSTRACT SUPERTYPE
   SUBTYPE OF (defined_function,

 boolean_expression);
   END_ENTITY;



   ENTITY boolean_expression
   ABSTRACT SUPERTYPE OF (ONEOF(simple_boolean_expression,

 unary_boolean_expression,

 binary_boolean_expression,

 multiple_arity_Boolean_expression,

 comparison_expression,

 interval_expression,

 boolean_defined_function))
   SUBTYPE OF (expression);
   END_ENTITY;



   ENTITY boolean_literal
   SUBTYPE OF (simple_boolean_expression,

 generic_literal);
      the_value : BOOLEAN;
   END_ENTITY;



   ENTITY boolean_result
   SUBTYPE OF (geometric_representation_item);
      operator : boolean_operator;
      first_operand : boolean_operand;
      second_operand : boolean_operand;
   END_ENTITY;



   ENTITY boolean_variable
   SUBTYPE OF (simple_boolean_expression,

 variable);
   END_ENTITY;



   ENTITY bound_variable_semantics
   SUBTYPE OF (variable_semantics);
   END_ENTITY;



   ENTITY boundary_curve
   SUBTYPE OF (composite_curve_on_surface);
   WHERE
      WR1:
         SELF\composite_curve.closed_curve;
   END_ENTITY;



   ENTITY bounded_curve
   SUPERTYPE OF (ONEOF(polyline,

 b_spline_curve,

 trimmed_curve,

 bounded_pcurve,

 bounded_surface_curve,

 composite_curve))
   SUBTYPE OF (curve);
   END_ENTITY;



   ENTITY bounded_pcurve
   SUBTYPE OF (pcurve,

 bounded_curve);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]);
   END_ENTITY;



   ENTITY bounded_surface
   SUPERTYPE OF (ONEOF(b_spline_surface,

 rectangular_trimmed_surface,

 curve_bounded_surface,

 rectangular_composite_surface))
   SUBTYPE OF (surface);
   END_ENTITY;



   ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve,

 bounded_curve);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d);
   END_ENTITY;



   ENTITY box_domain
   SUBTYPE OF (founded_item);
      corner : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      zlength : positive_length_measure;
   WHERE
      WR1:
         SIZEOF(QUERY (item <* USEDIN(SELF,

 '')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0;
   END_ENTITY;



   ENTITY boxed_half_space
   SUBTYPE OF (half_space_solid);
      enclosure : box_domain;
   END_ENTITY;



   ENTITY brep_with_voids
   SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
   END_ENTITY;



   ENTITY bus_element_link
   SUBTYPE OF (product_definition,

 product_definition_relationship);
   UNIQUE
      UR1 : SELF\product_definition_relationship.related_product_definition,

 SELF\product_definition_relationship.relating_product_definition;
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition));
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition));
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\bus_element_link)) = 0;
      WR5:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = '');
      WR6:
         SELF\product_definition_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) >= 1;
   END_ENTITY;



   ENTITY bus_structural_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (bce <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'bus composition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_ELEMENT_LINK' IN TYPEOF(bce.related_product_definition)))) >= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment'))) <= 1))) <= 1;
      WR3:
         consistent_bus_structural_definition(bag_to_set(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_ELEMENT_LINK' IN TYPEOF(pdr.related_product_definition))));
   END_ENTITY;



   ENTITY cable_component
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1;
      WR2:
         SELF\product_definition.description :<>: 'laminate component';
   END_ENTITY;



   ENTITY cable_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CABLE_USAGE_VIEW' IN TYPEOF(SELF.of_shape.definition);
   END_ENTITY;



   ENTITY cable_usage_view
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CABLE_TERMINAL' IN TYPEOF(sa)))) >= 1))) = 0;
      WR2:
         SELF.frame_of_reference.name IN [ 'physical design usage' ];
   END_ENTITY;



   ENTITY calendar_date
   SUBTYPE OF (date);
      day_component : day_in_month_number;
      month_component : month_in_year_number;
   WHERE
      WR1:
         valid_calendar_date(SELF);
   END_ENTITY;



   ENTITY capacitance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\capacitance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = farad;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY cartesian_complex_number_region
   SUBTYPE OF (maths_space,

 generic_literal);
      real_constraint : real_interval;
      imag_constraint : real_interval;
   WHERE
      WR1:
         ((min_exists(real_constraint) OR max_exists(real_constraint)) OR min_exists(imag_constraint)) OR max_exists(imag_constraint);
   END_ENTITY;



   ENTITY cartesian_point
   SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
   END_ENTITY;



   ENTITY cartesian_transformation_operator
   SUPERTYPE OF (ONEOF(cartesian_transformation_operator_2d,

 cartesian_transformation_operator_3d))
   SUBTYPE OF (geometric_representation_item,

 functionally_defined_transformation);
      axis1 : OPTIONAL direction;
      axis2 : OPTIONAL direction;
      local_origin : cartesian_point;
      scale : OPTIONAL REAL;
   DERIVE
      scl : REAL := NVL(scale,

 1.00000);
   WHERE
      WR1:
         scl > 0.00000;
   END_ENTITY;



   ENTITY cartesian_transformation_operator_2d
   SUBTYPE OF (cartesian_transformation_operator);
   DERIVE
      u : LIST [2:2] OF direction := base_axis(2,

 SELF\cartesian_transformation_operator.axis1,

 SELF\cartesian_transformation_operator.axis2,

 ?);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
   DERIVE
      u : LIST [3:3] OF direction := base_axis(3,

 SELF\cartesian_transformation_operator.axis1,

 SELF\cartesian_transformation_operator.axis2,

 axis3);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY category_model_parameter
   SUBTYPE OF (model_parameter);
   END_ENTITY;



   ENTITY celsius_temperature_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY centre_of_symmetry
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sadr <* deriving_relationships| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMMETRIC_SHAPE_ASPECT' IN TYPEOF(sadr.related_shape_aspect)))) = 0;
   END_ENTITY;



   ENTITY certification;
      name : label;
      purpose : text;
      kind : certification_type;
   END_ENTITY;



   ENTITY certification_assignment
   ABSTRACT SUPERTYPE;
      assigned_certification : certification;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY certification_type;
      description : label;
   END_ENTITY;



   ENTITY change
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIRECTED_ACTION' IN TYPEOF(SELF.assigned_action);
      WR2:
         unique_version_change_order(SELF.assigned_action,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
   END_ENTITY;



   ENTITY change_from_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_assignment.assigned_action,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_TO_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
   END_ENTITY;



   ENTITY change_from_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_request_assignment.assigned_action_request,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_TO_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
   END_ENTITY;



   ENTITY change_request
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF change_request_item;
   END_ENTITY;



   ENTITY change_to_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_assignment.assigned_action,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_FROM_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
      WR2:
         SIZEOF(QUERY (pdr <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'design object change'))) = 1;
   END_ENTITY;



   ENTITY change_to_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_request_assignment.assigned_action_request,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_FROM_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
      WR2:
         SIZEOF(QUERY (pdr <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'design object change'))) = 1;
   END_ENTITY;



   ENTITY character_glyph_font_usage;
      character : character_glyph_symbol;
      font : text_font;
   END_ENTITY;



   ENTITY character_glyph_style_outline;
      outline_style : curve_style;
   END_ENTITY;



   ENTITY character_glyph_style_stroke;
      stroke_style : curve_style;
   END_ENTITY;



   ENTITY character_glyph_symbol
   SUBTYPE OF (symbol_representation);
      character_box : planar_extent;
      baseline_ratio : ratio_measure;
   DERIVE
      box_height : length_measure := character_box.size_in_y;
   WHERE
      WR1:
         (0.00000 <= baseline_ratio) AND (baseline_ratio <= 1.00000);
      WR2:
         item_in_context(SELF.character_box,

 SELF\representation.context_of_items);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(SELF.box_height);
   END_ENTITY;



   ENTITY character_glyph_symbol_outline
   SUBTYPE OF (character_glyph_symbol);
      outlines : SET [1:?] OF annotation_fill_area;
   WHERE
      WR1:
         SELF.outlines <= SELF\representation.items;
   END_ENTITY;



   ENTITY characteristic_type
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'string property',

 'logical property',

 'boolean property',

 'numeric property',

 'physical property',

 'externally defined property',

 'polar complex numeric property',

 'compound characteristic' ];
   END_ENTITY;



   ENTITY characterized_object;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY characterized_product_category
   SUBTYPE OF (characterized_object,

 product_category);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'product category values') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) <= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'product category parameters') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (ri <* pdr.used_representation.items| NOT (SIZEOF(TYPEOF(ri) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER') ]) = 1))) = 0))) >= 1))) <= 1;
      WR3:
         SELF\characterized_object.name = SELF\product_category.name;
      WR4:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY circle
   SUBTYPE OF (conic);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY circular_area
   SUBTYPE OF (primitive_2d);
      centre : cartesian_point;
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY circular_runout_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'circular runout';
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR3:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'referenced datum system definition') AND (pdr.related_property_definition\property_definition.description = 'datum system property without material conditions'))) = 1;
   END_ENTITY;



   ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
   END_ENTITY;



   ENTITY colour;
   END_ENTITY;



   ENTITY colour_rgb
   SUBTYPE OF (colour_specification);
      red : REAL;
      green : REAL;
      blue : REAL;
   WHERE
      WR1:
         (0.00000 <= red) AND (red <= 1.00000);
      WR2:
         (0.00000 <= green) AND (green <= 1.00000);
      WR3:
         (0.00000 <= blue) AND (blue <= 1.00000);
   END_ENTITY;



   ENTITY colour_specification
   SUBTYPE OF (colour);
      name : label;
   END_ENTITY;



   ENTITY comparison_equal
   SUBTYPE OF (comparison_expression);
   END_ENTITY;



   ENTITY comparison_expression
   ABSTRACT SUPERTYPE OF (ONEOF(comparison_equal,

 comparison_greater,

 comparison_greater_equal,

 comparison_less,

 comparison_less_equal,

 comparison_not_equal,

 like_expression))
   SUBTYPE OF (boolean_expression,

 binary_generic_expression);
      SELF\binary_generic_expression.operands : LIST [2:2] OF expression;
   WHERE
      WR1:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[2])) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOOLEAN_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOOLEAN_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[2]))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[2]));
   END_ENTITY;



   ENTITY comparison_greater
   SUBTYPE OF (comparison_expression);
   END_ENTITY;



   ENTITY comparison_greater_equal
   SUBTYPE OF (comparison_expression);
   END_ENTITY;



   ENTITY comparison_less
   SUBTYPE OF (comparison_expression);
   END_ENTITY;



   ENTITY comparison_less_equal
   SUBTYPE OF (comparison_expression);
   END_ENTITY;



   ENTITY comparison_not_equal
   SUBTYPE OF (comparison_expression);
   END_ENTITY;



   ENTITY complex_number_literal
   SUBTYPE OF (generic_literal);
      real_part : REAL;
      imag_part : REAL;
   END_ENTITY;



   ENTITY component_definition
   SUPERTYPE OF ((ONEOF(printed_component,

 packaged_component,

 routed_physical_component) ANDOR

 thermal_component) ANDOR

 cable_component)
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR3:
         NOT (SELF\product_definition.description = 'bare die component') OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1);
      WR4:
         NOT is_assembly_module_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (ip.relating_product_definition\product_definition.name = 'assembly module'))) = 1);
      WR5:
         NOT is_assembly_module_occurrence(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'assembly module component terminal'))) >= 2))) >= 1);
      WR6:
         NOT is_interconnect_module_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (SELF\product_definition.name = 'interconnect module'))) = 1);
      WR7:
         NOT (SELF\product_definition.description = 'mating connector') OR ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) AND (SIZEOF(QUERY (doc <* SELF\product_definition_with_associated_documents.documentation_ids| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(doc)))) = 1) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'part template occurrence'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'printed connector template'))) = 1))) = 1))) = 0)) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition\product_definition.description = 'packaged connector'))) = 1));
      WR8:
         NOT (SELF\product_definition.description = 'mating connector') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'mating connector placement'))) = 1))) = 1);
      WR9:
         NOT (SELF\product_definition.description = 'mating connector') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr)))) = 0) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr)))) = 0);
      WR10:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| NOT (NOT (pdr\product_definition_relationship.name = 'instantiated part') OR (SELF.formation :=: pdr.relating_product_definition.formation)))) = 0;
      WR11:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| ((sr_pdr.used_representation\representation.name = 'part template non planar 2d shape') OR (sr_pdr.used_representation\representation.name = 'non planar 2d shape')) OR (sr_pdr.used_representation\representation.name = 'open shell based surface'))) <= 1))) = 0;
      WR12:
         NOT ((SELF.frame_of_reference.name = 'layout occurrence') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_COMPONENT' IN TYPEOF(SELF))) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(sa)) >= 1))) = 1))) = 0);
      WR13:
         NOT is_assembly_module_macro_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design definition'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design')) AND (ip.relating_product_definition\product_definition.name = 'assembly module'))) = 1);
      WR14:
         NOT is_interconnect_module_macro_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design definition'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design')) AND (ip.relating_product_definition\product_definition.name = 'interconnect module'))) = 1);
      WR15:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated definition') AND NOT (SELF.formation :=: pdr.relating_product_definition.formation))) = 0;
      WR16:
         NOT (SELF\product_definition.description = 'routed interconnect component') OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1) AND (SELF.frame_of_reference.name = 'physical occurrence');
   END_ENTITY;



   ENTITY component_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
   END_ENTITY;



   ENTITY component_feature_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\component_feature_relationship)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
   END_ENTITY;



   ENTITY component_functional_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(it.relating_shape_aspect)))) = 1;
      WR3:
         SIZEOF(QUERY (futba <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit terminal bus assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(futba.relating_property_definition.definition)))) <= 1;
      WR4:
         SIZEOF(QUERY (futna <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit terminal node assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(futna.relating_property_definition.definition)))) <= 1;
   END_ENTITY;



   ENTITY component_functional_unit
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'functional occurrence';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL' IN TYPEOF(sa)))) >= 1))) >= 1;
      WR3:
         SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated functional unit'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)))) = 1;
      WR4:
         SIZEOF(QUERY (nc <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'network composition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(nc.relating_product_definition)) AND (nc.relating_product_definition.frame_of_reference.name = 'functional network design'))) = 1;
   END_ENTITY;



   ENTITY component_interface_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interconnect component interface terminal',

 'packaged connector component interface terminal' ];
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design usage'))) <= 1;
      WR5:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
      WR6:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence');
      WR7:
         NOT (SELF\shape_aspect.description = 'interconnect component interface terminal') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1) AND NOT (SELF.of_shape.definition\product_definition.description IN [ 'assembly module component',

 'bare die component',

 'interconnect module component',

 'laminate component',

 'packaged component' ]);
      WR8:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR SELF.product_definitional;
      WR9:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'packaged connector component')) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence');
      WR10:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'interface terminal'))) = 1);
   END_ENTITY;



   ENTITY component_location
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'placement fixed')) AND ((it\descriptive_representation_item.description = 'true') OR (it\descriptive_representation_item.description = 'false')))) = 1;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 1;
      WR3:
         NOT (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(it)))) = 1);
      WR4:
         NOT (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3) OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) = 1);
      WR5:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)))) = 1;
      WR6:
         NOT (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(it)))) = 1) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND (SIZEOF(QUERY (mi <* USEDIN(cto2d,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM.MAPPING_TARGET')| (SIZEOF(QUERY (cl <* USEDIN(mi,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (cl = SELF))) = 1))) >= 1))) = 1);
      WR7:
         NOT (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) = 1) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(cto2d)) AND (SIZEOF(QUERY (mi <* USEDIN(cto2d,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM.MAPPING_TARGET')| (SIZEOF(QUERY (cl <* USEDIN(mi,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (cl = SELF))) = 1))) = 1))) = 1);
      WR8:
         NOT (((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component surface')) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'mounting surface assembly joint')) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar.relating_shape_aspect\shape_aspect.description = 'interconnect module primary surface') OR (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge surface')) OR (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge segment surface'))) = 1))) = 1)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 1.00000,

 0.00100000))) = 1);
      WR9:
         NOT (((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component surface')) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'mounting surface assembly joint')) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module secondary surface'))) = 1))) = 1)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 -1.00000,

 0.00100000))) = 1);
      WR10:
         NOT is_laminate_component_location(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 0);
      WR11:
         NOT (is_laminate_component_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 1.00000,

 0.00100000))) = 1);
      WR12:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition\shape_aspect.description = 'interconnect module component surface feature'))) = 0;
      WR13:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component stacked')) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 0);
      WR14:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component edge')) OR (NOT is_laminate_component_location(SELF) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'reference terminal assembly joint')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(pdr.definition.definition.related_shape_aspect))) AND (pdr.definition.definition.related_shape_aspect\shape_aspect.description IN [ 'packaged component join terminal',

 'package terminal occurrence' ])) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.related_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sar.relating_shape_aspect)))) = 1)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))) AND (component_definition_located_by_component_location(SELF) = pdr.definition.definition.related_shape_aspect.of_shape.definition))) = 1)) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'mounting surface assembly joint')) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge surface') OR (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge segment surface'))) = 1)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(pdr.definition.definition.related_shape_aspect))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))) AND (component_definition_located_by_component_location(SELF) = pdr.definition.definition.related_shape_aspect.of_shape.definition))) = 1);
      WR15:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component stacked')) OR NOT is_laminate_component_location(SELF) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND ('mounting joint' = pdr.name)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(pdr.definition.definition.related_shape_aspect))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))) AND (component_definition_located_by_component_location(SELF) :=: pdr.definition.definition.related_shape_aspect.of_shape.definition)) AND (component_definition_located_by_component_location(SELF) :<>: pdr.definition.definition.relating_shape_aspect.of_shape.definition))) = 1);
      WR16:
         NOT is_interconnect_module_component_location(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 0);
      WR17:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component stacked')) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND (cto2d_determinant_test(cto2d,

 1.00000,

 0.00100000) OR cto2d_determinant_test(cto2d,

 -1.00000,

 0.00100000)))) = 1);
      WR18:
         SIZEOF(QUERY (it <* SELF\representation.items| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D') ] * TYPEOF(it)) = 1))) = 0;
      WR19:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)) AND (it\representation_item.name = 'origin'))) = 0;
      WR20:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)) AND NOT ((((it\representation_item.name = 'component assembly 2d position') OR (it\representation_item.name = 'component assembly 3d position')) AND (it.mapping_source.mapping_origin\representation_item.name = 'origin')) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(it.mapping_source.mapping_origin)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it.mapping_source.mapping_origin)))))) = 0;
      WR21:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr.definition.definition)))) = 1;
      WR22:
         NOT (is_top_footprint_occurrence_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 1.00000,

 0.00100000))) = 1);
      WR23:
         NOT (is_bottom_footprint_occurrence_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 -1.00000,

 0.00100000))) = 1);
      WR24:
         NOT (is_symmetrical_footprint_occurrence_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 1.00000,

 0.00100000))) = 1);
      WR25:
         NOT (is_top_padstack_occurrence_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 1.00000,

 0.00100000))) = 1);
      WR26:
         NOT (is_bottom_padstack_occurrence_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 -1.00000,

 0.00100000))) = 1);
      WR27:
         NOT (is_symmetrical_padstack_occurrence_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,

 1.00000,

 0.00100000))) = 1);
   END_ENTITY;



   ENTITY component_mating_constraint_condition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,

 SELF\shape_aspect.of_shape;
   END_ENTITY;



   ENTITY component_mounting_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND') ] * TYPEOF(SELF)) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR5:
         NOT (SELF\shape_aspect.description IN [ 'component feature' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design usage'))) <= 1);
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
   END_ENTITY;



   ENTITY component_shape_aspect
   SUPERTYPE OF (ONEOF(land,

 connected_area_component,

 inter_stratum_feature) ANDOR

 thermal_component_shape_aspect)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FIDUCIAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTED_AREA_COMPONENT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'THERMAL_COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTEGRAL_SHIELD'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND') ] * TYPEOF(SELF)) >= 1) OR (SELF\shape_aspect.description IN [ 'part template occurrence',

 'laminate component',

 'laminate text component',

 'laminate text string component',

 'conductive interconnect element with pre defined transitions',

 'join 2 physical connectivity definition supporting',

 'conductive interconnect element with user defined single transition',

 'special symbol laminate component',

 'primary stratum indicator symbol',

 'stratum feature template component' ]);
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR5:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'laminate text component',

 'laminate text string component',

 'special symbol laminate component',

 'primary stratum indicator symbol',

 'stratum feature template component' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'laminate component'));
      WR6:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'laminate text component') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEXT_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)))) = 1));
      WR7:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'stratum feature template component' ]) OR (SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) = 1));
      WR8:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'conductive interconnect element with pre defined transitions',

 'join 2 physical connectivity definition supporting',

 'conductive interconnect element with ' + 'user defined single transition' ]) OR (SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed conductor'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(cc.related_shape_aspect)))) = 1));
      WR10:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'special symbol laminate component',

 'primary stratum indicator symbol' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.description = 'special symbol part template'))) = 1));
      WR11:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'stratum feature template component') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'stratum feature template') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) <= 1));
      WR12:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'laminate text component' ]) OR (SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) >= 1));
      WR13:
         NOT ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FIDUCIAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTED_AREA_COMPONENT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'THERMAL_COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTEGRAL_SHIELD'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND') ] * TYPEOF(SELF)) >= 1) OR (SELF\shape_aspect.description IN [ 'laminate component',

 'laminate text component',

 'laminate text string component',

 'conductive interconnect element with pre defined transitions',

 'join 2 physical connectivity definition supporting',

 'conductive interconnect element with user defined single transition',

 'special symbol laminate component',

 'primary stratum indicator symbol',

 'stratum feature template component' ])) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference\application_context_element.name = 'layout occurrence');
      WR14:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))) <= 1;
      WR15:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'join 2 physical connectivity definition supporting') OR (SIZEOF(QUERY (propd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (ri <* QUERY (propdr <* USEDIN(propd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (propdr\property_definition_relationship.name = 'requirement implementation'))| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(ri.relating_property_definition.definition)) AND (ri.relating_property_definition.definition\shape_aspect_relationship.name = 'ordered physical connectivity definition')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(ri.relating_property_definition.definition.related_shape_aspect))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(ri.relating_property_definition.definition.relating_shape_aspect)))) = 1))) = 1));
   END_ENTITY;



   ENTITY component_terminal
   SUPERTYPE OF (ONEOF(assembly_module_macro_component_join_terminal,

 interconnect_module_macro_component_join_terminal))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         ((SELF\shape_aspect.description IN [ 'assembly module component terminal',

 'bare die component terminal',

 'component termination passage join terminal',

 'conductive interconnect element terminal',

 'interconnect component join terminal',

 'interconnect module component terminal',

 'land join terminal',

 'minimally defined component terminal',

 'non functional land join terminal',

 'packaged component join terminal',

 'printed component join terminal',

 'package terminal occurrence',

 'via terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN TYPEOF(SELF));
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
      WR4:
         SIZEOF(QUERY (at <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(at.relating_shape_aspect)))) <= 1;
      WR5:
         SIZEOF(QUERY (cr <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connectivity requirement'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK' IN TYPEOF(cr.relating_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design usage'))) <= 1;
      WR7:
         NOT (SELF\shape_aspect.description IN [ 'assembly module component terminal',

 'bare die component terminal',

 'package terminal occurrence',

 'packaged component join terminal',

 'printed component join terminal' ]) OR SELF.product_definitional;
      WR8:
         NOT (SELF\shape_aspect.description = 'assembly module component terminal') OR ((SELF.of_shape.definition.frame_of_reference.name = 'physical occurrence') AND EXISTS(SELF.of_shape.definition\product_definition.name)) AND (NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR (SELF.of_shape.definition\product_definition.name = 'assembly module'));
      WR9:
         NOT (SELF\shape_aspect.description = 'assembly module component terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))) = 1);
      WR10:
         NOT (SELF\shape_aspect.description = 'bare die component terminal') OR (SELF.of_shape.definition\product_definition.description = 'bare die component');
      WR11:
         NOT (SELF\shape_aspect.description = 'bare die component terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description = 'component termination passage join terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description = 'component termination passage template join terminal'))) = 1);
      WR15:
         NOT (SELF\shape_aspect.description IN [ 'conductive interconnect element terminal',

 'interconnect component join terminal',

 'printed component join terminal' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1);
      WR16:
         NOT (SELF\shape_aspect.description = 'interconnect module component terminal') OR ((SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence') AND EXISTS(SELF.of_shape.definition\product_definition.name)) AND (NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR (SELF.of_shape.definition\product_definition.name = 'interconnect module'));
      WR17:
         NOT (SELF\shape_aspect.description = 'interconnect module component terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))) = 1);
      WR18:
         NOT (SELF\shape_aspect.description IN [ 'land join terminal',

 'non functional land join terminal' ]) OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND TRUE)) = 1);
      WR20:
         NOT (SELF\shape_aspect.description = 'minimally defined terminal') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'part terminal external reference'))) = 1);
      WR22:
         NOT (SELF\shape_aspect.description = 'package terminal occurrence') OR (SIZEOF(QUERY (ud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'usage definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(ud.relating_shape_aspect)))) = 1);
      WR23:
         NOT (SELF\shape_aspect.description IN [ 'package terminal occurrence',

 'packaged component join terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence');
      WR24:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'join terminal'))) = 1);
      WR25:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) <= 2))) <= 1))) <= 1);
      WR26:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'maximum wire length'))) <= 1))) <= 1))) <= 1);
      WR27:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'minimum wire length'))) <= 1))) <= 1))) <= 1);
      WR28:
         NOT (SELF\shape_aspect.description = 'printed component join terminal') OR (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'layout occurrence') AND (SELF.of_shape.definition\product_definition.name = 'interconnect module');
      WR29:
         NOT (SELF\shape_aspect.description = 'printed component join terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'join terminal'))) = 1);
      WR30:
         NOT (SELF\shape_aspect.description = 'printed component join terminal') OR (SIZEOF(QUERY (i <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (pdr\shape_aspect_relationship.name = 'implementation'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(i.relating_shape_aspect)) >= 1) AND (i.relating_shape_aspect\shape_aspect.description = 'stratum feature template component'))) = 1);
      WR32:
         NOT (SELF\shape_aspect.description = 'via terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description = 'via template terminal'))) = 1);
      WR33:
         NOT (SELF\shape_aspect.description = 'interconnect component join terminal') OR (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence') AND NOT (SELF.of_shape.definition\product_definition.description IN [ 'assembly module component',

 'bare die component',

 'interconnect module component',

 'laminate component',

 'packaged component' ]);
      WR34:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (dri <* pdr.used_representation.items| (dri\representation_item.name = 'global swappable') AND (dri\descriptive_representation_item.description IN [ 'true',

 'false' ]))) = 1))) = 1))) <= 1;
      WR35:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (dri <* pdr.used_representation.items| (dri\representation_item.name = 'local swappable') AND (dri\descriptive_representation_item.description IN [ 'true',

 'false' ]))) = 1))) = 1))) <= 1;
      WR36:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (dri <* pdr.used_representation.items| (dri\representation_item.name = 'swap code'))) = 1))) = 1))) <= 1;
   END_ENTITY;



   ENTITY composite_array_shape_aspect
   SUPERTYPE OF (ONEOF(linear_composite_array_shape_aspect,

 rectangular_composite_array_shape_aspect))
   SUBTYPE OF (composite_shape_aspect);
   END_ENTITY;



   ENTITY composite_array_shape_aspect_link
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\composite_array_shape_aspect_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
      segments : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
   DERIVE
      n_segments : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
   WHERE
      WR1:
         NOT closed_curve AND (SIZEOF(QUERY (temp <* segments| (temp.transition = discontinuous))) = 1) OR closed_curve AND (SIZEOF(QUERY (temp <* segments| (temp.transition = discontinuous))) = 0);
   END_ENTITY;



   ENTITY composite_curve_on_surface
   SUPERTYPE OF (boundary_curve)
   SUBTYPE OF (composite_curve);
   DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
   WHERE
      WR1:
         SIZEOF(basis_surface) > 0;
      WR2:
         constraints_composite_curve_on_surface(SELF);
   END_ENTITY;



   ENTITY composite_curve_segment
   SUBTYPE OF (founded_item);
      transition : transition_code;
      same_sense : BOOLEAN;
      parent_curve : curve;
   INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' IN TYPEOF(parent_curve);
   END_ENTITY;



   ENTITY composite_group_shape_aspect
   SUBTYPE OF (composite_shape_aspect);
   END_ENTITY;



   ENTITY composite_shape_aspect
   SUBTYPE OF (shape_aspect);
   INVERSE
      component_relationships : SET [2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
   END_ENTITY;



   ENTITY composite_signal_property_relationship
   SUBTYPE OF (property_definition,

 property_definition_relationship);
   WHERE
      WR1:
         SELF\property_definition_relationship.related_property_definition.definition :<>: SELF\property_definition_relationship.relating_property_definition.definition;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship || SELF\composite_signal_property_relationship || SELF\property_definition)) = 0;
      WR3:
         SELF\property_definition_relationship.related_property_definition.name = 'signal property';
      WR4:
         SELF\property_definition_relationship.relating_property_definition.name = 'composite signal property';
      WR5:
         SELF\property_definition.name = '';
      WR6:
         SELF\property_definition.description = '';
      WR7:
         SELF\property_definition_relationship.name = '';
      WR8:
         SELF\property_definition_relationship.description = '';
      WR9:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) AND (SELF\property_definition.definition.description = 'aggregate operation');
      WR10:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNAL_DEFINITION' IN TYPEOF(SELF\property_definition.definition);
   END_ENTITY;



   ENTITY composite_text
   SUBTYPE OF (geometric_representation_item);
      collected_text : SET [2:?] OF text_or_character;
   WHERE
      WR1:
         acyclic_composite_text(SELF,

 SELF.collected_text);
   END_ENTITY;



   ENTITY composite_unit_shape_aspect
   SUBTYPE OF (composite_shape_aspect);
   END_ENTITY;



   ENTITY compound_maths_space_context
   SUBTYPE OF (maths_space_context);
      components : LIST [2:?] OF maths_space_context;
   END_ENTITY;



   ENTITY compound_representation_item
   SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
   END_ENTITY;



   ENTITY concat_expression
   SUBTYPE OF (string_expression,

 multiple_arity_generic_expression);
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF string_expression;
   END_ENTITY;



   ENTITY concentricity_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'concentricity';
   END_ENTITY;



   ENTITY conductance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\conductance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = siemens;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY conductive_interconnect_element_terminal_link
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\conductive_interconnect_element_terminal_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
      WR8:
         SELF\shape_aspect_relationship.related_shape_aspect.description = 'conductive interconnect element terminal';
      WR9:
         SELF\shape_aspect_relationship.relating_shape_aspect.description = 'conductive interconnect element terminal';
      WR10:
         SELF\shape_aspect.of_shape.definition\product_definition.description = 'laminate component';
   END_ENTITY;



   ENTITY configuration_design;
      configuration : configuration_item;
      design : configuration_design_item;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   UNIQUE
      UR1 : configuration,

 design;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY configuration_effectivity
   SUBTYPE OF (product_definition_effectivity);
      configuration : configuration_design;
   UNIQUE
      UR1 : configuration,

 usage,

 id;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF\product_definition_effectivity.usage);
   END_ENTITY;



   ENTITY configuration_item;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      item_concept : product_concept;
      purpose : OPTIONAL label;
   END_ENTITY;



   ENTITY conic
   SUPERTYPE OF (ONEOF(circle,

 ellipse,

 hyperbola,

 parabola))
   SUBTYPE OF (curve);
      position : axis2_placement;
   END_ENTITY;



   ENTITY conical_surface
   SUBTYPE OF (elementary_surface);
      radius : length_measure;
      semi_angle : plane_angle_measure;
   WHERE
      WR1:
         radius >= 0.00000;
   END_ENTITY;



   ENTITY connected_area_component
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) = 1;
      WR2:
         SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated layer connection point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sfi.relating_shape_aspect)))) >= 1;
      WR3:
         SELF\shape_aspect.description = 'stratum feature template component';
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\component_shape_aspect || SELF\connected_area_component)) = 0;
   END_ENTITY;



   ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
   END_ENTITY;



   ENTITY connected_face_set
   SUPERTYPE OF (ONEOF(closed_shell,

 open_shell))
   SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
   END_ENTITY;



   ENTITY connected_face_sub_set
   SUBTYPE OF (connected_face_set);
      parent_face_set : connected_face_set;
   END_ENTITY;



   ENTITY connection_zone_based_assembly_joint
   SUBTYPE OF (assembly_joint);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 1'))) = 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 2'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'connection zone'))) = 2;
   END_ENTITY;



   ENTITY connection_zone_based_fabrication_joint
   SUBTYPE OF (fabrication_joint);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 1'))) = 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 2'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'connection zone'))) = 2;
   END_ENTITY;



   ENTITY connection_zone_interface_plane_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.name;
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship || SELF\connection_zone_interface_plane_relationship || SELF\shape_aspect)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'plane';
      WR4:
         SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'connection zone';
      WR5:
         SELF\shape_aspect_relationship.description IN [ 'area',

 'edge' ];
      WR6:
         SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
      WR7:
         SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
      WR8:
         SIZEOF(QUERY (dz <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'derived zone'))| (dz.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY connection_zone_map_identification
   SUBTYPE OF (shape_aspect,

 representation_relationship);
   WHERE
      WR1:
         SELF\representation_relationship.rep_2 :<>: SELF\representation_relationship.rep_1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF\representation_relationship.rep_1);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF\representation_relationship.rep_2);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\representation_relationship || SELF\connection_zone_map_identification)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\representation_relationship.name = '';
      WR7:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
   END_ENTITY;



   ENTITY constant_function
   SUBTYPE OF (maths_function,

 generic_literal);
      sole_output : maths_value;
      source_of_domain : maths_space_or_function;
   WHERE
      WR1:
         no_cyclic_domain_reference(source_of_domain,

 [ SELF ]);
      WR2:
         expression_is_constant(domain_from(source_of_domain));
   END_ENTITY;



   ENTITY context_dependent_shape_representation;
      representation_relation : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition);
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY context_dependent_unit
   SUBTYPE OF (named_unit);
      name : label;
   END_ENTITY;



   ENTITY contract;
      name : label;
      purpose : text;
      kind : contract_type;
   END_ENTITY;



   ENTITY contract_assignment
   ABSTRACT SUPERTYPE;
      assigned_contract : contract;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY contract_type;
      description : label;
   END_ENTITY;



   ENTITY conversion_based_unit
   SUBTYPE OF (named_unit);
      name : label;
      conversion_factor : measure_with_unit;
   END_ENTITY;



   ENTITY coordinated_representation_item
   SUBTYPE OF (representation,

 representation_item);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (SIZEOF(USEDIN(pdr,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATA_ENVIRONMENT.ELEMENTS')) <= 1))) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
      WR3:
         NOT (SELF\representation_item.name = 'tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))) >= 1);
      WR4:
         NOT (SELF\representation_item.name = 'plus minus tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 3);
      WR5:
         NOT (SELF\representation_item.name = 'symmetrical tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 2);
      WR6:
         NOT (SELF\representation_item.name = 'plus minus tolerance') OR ((SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'basic value'))) = 1) AND (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'plus value'))) = 1)) AND (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'minus value'))) = 1);
      WR7:
         NOT (SELF\representation_item.name = 'symmetrical tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'basic value'))) = 1) AND (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'deviation value'))) = 1);
   END_ENTITY;



   ENTITY coordinated_universal_time_offset;
      hour_offset : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense : ahead_or_behind;
   DERIVE
      actual_minute_offset : INTEGER := NVL(minute_offset,

 0);
   WHERE
      WR1:
         (0 <= hour_offset) AND (hour_offset < 24);
      WR2:
         (0 <= actual_minute_offset) AND (actual_minute_offset <= 59);
      WR3:
         NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = exact));
   END_ENTITY;



   ENTITY cos_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY csg_2d_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D' ] * TYPEOF(it)) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID' ] * TYPEOF(it)) = 1) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))) >= 1;
      WR4:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_representation || SELF\csg_2d_shape_representation || SELF\representation)) = 0;
   END_ENTITY;



   ENTITY csg_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REVOLVED_FACE_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXTRUDED_FACE_SOLID' ] * TYPEOF(it)) <> 1))) = 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (sr <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA' IN TYPEOF(it)))| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REVOLVED_FACE_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXTRUDED_FACE_SOLID' ] * TYPEOF(sr\solid_replica.parent_solid)) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (it <* SELF.items| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) > 0;
   END_ENTITY;



   ENTITY csg_solid
   SUBTYPE OF (solid_model);
      tree_root_expression : csg_select;
   END_ENTITY;



   ENTITY curve
   SUPERTYPE OF (ONEOF(line,

 conic,

 pcurve,

 surface_curve,

 offset_curve_2d,

 offset_curve_3d,

 curve_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY curve_bounded_surface
   SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      boundaries : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
   WHERE
      WR1:
         NOT implicit_outer OR (SIZEOF(QUERY (temp <* boundaries| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))) = 0);
      WR2:
         NOT implicit_outer OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
      WR3:
         SIZEOF(QUERY (temp <* boundaries| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))) <= 1;
      WR4:
         SIZEOF(QUERY (temp <* boundaries| (temp\composite_curve_on_surface.basis_surface[1] <> SELF.basis_surface))) = 0;
   END_ENTITY;



   ENTITY curve_dimension
   SUBTYPE OF (dimensional_size);
   WHERE
      WR1:
         SELF\dimensional_size.name <> 'angular';
   END_ENTITY;



   ENTITY curve_replica
   SUBTYPE OF (curve);
      parent_curve : curve;
      transformation : cartesian_transformation_operator;
   WHERE
      WR1:
         transformation.dim = parent_curve.dim;
      WR2:
         acyclic_curve_replica(SELF,

 parent_curve);
   END_ENTITY;



   ENTITY curve_style;
      name : label;
      curve_font : curve_font_or_scaled_curve_font_select;
      curve_width : size_select;
      curve_colour : colour;
   END_ENTITY;



   ENTITY curve_style_font;
      name : label;
      pattern_list : LIST [1:?] OF curve_style_font_pattern;
   END_ENTITY;



   ENTITY curve_style_font_and_scaling;
      name : label;
      curve_font : curve_style_font_select;
      curve_font_scaling : REAL;
   END_ENTITY;



   ENTITY curve_style_font_pattern;
      visible_segment_length : positive_length_measure;
      invisible_segment_length : positive_length_measure;
   END_ENTITY;



   ENTITY curve_style_with_ends_and_corners
   SUBTYPE OF (curve_style);
      curve_ends : squared_or_rounded;
      curve_corners : squared_or_rounded;
   END_ENTITY;



   ENTITY curve_style_with_extension
   SUBTYPE OF (curve_style);
      curve_extensions : length_measure;
   END_ENTITY;



   ENTITY curve_swept_solid_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_AREA_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_DISK_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_AREA_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_DISK_SOLID',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (scsas <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE_SWEPT_AREA_SOLID' IN TYPEOF(it)))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(scsas.directrix)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(scsas.directrix))))) = 0;
   END_ENTITY;



   ENTITY cutout_edge_segment
   SUPERTYPE OF (plated_cutout_edge_segment)
   SUBTYPE OF (inter_stratum_feature,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated cutout edge segment',

 'cutout edge segment' ];
      WR2:
         SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed cutout'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect)) AND (cc.relating_shape_aspect\shape_aspect.description IN [ 'cutout',

 'physical connectivity interrupting cutout',

 'plated cutout' ]))) = 1;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR5:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
   END_ENTITY;



   ENTITY cyclide_segment_solid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      radius1 : positive_length_measure;
      radius2 : positive_length_measure;
      cone_angle1 : plane_angle_measure;
      cone_angle2 : plane_angle_measure;
      turn_angle : plane_angle_measure;
   END_ENTITY;



   ENTITY cylindrical_surface
   SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY data_environment;
      name : label;
      description : text;
      elements : SET [1:?] OF property_definition_representation;
   END_ENTITY;



   ENTITY data_set_representation_item
   SUBTYPE OF (compound_representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')) > 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SET_REPRESENTATION_ITEM' IN TYPEOF(SELF\compound_representation_item.item_element);
   END_ENTITY;



   ENTITY date
   SUPERTYPE OF (calendar_date);
      year_component : year_number;
   END_ENTITY;



   ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
   END_ENTITY;



   ENTITY date_and_time_assignment
   ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role : date_time_role;
   END_ENTITY;



   ENTITY date_assignment
   ABSTRACT SUPERTYPE;
      assigned_date : date;
      role : date_role;
   END_ENTITY;



   ENTITY date_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY date_time_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY dated_effectivity
   SUBTYPE OF (effectivity);
      effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
      effectivity_start_date : date_time_or_event_occurrence;
   END_ENTITY;



   ENTITY datum_difference
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect));
      WR2:
         SELF\shape_aspect.name = SELF\shape_aspect_relationship.name;
      WR3:
         SELF\shape_aspect.description = SELF\shape_aspect_relationship.description;
      WR4:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\datum_difference)) = 0;
   END_ENTITY;



   ENTITY datum_difference_analytical_model_port_assignment
   SUBTYPE OF (property_definition_representation);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(SELF\property_definition_representation.used_representation)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(SELF\property_definition_representation.definition));
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_representation || SELF\datum_difference_analytical_model_port_assignment)) = 0;
   END_ENTITY;



   ENTITY datum_difference_based_characteristic
   SUBTYPE OF (representation_item);
   WHERE
      WR1:
         SIZEOF(QUERY (r <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (SIZEOF(QUERY (prd2 <* QUERY (prd <* USEDIN(r,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION' IN TYPEOF(prd)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(prd\property_definition_representation.definition)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(prd2\property_definition_representation.definition\property_definition.definition)))) = 1))) = 1;
   END_ENTITY;



   ENTITY datum_difference_based_model_parameter
   SUBTYPE OF (model_parameter);
   WHERE
      WR1:
         SIZEOF(QUERY (r <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (SIZEOF(QUERY (prd2 <* QUERY (prd <* USEDIN(r,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION' IN TYPEOF(prd)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(prd\property_definition_representation.definition)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(prd2\property_definition_representation.definition\property_definition.definition)))) = 1))) = 1;
   END_ENTITY;



   ENTITY datum_difference_functional_unit_usage_view_terminal_assignment
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship || SELF\datum_difference_functional_unit_usage_view_terminal_assignment)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
   END_ENTITY;



   ENTITY datum_reference_frame
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\datum_reference_frame)) = 0;
      WR2:
         SELF\shape_aspect.product_definitional = FALSE;
      WR3:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference axis'))| (pud.related_shape_aspect\shape_aspect.description = 'axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) <= 3;
      WR4:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference plane'))| (pud.related_shape_aspect\shape_aspect.description = 'plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) <= 3;
      WR5:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference origin'))| (pud.related_shape_aspect\shape_aspect.description = 'point') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (ds <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'established datum reference frame'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(ds.related_shape_aspect)))) >= 1;
      WR7:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference axis'))| (pud.related_shape_aspect\shape_aspect.description = 'axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) + SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference plane'))| (pud.related_shape_aspect\shape_aspect.description = 'plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) + SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference origin'))| (pud.related_shape_aspect\shape_aspect.description = 'point') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) >= 1;
      WR8:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference origin'))| (pud.related_shape_aspect\shape_aspect.description <> 'point') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DERIVED_SHAPE_ASPECT' IN TYPEOF(pud.related_shape_aspect)))) = 0;
   END_ENTITY;



   ENTITY datum_system
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = FALSE;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'established datum reference frame'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum usage in datum system'))) >= 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'datum system property with material conditions') OR (pd\property_definition.description = 'datum system property without material conditions'))) = 1;
   END_ENTITY;



   ENTITY datum_system_based_dimensional_location
   SUBTYPE OF (dimensional_location);
   END_ENTITY;



   ENTITY defined_character_glyph
   SUBTYPE OF (geometric_representation_item);
      definition : defined_glyph_select;
      placement : axis2_placement;
   END_ENTITY;



   ENTITY defined_function
   ABSTRACT SUPERTYPE OF (ONEOF(numeric_defined_function,

 string_defined_function,

 boolean_defined_function) ANDOR

 SQL_mappable_defined_function);
   END_ENTITY;



   ENTITY defined_maths_space_context
   SUBTYPE OF (maths_space_context);
   END_ENTITY;



   ENTITY defined_symbol
   SUBTYPE OF (geometric_representation_item);
      definition : defined_symbol_select;
      target : symbol_target;
   END_ENTITY;



   ENTITY definite_integral_expression
   SUBTYPE OF (quantifier_expression);
      lower_limit_neg_infinity : BOOLEAN;
      upper_limit_pos_infinity : BOOLEAN;
   DERIVE
      integrand : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
      variable_of_integration : maths_variable := SELF\multiple_arity_generic_expression.operands[2];
      SELF\quantifier_expression.variables : LIST [1:1] OF UNIQUE generic_variable := [ variable_of_integration ];
   WHERE
      WR1:
         has_values_space(integrand);
      WR2:
         space_is_continuum(values_space_of(integrand));
      WR3:
         definite_integral_expr_check(SELF\multiple_arity_generic_expression.operands,

 lower_limit_neg_infinity,

 upper_limit_pos_infinity);
   END_ENTITY;



   ENTITY definite_integral_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      variable_of_integration : input_selector;
      lower_limit_neg_infinity : BOOLEAN;
      upper_limit_pos_infinity : BOOLEAN;
   DERIVE
      integrand : maths_function := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         space_is_continuum(integrand.range);
      WR2:
         definite_integral_check(integrand.domain,

 variable_of_integration,

 lower_limit_neg_infinity,

 upper_limit_pos_infinity);
   END_ENTITY;



   ENTITY definitional_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
   END_ENTITY;



   ENTITY degenerate_pcurve
   SUBTYPE OF (point);
      basis_surface : surface;
      reference_to_curve : definitional_representation;
   WHERE
      WR1:
         SIZEOF(reference_to_curve\representation.items) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
      WR3:
         reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
   WHERE
      WR1:
         major_radius < minor_radius;
   END_ENTITY;



   ENTITY delete_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object deletion'))) = 1;
   END_ENTITY;



   ENTITY delete_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object deletion'))) = 1;
   END_ENTITY;



   ENTITY dependent_material_removal_feature_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SELF\shape_aspect.description = 'material removal feature template';
      WR2:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(am.relating_shape_aspect)) AND (am.relating_shape_aspect.description IN [ 'default attachment size and component termination passage based',

 'default attachment size based',

 'default attachment size and via based',

 'default component termination passage based',

 'default via based',

 'default unsupported passage based' ]))) = 1;
   END_ENTITY;



   ENTITY dependent_variable_definition
   SUBTYPE OF (unary_generic_expression);
      name : label;
      description : text;
   END_ENTITY;



   ENTITY derived_shape_aspect
   SUPERTYPE OF (ONEOF(apex,

 centre_of_symmetry,

 geometric_alignment,

 geometric_intersection,

 extension,

 tangent))
   SUBTYPE OF (shape_aspect);
   INVERSE
      deriving_relationships : SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
   END_ENTITY;



   ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
   DERIVE
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         (SIZEOF(elements) > 1) OR (SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.00000);
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY derived_unit_element;
      unit : named_unit;
      exponent : REAL;
   END_ENTITY;



   ENTITY description_attribute;
      attribute_value : text;
      described_item : description_attribute_select;
   END_ENTITY;



   ENTITY descriptive_representation_item
   SUBTYPE OF (representation_item);
      description : text;
   END_ENTITY;



   ENTITY design_layer_type_specific_padstack_definition
   SUBTYPE OF (padstack_definition);
   END_ENTITY;



   ENTITY design_make_from_relationship
   SUBTYPE OF (product_definition_relationship);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT') ] * TYPEOF(SELF.relating_product_definition)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT') ] * TYPEOF(SELF.related_product_definition)) = 1;
      WR3:
         SIZEOF(QUERY (pds <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pds)))) = 0;
   END_ENTITY;



   ENTITY design_object
   SUBTYPE OF (characterized_object,

 group);
   END_ENTITY;



   ENTITY device_terminal_map
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.related_shape_aspect,

 SELF\shape_aspect_relationship.relating_shape_aspect;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect);
   END_ENTITY;



   ENTITY digital_analytical_model_port
   SUBTYPE OF (analytical_model_port);
   WHERE
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'nominal signal flow direction')) AND (it\descriptive_representation_item.description IN [ 'input direction',

 'output direction',

 'bidirectional',

 'unknown direction' ]))) = 1;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'port type')) AND (it\descriptive_representation_item.description IN [ 'string property type',

 'logical property type',

 'boolean property type' ]))) = 1;
   END_ENTITY;



   ENTITY dimension_related_tolerance_zone_element;
      related_dimension : dimensional_location;
      related_element : tolerance_zone_definition;
   END_ENTITY;



   ENTITY dimensional_characteristic_representation;
      dimension : dimensional_characteristic;
      representation : shape_dimension_representation;
   END_ENTITY;



   ENTITY dimensional_exponents;
      length_exponent : REAL;
      mass_exponent : REAL;
      time_exponent : REAL;
      electric_current_exponent : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent : REAL;
      luminous_intensity_exponent : REAL;
   END_ENTITY;



   ENTITY dimensional_location
   SUPERTYPE OF (ONEOF(angular_location,

 dimensional_location_with_path))
   SUBTYPE OF (shape_aspect_relationship);
   END_ENTITY;



   ENTITY dimensional_location_with_direction
   SUBTYPE OF (dimensional_location);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.description = 'linear';
   END_ENTITY;



   ENTITY dimensional_location_with_path
   SUBTYPE OF (dimensional_location);
      path : shape_aspect;
   END_ENTITY;



   ENTITY dimensional_size
   SUPERTYPE OF (angular_size);
      applies_to : shape_aspect;
      name : label;
   WHERE
      WR1:
         applies_to.product_definitional = TRUE;
   END_ENTITY;



   ENTITY dimensional_size_property
   SUBTYPE OF (dimensional_size,

 property_definition);
   END_ENTITY;



   ENTITY direct_stratum_component_join_implementation
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship || SELF\direct_stratum_component_join_implementation)) = 0;
   END_ENTITY;



   ENTITY directed_action
   SUBTYPE OF (executed_action);
      directive : action_directive;
   END_ENTITY;



   ENTITY directed_dimensional_location
   SUBTYPE OF (dimensional_location);
   END_ENTITY;



   ENTITY direction
   SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
   WHERE
      WR1:
         SIZEOF(QUERY (tmp <* direction_ratios| (tmp <> 0.00000))) > 0;
   END_ENTITY;



   ENTITY discrete_shield
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical occurrence';
      WR2:
         SIZEOF(QUERY (si <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'shielded item'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(si.relating_product_definition)))) >= 1;
   END_ENTITY;



   ENTITY div_expression
   SUBTYPE OF (binary_numeric_expression);
   END_ENTITY;



   ENTITY document;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      kind : document_type;
   INVERSE
      representation_types : SET [0:?] OF document_representation_type FOR represented_document;
   END_ENTITY;



   ENTITY document_identifier
   SUBTYPE OF (group);
   UNIQUE
      UR1 : SELF\group.name,

 SELF\group.description;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 '')) = 1;
   END_ENTITY;



   ENTITY document_identifier_assignment
   SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : document_identifier;
      items : SET [1:?] OF document_identifier_assigned_item;
   END_ENTITY;



   ENTITY document_reference
   ABSTRACT SUPERTYPE;
      assigned_document : document;
      source : label;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY document_relationship;
      name : label;
      description : OPTIONAL text;
      relating_document : document;
      related_document : document;
   END_ENTITY;



   ENTITY document_representation_type;
      name : label;
      represented_document : document;
   END_ENTITY;



   ENTITY document_type;
      product_data_type : label;
   END_ENTITY;



   ENTITY document_usage_constraint;
      source : document;
      subject_element : label;
      subject_element_value : text;
   END_ENTITY;



   ENTITY document_with_class
   SUBTYPE OF (document);
      class : identifier;
   END_ENTITY;



   ENTITY dose_equivalent_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\dose_equivalent_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = sievert;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY eccentric_cone
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      height : positive_length_measure;
      x_offset : length_measure;
      y_offset : length_measure;
      ratio : REAL;
   WHERE
      WR1:
         ratio >= 0.00000;
   END_ENTITY;



   ENTITY edge
   SUPERTYPE OF (ONEOF(edge_curve,

 oriented_edge,

 subedge))
   SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end : vertex;
   END_ENTITY;



   ENTITY edge_based_2d_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF\representation.items| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D') ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF\representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM') ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_CURVE' IN TYPEOF(edges)))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (pline_edges <* QUERY (edges <* eb.ces_edges| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POLYLINE' IN TYPEOF(edges\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_edges\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(edges.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(edges.edge_end))))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT valid_2d_wireframe_edge_curve(edges\edge_curve.edge_geometry,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (con_edges <* QUERY (edges <* eb.ces_edges| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONIC' IN TYPEOF(edges\edge_curve.edge_geometry)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(con_edges\edge_curve.edge_geometry\conic.position)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR10:
         SELF\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
   END_ENTITY;



   ENTITY edge_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
   END_ENTITY;



   ENTITY edge_based_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(edges)))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (pline_edges <* QUERY (edges <* eb.ces_edges| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(edges\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_edges\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(edges.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(edges.edge_end))))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR9:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
   END_ENTITY;



   ENTITY edge_curve
   SUBTYPE OF (edge,

 geometric_representation_item);
      edge_geometry : curve;
      same_sense : BOOLEAN;
   END_ENTITY;



   ENTITY edge_loop
   SUBTYPE OF (loop,

 path);
   DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
   WHERE
      WR1:
         SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].edge_end;
   END_ENTITY;



   ENTITY edge_segment_cross_section
   SUBTYPE OF (shape_definition_3d_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\shape_definition_3d_intersection || SELF\edge_segment_cross_section)) = 0;
   END_ENTITY;



   ENTITY edge_segment_vertex
   SUBTYPE OF (physical_unit_datum);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\physical_unit_datum || SELF\edge_segment_vertex)) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'shape element characterization'))) = 1;
      WR3:
         SELF\shape_aspect.of_shape\property_definition.definition.frame_of_reference\application_context_element.name IN [ 'physical design occurrence',

 'physical design usage' ];
      WR4:
         SELF\shape_aspect.name = 'single datum';
   END_ENTITY;



   ENTITY ee_specification
   SUBTYPE OF (document);
   WHERE
      WR1:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'document source'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'document source'))) >= 1;
      WR2:
         SELF\document.kind\document_type.product_data_type IN [ 'assembly technology specification',

 'design specification',

 'fabrication technology specification',

 'interface specification',

 'language reference manual',

 'lead form specification',

 'material specification',

 'reference document',

 'source code',

 'font registration document',

 'process specification',

 'surface finish specification',

 'test specification' ];
   END_ENTITY;



   ENTITY effectivity
   SUPERTYPE OF (ONEOF(serial_numbered_effectivity,

 dated_effectivity,

 lot_effectivity));
      id : identifier;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY effectivity_assignment
   ABSTRACT SUPERTYPE;
      assigned_effectivity : effectivity;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY electric_charge_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\electric_charge_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = coulomb;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY electric_current_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY electric_current_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY electrical_isolation_component_shape_aspect
   SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY electrical_isolation_removal_template_definition
   SUBTYPE OF (part_template_definition);
   END_ENTITY;



   ENTITY electrical_network
   SUBTYPE OF (functional_unit);
   END_ENTITY;



   ENTITY electromagnetic_compatibility_requirement_allocation
   SUPERTYPE OF (shield_allocation)
   SUBTYPE OF (product_definition_relationship);
   END_ENTITY;



   ENTITY electromotive_force_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\electromotive_force_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = volt;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY elementary_function
   SUBTYPE OF (maths_function,

 generic_literal);
      func_id : elementary_function_enumerators;
   END_ENTITY;



   ENTITY elementary_space
   SUBTYPE OF (maths_space,

 generic_literal);
      space_id : elementary_space_enumerators;
   END_ENTITY;



   ENTITY elementary_surface
   SUPERTYPE OF (ONEOF(plane,

 cylindrical_surface,

 conical_surface,

 spherical_surface,

 toroidal_surface))
   SUBTYPE OF (surface);
      position : axis2_placement_3d;
   END_ENTITY;



   ENTITY ellipse
   SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
   END_ENTITY;



   ENTITY ellipsoid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      semi_axis_3 : positive_length_measure;
   END_ENTITY;



   ENTITY elliptic_area
   SUBTYPE OF (primitive_2d);
      position : axis2_placement_2d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
   END_ENTITY;



   ENTITY energy_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\energy_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = joule;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY environment;
      syntactic_representation : generic_variable;
      semantics : variable_semantics;
   END_ENTITY;



   ENTITY equals_expression
   SUBTYPE OF (binary_boolean_expression);
   END_ENTITY;



   ENTITY evaluated_characteristic
   SUBTYPE OF (representation,

 representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,

 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\representation_relationship_with_transformation || SELF\evaluated_characteristic)) = 0;
      WR2:
         SELF\representation_relationship.rep_1 <> SELF\representation_relationship.rep_2;
      WR3:
         SELF\representation_relationship.name = '';
      WR4:
         SELF\representation.name = '';
      WR5:
         SELF\representation_relationship.rep_1.name = 'planned characteristic';
   END_ENTITY;



   ENTITY evaluated_degenerate_pcurve
   SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
   END_ENTITY;



   ENTITY evaluation_product_definition
   SUBTYPE OF (product_definition);
   END_ENTITY;



   ENTITY executed_action
   SUBTYPE OF (action);
   END_ENTITY;



   ENTITY exp_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY expanded_uncertainty
   SUBTYPE OF (standard_uncertainty);
      coverage_factor : REAL;
   END_ENTITY;



   ENTITY explicit_table_function
   ABSTRACT SUPERTYPE OF (ONEOF(listed_real_data,

 listed_integer_data,

 listed_logical_data,

 listed_string_data,

 listed_complex_number_data,

 listed_data,

 externally_listed_data,

 linearized_table_function,

 basic_sparse_matrix))
   SUBTYPE OF (maths_function);
      index_base : zero_or_one;
      shape : LIST [1:?] OF positive_integer;
   END_ENTITY;



   ENTITY explicitly_enumerated_maths_space_context
   SUBTYPE OF (maths_space_context);
      members : SET [1:?] OF maths_value_context;
   END_ENTITY;



   ENTITY expression
   ABSTRACT SUPERTYPE OF (ONEOF(numeric_expression,

 boolean_expression,

 string_expression))
   SUBTYPE OF (generic_expression);
   END_ENTITY;



   ENTITY expression_conversion_based_unit
   SUBTYPE OF (context_dependent_unit,

 variable_semantics);
   INVERSE
      associated_variable_environment : environment FOR semantics;
   END_ENTITY;



   ENTITY expression_denoted_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
   DERIVE
      expr : generic_expression := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         schema_prefix + 'FUNCTION_SPACE' IN TYPEOF(values_space_of(expr));
   END_ENTITY;



   ENTITY extended_tuple_space
   SUBTYPE OF (maths_space,

 generic_literal);
      base : product_space;
      extender : maths_space;
   WHERE
      WR1:
         expression_is_constant(base) AND expression_is_constant(extender);
      WR2:
         no_cyclic_space_reference(SELF,

 []);
      WR3:
         extender <> the_empty_space;
   END_ENTITY;



   ENTITY extension
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) = 1;
   END_ENTITY;



   ENTITY external_definition
   SUPERTYPE OF (bond_category)
   SUBTYPE OF (characterized_object,

 descriptive_representation_item,

 externally_defined_representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY external_source;
      source_id : source_item;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY external_source_relationship;
      name : label;
      description : OPTIONAL text;
      relating_source : external_source;
      related_source : external_source;
   END_ENTITY;



   ENTITY externally_defined_assembly_definition
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'assembly module');
      WR3:
         NOT (SELF.frame_of_reference\application_context_element.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
   END_ENTITY;



   ENTITY externally_defined_bare_die
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (ifdu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition)) AND (ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'device unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0;
   END_ENTITY;



   ENTITY externally_defined_character_glyph
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_curve_font
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_functional_unit
   SUBTYPE OF (functional_unit,

 externally_defined_product_definition);
   END_ENTITY;



   ENTITY externally_defined_hatch_style
   SUBTYPE OF (externally_defined_item,

 geometric_representation_item);
   END_ENTITY;



   ENTITY externally_defined_interconnect_definition
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'interconnect module');
   END_ENTITY;



   ENTITY externally_defined_item;
      item_id : source_item;
      source : external_source;
   END_ENTITY;



   ENTITY externally_defined_package
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical design usage';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'registered case style'))) >= 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr)))| (sr_pdr.used_representation\representation.name = 'seating plane'))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' IN TYPEOF(sa)))) <= 1))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(sa)))) >= 1))) = 0;
      WR6:
         NOT (SELF\product_definition.description = 'altered package') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package preparation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pdr.relating_product_definition)) = 1))) = 1);
   END_ENTITY;



   ENTITY externally_defined_packaged_connector
   SUBTYPE OF (externally_defined_packaged_part);
   END_ENTITY;



   ENTITY externally_defined_packaged_part
   SUPERTYPE OF (externally_defined_packaged_connector)
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0);
      WR2:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)) AND (ifu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR4:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE' IN TYPEOF(upkg.related_product_definition)))) = 1);
      WR5:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (bpp <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'base packaged part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(bpp.relating_product_definition)) = 1) AND (bpp.relating_product_definition.frame_of_reference.name = 'physical design usage'))) >= 1);
      WR6:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(upkg.relating_product_definition)) = 1))) >= 1);
   END_ENTITY;



   ENTITY externally_defined_physical_unit
   SUPERTYPE OF (ONEOF(externally_defined_package,

 externally_defined_packaged_part,

 externally_defined_bare_die,

 externally_defined_assembly_definition,

 externally_defined_interconnect_definition))
   SUBTYPE OF (physical_unit,

 externally_defined_product_definition);
   END_ENTITY;



   ENTITY externally_defined_product_definition
   SUPERTYPE OF (library_defined_product_definition)
   SUBTYPE OF (product_definition,

 externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_representation_item
   SUBTYPE OF (externally_defined_item,

 representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY externally_defined_style
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_symbol
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_text_font
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_tile
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_tile_style
   SUBTYPE OF (externally_defined_item,

 geometric_representation_item);
   END_ENTITY;



   ENTITY externally_listed_data
   SUBTYPE OF (explicit_table_function,

 generic_literal,

 externally_defined_item);
      value_range : maths_space;
   WHERE
      WR1:
         expression_is_constant(value_range);
   END_ENTITY;



   ENTITY extruded_area_solid
   SUBTYPE OF (swept_area_solid);
      extruded_direction : direction;
      depth : positive_length_measure;
   WHERE
      WR1:
         dot_product(SELF\swept_area_solid.swept_area.basis_surface\elementary_surface.position.p[3],

 extruded_direction) <> 0.00000;
   END_ENTITY;



   ENTITY extruded_face_solid
   SUBTYPE OF (swept_face_solid);
      extruded_direction : direction;
      depth : positive_length_measure;
   WHERE
      WR1:
         dot_product(SELF\swept_face_solid.swept_face.face_geometry\elementary_surface.position.p[3],

 extruded_direction) <> 0.00000;
   END_ENTITY;



   ENTITY fabrication_joint
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description IN [ 'via terminal',

 'printed component join terminal',

 'non functional land join terminal',

 'land join terminal',

 'conductive interconnect element terminal',

 'component termination passage join terminal' ]);
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect)) AND (SELF.relating_shape_aspect\shape_aspect.description IN [ 'via terminal',

 'printed component join terminal',

 'non functional land join terminal',

 'land join terminal',

 'conductive interconnect element terminal',

 'component termination passage join terminal' ]);
      WR3:
         SIZEOF(QUERY (ajm <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'auxiliary joint material'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND' IN TYPEOF(ajm.related_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(ajm.related_shape_aspect)) AND (ajm.related_shape_aspect\shape_aspect.description = 'stratum feature template component'))) <= 1;
      WR4:
         acyclic_shape_aspect_relationship(SELF,

 [ SELF\shape_aspect_relationship.related_shape_aspect ],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT');
   END_ENTITY;



   ENTITY face
   SUPERTYPE OF (ONEOF(face_surface,

 subface,

 oriented_face))
   SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
   WHERE
      WR1:
         NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)));
      WR2:
         SIZEOF(QUERY (temp <* bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp)))) <= 1;
   END_ENTITY;



   ENTITY face_bound
   SUBTYPE OF (topological_representation_item);
      bound : loop;
      orientation : BOOLEAN;
   END_ENTITY;



   ENTITY face_outer_bound
   SUBTYPE OF (face_bound);
   END_ENTITY;



   ENTITY face_surface
   SUBTYPE OF (face,

 geometric_representation_item);
      face_geometry : surface;
      same_sense : BOOLEAN;
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
   END_ENTITY;



   ENTITY faceted_brep
   SUBTYPE OF (manifold_solid_brep);
   END_ENTITY;



   ENTITY faceted_brep_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (fbrep <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(fbrep,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')| NOT (SIZEOF(QUERY (fcs <* csh.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE' IN TYPEOF(fcs)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(fcs\face_surface.face_geometry)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(fcs\face_surface.face_geometry\elementary_surface.position.location)))))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (fbrep <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(fbrep,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')| NOT (SIZEOF(QUERY (fcs <* csh.cfs_faces| NOT (SIZEOF(QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds)))) = 1))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\manifold_solid_brep.outer)))) = 0;
      WR6:
         SIZEOF(QUERY (brv <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation)) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
   END_ENTITY;



   ENTITY faceted_primitive
   SUBTYPE OF (geometric_representation_item);
      points : LIST [4:?] OF UNIQUE cartesian_point;
   WHERE
      WR1:
         points[1].dim = 3;
   END_ENTITY;



   ENTITY feature_shape_occurrence_relationship
   SUBTYPE OF (representation,

 shape_representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,

 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\feature_shape_occurrence_relationship)) = 0;
   END_ENTITY;



   ENTITY fiducial
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'laminate component');
   END_ENTITY;



   ENTITY fiducial_part_feature
   SUBTYPE OF (part_tooling_feature);
   END_ENTITY;



   ENTITY fiducial_stratum_feature
   SUBTYPE OF (stratum_feature);
   END_ENTITY;



   ENTITY fill_area_style;
      name : label;
      fill_styles : SET [1:?] OF fill_style_select;
   WHERE
      WR1:
         SIZEOF(QUERY (fill_style <* SELF.fill_styles| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FILL_AREA_STYLE_COLOUR' IN TYPEOF(fill_style)))) <= 1;
   END_ENTITY;



   ENTITY fill_area_style_colour;
      name : label;
      fill_colour : colour;
   END_ENTITY;



   ENTITY fill_area_style_hatching
   SUBTYPE OF (geometric_representation_item);
      hatch_line_appearance : curve_style;
      start_of_next_hatch_line : one_direction_repeat_factor;
      point_of_reference_hatch_line : cartesian_point;
      pattern_start : cartesian_point;
      hatch_line_angle : plane_angle_measure;
   END_ENTITY;



   ENTITY fill_area_style_tile_coloured_region
   SUBTYPE OF (geometric_representation_item);
      closed_curve : curve_or_annotation_curve_occurrence;
      region_colour : colour;
   END_ENTITY;



   ENTITY fill_area_style_tile_curve_with_style
   SUBTYPE OF (geometric_representation_item);
      styled_curve : annotation_curve_occurrence;
   END_ENTITY;



   ENTITY fill_area_style_tile_symbol_with_style
   SUBTYPE OF (geometric_representation_item);
      symbol : annotation_symbol_occurrence;
   END_ENTITY;



   ENTITY fill_area_style_tiles
   SUBTYPE OF (geometric_representation_item);
      tiling_pattern : two_direction_repeat_factor;
      tiles : SET [1:?] OF fill_area_style_tile_shape_select;
      tiling_scale : positive_ratio_measure;
   END_ENTITY;



   ENTITY filled_area_material_removal_component_shape_aspect
   SUBTYPE OF (material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY finite_function
   SUBTYPE OF (maths_function,

 generic_literal);
      pairs : SET [1:?] OF LIST [2:2] OF maths_value;
   WHERE
      WR1:
         VALUE_UNIQUE(list_selected_components(pairs,

 1));
   END_ENTITY;



   ENTITY finite_integer_interval
   SUBTYPE OF (maths_space,

 generic_literal);
      min : INTEGER;
      max : INTEGER;
   DERIVE
      size : positive_integer := max - min + 1;
   WHERE
      WR1:
         min <= max;
   END_ENTITY;



   ENTITY finite_real_interval
   SUBTYPE OF (maths_space,

 generic_literal);
      min : REAL;
      min_closure : open_closed;
      max : REAL;
      max_closure : open_closed;
   WHERE
      WR1:
         min < max;
   END_ENTITY;



   ENTITY finite_space
   SUBTYPE OF (maths_space,

 generic_literal);
      members : SET OF maths_value;
   WHERE
      WR1:
         VALUE_UNIQUE(members);
      WR2:
         SIZEOF(QUERY (expr <* QUERY (member <* members| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GENERIC_EXPRESSION' IN TYPEOF(member)))| NOT expression_is_constant(expr))) = 0;
      WR3:
         no_cyclic_space_reference(SELF,

 []);
   END_ENTITY;



   ENTITY footprint_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\footprint_definition)) = 0;
      WR7:
         SELF.frame_of_reference.name IN [ 'layout design usage' ];
      WR8:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'template model'))) = 1;
   END_ENTITY;



   ENTITY footprint_occurrence
   SUBTYPE OF (assembly_group_component_shape_aspect);
   END_ENTITY;



   ENTITY footprint_occurrence_shape_aspect_relationship
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         SELF\shape_aspect_relationship.name = 'footprint occurrence sub assembly relationship';
   END_ENTITY;



   ENTITY force_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\force_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = newton;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY format_function
   SUBTYPE OF (string_expression,

 binary_generic_expression);
   DERIVE
      value_to_format : generic_expression := SELF\binary_generic_expression.operands[1];
      format_string : generic_expression := SELF\binary_generic_expression.operands[2];
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(value_to_format)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(format_string));
   END_ENTITY;



   ENTITY founded_item;
   END_ENTITY;



   ENTITY free_variable_semantics
   SUBTYPE OF (variable_semantics);
   END_ENTITY;



   ENTITY frequency_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\frequency_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = hertz;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY frozen_assignment
   SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF frozen_assigned_item;
   WHERE
      WR1:
         SELF\approval_assignment.assigned_approval.status.name IN [ 'approved',

 'not yet approved' ];
   END_ENTITY;



   ENTITY function_application
   SUBTYPE OF (multiple_arity_generic_expression);
      func : maths_function_select;
      arguments : LIST [1:?] OF maths_expression;
   DERIVE
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression := [ convert_to_maths_function(func) ] + convert_to_operands(arguments);
   WHERE
      WR1:
         function_applicability(func,

 arguments);
   END_ENTITY;



   ENTITY function_space
   SUBTYPE OF (maths_space,

 generic_literal);
      domain_constraint : space_constraint_type;
      domain_argument : maths_space;
      range_constraint : space_constraint_type;
      range_argument : maths_space;
   WHERE
      WR1:
         expression_is_constant(domain_argument) AND expression_is_constant(range_argument);
      WR2:
         (domain_argument <> the_empty_space) AND (range_argument <> the_empty_space);
      WR3:
         (domain_constraint <> sc_member) OR NOT member_of(the_empty_space,

 domain_argument);
      WR4:
         (range_constraint <> sc_member) OR NOT member_of(the_empty_space,

 range_argument);
      WR5:
         NOT (any_space_satisfies(domain_constraint,

 domain_argument) AND any_space_satisfies(range_constraint,

 range_argument));
   END_ENTITY;



   ENTITY functional_orientation_feature
   SUBTYPE OF (shape_aspect);
   END_ENTITY;



   ENTITY functional_specification
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr\representation_relationship.name = 'functional characteristic category') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNAL_DEFINITION' IN TYPEOF(rr.rep_1.items[1])))) = 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr\representation_relationship.name = 'characterizing signal' + 'for functional specification'))) = 1;
      WR3:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr\representation_relationship.name = 'reference signal for' + 'functional specification'))) = 1;
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\functional_specification)) = 0;
      WR5:
         SELF\representation.name = '';
      WR6:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.definition.definition)))) = 0;
   END_ENTITY;



   ENTITY functional_specification_definition
   SUBTYPE OF (functional_unit);
   WHERE
      WR1:
         SELF.frame_of_reference\application_context_element.name = 'functional network design';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_SPECIFICATION' IN TYPEOF(pdr.used_representation)))) > 0))) > 0;
   END_ENTITY;



   ENTITY functional_terminal_group
   SUBTYPE OF (group);
   UNIQUE
      UR1 : SELF\group.name;
   END_ENTITY;



   ENTITY functional_unit
   SUPERTYPE OF ((electrical_network ANDOR

 thermal_network) ANDOR

 functional_specification_definition)
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name IN [ 'functional design usage',

 'functional network design' ];
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR3:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) = 1;
      WR4:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR5:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR6:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR7:
         NOT (SELF.frame_of_reference.name = 'functional network design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| (du.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR8:
         NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'THERMAL_NETWORK'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ELECTRICAL_NETWORK') ] * TYPEOF(SELF)) = 1) OR (SELF.frame_of_reference.name = 'functional network design');
   END_ENTITY;



   ENTITY functional_unit_terminal_definition
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'functional design usage');
      WR2:
         SIZEOF(QUERY (pd2 <* QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pd)))| (SIZEOF(QUERY (funtdba <* QUERY (pdr <* USEDIN(pd2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(funtdba.relating_property_definition.definition)))) <= 1))) <= 1;
      WR3:
         SIZEOF(QUERY (pd2 <* QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pd)))| (SIZEOF(QUERY (funtdna <* QUERY (pdr <* USEDIN(pd2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition node assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(funtdna.relating_property_definition.definition)))) <= 1))) <= 1;
   END_ENTITY;



   ENTITY functionally_defined_transformation;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY general_linear_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      sum_index : one_or_two;
   DERIVE
      mat : maths_function := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         function_is_2d_table(mat);
      WR2:
         (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range),

 es_numbers);
   END_ENTITY;



   ENTITY general_property;
      id : identifier;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY general_property_relationship;
      name : label;
      description : OPTIONAL text;
      relating_property : general_property;
      related_property : general_property;
   END_ENTITY;



   ENTITY generic_expression
   ABSTRACT SUPERTYPE OF (ONEOF(simple_generic_expression,

 unary_generic_expression,

 binary_generic_expression,

 multiple_arity_generic_expression));
   WHERE
      WR1:
         is_acyclic(SELF);
   END_ENTITY;



   ENTITY generic_literal
   ABSTRACT SUPERTYPE
   SUBTYPE OF (simple_generic_expression);
   END_ENTITY;



   ENTITY generic_variable
   ABSTRACT SUPERTYPE
   SUBTYPE OF (simple_generic_expression);
   INVERSE
      interpretation : environment FOR syntactic_representation;
   END_ENTITY;



   ENTITY geometric_alignment
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) > 1;
   END_ENTITY;



   ENTITY geometric_curve_set
   SUBTYPE OF (geometric_set);
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* SELF\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(temp)))) = 0;
   END_ENTITY;



   ENTITY geometric_intersection
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) > 1;
   END_ENTITY;



   ENTITY geometric_representation_context
   SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
   END_ENTITY;



   ENTITY geometric_representation_item
   SUPERTYPE OF (ONEOF(point,

 direction,

 vector,

 placement,

 cartesian_transformation_operator,

 curve,

 surface,

 edge_curve,

 face_surface,

 poly_loop,

 vertex_point,

 solid_model,

 boolean_result,

 sphere,

 right_circular_cone,

 right_circular_cylinder,

 torus,

 block,

 primitive_2d,

 right_angular_wedge,

 ellipsoid,

 faceted_primitive,

 rectangular_pyramid,

 cyclide_segment_solid,

 volume,

 half_space_solid,

 half_space_2d,

 shell_based_surface_model,

 shell_based_wireframe_model,

 edge_based_wireframe_model,

 geometric_set))
   SUBTYPE OF (representation_item);
   DERIVE
      dim : dimension_count := dimension_of(SELF);
   WHERE
      WR1:
         SIZEOF(QUERY (using_rep <* using_representations(SELF)| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(using_rep.context_of_items)))) = 0;
   END_ENTITY;



   ENTITY geometric_set
   SUPERTYPE OF (geometric_curve_set)
   SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
   END_ENTITY;



   ENTITY geometric_tolerance;
      name : label;
      description : text;
      magnitude : measure_with_unit;
      toleranced_shape_aspect : shape_aspect;
   WHERE
      WR1:
         magnitude.value_component >= 0.00000;
   END_ENTITY;



   ENTITY geometric_tolerance_group
   SUBTYPE OF (property_definition);
   WHERE
      WR1:
         SELF\property_definition.description IN [ 'separate requirement',

 'simultaneous requirement' ];
      WR2:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) >= 1);
      WR3:
         NOT (SELF\property_definition.description = 'simultaneous requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) >= 2);
      WR4:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.name = 'linear profile refinement')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) = 0);
      WR5:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.name = 'surface profile refinement')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) = 0);
      WR6:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.name = 'feature relating position')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) = 0);
      WR7:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'group geometric tolerance') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE') ] * TYPEOF(pdr.related_property_definition)) > 0))) = 0);
   END_ENTITY;



   ENTITY geometric_tolerance_relationship;
      name : label;
      description : text;
      relating_geometric_tolerance : geometric_tolerance;
      related_geometric_tolerance : geometric_tolerance;
   END_ENTITY;



   ENTITY geometric_tolerance_with_specified_datum_system
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANGULARITY_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CIRCULAR_RUNOUT_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONCENTRICITY_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARALLELISM_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERPENDICULARITY_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SYMMETRY_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOTAL_RUNOUT_TOLERANCE') ] * TYPEOF(SELF)) = 1;
      WR2:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr.related_property_definition\property_definition.description = 'datum system property with material conditions') OR (pdr.related_property_definition\property_definition.description = 'datum system property without material conditions')) AND (pdr\property_definition_relationship.name = 'referenced datum system definition'))) = 1;
      WR3:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_GROUP' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.description = 'separate requirement')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) <= 1;
   END_ENTITY;



   ENTITY geometrically_bounded_2d_wireframe_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
      WR2:
         SIZEOF(QUERY (item <* SELF.items| NOT (SIZEOF(TYPEOF(item) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (item <* SELF.items| (SIZEOF(TYPEOF(item) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) >= 1;
      WR4:
         SIZEOF(QUERY (mi <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(item)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR5:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (elem <* gcs\geometric_set.elements| NOT (SIZEOF(TYPEOF(elem) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_2D',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' ]) = 1))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (crv <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(elem)))| NOT valid_basis_curve_in_2d_wireframe(crv))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (pnt <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' IN TYPEOF(elem)))| NOT (SIZEOF(TYPEOF(pnt) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE' ]) = 1))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (pl <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(elem)))| NOT (SIZEOF(pl\polyline.points) > 2))) = 0))) = 0;
   END_ENTITY;



   ENTITY geometrically_bounded_surface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (gs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (pnt <* QUERY (gsel <* gs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' IN TYPEOF(gsel)))| NOT gbsf_check_point(pnt))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (gs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cv <* QUERY (gsel <* gs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(gsel)))| NOT gbsf_check_curve(cv))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (gs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (sf <* QUERY (gsel <* gs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(gsel)))| NOT gbsf_check_surface(sf))) = 0))) = 0;
   END_ENTITY;



   ENTITY geometrically_bounded_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF(TYPEOF(it) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(TYPEOF(it) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (crv <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(elem)))| NOT valid_geometrically_bounded_wf_curve(crv,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (pnts <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' IN TYPEOF(elem)))| NOT valid_geometrically_bounded_wf_point(pnts,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cnc <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC' IN TYPEOF(elem)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\conic.position)))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (pline <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(elem)))| NOT (SIZEOF(pline\polyline.points) > 2))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR8:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
   END_ENTITY;



   ENTITY global_uncertainty_assigned_context
   SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
   END_ENTITY;



   ENTITY global_unit_assigned_context
   SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
   END_ENTITY;



   ENTITY group;
      name : label;
      description : OPTIONAL text;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY group_assignment
   ABSTRACT SUPERTYPE;
      assigned_group : group;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY group_product_definition
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'design requirement';
      WR2:
         NOT (SELF\product_definition.description = 'placement group') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))) >= 1);
   END_ENTITY;



   ENTITY group_relationship;
      name : label;
      description : OPTIONAL text;
      relating_group : group;
      related_group : group;
   END_ENTITY;



   ENTITY group_shape_aspect
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
      WR2:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF\shape_aspect.of_shape.definition)) AND EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name)) AND (NOT EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name) OR (SELF\shape_aspect.of_shape.definition\product_definition.name = 'interconnect module'));
      WR3:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'constrained object') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY' IN TYPEOF(pdr.related_property_definition.definition)))) = 1))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'design specific purpose'))) = 1))) = 1))) = 0);
      WR5:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'keepout')) AND (it\descriptive_representation_item.description IN [ 'true',

 'false' ]))) = 1))) = 1))) = 0);
      WR6:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) = 1))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition)))) = 1))) = 1);
      WR8:
         NOT (SELF\shape_aspect.description = 'termination constraint') OR (SIZEOF(QUERY (ctm <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'constrained termination member'))| (ctm.related_shape_aspect\shape_aspect.description = 'mating connector termination'))) >= 2);
      WR9:
         EXISTS(SELF\shape_aspect.description);
      WR10:
         NOT (SELF\shape_aspect.description IN [ 'placement group' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition))) AND (pdr.relating_property_definition\property_definition.name = 'requirement'))) = 1))) = 1);
      WR11:
         NOT (SELF\shape_aspect.description IN [ 'termination constraint' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'termination usage constraint') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition))) AND (pdr.relating_property_definition\property_definition.name = 'termination usage constraint'))) = 1))) = 1);
   END_ENTITY;



   ENTITY grouped_requirements_property
   SUBTYPE OF (group,

 requirements_property);
   WHERE
      WR1:
         NOT (SELF\group.name = 'item restricted requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(aga.items) = 1))) = 1);
      WR2:
         NOT (SELF\group.name = 'layout spacing requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(aga.items) = 2) AND (SIZEOF(QUERY (rp <* QUERY (it <* aga.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(rp)) AND (rp\characterized_object.name IN [ 'assembly module assembly component',

 'assembly module component terminal',

 'assembly module component',

 'assembly module macro component join terminal',

 'assembly module macro component',

 'assembly module',

 'bare die component terminal',

 'bare die component',

 'bonded conductive base blind via',

 'buried via',

 'cable component',

 'component feature',

 'component mounting feature',

 'component termination passage and contact size dependent land',

 'component termination passage and contact size dependent non functional land',

 'component termination passage dependent land',

 'component termination passage dependent non functional land',

 'component termination passage interface terminal',

 'component termination passage join terminal',

 'component termination passage',

 'conductive interconnect element terminal',

 'conductive interconnect element with pre defined transitions',

 'conductive interconnect element with user defined single transition',

 'connected area component',

 'contact size dependent land',

 'contact size dependent non functional land',

 'cutout edge segment',

 'cutout',

 'dielectric material passage',

 'electrical isolation laminate component',

 'embedded component terminal',

 'fiducial',

 'fill area',

 'filled area material removal laminate component',

 'inter stratum feature',

 'interconnect component interface terminal',

 'interconnect component join terminal',

 'interconnect module assembly component',

 'interconnect module component stratum based terminal',

 'interconnect module component surface feature',

 'interconnect module component terminal',

 'interconnect module component',

 'interconnect module edge segment',

 'interconnect module edge',

 'interconnect module macro component join terminal',

 'interconnect module macro component',

 'interface access material removal laminate component',

 'interface access stratum feature template component',

 'interface component',

 'interfacial connection',

 'internal probe access area',

 'join two physical connectivity definition supporting inter stratum feature',

 'join two physical connectivity definition supporting printed component',

 'laminate component',

 'laminate text component',

 'laminate text string component',

 'land interface terminal',

 'land join terminal',

 'land',

 'material removal laminate component',

 'minimally defined component terminal',

 'movable packaged component join terminal',

 'multi layer material removal laminate component',

 'multi layer stratum feature template component',

 'non conductive base blind via',

 'non functional land interface terminal',

 'non functional land join terminal',

 'non functional land',

 'packaged component join terminal',

 'packaged component',

 'packaged connector component interface terminal',

 'packaged connector component',

 'partially plated cutout',

 'partially plated interconnect module edge',

 'physical component',

 'physical connectivity interrupting cutout',

 'physical laminate component',

 'physical network supporting inter stratum feature',

 'plated conductive base blind via',

 'plated cutout edge segment',

 'plated cutout',

 'plated interconnect module edge segment',

 'plated interconnect module edge',

 'plated passage or unsupported passage',

 'plated passage',

 'primary stratum indicator symbol',

 'printed component join terminal',

 'printed connector component interface terminal',

 'probe access area',

 'routed interconnect component',

 'routed physical component',

 'special symbol laminate component',

 'stratum feature template component',

 'stratum feature',

 'thermal isolation laminate component',

 'unrouted conductive interconnect element',

 'unsupported passage dependent non functional land',

 'unsupported passage',

 'via and contact size dependent land',

 'via and contact size dependent non functional land',

 'via dependent land',

 'via dependent non functional land',

 'via terminal',

 'via' ]))) = 2))) = 1);
      WR3:
         NOT (SELF\group.name = 'layout spacing requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(QUERY (rp <* QUERY (it <* aga.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(rp)) AND (rp\characterized_object.description = 'dependent design object category'))) = 1))) = 1);
      WR4:
         NOT (SELF\group.name = 'layout spacing requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(QUERY (rp <* QUERY (it <* aga.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(rp)) AND (rp\characterized_object.description = 'reference design object category'))) = 1))) = 1);
   END_ENTITY;



   ENTITY guided_wave_terminal
   SUBTYPE OF (package_terminal);
   END_ENTITY;



   ENTITY half_space_2d
   SUBTYPE OF (geometric_representation_item);
      base_curve : curve;
      agreement_flag : BOOLEAN;
   END_ENTITY;



   ENTITY half_space_solid
   SUBTYPE OF (geometric_representation_item);
      base_surface : surface;
      agreement_flag : BOOLEAN;
   END_ENTITY;



   ENTITY homogeneous_linear_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      sum_index : one_or_two;
   DERIVE
      mat : maths_function := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         function_is_2d_table(mat);
      WR2:
         (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range),

 es_numbers);
   END_ENTITY;



   ENTITY hyperbola
   SUBTYPE OF (conic);
      semi_axis : positive_length_measure;
      semi_imag_axis : positive_length_measure;
   END_ENTITY;



   ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
   END_ENTITY;



   ENTITY identification_assignment
   ABSTRACT SUPERTYPE;
      assigned_id : identifier;
      role : identification_role;
   END_ENTITY;



   ENTITY identification_role;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY illuminance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\illuminance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = lux;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY imported_curve_function
   SUBTYPE OF (maths_function,

 generic_literal);
      geometry : curve;
      parametric_domain : tuple_space;
   WHERE
      WR1:
         expression_is_constant(parametric_domain);
   END_ENTITY;



   ENTITY imported_point_function
   SUBTYPE OF (maths_function,

 generic_literal);
      geometry : point;
   END_ENTITY;



   ENTITY imported_surface_function
   SUBTYPE OF (maths_function,

 generic_literal);
      geometry : surface;
      parametric_domain : tuple_space;
   WHERE
      WR1:
         expression_is_constant(parametric_domain);
   END_ENTITY;



   ENTITY imported_volume_function
   SUBTYPE OF (maths_function,

 generic_literal);
      geometry : volume;
      parametric_domain : tuple_space;
   WHERE
      WR1:
         expression_is_constant(parametric_domain);
   END_ENTITY;



   ENTITY index_expression
   SUBTYPE OF (string_expression,

 binary_generic_expression);
   DERIVE
      operand : generic_expression := SELF\binary_generic_expression.operands[1];
      index : generic_expression := SELF\binary_generic_expression.operands[2];
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(operand)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(index));
      WR2:
         is_int_expr(index);
   END_ENTITY;



   ENTITY indirect_stratum_component_join_implementation
   SUBTYPE OF (plated_inter_stratum_feature);
   END_ENTITY;



   ENTITY inductance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\inductance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = henry;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY int_literal
   SUBTYPE OF (literal_number);
      SELF\literal_number.the_value : INTEGER;
   END_ENTITY;



   ENTITY int_numeric_variable
   SUBTYPE OF (numeric_variable);
   END_ENTITY;



   ENTITY int_value_function
   SUBTYPE OF (value_function);
   END_ENTITY;



   ENTITY integer_defined_function
   ABSTRACT SUPERTYPE
   SUBTYPE OF (numeric_defined_function);
   END_ENTITY;



   ENTITY integer_interval_from_min
   SUBTYPE OF (maths_space,

 generic_literal);
      min : INTEGER;
   END_ENTITY;



   ENTITY integer_interval_to_max
   SUBTYPE OF (maths_space,

 generic_literal);
      max : INTEGER;
   END_ENTITY;



   ENTITY integer_tuple_literal
   SUBTYPE OF (generic_literal);
      lit_value : LIST [1:?] OF INTEGER;
   END_ENTITY;



   ENTITY integral_shield
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_property_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(pdr.relating_property_definition))) AND (pdr\property_definition_relationship.name = 'shielded item'))) >= 1;
   END_ENTITY;



   ENTITY inter_stratum_feature
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'bonded conductive base blind via',

 'buried via',

 'component termination passage',

 'interfacial connection',

 'non conductive base blind via',

 'plated conductive base blind via',

 'plated cutout',

 'partially plated cutout',

 'plated cutout edge segment',

 'partially plated interconnect module edge',

 'plated interconnect module edge segment',

 'plated interconnect module edge',

 'unsupported passage',

 'cutout',

 'physical connectivity interrupting cutout',

 'dielectric material passage',

 'cutout edge segment',

 'interconnect module edge segment',

 'interconnect module edge' ];
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'feature of size')) AND (it\descriptive_representation_item.description IN [ 'true',

 'false' ]))) = 1))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description IN [ 'inter stratum feature template',

 'via template',

 'component termination passage template',

 'unsupported passage template' ]))) = 1;
      WR4:
         NOT (SELF\shape_aspect.description = 'cutout edge segment') OR (SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed cutout'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect)) AND (((cc.relating_shape_aspect\shape_aspect.description = 'cutout') OR (cc.relating_shape_aspect\shape_aspect.description = 'physical connectivity interrupting cutout')) OR (cc.relating_shape_aspect\shape_aspect.description = 'partially plated cutout')))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND ((ce.relating_shape_aspect\shape_aspect.description = 'interconnect module edge') OR (ce.relating_shape_aspect\shape_aspect.description = 'interconnect module edge')))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'dielectric material passage') OR (SIZEOF(QUERY (pp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent passage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(pp.relating_shape_aspect)) AND (((pp.relating_shape_aspect\shape_aspect.description = 'cutout') OR (pp.relating_shape_aspect\shape_aspect.description = 'physical connectivity interrupting cutout')) OR (pp.relating_shape_aspect\shape_aspect.description = 'partially plated cutout')))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'dielectric material passage') OR ((SIZEOF(QUERY (rp <* QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))| (rp\property_definition.name = 'feature material'))) <= 1) OR (SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1));
      WR8:
         NOT (SELF\shape_aspect.description = 'physical connectivity interrupting cutout') OR (SIZEOF(QUERY (ice <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'interrupted connectivity elements'))| (ice.relating_shape_aspect\shape_aspect.name = 'conductive interconnect element'))) >= 1);
      WR9:
         NOT (SELF\shape_aspect.description = 'unsupported passage') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'unsupported passage template'))) = 1);
      WR10:
         NOT (SELF\shape_aspect.description = 'cutout edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
      WR11:
         NOT (SELF\shape_aspect.description = 'plated cutout edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
      WR12:
         NOT (SELF\shape_aspect.description = 'interconnect module edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description = 'plated interconnect module edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
   END_ENTITY;



   ENTITY inter_stratum_feature_edge_segment_template
   SUBTYPE OF (part_template_definition,

 shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF(QUERY (ce <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_TEMPLATE' IN TYPEOF(ce.relating_shape_aspect)))) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition || SELF\shape_aspect_relationship || SELF\inter_stratum_feature_edge_segment_template)) = 0;
   END_ENTITY;



   ENTITY inter_stratum_feature_edge_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition || SELF\inter_stratum_feature_edge_template)) = 0;
      WR2:
         SELF\shape_aspect.description = 'inter stratum feature edge template';
   END_ENTITY;



   ENTITY interconnect_definition
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'interconnect module');
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_INTERCONNECT_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'interconnect module'))) = 1);
   END_ENTITY;



   ENTITY interconnect_module_component_surface_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SELF\shape_aspect.description IN [ 'interconnect module component surface feature' ];
      WR3:
         SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description IN [ 'interconnect module secondary surface',

 'interconnect module primary surface',

 'interconnect module cavity surface',

 'interconnect module cutout surface',

 'interconnect module edge surface',

 'interconnect module edge segment surface' ]))) = 1;
   END_ENTITY;



   ENTITY interconnect_module_cutout_segment_surface
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('interconnect module cutout surface' = ce.relating_shape_aspect\shape_aspect.description))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\interconnect_module_cutout_segment_surface)) = 0;
   END_ENTITY;



   ENTITY interconnect_module_design_object_category
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SELF\characterized_object.description IN [ 'cutout category',

 'fill area category',

 'inter stratum feature category',

 'stratum feature category',

 'via category' ];
   END_ENTITY;



   ENTITY interconnect_module_edge_segment
   SUBTYPE OF (inter_stratum_feature,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated interconnect module edge segment',

 'interconnect module edge segment' ];
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         NOT (SELF\shape_aspect.description = 'plated interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.description = 'plated interconnect module edge'))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description = 'interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.description = 'interconnect module edge'))) = 1);
      WR5:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR6:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR7:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
   END_ENTITY;



   ENTITY interconnect_module_edge_segment_surface
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('interconnect module edge surface' = ce.relating_shape_aspect\shape_aspect.description))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\interconnect_module_edge_segment_surface)) = 0;
   END_ENTITY;



   ENTITY interconnect_module_interface_terminal
   SUBTYPE OF (interconnect_module_terminal);
   END_ENTITY;



   ENTITY interconnect_module_join_terminal
   SUBTYPE OF (interconnect_module_terminal);
   END_ENTITY;



   ENTITY interconnect_module_macro_component_join_terminal
   SUBTYPE OF (component_terminal);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'assembly module component terminal',

 'bare die component terminal',

 'component termination passage join terminal',

 'conductive interconnect element terminal',

 'interconnect component join terminal',

 'land join terminal',

 'minimally defined component terminal',

 'non functional land join terminal',

 'packaged component join terminal',

 'printed component join terminal',

 'package terminal occurrence',

 'via terminal' ]);
   END_ENTITY;



   ENTITY interconnect_module_stratum_based_terminal
   SUBTYPE OF (interconnect_module_terminal);
   END_ENTITY;



   ENTITY interconnect_module_terminal
   SUPERTYPE OF (ONEOF(interconnect_module_interface_terminal,

 interconnect_module_join_terminal))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design usage')) AND (SELF.of_shape.definition\product_definition.name = 'interconnect module');
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) >= 1;
      WR4:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR5:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1;
   END_ENTITY;



   ENTITY interface_access_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY interface_access_material_removal_component_shape_aspect
   SUBTYPE OF (material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY interface_component_definition
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description IN [ 'interconnect component interface terminal',

 'packaged connector component interface terminal' ]))) >= 1))) >= 1;
   END_ENTITY;



   ENTITY interface_mounted_join
   SUBTYPE OF (shape_aspect_relationship,

 shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal');
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect)) AND ((((((SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal') OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal'));
   END_ENTITY;



   ENTITY interfaced_group_component_definition
   SUBTYPE OF (assembly_group_component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (gc <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'group component'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(gc.related_product_definition)))) >= 1;
   END_ENTITY;



   ENTITY intersection_curve
   SUBTYPE OF (surface_curve);
   WHERE
      WR1:
         SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2:
         associated_surface(SELF\surface_curve.associated_geometry[1]) <> associated_surface(SELF\surface_curve.associated_geometry[2]);
   END_ENTITY;



   ENTITY interval_expression
   SUBTYPE OF (boolean_expression,

 multiple_arity_generic_expression);
   DERIVE
      interval_low : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
      interval_item : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
      interval_high : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
   WHERE
      WR1:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXPRESSION' IN TYPEOF(interval_low)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXPRESSION' IN TYPEOF(interval_item))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXPRESSION' IN TYPEOF(interval_high));
      WR2:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF.interval_high))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF.interval_item)) OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_item))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_high));
   END_ENTITY;



   ENTITY item_defined_transformation;
      name : label;
      description : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
   END_ENTITY;



   ENTITY item_identified_representation_usage;
      name : label;
      description : OPTIONAL text;
      definition : represented_definition;
      used_representation : representation;
      identified_item : representation_item;
   WHERE
      WR1:
         SELF.used_representation IN using_representations(SELF.identified_item);
   END_ENTITY;



   ENTITY join_shape_aspect
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.name IN [ 'constrained intra layer join',

 'inter stratum join',

 'intra stratum join' ]) OR (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(cp.related_shape_aspect)))) >= 2);
      WR2:
         SIZEOF(QUERY (nt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'network topology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK' IN TYPEOF(nt.relating_shape_aspect)))) = 1;
      WR3:
         NOT (SELF\shape_aspect.name = 'intra stratum join') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect)) AND (ji.related_shape_aspect\shape_aspect.description = 'conductor'))) <= 1);
      WR4:
         NOT (SELF\shape_aspect.name = 'intra stratum join') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect)) AND (ji.related_shape_aspect\shape_aspect.description = 'connected filled area'))) <= 1);
      WR5:
         NOT (SELF\shape_aspect.name = 'inter stratum join') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP' IN TYPEOF(ji.related_shape_aspect)) AND (ji.related_shape_aspect\shape_aspect.description = 'physical network supporting stratum feature conductive join') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect)))) <= 1);
      WR6:
         NOT (SELF\shape_aspect.name = 'unrouted join') OR (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'unrouted terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(cp.related_shape_aspect)))) >= 2);
   END_ENTITY;



   ENTITY keepout_design_object_category
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SELF\characterized_object.description IN [ 'assembly module assembly component category',

 'component feature category',

 'assembly ee material category',

 'interconnect ee material category',

 'interconnect module assembly component category',

 'via category',

 'inter stratum feature category',

 'cutout category',

 'fill area category',

 'laminate component category',

 'stratum feature category' ];
   END_ENTITY;



   ENTITY laminate_component_interface_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage interface terminal',

 'land interface terminal',

 'printed connector component interface terminal',

 'non functional land interface terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) = 1;
      WR4:
         NOT (SELF\shape_aspect.description = 'component termination passage interface terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description = 'component termination passage template interface terminal'))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description IN [ 'land interface terminal',

 'non functional land interface terminal' ]) OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND TRUE)) = 1);
      WR8:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR SELF.product_definitional;
      WR9:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_COMPONENT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'printed connector component');
      WR10:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'interface terminal'))) = 1);
      WR11:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR (SIZEOF(QUERY (i <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (pdr\shape_aspect_relationship.name = 'implementation'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(i.relating_shape_aspect)) = 1))) = 1);
      WR12:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference\application_context_element.name = 'layout occurrence');
   END_ENTITY;



   ENTITY laminate_group_component_make_from_relationship
   SUBTYPE OF (make_from_usage_option);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION') ] * TYPEOF(SELF.relating_product_definition)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION') ] * TYPEOF(SELF.related_product_definition)) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr.name = 'stratum mapping') AND (pdr.related_property_definition\property_definition.definition\product_definition_relationship.name = 'stratum make from')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_USAGE_OPTION' IN TYPEOF(pdr.related_property_definition\property_definition.definition)))) > 0))) > 0;
   END_ENTITY;



   ENTITY land
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(i_f.relating_shape_aspect)))) = 1;
      WR2:
         SIZEOF(QUERY (aud <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'alternate usage definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(aud.relating_shape_aspect)))) <= 1;
      WR3:
         SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) = 1;
      WR8:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage and contact size dependent land',

 'component termination passage and contact size dependent' + 'non functional land',

 'component termination passage dependent land',

 'component termination passage dependent non functional land' ]) OR (SIZEOF(QUERY (rp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference passage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(rp.relating_shape_aspect)) AND (rp.relating_shape_aspect\shape_aspect.description = 'component termination passage'))) = 1);
      WR9:
         NOT (SELF\shape_aspect.description IN [ 'via and contact size dependent land',

 'via and contact size dependent non functional land',

 'via dependent land',

 'via dependent non functional land' ]) OR (SIZEOF(QUERY (rv <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference via'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(rv.relating_shape_aspect)) AND (rv.relating_shape_aspect\shape_aspect.description IN [ 'buried via',

 'interfacial connection',

 'bonded conductive base blind via',

 'non conductive base blind via',

 'plated conductive base blind via' ]))) = 1);
      WR10:
         NOT (SELF\shape_aspect.description = 'unsupported passage dependent non functional land') OR (SIZEOF(QUERY (rp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference passage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(rp.relating_shape_aspect)) AND (rp.relating_shape_aspect\shape_aspect.description = 'unsupported passage'))) = 1);
      WR11:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage dependent land',

 'component termination passage dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default component termination passage based'))) = 1);
      WR12:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage and contact size dependent land',

 'component termination passage and contact size dependent ' + 'non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default attachment size and component termination ' + 'passage based'))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description IN [ 'contact size dependent land',

 'contact size dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default attachment size based'))) = 1);
      WR14:
         NOT (SELF\shape_aspect.description IN [ 'via and contact size dependent land',

 'via and contact size dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default attachment size and via based'))) = 1);
      WR15:
         NOT (SELF\shape_aspect.description IN [ 'via dependent land',

 'via dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default via based'))) = 1);
      WR16:
         NOT (SELF\shape_aspect.description = 'unsupported passage dependent ' + 'non functional land') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default unsupported passage based'))) = 1);
   END_ENTITY;



   ENTITY land_physical_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'pre defined classification code'))) = 1))) <= 1;
      WR2:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(am.related_shape_aspect)))) >= 1;
      WR3:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size based',

 'default attachment size and component termination passage based',

 'default attachment size and via based' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'minimum attachment region size') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1));
      WR4:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size based',

 'default attachment size and component termination passage based',

 'default attachment size and via based' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'maximum attachment region size') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1));
      WR5:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default component termination passage based',

 'default attachment size and component termination passage based' ]) OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)) AND (tu.related_shape_aspect\shape_aspect.description = 'default component termination passage definition'))) = 1));
      WR6:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',

 'default attachment size based',

 'default attachment size and via based',

 'default component termination passage based',

 'default via based',

 'default unsupported passage based' ]) OR (SIZEOF(QUERY (ost <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'of stratum technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(ost.relating_shape_aspect.of_shape.definition)))) = 1));
      WR7:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',

 'default attachment size and via based',

 'default component termination passage based',

 'default via based',

 'default unsupported passage based' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) = 2))) = 1))) = 0));
      WR8:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',

 'default attachment size and via based',

 'default component termination passage based',

 'default via based',

 'default unsupported passage based' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum fabrication allowance'))) = 1))) = 1))) = 0));
      WR9:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',

 'default attachment size and via based',

 'default component termination passage based',

 'default via based',

 'default unsupported passage based' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum annular ring'))) = 1))) = 1))) = 0));
      WR10:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',

 'default attachment size and via based',

 'default component termination passage based',

 'default via based',

 'default unsupported passage based' ]) OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)))) = 1));
      WR11:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default via based',

 'default attachment size and via based' ]) OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)) AND (tu.related_shape_aspect\shape_aspect.description = 'default via definition'))) = 1));
      WR12:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'default unsupported passage') OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)) AND (tu.related_shape_aspect\shape_aspect.description = 'default unsupported passage definition'))) = 1));
   END_ENTITY;



   ENTITY land_template_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ];
      WR2:
         SIZEOF(QUERY (tcz <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'terminal connection zone') AND (sar\shape_aspect_relationship.description IN [ 'edge curve',

 'edge point',

 'surface area',

 'surface point' ]))| (tcz.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 0;
   END_ENTITY;



   ENTITY layer
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'layer definition'))) = 1))) <= 1;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition_relationship.name = 'inter stratum extent');
   END_ENTITY;



   ENTITY layer_connection_point
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,

 SELF\shape_aspect.of_shape;
   WHERE
      WR1:
         SELF\shape_aspect.of_shape.definition\product_definition.name = 'design layer';
      WR2:
         SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'intra stratum join'))) = 1;
      WR4:
         NOT (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'inter stratum join'))) = 1) OR (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'intra stratum join'))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'dependently located') OR (SIZEOF(QUERY (ado <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated design object'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL') ] * TYPEOF(ado.relating_shape_aspect)) = 1) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(ado.relating_shape_aspect)) = 1) AND (ado.relating_shape_aspect.description IN [ 'printed component join terminal',

 'embedded component terminal' ]))) = 1);
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'connection point location 2d')) AND (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(it)) AND (it\geometric_representation_item.dim = 2))) = 1))) <= 1))) = 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'connection point location 3d')) AND (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(it)) AND (it\geometric_representation_item.dim = 3))) = 1))) <= 1))) = 0;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND ((pdr.used_representation\representation.name = 'connection point location 2d') OR (pdr.used_representation\representation.name = 'connection point location 3d')))) >= 1))) = 0;
      WR9:
         NOT (SELF\shape_aspect.description = 'dependently located') OR (SIZEOF(QUERY (ado <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference zone'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT') ] * TYPEOF(ado.relating_shape_aspect)) = 1) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT') ] * TYPEOF(ado.relating_shape_aspect)) = 1) AND (ado.relating_shape_aspect.description IN [ 'connection zone' ]))) <= 1);
   END_ENTITY;



   ENTITY layout_macro_component
   SUBTYPE OF (printed_component);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'layout macro component shape aspect'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design definition'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_DEFINITION') ] * TYPEOF(ip.relating_product_definition)) = 1))) = 1;
      WR3:
         SELF\product_definition.description <> 'printed connector component';
   END_ENTITY;



   ENTITY layout_macro_definition
   SUBTYPE OF (interconnect_definition);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_INTERCONNECT_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'interconnect module'))) = 0;
      WR3:
         SELF.frame_of_reference\application_context_element.name = 'physical design';
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'layout macro definition shape aspect'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'floor layout view'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1))) = 1))) = 0;
   END_ENTITY;



   ENTITY layout_macro_definition_terminal_to_usage_terminal_assignment
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.name;
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship || SELF\layout_macro_definition_terminal_to_usage_terminal_assignment || SELF\shape_aspect)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description IN [ 'component termination passage join terminal',

 'conductive interconnect element terminal',

 'land join terminal',

 'non functional land join terminal',

 'printed component join terminal',

 'via terminal' ];
      WR4:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')) <= 1;
   END_ENTITY;



   ENTITY layout_macro_floor_plan_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage template',

 'component termination passage template',

 'default trace template',

 'inter stratum feature template',

 'printed connector template',

 'printed part cross section template',

 'printed part template',

 'trace template',

 'unsupported passage template',

 'via template',

 'non conductive cross section template' ]);
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access maps') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_DEFINITION_TERMINAL_TO_USAGE_TERMINAL_ASSIGNMENT' IN TYPEOF(sar.relating_shape_aspect)))) >= 1;
   END_ENTITY;



   ENTITY length_function
   SUBTYPE OF (numeric_expression,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : string_expression;
   END_ENTITY;



   ENTITY length_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY length_trimmed_terminal
   SUBTYPE OF (altered_package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) = 2))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum trimmed length'))) = 1))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum trimmed length'))) = 1))) = 1))) = 0;
   END_ENTITY;



   ENTITY length_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 1.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY library_defined_assembly_definition
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SELF\product_definition.name = 'assembly module';
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
   END_ENTITY;



   ENTITY library_defined_bare_die
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (ifdu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition)) AND (ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'device unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0;
   END_ENTITY;



   ENTITY library_defined_functional_unit
   SUBTYPE OF (externally_defined_functional_unit);
   DERIVE
      library : external_source := SELF\externally_defined_item.source;
   END_ENTITY;



   ENTITY library_defined_interconnect_definition
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SELF\product_definition.name = 'interconnect module';
   END_ENTITY;



   ENTITY library_defined_package
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical design usage';
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')) > 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sa)))) = 1))) = 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' IN TYPEOF(sa)))) = 1))) <= 1;
      WR5:
         NOT (EXISTS(SELF\product_definition.description) AND (SELF\product_definition.description = 'altered package')) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package preparation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pdr.relating_product_definition)) = 1))) = 1);
   END_ENTITY;



   ENTITY library_defined_packaged_connector
   SUBTYPE OF (library_defined_packaged_part);
   END_ENTITY;



   ENTITY library_defined_packaged_part
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0);
      WR2:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)) AND (ifu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR4:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE' IN TYPEOF(upkg.related_product_definition)))) = 1);
      WR5:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (bpp <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'base packaged part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(bpp.relating_product_definition)) = 1) AND (bpp.relating_product_definition.frame_of_reference.name = 'physical design usage'))) >= 1);
      WR6:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(upkg.relating_product_definition)) = 1))) >= 1);
   END_ENTITY;



   ENTITY library_defined_physical_unit
   SUPERTYPE OF (ONEOF(library_defined_package,

 library_defined_assembly_definition,

 library_defined_interconnect_definition,

 library_defined_packaged_part,

 library_defined_bare_die))
   SUBTYPE OF (externally_defined_physical_unit);
   DERIVE
      library : external_source := SELF\externally_defined_item.source;
   END_ENTITY;



   ENTITY library_defined_product_definition
   SUBTYPE OF (externally_defined_product_definition);
   DERIVE
      library : external_source := SELF\externally_defined_item.source;
   END_ENTITY;



   ENTITY like_expression
   SUBTYPE OF (comparison_expression);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF\comparison_expression.operands[1])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(SELF\comparison_expression.operands[2]));
   END_ENTITY;



   ENTITY line
   SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
   WHERE
      WR1:
         dir.dim = pnt.dim;
   END_ENTITY;



   ENTITY linear_array_component_definition_link
   SUBTYPE OF (product_definition,

 product_definition_relationship);
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\linear_array_component_definition_link)) = 0;
      WR5:
         SELF\product_definition.name = '';
      WR6:
         SELF\product_definition_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
   END_ENTITY;



   ENTITY linear_array_component_shape_aspect_link
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\linear_array_component_shape_aspect_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY linear_array_placement_group_component_definition
   SUBTYPE OF (array_placement_group_component_definition);
   END_ENTITY;



   ENTITY linear_array_placement_group_component_shape_aspect
   SUBTYPE OF (array_placement_group_component_shape_aspect);
   END_ENTITY;



   ENTITY linear_composite_array_shape_aspect
   SUBTYPE OF (composite_array_shape_aspect);
   END_ENTITY;



   ENTITY linear_composite_array_shape_aspect_link
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\linear_composite_array_shape_aspect_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY linear_profile_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         NOT (SELF\geometric_tolerance.name = 'linear profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control')) AND ((gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile locating') OR (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')))) = 1);
      WR2:
         NOT (SELF\geometric_tolerance.name = 'linear profile locating') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) = 1);
      WR3:
         NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(SELF)) AND (SELF\geometric_tolerance.name = 'linear profile refinement')) OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) = 0);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'linear profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) <= 1);
      WR5:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY linearized_table_function
   SUPERTYPE OF (ONEOF(standard_table_function,

 regular_table_function,

 triangular_matrix,

 symmetric_matrix,

 banded_matrix))
   SUBTYPE OF (explicit_table_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      first : INTEGER;
   DERIVE
      source : maths_function := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         function_is_1d_array(source);
   END_ENTITY;



   ENTITY listed_complex_number_data
   SUBTYPE OF (explicit_table_function,

 generic_literal);
      values : LIST [2:?] OF REAL;
   DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [];
   WHERE
      WR1:
         NOT ODD(SIZEOF(values));
   END_ENTITY;



   ENTITY listed_data
   SUBTYPE OF (explicit_table_function,

 generic_literal);
      values : LIST [1:?] OF maths_value;
      value_range : maths_space;
   DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) ];
   WHERE
      WR1:
         expression_is_constant(value_range);
      WR2:
         SIZEOF(QUERY (val <* values| NOT member_of(val,

 value_range))) = 0;
   END_ENTITY;



   ENTITY listed_integer_data
   SUBTYPE OF (explicit_table_function,

 generic_literal);
      values : LIST [1:?] OF INTEGER;
   DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) ];
   END_ENTITY;



   ENTITY listed_logical_data
   SUBTYPE OF (explicit_table_function,

 generic_literal);
      values : LIST [1:?] OF LOGICAL;
   DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) ];
   END_ENTITY;



   ENTITY listed_product_space
   SUBTYPE OF (maths_space,

 generic_literal);
      factors : LIST OF maths_space;
   WHERE
      WR1:
         SIZEOF(QUERY (space <* factors| NOT expression_is_constant(space))) = 0;
      WR2:
         no_cyclic_space_reference(SELF,

 []);
      WR3:
         NOT (the_empty_space IN factors);
   END_ENTITY;



   ENTITY listed_real_data
   SUBTYPE OF (explicit_table_function,

 generic_literal);
      values : LIST [1:?] OF REAL;
   DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) ];
   END_ENTITY;



   ENTITY listed_string_data
   SUBTYPE OF (explicit_table_function,

 generic_literal);
      values : LIST [1:?] OF STRING;
   DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) ];
   END_ENTITY;



   ENTITY literal_number
   ABSTRACT SUPERTYPE OF (ONEOF(int_literal,

 real_literal))
   SUBTYPE OF (simple_numeric_expression,

 generic_literal);
      the_value : NUMBER;
   END_ENTITY;



   ENTITY local_time;
      hour_component : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone : coordinated_universal_time_offset;
   WHERE
      WR1:
         valid_time(SELF);
   END_ENTITY;



   ENTITY log10_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY log2_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY log_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY logical_literal
   SUBTYPE OF (generic_literal);
      lit_value : LOGICAL;
   END_ENTITY;



   ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop,

 edge_loop,

 poly_loop))
   SUBTYPE OF (topological_representation_item);
   END_ENTITY;



   ENTITY lot_effectivity
   SUBTYPE OF (effectivity);
      effectivity_lot_id : identifier;
      effectivity_lot_size : measure_with_unit;
   END_ENTITY;



   ENTITY luminous_flux_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\luminous_flux_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = lumen;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY luminous_intensity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY luminous_intensity_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.00000);
   END_ENTITY;



   ENTITY magnetic_flux_density_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\magnetic_flux_density_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = tesla;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY magnetic_flux_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\magnetic_flux_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = weber;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY make_from_connectivity_relationship
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.relating_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.related_shape_aspect);
   END_ENTITY;



   ENTITY make_from_feature_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.relating_shape_aspect)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.related_shape_aspect)) = 1;
      WR3:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.relating_shape_aspect)) OR (SELF.relating_shape_aspect\shape_aspect.description IN [ 'component feature',

 'component termination passage interface terminal',

 'land or non functional land interface terminal',

 'printed connector component interface terminal' ]);
      WR4:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.related_shape_aspect)) OR (SELF.related_shape_aspect\shape_aspect.description IN [ 'component feature',

 'component termination passage interface terminal',

 'land or non functional land interface terminal',

 'printed connector component interface terminal' ]);
   END_ENTITY;



   ENTITY make_from_functional_unit_terminal_definition_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.relating_shape_aspect,

 SELF\shape_aspect_relationship.related_shape_aspect;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') ] * TYPEOF(SELF.relating_shape_aspect)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') ] * TYPEOF(SELF.related_shape_aspect)) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\make_from_functional_unit_terminal_definition_relationship)) = 0;
      WR4:
         relating_shape_aspect.of_shape :<>: related_shape_aspect.of_shape;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect.description = '';
      WR7:
         SELF\shape_aspect.product_definitional = FALSE;
      WR8:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')) = 0;
      WR9:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_MAKE_FROM_RELATIONSHIP' IN TYPEOF(sar.of_shape\property_definition.definition)))) = 1;
   END_ENTITY;



   ENTITY make_from_model_port_relationship
   SUBTYPE OF (representation,

 representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,

 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT') ] * TYPEOF(SELF.rep_1)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT') ] * TYPEOF(SELF.rep_2)) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\make_from_model_port_relationship)) = 0;
      WR4:
         rep_1 :<>: rep_2;
      WR5:
         SIZEOF(QUERY (rr1 <* USEDIN(SELF.rep_1,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (SIZEOF(QUERY (rr2 <* USEDIN(SELF.rep_2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr1.rep_1 :=: rr2.rep_1))) = 0))) = 1;
      WR6:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_MAKE_FROM_RELATIONSHIP' IN TYPEOF(rr.rep_1)))) = 1;
   END_ENTITY;



   ENTITY make_from_part_feature_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.relating_shape_aspect,

 SELF\shape_aspect_relationship.related_shape_aspect;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.relating_shape_aspect)) = 0;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.related_shape_aspect)) = 0;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\make_from_part_feature_relationship)) = 0;
      WR4:
         SELF.related_shape_aspect.product_definitional = TRUE;
      WR5:
         SELF.relating_shape_aspect.product_definitional = TRUE;
      WR6:
         SELF\shape_aspect.name = '';
      WR7:
         SELF\shape_aspect.description = '';
      WR8:
         SELF\shape_aspect.product_definitional = FALSE;
      WR9:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')) = 0;
      WR10:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_MAKE_FROM_RELATIONSHIP' IN TYPEOF(sar.of_shape\property_definition.definition)))) = 1;
   END_ENTITY;



   ENTITY make_from_usage_option
   SUBTYPE OF (product_definition_usage);
      ranking : INTEGER;
      ranking_rationale : text;
      quantity : measure_with_unit;
   WHERE
      WR1:
         NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.value_component > 0);
   END_ENTITY;



   ENTITY manifold_constraining_context_dependent_shape_representation
   SUBTYPE OF (context_dependent_shape_representation,

 representation_relationship);
   END_ENTITY;



   ENTITY manifold_solid_brep
   SUBTYPE OF (solid_model);
      outer : closed_shell;
   END_ENTITY;



   ENTITY manifold_subsurface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
      WR5:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(cfss.parent_face_set)) AND (SIZEOF(QUERY (fac <* cfss.parent_face_set.cfs_faces| NOT advanced_face_properties(fac))) = 0) OR (SIZEOF(QUERY (fac <* cfss.parent_face_set.cfs_faces| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fac)))) >= 0)))) = 0;
      WR6:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| (SIZEOF(QUERY (fac <* cfss\connected_face_set.cfs_faces| NOT advanced_face_properties(fac))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBEDGE' IN TYPEOF(oe.edge_element))))) = 0))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_end))))) = 0))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (bnds <* fcs.bounds| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' ] * TYPEOF(bnds.bound)) = 1))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(QUERY (sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(sc_ag)))) = 0))) = 0))) = 0))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3))) = 0))) = 0))) = 0))) = 0;
   END_ENTITY;



   ENTITY manifold_surface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (sh <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' ] * TYPEOF(sh)) = 1))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' ] * TYPEOF(fa)) = 1))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (f_sf <* QUERY (fa <* cfs\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE' IN TYPEOF(fa)))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(f_sf)) OR (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' ] * TYPEOF(f_sf\face_surface.face_geometry)) = 1)))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR msf_surface_check(fa\face_surface.face_geometry)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (bnds <* fa.bounds| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' ] * TYPEOF(bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe_cv <* QUERY (oe <* elp_fbnds\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)))| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' ] * TYPEOF(oe_cv.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT msf_curve_check(oe.edge_element\edge_curve.edge_geometry))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR13:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ((SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1) AND (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR14:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) = 0))) = 0;
      WR15:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' ] * TYPEOF(vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) = 1))) = 0)))) = 0))) = 0))) = 0;
   END_ENTITY;



   ENTITY mapped_item
   SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
   WHERE
      WR1:
         acyclic_mapped_representation(using_representations(SELF),

 [ SELF ]);
   END_ENTITY;



   ENTITY mass_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY mass_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 1.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY material_designation;
      name : label;
      definitions : SET [1:?] OF characterized_definition;
   END_ENTITY;



   ENTITY material_designation_characterization;
      name : label;
      description : text;
      designation : material_designation;
      property : characterized_material_property;
   END_ENTITY;



   ENTITY material_electrical_conductivity_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'conductive',

 'non conductive',

 'resistive',

 'semi conductive' ];
   END_ENTITY;



   ENTITY material_functional_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'bonding agent',

 'potting compound',

 'marking material' ];
   END_ENTITY;



   ENTITY material_optical_conductivity_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'conductive',

 'non conductive',

 'resistive',

 'semi conductive' ];
   END_ENTITY;



   ENTITY material_property
   SUBTYPE OF (property_definition);
   UNIQUE
      UR1 : SELF\property_definition.name,

 SELF\property_definition.definition;
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) OR (SIZEOF(bag_to_set(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - QUERY (temp <* bag_to_set(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp)))) = 0);
   END_ENTITY;



   ENTITY material_property_representation
   SUBTYPE OF (property_definition_representation);
      dependent_environment : data_environment;
   END_ENTITY;



   ENTITY material_removal_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY material_thermal_conductivity_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'conductive',

 'non conductive',

 'resistive',

 'semi conductive' ];
   END_ENTITY;



   ENTITY mathematical_description;
      described : maths_expression;
      describing : STRING;
      encoding : label;
   END_ENTITY;



   ENTITY maths_boolean_variable
   SUBTYPE OF (maths_variable,

 boolean_variable);
   WHERE
      WR1:
         subspace_of_es(SELF\maths_variable.values_space,

 es_booleans);
   END_ENTITY;



   ENTITY maths_enum_literal
   SUBTYPE OF (generic_literal);
      lit_value : maths_enum_atom;
   END_ENTITY;



   ENTITY maths_function
   ABSTRACT SUPERTYPE OF (ONEOF(finite_function,

 constant_function,

 selector_function,

 elementary_function,

 restriction_function,

 repackaging_function,

 reindexed_array_function,

 series_composed_function,

 parallel_composed_function,

 explicit_table_function,

 homogeneous_linear_function,

 general_linear_function,

 b_spline_basis,

 b_spline_function,

 rationalize_function,

 partial_derivative_function,

 definite_integral_function,

 abstracted_expression_function,

 expression_denoted_function,

 imported_point_function,

 imported_curve_function,

 imported_surface_function,

 imported_volume_function,

 application_defined_function))
   SUBTYPE OF (generic_expression);
   DERIVE
      domain : tuple_space := derive_function_domain(SELF);
      range : tuple_space := derive_function_range(SELF);
   END_ENTITY;



   ENTITY maths_integer_variable
   SUBTYPE OF (maths_variable,

 int_numeric_variable);
   WHERE
      WR1:
         subspace_of_es(SELF\maths_variable.values_space,

 es_integers);
   END_ENTITY;



   ENTITY maths_real_variable
   SUBTYPE OF (maths_variable,

 real_numeric_variable);
   WHERE
      WR1:
         subspace_of_es(SELF\maths_variable.values_space,

 es_reals);
   END_ENTITY;



   ENTITY maths_space
   ABSTRACT SUPERTYPE OF (ONEOF(elementary_space,

 finite_integer_interval,

 integer_interval_from_min,

 integer_interval_to_max,

 finite_real_interval,

 real_interval_from_min,

 real_interval_to_max,

 cartesian_complex_number_region,

 polar_complex_number_region,

 finite_space,

 uniform_product_space,

 listed_product_space,

 extended_tuple_space,

 function_space))
   SUBTYPE OF (generic_expression);
   END_ENTITY;



   ENTITY maths_space_context
   SUPERTYPE OF (ONEOF(compound_maths_space_context,

 defined_maths_space_context,

 explicitly_enumerated_maths_space_context));
      id : identifier;
      name : label;
      description : OPTIONAL text;
      abstract_space : maths_space;
      physical_space : space_context_select;
   END_ENTITY;



   ENTITY maths_space_context_relationship;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      related_context : maths_space_context;
      relating_context : maths_space_context;
   END_ENTITY;



   ENTITY maths_space_context_relationship_description;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      described_relationship : maths_space_context_relationship;
      describing_relationship : maths_function;
   END_ENTITY;



   ENTITY maths_string_variable
   SUBTYPE OF (maths_variable,

 string_variable);
   WHERE
      WR1:
         subspace_of_es(SELF\maths_variable.values_space,

 es_strings);
   END_ENTITY;



   ENTITY maths_tuple_literal
   SUBTYPE OF (generic_literal);
      lit_value : LIST OF maths_value;
   END_ENTITY;



   ENTITY maths_value_context;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      abstract_value : maths_value;
      physical_value : value_context_select;
   END_ENTITY;



   ENTITY maths_variable
   SUBTYPE OF (generic_variable);
      values_space : maths_space;
      name : label;
   WHERE
      WR1:
         expression_is_constant(values_space);
   END_ENTITY;



   ENTITY maximum_function
   SUBTYPE OF (multiple_arity_function_call);
   END_ENTITY;



   ENTITY measure_qualification;
      name : label;
      description : text;
      qualified_measure : measure_with_unit;
      qualifiers : SET [1:?] OF value_qualifier;
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* qualifiers| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRECISION_QUALIFIER' IN TYPEOF(temp)))) < 2;
   END_ENTITY;



   ENTITY measure_representation_item
   SUBTYPE OF (representation_item,

 measure_with_unit);
   END_ENTITY;



   ENTITY measure_with_unit
   SUPERTYPE OF (ONEOF(length_measure_with_unit,

 mass_measure_with_unit,

 time_measure_with_unit,

 electric_current_measure_with_unit,

 thermodynamic_temperature_measure_with_unit,

 celsius_temperature_measure_with_unit,

 amount_of_substance_measure_with_unit,

 luminous_intensity_measure_with_unit,

 plane_angle_measure_with_unit,

 solid_angle_measure_with_unit,

 area_measure_with_unit,

 volume_measure_with_unit,

 ratio_measure_with_unit));
      value_component : measure_value;
      unit_component : unit;
   WHERE
      WR1:
         valid_units(SELF);
   END_ENTITY;



   ENTITY membership_of_maths_space_context;
      space_context : maths_space_context;
      value_context : maths_value_context;
   END_ENTITY;



   ENTITY minimally_defined_bare_die_terminal
   SUPERTYPE OF (bare_die_terminal)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'external connection area'))| (eca.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
      WR4:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY minimally_defined_connector
   SUBTYPE OF (packaged_part);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)) AND (sa.description = 'interface terminal'))) >= 0))) >= 0;
   END_ENTITY;



   ENTITY minimum_function
   SUBTYPE OF (multiple_arity_function_call);
   END_ENTITY;



   ENTITY minus_expression
   SUBTYPE OF (binary_numeric_expression);
   END_ENTITY;



   ENTITY minus_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY mod_expression
   SUBTYPE OF (binary_numeric_expression);
   END_ENTITY;



   ENTITY model_parameter
   SUPERTYPE OF (ONEOF(analytical_model_parameter,

 category_model_parameter,

 rule_function_domain_parameter,

 rule_function_range_parameter))
   SUBTYPE OF (descriptive_representation_item,

 group_assignment);
      items : OPTIONAL SET [1:1] OF model_parameter_assigned_item;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
      WR2:
         SIZEOF(QUERY (aga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_TYPE' IN TYPEOF(aga.assigned_group)) AND (aga.assigned_group\group.name IN [ 'string property type',

 'logical property type',

 'physical property type',

 'boolean property type' ]))) = 1;
   END_ENTITY;



   ENTITY model_parameter_relationship
   SUBTYPE OF (representation_item,

 representation_item_relationship);
   UNIQUE
      UR1 : SELF\representation_item_relationship.relating_representation_item,

 SELF\representation_item_relationship.related_representation_item;
   WHERE
      WR1:
         SELF\representation_item_relationship.relating_representation_item :<>: SELF\representation_item_relationship.related_representation_item;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation_item || SELF\representation_item_relationship || SELF\model_parameter_relationship)) = 0;
   END_ENTITY;



   ENTITY modified_geometric_tolerance
   SUBTYPE OF (geometric_tolerance);
      modifier : limit_condition;
   END_ENTITY;



   ENTITY mounting_restriction_area
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
      WR3:
         SELF.of_shape.definition.frame_of_reference.name IN [ 'physical design' ];
      WR4:
         SELF.of_shape.definition\product_definition.name = 'assembly module';
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) = 1))) = 0;
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'mounting surface') AND (sar.related_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 1;
      WR7:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\mounting_restriction_area)) = 0;
   END_ENTITY;



   ENTITY mounting_restriction_volume
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SELF.of_shape.definition.frame_of_reference.name IN [ 'physical design' ];
      WR3:
         SELF.of_shape.definition.name = 'assembly module';
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 3))) = 1))) = 0;
      WR5:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'mounting surface')) AND (sar.related_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\mounting_restriction_volume)) = 0;
   END_ENTITY;



   ENTITY mult_expression
   SUBTYPE OF (multiple_arity_numeric_expression);
   END_ENTITY;



   ENTITY multi_layer_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY multi_layer_material_removal_component_shape_aspect
   SUBTYPE OF (material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY multi_layer_stratum_feature
   SUBTYPE OF (stratum_feature);
   END_ENTITY;



   ENTITY multiple_arity_Boolean_expression
   ABSTRACT SUPERTYPE OF (ONEOF(and_expression,

 or_expression))
   SUBTYPE OF (boolean_expression,

 multiple_arity_generic_expression);
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF boolean_expression;
   END_ENTITY;



   ENTITY multiple_arity_function_call
   ABSTRACT SUPERTYPE OF (ONEOF(maximum_function,

 minimum_function))
   SUBTYPE OF (multiple_arity_numeric_expression);
   END_ENTITY;



   ENTITY multiple_arity_generic_expression
   ABSTRACT SUPERTYPE
   SUBTYPE OF (generic_expression);
      operands : LIST [2:?] OF generic_expression;
   END_ENTITY;



   ENTITY multiple_arity_numeric_expression
   ABSTRACT SUPERTYPE OF (ONEOF(plus_expression,

 mult_expression,

 multiple_arity_function_call))
   SUBTYPE OF (numeric_expression,

 multiple_arity_generic_expression);
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF numeric_expression;
   END_ENTITY;



   ENTITY name_attribute;
      attribute_value : label;
      named_item : name_attribute_select;
   END_ENTITY;



   ENTITY named_unit
   SUPERTYPE OF (ONEOF(si_unit,

 conversion_based_unit,

 context_dependent_unit) ANDOR

 ONEOF(length_unit,

 mass_unit,

 time_unit,

 electric_current_unit,

 thermodynamic_temperature_unit,

 amount_of_substance_unit,

 luminous_intensity_unit,

 plane_angle_unit,

 solid_angle_unit,

 area_unit,

 volume_unit,

 ratio_unit));
      dimensions : dimensional_exponents;
   END_ENTITY;



   ENTITY named_unit_variable
   SUBTYPE OF (named_unit,

 variable_semantics);
   INVERSE
      associated_variable_environment : environment FOR semantics;
   END_ENTITY;



   ENTITY network_node_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'functional network design';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (funtdna <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition node assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(funtdna.related_property_definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(funtdna.related_property_definition.definition)))) <= 1))) <= 1;
      WR3:
         SIZEOF(QUERY (funn <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(funn.relating_product_definition)) AND (funn.relating_product_definition.frame_of_reference.name = 'functional network design'))) = 1;
   END_ENTITY;



   ENTITY next_assembly_usage_occurrence
   SUBTYPE OF (assembly_component_usage);
   END_ENTITY;



   ENTITY normalized_maths_space_context
   SUBTYPE OF (defined_maths_space_context);
      normalization_basis : value_context_select;
   END_ENTITY;



   ENTITY normalized_property_distribution_description;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      abstract_function : maths_function;
      domain_context : maths_space_context;
      normalization_basis : property_distribution_select;
      physical_function : property_distribution_select;
   END_ENTITY;



   ENTITY not_expression
   SUBTYPE OF (unary_boolean_expression);
      SELF\unary_generic_expression.operand : boolean_expression;
   END_ENTITY;



   ENTITY numeric_defined_function
   ABSTRACT SUPERTYPE OF (ONEOF(integer_defined_function,

 real_defined_function))
   SUBTYPE OF (numeric_expression,

 defined_function);
   END_ENTITY;



   ENTITY numeric_expression
   ABSTRACT SUPERTYPE OF (ONEOF(simple_numeric_expression,

 unary_numeric_expression,

 binary_numeric_expression,

 multiple_arity_numeric_expression,

 length_function,

 value_function,

 numeric_defined_function))
   SUBTYPE OF (expression);
   DERIVE
      is_int : BOOLEAN := is_int_expr(SELF);
      sql_mappable : BOOLEAN := is_SQL_mappable(SELF);
   END_ENTITY;



   ENTITY numeric_variable
   SUPERTYPE OF (ONEOF(int_numeric_variable,

 real_numeric_variable))
   SUBTYPE OF (simple_numeric_expression,

 variable);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.INT_NUMERIC_VARIABLE' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REAL_NUMERIC_VARIABLE' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY object_role;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY odd_function
   SUBTYPE OF (unary_boolean_expression);
      SELF\unary_generic_expression.operand : numeric_expression;
   END_ENTITY;



   ENTITY offset_curve_2d
   SUBTYPE OF (curve);
      basis_curve : curve;
      distance : length_measure;
      self_intersect : LOGICAL;
   WHERE
      WR1:
         basis_curve.dim = 2;
   END_ENTITY;



   ENTITY offset_curve_3d
   SUBTYPE OF (curve);
      basis_curve : curve;
      distance : length_measure;
      self_intersect : LOGICAL;
      ref_direction : direction;
   WHERE
      WR1:
         (basis_curve.dim = 3) AND (ref_direction.dim = 3);
   END_ENTITY;



   ENTITY offset_surface
   SUBTYPE OF (surface);
      basis_surface : surface;
      distance : length_measure;
      self_intersect : LOGICAL;
   END_ENTITY;



   ENTITY one_direction_repeat_factor
   SUBTYPE OF (geometric_representation_item);
      repeat_factor : vector;
   END_ENTITY;



   ENTITY open_shell
   SUBTYPE OF (connected_face_set);
   END_ENTITY;



   ENTITY opposing_boundary_dimensional_size
   SUBTYPE OF (dimensional_size);
   WHERE
      WR1:
         SELF\dimensional_size.name IN [ 'angular',

 'linear' ];
   END_ENTITY;



   ENTITY or_expression
   SUBTYPE OF (multiple_arity_Boolean_expression);
   END_ENTITY;



   ENTITY organization;
      id : OPTIONAL identifier;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY organization_assignment
   ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role : organization_role;
   END_ENTITY;



   ENTITY organization_relationship;
      name : label;
      description : OPTIONAL text;
      relating_organization : organization;
      related_organization : organization;
   END_ENTITY;



   ENTITY organization_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY organizational_address
   SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY organizational_project;
      name : label;
      description : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation : BOOLEAN;
   DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,

 SELF.closed_shell_element.cfs_faces);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element));
   END_ENTITY;



   ENTITY oriented_edge
   SUBTYPE OF (edge);
      edge_element : edge;
      orientation : BOOLEAN;
   DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,

 SELF.edge_element.edge_start,

 SELF.edge_element.edge_end);
      SELF\edge.edge_end : vertex := boolean_choose(SELF.orientation,

 SELF.edge_element.edge_end,

 SELF.edge_element.edge_start);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
   END_ENTITY;



   ENTITY oriented_face
   SUBTYPE OF (face);
      face_element : face;
      orientation : BOOLEAN;
   DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.orientation,

 SELF.face_element.bounds);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
   END_ENTITY;



   ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation : BOOLEAN;
   DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,

 SELF.open_shell_element.cfs_faces);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF.open_shell_element));
   END_ENTITY;



   ENTITY oriented_path
   SUBTYPE OF (path);
      path_element : path;
      orientation : BOOLEAN;
   DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := conditional_reverse(SELF.orientation,

 SELF.path_element.edge_list);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
   END_ENTITY;



   ENTITY oriented_surface
   SUBTYPE OF (surface);
      orientation : BOOLEAN;
   END_ENTITY;



   ENTITY outer_boundary_curve
   SUBTYPE OF (boundary_curve);
   END_ENTITY;



   ENTITY owner_assignment
   SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF owner_assigned_item;
   END_ENTITY;



   ENTITY package
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical design usage';
      WR2:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'package'))) > 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' IN TYPEOF(sa)))) = 1))) <= 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(sa)))) >= 1))) >= 1;
      WR5:
         NOT (SELF\product_definition.description = 'altered package') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package alteration') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pdr.relating_product_definition)) = 1))) = 1);
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data'))) = 1))) = 1;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body height above seating plane'))) = 1))) = 1))) = 1;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body height below seating plane'))) = 1))) = 1))) <= 1;
      WR9:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body clearance above seating plane'))) = 1))) = 1))) <= 1;
      WR10:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body clearance below seating plane'))) = 1))) = 1))) <= 1;
      WR11:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'minimum body clearance above seating plane'))) = 1))) = 1))) <= 1;
      WR12:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'minimum body clearance below seating plane'))) = 1))) = 1))) <= 1;
      WR13:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum lead length below seating plane'))) = 1))) = 1))) <= 1;
      WR14:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'least lead length below seating plane'))) = 1))) = 1))) <= 1;
      WR15:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sa)) AND (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'package seating plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sar.related_shape_aspect)))) = 1))) = 1))) = 1;
      WR16:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sa)))) = 1))) = 1;
      WR17:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sa)) AND (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'of datum reference plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar.related_shape_aspect)))) = 1))) = 1))) <= 1;
      WR18:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sa)))) = 1))) <= 1;
   END_ENTITY;



   ENTITY package_body
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ]) = 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
   END_ENTITY;



   ENTITY package_body_bottom_surface
   SUBTYPE OF (package_body_surface);
   END_ENTITY;



   ENTITY package_body_edge_segment_surface
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect)))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\package_body_edge_segment_surface)) = 0;
   END_ENTITY;



   ENTITY package_body_edge_surface
   SUBTYPE OF (package_body_surface);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\part_mounting_feature || SELF\package_body_edge_surface || SELF\package_body_surface)) = 0;
   END_ENTITY;



   ENTITY package_body_surface
   ABSTRACT SUPERTYPE OF (ONEOF(package_body_top_surface,

 package_body_edge_surface,

 package_body_bottom_surface))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (TYPEOF(sar\shape_aspect_relationship.relating_shape_aspect) = [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' ]))) = 1;
   END_ENTITY;



   ENTITY package_body_top_surface
   SUBTYPE OF (package_body_surface);
   END_ENTITY;



   ENTITY package_terminal
   SUPERTYPE OF (((altered_package_terminal ANDOR

 guided_wave_terminal) ANDOR

 wire_terminal) ANDOR

 primary_reference_terminal)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR2:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ]) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND (sar\shape_aspect_relationship.name = 'terminal core material')) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference\application_context_element.name = 'material definition'))) <= 1;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND (sar\shape_aspect_relationship.name = 'terminal surface material')) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference\application_context_element.name = 'material definition'))) = 1;
      WR5:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'external connection zone') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'maximum terminal diametrical extent'))) <= 1))) <= 1))) <= 1;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'minimum terminal diametrical extent'))) <= 1))) <= 1))) <= 1;
      WR9:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) <= 1;
      WR10:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) <= 1;
      WR11:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'seating plane zone'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY packaged_component
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pa <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package alternate'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pa.relating_product_definition)) = 1) AND (pa.relating_product_definition\product_definition.description = 'altered package'))) <= 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'packaged component join terminal'))) >= 1))) = 0;
      WR4:
         NOT (SELF\product_definition.description = 'packaged connector component') OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(ip.relating_product_definition)) = 1) AND TRUE)) = 1);
      WR5:
         NOT (SELF\product_definition.description = 'packaged connector component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'packaged component join terminal'))) >= 1))) = 0);
      WR6:
         NOT (SELF\product_definition.description = 'routed packaged component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (pd <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1))) = 1))) = 1))) = 0);
   END_ENTITY;



   ENTITY packaged_connector
   SUBTYPE OF (packaged_part);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sa)))) = 1))) >= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'interface plane'))) = 1))) = 1))) <= 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sa)))) = 1))) <= 1;
   END_ENTITY;



   ENTITY packaged_connector_terminal_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         (SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ]) = 1) AND (SELF.of_shape.definition\product_definition.description = 'packaged connector');
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect)) AND (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'interface terminal');
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect)) AND (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'join terminal');
   END_ENTITY;



   ENTITY packaged_part
   SUPERTYPE OF (packaged_connector)
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))) >= 0))) = 0;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
      WR3:
         SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)) AND (ifu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) <= 1;
      WR4:
         NOT EXISTS(SELF\product_definition.description) OR (NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (bpp <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'base packaged part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(bpp.relating_product_definition)) = 1) AND (bpp.relating_product_definition.frame_of_reference.name = 'physical design usage'))) >= 1));
      WR5:
         SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(upkg.relating_product_definition)) = 1))) >= 1;
      WR6:
         SELF.frame_of_reference.name = 'physical design usage';
   END_ENTITY;



   ENTITY packaged_part_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ];
      WR2:
         (SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ]) = 1) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design usage');
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR4:
         SIZEOF(QUERY (top <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'terminal of package'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(top.related_shape_aspect)))) >= 1;
      WR5:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR6:
         NOT (SELF\shape_aspect.description = 'interface terminal') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar)) AND (sar.relating_shape_aspect\shape_aspect.description = 'join terminal'))) >= 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'join terminal') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar)) AND (sar.relating_shape_aspect\shape_aspect.description = 'interface terminal'))) <= 1);
   END_ENTITY;



   ENTITY padstack_definition
   SUPERTYPE OF (ONEOF(design_layer_type_specific_padstack_definition,

 stratum_type_independent_padstack_definition) ANDOR

 passage_padstack_definition)
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\padstack_definition)) = 0;
      WR7:
         SELF.frame_of_reference.name IN [ 'layout design usage' ];
      WR9:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'template model'))) = 1;
   END_ENTITY;



   ENTITY padstack_occurrence
   SUBTYPE OF (assembly_group_component_shape_aspect);
   END_ENTITY;



   ENTITY padstack_occurrence_shape_aspect_relationship
   SUBTYPE OF (property_definition,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         SIZEOF(TYPEOF(SELF)) - SIZEOF(TYPEOF(SELF\property_definition || SELF\shape_aspect_relationship || SELF\padstack_occurrence_shape_aspect_relationship)) = 0;
      WR3:
         SELF\shape_aspect_relationship.name = 'padstack occurrence sub assembly relationship';
   END_ENTITY;



   ENTITY parabola
   SUBTYPE OF (conic);
      focal_dist : length_measure;
   WHERE
      WR1:
         focal_dist <> 0.00000;
   END_ENTITY;



   ENTITY parallel_composed_function
   SUBTYPE OF (maths_function,

 multiple_arity_generic_expression);
      source_of_domain : maths_space_or_function;
      prep_functions : LIST [1:?] OF maths_function;
      final_function : maths_function_select;
   DERIVE
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression := convert_to_operands_prcmfn(source_of_domain,

 prep_functions,

 final_function);
   WHERE
      WR1:
         no_cyclic_domain_reference(source_of_domain,

 [ SELF ]);
      WR2:
         expression_is_constant(domain_from(source_of_domain));
      WR3:
         parallel_composed_function_domain_check(domain_from(source_of_domain),

 prep_functions);
      WR4:
         parallel_composed_function_composability_check(prep_functions,

 final_function);
   END_ENTITY;



   ENTITY parallelism_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'parallelism';
   END_ENTITY;



   ENTITY parameter_assignment_override
   SUBTYPE OF (representation,

 representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,

 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\parameter_assignment_override)) = 0;
      WR2:
         SELF\representation_relationship.rep_1 <> SELF\representation_relationship.rep_2;
      WR3:
         SELF\representation_relationship.name = '';
      WR4:
         SELF\representation.name = '';
      WR5:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_1);
      WR6:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_2);
   END_ENTITY;



   ENTITY parameter_assignment_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(SELF.items) = 2;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(TYPEOF(it) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER') ]) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(TYPEOF(it) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COORDINATED_REPRESENTATION_ITEM') ]) = 1))) <= 1;
      WR4:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(QUERY (aga <* USEDIN(it,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| (SIZEOF(TYPEOF(aga\group_assignment.assigned_group) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERISTIC_TYPE') ]) = 1))) = 1))) <= 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\parameter_assignment_representation)) = 0;
   END_ENTITY;



   ENTITY parameter_type
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'string property type',

 'logical property type',

 'physical property type',

 'boolean property type' ];
   END_ENTITY;



   ENTITY parametric_representation_context
   SUBTYPE OF (representation_context);
   END_ENTITY;



   ENTITY part_connected_terminals_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL') ] * TYPEOF(mct.related_shape_aspect)) = 1))) >= 2;
   END_ENTITY;



   ENTITY part_feature_template_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\part_feature_template_definition)) = 0;
      WR7:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1;
   END_ENTITY;



   ENTITY part_interface_access_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'interface_access area') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY part_mating_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'mating area') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY part_mounting_feature
   SUPERTYPE OF (bare_die_surface)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'mounting area') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY part_template_definition
   SUPERTYPE OF (dependent_material_removal_feature_template)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.of_shape\property_definition.definition.frame_of_reference\application_context_element.name = 'template definition';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'part template analytical model'))) <= 1))) = 0;
      WR3:
         NOT (SELF\shape_aspect.description = 'component termination passage template') OR (SIZEOF(QUERY (ctpt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(ctpt.relating_shape_aspect)) AND (ctpt.relating_shape_aspect\shape_aspect.description = 'default component termination passage definition'))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description = 'component termination passage template') OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access mechanism'))| (am.related_shape_aspect\shape_aspect.description IN [ 'component termination passage template interface terminal',

 'component termination passage template join terminal' ]))) >= 2);
      WR5:
         NOT (SELF\shape_aspect.description = 'default trace template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'inter stratum feature template') OR (SIZEOF(QUERY (isfpt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(isfpt.relating_shape_aspect)))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'printed connector template') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name IN [ 'connector' ]))) >= 1);
      WR8:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'transmission line model'))) = 1))) = 0);
      WR9:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) = 2))) = 1))) = 0);
      WR10:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum width'))) = 1))) = 1))) = 0);
      WR11:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum width'))) = 1))) = 1))) = 0);
      WR12:
         NOT (SELF\shape_aspect.description = 'printed part template') OR (SIZEOF(QUERY (impl_func <* QUERY (pdr <* USEDIN(SELF.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(impl_func.relating_product_definition)) AND (impl_func.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description = 'printed part template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(ad.related_shape_aspect)) AND (ad.related_shape_aspect\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ]))) >= 2);
      WR14:
         NOT (SELF\shape_aspect.description = 'trace template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'curve style parameters'))) = 1))) = 1);
      WR15:
         NOT (SELF\shape_aspect.description = 'unsupported passage template') OR (SIZEOF(QUERY (upt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(upt.relating_shape_aspect)) AND (upt.relating_shape_aspect\shape_aspect.description = 'default unsupported passage definition'))) = 1);
      WR16:
         NOT (SELF\shape_aspect.description = 'via template') OR (SIZEOF(QUERY (vpt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(vpt.relating_shape_aspect)) AND (vpt.relating_shape_aspect\shape_aspect.description = 'default via definition'))) = 1);
      WR17:
         NOT (SELF\shape_aspect.description = 'via template') OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access mechanism'))| (am.related_shape_aspect\shape_aspect.description = 'via template terminal'))) >= 2);
      WR18:
         EXISTS(SELF\shape_aspect.name);
      WR19:
         NOT (SELF\shape_aspect.description = 'non conductive cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1);
      WR20:
         NOT (SELF\shape_aspect.description = 'non conductive cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'nominal width'))) = 1))) = 1))) = 0);
      WR21:
         NOT (SELF\shape_aspect.description = 'printed connector template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(ad.related_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ]))) >= 2);
      WR22:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'horizontal material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'left'))))) = 0);
      WR27:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'horizontal material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'right'))))) = 0);
      WR28:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'vertical material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'bottom'))))) = 0);
      WR29:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'vertical material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'top'))))) = 0);
      WR30:
         SELF\shape_aspect.name = 'NULL';
   END_ENTITY;



   ENTITY part_text_template_definition
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_LITERAL' IN TYPEOF(it)))) = 1))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum font vertical extent'))) = 1))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum font horizontal extent'))) = 1))) = 1))) = 0;
   END_ENTITY;



   ENTITY part_tooling_feature
   SUPERTYPE OF (ONEOF(fiducial_part_feature,

 tool_registration_mark) ANDOR

 test_point_part_feature)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = FALSE;
   END_ENTITY;



   ENTITY partial_derivative_expression
   SUBTYPE OF (unary_generic_expression);
      d_variables : LIST [1:?] OF maths_variable;
      extension : extension_options;
   DERIVE
      derivand : generic_expression := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         has_values_space(derivand);
      WR2:
         space_is_continuum(values_space_of(derivand));
      WR3:
         SIZEOF(QUERY (vbl <* d_variables| NOT subspace_of(values_space_of(vbl),

 the_reals) AND NOT subspace_of(values_space_of(vbl),

 the_complex_numbers))) = 0;
   END_ENTITY;



   ENTITY partial_derivative_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      d_variables : LIST [1:?] OF input_selector;
      extension : extension_options;
   DERIVE
      derivand : maths_function := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         space_is_continuum(derivand.range);
      WR2:
         partial_derivative_check(derivand.domain,

 d_variables);
   END_ENTITY;



   ENTITY passage_padstack_definition
   SUBTYPE OF (padstack_definition);
   END_ENTITY;



   ENTITY passage_technology
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,

 SELF\shape_aspect.of_shape;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT ((1 <= SIZEOF(pcr.used_representation.items)) AND (SIZEOF(pcr.used_representation.items) <= 8)))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| NOT (it\representation_item.name IN [ 'maximum aspect ratio',

 'plated passage',

 'maximum allowed component terminal extent',

 'minimum allowed component terminal extent',

 'maximum as finished deposition thickness',

 'minimum as finished deposition thickness',

 'maximum as finished passage extent',

 'minimum as finished passage extent' ]))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RATIO_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum aspect ratio')) AND (it\measure_with_unit.value_component > 1.00000))) <= 1))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'plated passage')) AND (it\descriptive_representation_item.description IN [ 'true',

 'false' ]))) = 1))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished passage extent'))) <= 1))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum as finished deposition thickness'))) <= 1))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished deposition thickness'))) <= 1))) = 0))) = 0;
      WR11:
         NOT (SELF\shape_aspect.description IN [ 'default component termination passage definition',

 'default via definition' ]) OR (SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      WR12:
         NOT (SELF\shape_aspect.description IN [ 'default component termination passage definition',

 'default unsupported passage definition',

 'default via definition' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished passage extent'))) = 1))) = 0))) = 0);
      WR13:
         NOT (SELF\shape_aspect.description = 'default component termination passage definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished deposition thickness'))) = 1))) = 0))) = 0);
      WR14:
         NOT (SELF\shape_aspect.description = 'default component termination passage definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum allowed component terminal extent'))) = 1))) = 0))) = 0);
      WR15:
         NOT (SELF\shape_aspect.description = 'default component termination passage definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum allowed component terminal extent'))) = 1))) = 0))) = 0);
      WR16:
         NOT (SELF\shape_aspect.description = 'default via definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished deposition thickness'))) = 1))) = 0))) = 0);
      WR17:
         SIZEOF(QUERY (rpt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'as finished inter stratum extent'))| (rpt.related_shape_aspect.of_shape\property_definition.description = 'finished stratum extent') AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(rpt.related_shape_aspect.of_shape\property_definition.definition)) AND (rpt.related_shape_aspect.of_shape\property_definition.definition\product_definition_relationship.name = 'inter stratum extent')))) = 1;
   END_ENTITY;



   ENTITY path
   SUPERTYPE OF (ONEOF(edge_loop,

 oriented_path))
   SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
   WHERE
      WR1:
         path_head_to_tail(SELF);
   END_ENTITY;



   ENTITY pcurve
   SUBTYPE OF (curve);
      basis_surface : surface;
      reference_to_curve : definitional_representation;
   WHERE
      WR1:
         SIZEOF(reference_to_curve\representation.items) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
      WR3:
         reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY perpendicularity_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'perpendicularity';
   END_ENTITY;



   ENTITY person;
      id : identifier;
      last_name : OPTIONAL label;
      first_name : OPTIONAL label;
      middle_names : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
   WHERE
      WR1:
         EXISTS(last_name) OR EXISTS(first_name);
   END_ENTITY;



   ENTITY person_and_organization;
      the_person : person;
      the_organization : organization;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY person_and_organization_assignment
   ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role : person_and_organization_role;
   END_ENTITY;



   ENTITY person_and_organization_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY person_assignment
   ABSTRACT SUPERTYPE;
      assigned_person : person;
      role : person_role;
   END_ENTITY;



   ENTITY person_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY personal_address
   SUBTYPE OF (address);
      people : SET [1:?] OF person;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY physical_connectivity_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,

 SELF\shape_aspect.of_shape;
   WHERE
      WR1:
         SIZEOF(QUERY (at <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(at.related_shape_aspect)) AND ((((((at.related_shape_aspect\shape_aspect.description = 'assembly module component terminal') OR (at.related_shape_aspect\shape_aspect.description = 'bare die component terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'interconnect component join terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'interconnect module component terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'minimally defined component terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'packaged component join terminal')))) > 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'connectivity allocation'))) = 1))) <= 1;
   END_ENTITY;



   ENTITY physical_connectivity_element
   SUBTYPE OF (shape_aspect_relationship,

 shape_aspect);
   WHERE
      WR1:
         (SELF.relating_shape_aspect\shape_aspect.description = 'topological junction') XOR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(SELF.relating_shape_aspect)) = 1);
      WR2:
         (SELF.related_shape_aspect\shape_aspect.description = 'topological junction') XOR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(SELF.related_shape_aspect)) = 1);
      WR3:
         SIZEOF(QUERY (se <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'structure element'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(se.relating_shape_aspect)))) = 1;
      WR4:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design');
   END_ENTITY;



   ENTITY physical_interconnection_definition
   SUBTYPE OF (property_definition);
   UNIQUE
      UR1 : SELF\property_definition.name,

 SELF\property_definition.definition;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_INTERCONNECT_DEFINITION' IN TYPEOF(SELF\property_definition.definition);
   END_ENTITY;



   ENTITY physical_network
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (cr <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connectivity requirement'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(cr.related_shape_aspect)) AND ((((cr.related_shape_aspect\shape_aspect.description = 'component termination passage join terminal') OR (cr.related_shape_aspect\shape_aspect.description = 'land join terminal')) OR (cr.related_shape_aspect\shape_aspect.description = 'non functional land join terminal')) OR (cr.related_shape_aspect\shape_aspect.description = 'printed component join terminal')))) >= 2;
      WR2:
         SIZEOF(QUERY (nt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'network topology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(nt.related_shape_aspect)))) >= 1;
      WR3:
         SIZEOF(QUERY (nt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference connected terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(nt.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY physical_node_requirement_to_implementing_component_allocation
   SUBTYPE OF (shape_aspect_relationship,

 shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.related_shape_aspect.of_shape\property_definition.definition)) AND NOT (SELF.related_shape_aspect.of_shape\property_definition.definition\product_definition.description IN [ 'laminate component' ]);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.relating_shape_aspect);
      WR3:
         acyclic_shape_aspect_relationship(SELF,

 [ SELF\shape_aspect_relationship.related_shape_aspect ],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION');
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\physical_node_requirement_to_implementing_component_allocation)) = 0;
   END_ENTITY;



   ENTITY physical_unit
   SUPERTYPE OF (ONEOF(bare_die,

 package,

 packaged_part,

 assembly_definition,

 interconnect_definition,

 reference_packaged_part_assembly_implementation,

 reference_packaged_part_interconnect_implementation))
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SELF.frame_of_reference.name IN [ 'physical design',

 'physical design usage' ];
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'physical unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) <= 1;
      WR8:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)))) >= 1))) = 0);
      WR9:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum negative component height'))) <= 1))) = 0);
      WR10:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum positive component height'))) <= 1))) = 0);
      WR11:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR12:
         NOT is_assembly_module_design(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')| is_laminate_component(pdr.related_product_definition))) = 0);
      WR14:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.relating_product_definition.frame_of_reference.name = 'functional design usage'))) <= 1);
      WR15:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd1 <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd1)) AND (SIZEOF(QUERY (cd <* USEDIN(pd1,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_DEFINITION' IN TYPEOF(cd)) AND (SIZEOF(QUERY (pd2 <* USEDIN(cd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd2\property_definition.name = 'located interconnect module thickness') AND (SIZEOF(USEDIN(pd2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) > 1))) = 1))) = 1))) <= 1);
      WR16:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics'))) <= 1);
      WR17:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'minimum thickness over metal requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR18:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum thickness over metal requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR19:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'minimum thickness over dielectric requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR20:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum thickness over dielectric requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR21:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'restraint') OR (pd\property_definition.name = 'tolerance specific restraint'))) <= 1);
      WR22:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'interconnect module primary surface'))) <= 1))) = 0);
      WR23:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'interconnect module secondary surface'))) <= 1))) = 0);
      WR24:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'interconnect module edge surface'))) <= 1))) = 0);
      WR25:
         NOT is_assembly_module_design(SELF) OR (NOT (((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(sa)))) > 0))) = 0)) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(sa)) AND (SIZEOF(QUERY (acu <* USEDIN(sa\shape_aspect_relationship.relating_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) >= 1))) >= 1))) >= 1));
      WR26:
         NOT is_assembly_module_design(SELF) OR (NOT ((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (acu <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) = 0))) = 0));
      WR27:
         NOT is_assembly_module_design(SELF) OR (NOT ((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (cl <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION' IN TYPEOF(cl)) AND (aj IN cl\representation.items))) = 0))) = 0));
      WR28:
         NOT is_interconnect_module_design(SELF) OR (NOT ((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'interconnect module')) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'interconnect module stratum assembly relationship')) AND (pdr.related_product_definition\product_definition.description = 'primary design layer stratum')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.related_product_definition)))) = 1));
   END_ENTITY;



   ENTITY physical_unit_datum
   SUPERTYPE OF (edge_segment_vertex)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'axis',

 'plane',

 'point',

 '' ];
      WR2:
         SELF\shape_aspect.product_definitional = FALSE;
      WR3:
         SELF\shape_aspect.name IN [ 'single datum',

 'common datum',

 '' ];
      WR4:
         NOT (SELF\shape_aspect.name = 'common datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in datum system') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(sar)))) >= 1);
      WR5:
         NOT (SELF\shape_aspect.name = 'common datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in common datum') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(sar)))) >= 2);
      WR6:
         NOT ((SELF\shape_aspect.description = 'axis') AND (SELF\shape_aspect.name IN [ 'common datum',

 'single datum' ])) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT (sar\shape_aspect_relationship.name = 'reference axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar)))) = 1);
      WR7:
         NOT ((SELF\shape_aspect.description = 'plane') AND (SELF\shape_aspect.name IN [ 'common datum',

 'single datum' ])) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT (sar\shape_aspect_relationship.name = 'reference plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar)))) = 1);
      WR8:
         NOT ((SELF\shape_aspect.description = 'point') AND (SELF\shape_aspect.name IN [ 'common datum',

 'single datum' ])) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT (sar\shape_aspect_relationship.name = 'reference origin') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar)))) = 1);
      WR9:
         NOT (SELF\shape_aspect.name = 'single datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum usage in datum system') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(sar)))) >= 1);
      WR10:
         NOT (SELF\shape_aspect.name = 'single datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in single datum') AND TRUE)) <= 1);
      WR11:
         NOT ((SELF\shape_aspect.name IN [ '' ]) AND (SELF\shape_aspect.description IN [ '' ]));
      WR12:
         NOT (SELF\shape_aspect.description = 'plane') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'datum direction property'))) <= 2);
   END_ENTITY;



   ENTITY physical_unit_datum_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')| (pd\property_definition.description = 'datum feature identification'))) = 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name IN [ 'datum feature usage in common datum',

 'datum feature usage in single datum' ]))) >= 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in single datum'))) <= 1;
   END_ENTITY;



   ENTITY physical_unit_datum_target
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum target usage'))) >= 1;
   END_ENTITY;



   ENTITY physical_unit_datum_target_set
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum target usage'))) >= 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'constituent'))) = 0;
   END_ENTITY;



   ENTITY physical_unit_geometric_tolerance
   SUBTYPE OF (geometric_tolerance,

 property_definition);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = SELF\property_definition.name;
      WR2:
         SELF\geometric_tolerance.toleranced_shape_aspect = SELF\property_definition.definition;
      WR3:
         NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE') ] * TYPEOF(SELF)) = 0) OR (SELF\geometric_tolerance.name IN [ 'circularity',

 'cylindricity',

 'flatness',

 'straightness' ]);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'circularity') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR5:
         NOT (SELF\geometric_tolerance.name = 'cylindricity') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR6:
         NOT (SELF\geometric_tolerance.name = 'flatness') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR7:
         SIZEOF(QUERY (pugt <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'group geometric tolerance'))| (pugt.relating_shape_aspect\shape_aspect.description = 'simultaneous requirement'))) <= 1;
   END_ENTITY;



   ENTITY physical_unit_interconnect_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\physical_unit_interconnect_definition)) = 0;
      WR7:
         SELF.frame_of_reference.name IN [ 'physical interconnect design' ];
   END_ENTITY;



   ENTITY physical_unit_network_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SELF.frame_of_reference.name IN [ 'physical network design' ];
   END_ENTITY;



   ENTITY placement
   SUPERTYPE OF (ONEOF(axis1_placement,

 axis2_placement_2d,

 axis2_placement_3d))
   SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
   END_ENTITY;



   ENTITY planar_extent
   SUBTYPE OF (geometric_representation_item);
      size_in_x : length_measure;
      size_in_y : length_measure;
   END_ENTITY;



   ENTITY plane
   SUBTYPE OF (elementary_surface);
   END_ENTITY;



   ENTITY plane_angle_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY plane_angle_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY plated_cutout_edge_segment
   SUBTYPE OF (cutout_edge_segment,

 plated_inter_stratum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated cutout edge segment' ];
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         NOT (SELF\shape_aspect.description = 'plated cutout edge segment') OR (SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed cutout'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect)) AND (cc.relating_shape_aspect\shape_aspect.description = 'plated cutout'))) = 1);
   END_ENTITY;



   ENTITY plated_inter_stratum_feature
   SUPERTYPE OF (ONEOF(plated_passage,

 plated_cutout_edge_segment,

 plated_interconnect_module_edge_segment))
   SUBTYPE OF (inter_stratum_feature);
   WHERE
      WR1:
         (SELF\shape_aspect.description IN [ 'bonded conductive base blind via',

 'buried via',

 'component termination passage',

 'interfacial connection',

 'non conductive base blind via',

 'join two physical connectivity definition supporting inter stratum feature',

 'plated conductive base blind via',

 'plated cutout',

 'plated interconnect module edge' ]) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_CUTOUT_EDGE_SEGMENT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTERCONNECT_MODULE_EDGE_SEGMENT') ] * TYPEOF(SELF)) = 1);
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
   END_ENTITY;



   ENTITY plated_interconnect_module_edge_segment
   SUBTYPE OF (interconnect_module_edge_segment,

 plated_inter_stratum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated interconnect module edge segment' ];
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         NOT (SELF\shape_aspect.description = 'plated interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.description = 'plated interconnect module edge'))) = 1);
   END_ENTITY;



   ENTITY plated_passage
   SUBTYPE OF (plated_inter_stratum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'bonded conductive base blind via',

 'buried via',

 'component termination passage',

 'interfacial connection',

 'non conductive base blind via',

 'plated conductive base blind via' ];
      WR2:
         NOT (SELF\shape_aspect.description = 'bonded conductive base blind via') OR (SIZEOF(QUERY (fj <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'features join'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP' IN TYPEOF(fj.relating_shape_aspect)) AND (fj.relating_shape_aspect\shape_aspect.name = 'stratum feature conductive join'))) = 1);
      WR3:
         NOT (SELF\shape_aspect.description = 'component termination passage') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'component termination passage template'))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description IN [ 'bonded conductive base blind via',

 'buried via',

 'interfacial connection',

 'non conductive base blind via',

 'plated conductive base blind via' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'via template'))) = 1);
   END_ENTITY;



   ENTITY plus_expression
   SUBTYPE OF (multiple_arity_numeric_expression);
   END_ENTITY;



   ENTITY plus_minus_tolerance;
      range : tolerance_method_definition;
      toleranced_dimension : dimensional_characteristic;
   UNIQUE
      UR1 : toleranced_dimension;
   END_ENTITY;



   ENTITY point
   SUPERTYPE OF (ONEOF(cartesian_point,

 point_on_curve,

 point_on_surface,

 point_replica,

 degenerate_pcurve))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY point_on_curve
   SUBTYPE OF (point);
      basis_curve : curve;
      point_parameter : parameter_value;
   END_ENTITY;



   ENTITY point_on_surface
   SUBTYPE OF (point);
      basis_surface : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
   END_ENTITY;



   ENTITY point_replica
   SUBTYPE OF (point);
      parent_pt : point;
      transformation : cartesian_transformation_operator;
   WHERE
      WR1:
         transformation.dim = parent_pt.dim;
      WR2:
         acyclic_point_replica(SELF,

 parent_pt);
   END_ENTITY;



   ENTITY polar_complex_number_literal
   SUBTYPE OF (generic_literal);
      radius : REAL;
      angle : REAL;
   WHERE
      WR1:
         radius >= 0;
      WR2:
         (0 <= angle) AND (angle < 2 * 3.14159);
   END_ENTITY;



   ENTITY polar_complex_number_region
   SUBTYPE OF (maths_space,

 generic_literal);
      centre : complex_number_literal;
      distance_constraint : real_interval;
      direction_constraint : finite_real_interval;
   WHERE
      WR1:
         min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.00000);
      WR2:
         (-3.14159 <= direction_constraint.min) AND (direction_constraint.min < 3.14159);
      WR3:
         direction_constraint.max - direction_constraint.min <= 2.00000 * 3.14159;
      WR4:
         (direction_constraint.max - direction_constraint.min < 2.00000 * 3.14159) OR (direction_constraint.min_closure = open);
      WR5:
         ((direction_constraint.max - direction_constraint.min < 2.00000 * 3.14159) OR (direction_constraint.max_closure = open)) OR (direction_constraint.min = -3.14159);
      WR6:
         (((real_min(distance_constraint) > 0.00000) OR max_exists(distance_constraint)) OR (direction_constraint.max - direction_constraint.min < 2.00000 * 3.14159)) OR (direction_constraint.max_closure = open);
   END_ENTITY;



   ENTITY poly_loop
   SUBTYPE OF (loop,

 geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
   END_ENTITY;



   ENTITY polygonal_area
   SUBTYPE OF (primitive_2d);
      bounds : LIST [3:?] OF UNIQUE cartesian_point;
   END_ENTITY;



   ENTITY polyline
   SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
   END_ENTITY;



   ENTITY port_variable
   SUPERTYPE OF (ONEOF(across_port_variable,

 through_port_variable,

 transform_port_variable))
   SUBTYPE OF (representation,

 representation_item);
   END_ENTITY;



   ENTITY position_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         NOT (SELF\geometric_tolerance.name = 'boundary based position') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR2:
         NOT (SELF\geometric_tolerance.name = 'boundary based position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(gtr.related_geometric_tolerance)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance))) AND (gtr.related_geometric_tolerance\geometric_tolerance.name IN [ 'surface profile',

 'surface profile locating',

 'surface profile refinement' ])) AND (gtr\geometric_tolerance_relationship.name = 'profile control'))) <= 1);
      WR3:
         NOT (SELF\geometric_tolerance.name = 'feature relating position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| ((gtr\geometric_tolerance_relationship.name = 'position refining control') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))) AND (gtr.relating_geometric_tolerance\geometric_tolerance.name IN [ 'feature locating position',

 'feature relating position' ]))) = 1);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'feature locating position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'feature relating position')) AND (gtr\geometric_tolerance_relationship.name = 'position refining control'))) = 1);
      WR5:
         NOT (SELF\geometric_tolerance.name = 'feature relating position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'feature relating position')) AND (gtr\geometric_tolerance_relationship.name = 'position refining control'))) <= 1);
   END_ENTITY;



   ENTITY positional_boundary
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'dimension related positional boundary',

 'profile related positional boundary' ];
      WR2:
         SELF\shape_aspect.product_definitional = FALSE;
      WR3:
         NOT (SELF\shape_aspect.description = 'dimension related positional boundary') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'boundary member'))) >= 1);
      WR4:
         NOT (SELF\shape_aspect.description = 'dimension related positional boundary') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect.product_definitional = FALSE) AND (sar\shape_aspect_relationship.name = 'constrained feature'))) + SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'constrained feature'))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'dimension related positional boundary') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'dimension related positional boundary property'))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'profile related positional boundary') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'profile related positional boundary property'))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'profile related positional boundary') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'positional boundary and profile boundary member'))) = 1);
   END_ENTITY;



   ENTITY positional_boundary_member
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = FALSE;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'positional boundary member property'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'boundary member') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(sar.relating_shape_aspect))) AND (sar.relating_shape_aspect\shape_aspect.description = 'dimension related positional boundary'))) = 1;
   END_ENTITY;



   ENTITY power_expression
   SUBTYPE OF (binary_numeric_expression);
   END_ENTITY;



   ENTITY power_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\power_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = watt;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY pre_defined_character_glyph
   SUBTYPE OF (pre_defined_item);
   END_ENTITY;



   ENTITY pre_defined_curve_font
   SUBTYPE OF (pre_defined_item);
   END_ENTITY;



   ENTITY pre_defined_item;
      name : label;
   END_ENTITY;



   ENTITY pre_defined_parallel_datum_axis_symbol_3d_2d_relationship
   SUBTYPE OF (shape_definition_3d_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\shape_definition_3d_intersection || SELF\pre_defined_parallel_datum_axis_symbol_3d_2d_relationship)) = 0;
   END_ENTITY;



   ENTITY pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship
   SUBTYPE OF (shape_definition_3d_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\shape_definition_3d_intersection || SELF\pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship)) = 0;
   END_ENTITY;



   ENTITY pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship
   SUBTYPE OF (shape_definition_3d_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\shape_definition_3d_intersection || SELF\pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship)) = 0;
   END_ENTITY;



   ENTITY pre_defined_surface_side_style
   SUBTYPE OF (pre_defined_item);
   END_ENTITY;



   ENTITY pre_defined_text_font
   SUBTYPE OF (pre_defined_item);
   END_ENTITY;



   ENTITY precision_qualifier;
      precision_value : INTEGER;
   END_ENTITY;



   ENTITY presentation_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SELF\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
   END_ENTITY;



   ENTITY presentation_style_assignment;
      styles : SET [1:?] OF presentation_style_select;
   WHERE
      WR1:
         SIZEOF(QUERY (style1 <* SELF.styles| NOT (SIZEOF(QUERY (style2 <* SELF.styles - style1| NOT ((TYPEOF(style1) <> TYPEOF(style2)) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_STYLE_USAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_STYLE') ] * TYPEOF(style1)) = 1)))) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (style1 <* SELF.styles| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_STYLE_USAGE' IN TYPEOF(style1)))) <= 2;
   END_ENTITY;



   ENTITY presentation_style_by_context
   SUBTYPE OF (presentation_style_assignment);
      style_context : style_context_select;
   END_ENTITY;



   ENTITY pressure_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\pressure_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = pascal;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY primary_orientation_feature
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = TRUE;
      WR2:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY primary_reference_terminal
   SUBTYPE OF (package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) <= 1;
   END_ENTITY;



   ENTITY primitive_2d
   SUPERTYPE OF (ONEOF(circular_area,

 elliptic_area,

 rectangular_area,

 polygonal_area))
   SUBTYPE OF (geometric_representation_item);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY printed_component
   SUPERTYPE OF (layout_macro_component)
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'layout occurrence';
      WR2:
         SELF\product_definition.description = 'printed component';
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'part template occurrence'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description IN [ 'printed part template',

 'printed part cross section template',

 'printed connector template' ]))) = 1))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'printed component join terminal'))) >= 1))) = 0;
      WR5:
         NOT (SELF\product_definition.description = 'printed connector component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAMINATE_COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'printed connector component interface terminal'))) >= 1))) = 0);
      WR6:
         NOT (SELF\product_definition.description = 'printed connector component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'part template occurrence'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'printed connector template'))) = 1))) = 1))) = 0);
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'stratum feature implementation')) AND (sar.relating_shape_aspect.description = 'stratum feature template component'))) >= 1))) >= 1))) >= 1;
   END_ENTITY;



   ENTITY printed_component_link
   SUBTYPE OF (product_definition,

 product_definition_relationship);
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\printed_component_link)) = 0;
      WR5:
         EXISTS(SELF\product_definition.name);
      WR6:
         SELF\product_definition.name = '';
      WR7:
         SELF\product_definition_relationship.name = '';
      WR8:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
   END_ENTITY;



   ENTITY printed_connector_template_terminal_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.relating_shape_aspect,

 SELF\shape_aspect_relationship.related_shape_aspect;
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connector') AND (sar.relating_shape_aspect\shape_aspect.description = 'printed connector template'))) = 1;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect)) AND (SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'interface terminal');
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect)) AND (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'join terminal');
      WR4:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
   END_ENTITY;



   ENTITY printed_part_cross_section_template_terminal
   SUBTYPE OF (printed_part_template_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'cross section definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(am.relating_shape_aspect)) AND (am.relating_shape_aspect\shape_aspect.description = 'printed part cross section template'))) = 1;
      WR2:
         SIZEOF(QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN TYPEOF(ga.assigned_group)) AND (ga.assigned_group.name IN [ 'area edge segment',

 'curve edge segment' ]))) = 1;
      WR3:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR4:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR5:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR7:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal') OR (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR8:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal') OR (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR9:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal') OR (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR10:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal') OR (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR11:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal') OR (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR12:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal') OR (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
   END_ENTITY;



   ENTITY printed_part_template_connected_terminals_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(mct.related_shape_aspect)) AND (mct.related_shape_aspect\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ]))) >= 2;
   END_ENTITY;



   ENTITY printed_part_template_link
   SUBTYPE OF (stratum_technology_link,

 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship || SELF\printed_part_template_link || SELF\property_definition || SELF\stratum_technology_link || SELF\shape_aspect_relationship)) = 0;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR5:
         SELF\shape_aspect_relationship.name = '';
      WR6:
         SELF\shape_aspect_relationship.description = '';
      WR7:
         SELF\shape_aspect_relationship.related_shape_aspect.description = 'printed part template';
      WR8:
         SELF\shape_aspect_relationship.relating_shape_aspect.description = 'printed part template';
   END_ENTITY;



   ENTITY printed_part_template_material
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)))| ((sr_pdr.used_representation\representation.name = 'physical characteristics representation') AND (SIZEOF(sr_pdr.used_representation.items) = 2)) AND (SIZEOF(QUERY (it <* sr_pdr.used_representation.items| (it\representation_item.name IN [ 'maximum width',

 'minimum width' ]))) = 2))) = 1))) = 0;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\printed_part_template_material)) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'top'))) <= 1))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'bottom'))) <= 1))) = 0;
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'left'))) <= 1))) = 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'right'))) <= 1))) = 0;
   END_ENTITY;



   ENTITY printed_part_template_material_link
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.related_shape_aspect,

 SELF\shape_aspect_relationship.relating_shape_aspect;
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\printed_part_template_material_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SELF\shape_aspect_relationship.related_shape_aspect.of_shape :<>: SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
      WR8:
         SELF\shape_aspect_relationship.relating_shape_aspect.description IN [ 'bottom',

 'right' ];
      WR9:
         SELF\shape_aspect_relationship.related_shape_aspect.description IN [ 'top',

 'left' ];
   END_ENTITY;



   ENTITY printed_part_template_terminal
   SUPERTYPE OF (printed_part_cross_section_template_terminal)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ];
      WR2:
         SIZEOF(QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN TYPEOF(ga.assigned_group)))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR5:
         SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(ad.relating_shape_aspect)) AND ((ad.relating_shape_aspect\shape_aspect.description = 'printed part template') OR (ad.relating_shape_aspect\shape_aspect.description = 'printed connector template')))) = 1;
      WR6:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY printed_part_template_terminal_connection_zone_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'area edge segment',

 'curve edge segment',

 'surface area',

 'surface point' ];
   END_ENTITY;



   ENTITY probe_access_area
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.name = 'interconnect module');
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
      WR4:
         SIZEOF(QUERY (pli <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'probed layout item'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(pli.related_shape_aspect)))) = 1;
      WR5:
         NOT (SELF\shape_aspect.description = 'internal probe access area') OR (SIZEOF(QUERY (i <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(i.relating_shape_aspect)))) = 1);
   END_ENTITY;



   ENTITY product;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
   END_ENTITY;



   ENTITY product_category;
      name : label;
      description : OPTIONAL text;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY product_category_relationship;
      name : label;
      description : OPTIONAL text;
      category : product_category;
      sub_category : product_category;
   WHERE
      WR1:
         acyclic_product_category_relationship(SELF,

 [ SELF.sub_category ]);
   END_ENTITY;



   ENTITY product_concept;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      market_context : product_concept_context;
   UNIQUE
      UR1 : id;
   END_ENTITY;



   ENTITY product_concept_context
   SUBTYPE OF (application_context_element);
      market_segment_type : label;
   END_ENTITY;



   ENTITY product_context
   SUBTYPE OF (application_context_element);
      discipline_type : label;
   END_ENTITY;



   ENTITY product_definition;
      id : identifier;
      description : OPTIONAL text;
      formation : product_definition_formation;
      frame_of_reference : product_definition_context;
   DERIVE
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY product_definition_context
   SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
   END_ENTITY;



   ENTITY product_definition_effectivity
   SUBTYPE OF (effectivity);
      usage : product_definition_relationship;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
   END_ENTITY;



   ENTITY product_definition_formation;
      id : identifier;
      description : OPTIONAL text;
      of_product : product;
   UNIQUE
      UR1 : id,

 of_product;
   END_ENTITY;



   ENTITY product_definition_formation_relationship;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      relating_product_definition_formation : product_definition_formation;
      related_product_definition_formation : product_definition_formation;
   END_ENTITY;



   ENTITY product_definition_formation_with_specified_source
   SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
   END_ENTITY;



   ENTITY product_definition_relationship;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition : product_definition;
   END_ENTITY;



   ENTITY product_definition_shape
   SUBTYPE OF (property_definition);
   UNIQUE
      UR1 : SELF\property_definition.definition;
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTERIZED_PRODUCT_DEFINITION',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTERIZED_OBJECT' ] * TYPEOF(SELF\property_definition.definition)) > 0;
   END_ENTITY;



   ENTITY product_definition_usage
   SUPERTYPE OF (ONEOF(make_from_usage_option,

 assembly_component_usage))
   SUBTYPE OF (product_definition_relationship);
   UNIQUE
      UR1 : SELF\product_definition_relationship.id,

 SELF\product_definition_relationship.relating_product_definition,

 SELF\product_definition_relationship.related_product_definition;
   WHERE
      WR1:
         acyclic_product_definition_relationship(SELF,

 [ SELF\product_definition_relationship.related_product_definition ],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_USAGE');
   END_ENTITY;



   ENTITY product_definition_with_associated_documents
   SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
   END_ENTITY;



   ENTITY product_material_composition_relationship
   SUBTYPE OF (product_definition_relationship);
      class : label;
      constituent_amount : SET [1:?] OF measure_with_unit;
      composition_basis : label;
      determination_method : text;
   END_ENTITY;



   ENTITY product_related_characterized_product_category
   SUBTYPE OF (characterized_product_category,

 product_related_product_category);
   END_ENTITY;



   ENTITY product_related_product_category
   SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
   END_ENTITY;



   ENTITY product_specific_parameter_value_assignment
   SUBTYPE OF (product_related_characterized_product_category);
   WHERE
      WR1:
         SIZEOF(SELF\product_related_product_category.products) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'product category parameter') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM') ] * TYPEOF(pdr.used_representation)) = 1))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pcr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY')| (pcr\product_category_relationship.description = 'product value assignment') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY' IN TYPEOF(pcr.category)))) = 1;
   END_ENTITY;



   ENTITY projected_zone_definition
   SUBTYPE OF (tolerance_zone_definition);
      projection_end : shape_aspect;
      projected_length : measure_with_unit;
   WHERE
      WR1:
         projected_length.value_component > 0.00000;
   END_ENTITY;



   ENTITY promissory_usage_in_product_model
   SUBTYPE OF (group);
   WHERE
      WR1:
         SIZEOF(QUERY (aga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PROMISSORY_USAGE_IN_PRODUCT_MODEL_ASSIGNMENT' IN TYPEOF(aga)))) >= 1;
   END_ENTITY;



   ENTITY promissory_usage_occurrence
   SUBTYPE OF (assembly_component_usage);
   END_ENTITY;



   ENTITY property_definition;
      name : label;
      description : OPTIONAL text;
      definition : characterized_definition;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY property_definition_relationship;
      name : label;
      description : text;
      relating_property_definition : property_definition;
      related_property_definition : property_definition;
   END_ENTITY;



   ENTITY property_definition_representation;
      definition : represented_definition;
      used_representation : representation;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY property_distribution_description;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      abstract_function : maths_function;
      domain_context : maths_space_context;
      physical_function : property_distribution_select;
      range_context : maths_space_context;
   END_ENTITY;



   ENTITY protocol_physical_layer_definition
   SUBTYPE OF (product_definition);
   END_ENTITY;



   ENTITY protocol_requirement_allocation_to_part_terminal
   SUBTYPE OF (shape_aspect_relationship,

 requirement_allocation_group);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(SELF\property_definition_relationship.relating_property_definition);
   END_ENTITY;



   ENTITY qualitative_uncertainty
   SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : text;
   END_ENTITY;



   ENTITY quantified_assembly_component_usage
   SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
   WHERE
      WR1:
         NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.value_component > 0);
   END_ENTITY;



   ENTITY quantifier_expression
   ABSTRACT SUPERTYPE
   SUBTYPE OF (multiple_arity_generic_expression);
      variables : LIST [1:?] OF UNIQUE generic_variable;
   WHERE
      WR1:
         SIZEOF(QUERY (vrbl <* variables| NOT (vrbl IN SELF\multiple_arity_generic_expression.operands))) = 0;
      WR2:
         SIZEOF(QUERY (vrbl <* variables| NOT (schema_prefix + 'BOUND_VARIABLE_SEMANTICS' IN TYPEOF(vrbl.interpretation.semantics)))) = 0;
   END_ENTITY;



   ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY ratio_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY ratio_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
   DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := list_to_array(weights_data,

 0,

 upper_index_on_control_points);
   WHERE
      WR1:
         SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.control_points_list);
      WR2:
         curve_weights_positive(SELF);
   END_ENTITY;



   ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
   DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := make_array_of_array(weights_data,

 0,

 u_upper,

 0,

 v_upper);
   WHERE
      WR1:
         (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
      WR2:
         surface_weights_positive(SELF);
   END_ENTITY;



   ENTITY rationalize_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
   DERIVE
      fun : maths_function := SELF\unary_generic_expression.operand;
   WHERE
      WR1:
         (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
      WR2:
         number_tuple_subspace_check(factor1(fun.range));
      WR3:
         space_dimension(factor1(fun.range)) > 1;
   END_ENTITY;



   ENTITY real_defined_function
   ABSTRACT SUPERTYPE
   SUBTYPE OF (numeric_defined_function);
   END_ENTITY;



   ENTITY real_interval_from_min
   SUBTYPE OF (maths_space,

 generic_literal);
      min : REAL;
      min_closure : open_closed;
   END_ENTITY;



   ENTITY real_interval_to_max
   SUBTYPE OF (maths_space,

 generic_literal);
      max : REAL;
      max_closure : open_closed;
   END_ENTITY;



   ENTITY real_literal
   SUBTYPE OF (literal_number);
      SELF\literal_number.the_value : REAL;
   END_ENTITY;



   ENTITY real_numeric_variable
   SUBTYPE OF (numeric_variable);
   END_ENTITY;



   ENTITY real_tuple_literal
   SUBTYPE OF (generic_literal);
      lit_value : LIST [1:?] OF REAL;
   END_ENTITY;



   ENTITY rectangle_domain
   SUBTYPE OF (founded_item);
      corner : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
   WHERE
      WR1:
         SIZEOF(QUERY (item <* USEDIN(SELF,

 '')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
   END_ENTITY;



   ENTITY rectangled_half_space
   SUBTYPE OF (half_space_2d);
      enclosure : rectangle_domain;
   END_ENTITY;



   ENTITY rectangular_area
   SUBTYPE OF (primitive_2d);
      position : axis2_placement_2d;
      x : positive_length_measure;
      y : positive_length_measure;
   END_ENTITY;



   ENTITY rectangular_array_placement_group_component_definition
   SUBTYPE OF (array_placement_group_component_definition);
   END_ENTITY;



   ENTITY rectangular_array_placement_group_component_shape_aspect
   SUBTYPE OF (array_placement_group_component_shape_aspect);
   END_ENTITY;



   ENTITY rectangular_composite_array_shape_aspect
   SUBTYPE OF (composite_array_shape_aspect);
   END_ENTITY;



   ENTITY rectangular_composite_surface
   SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
   DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
   WHERE
      WR1:
         SIZEOF(QUERY (s <* segments| (n_v <> SIZEOF(s)))) = 0;
      WR2:
         constraints_rectangular_composite_surface(SELF);
   END_ENTITY;



   ENTITY rectangular_pyramid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      height : positive_length_measure;
   END_ENTITY;



   ENTITY rectangular_trimmed_surface
   SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1 : parameter_value;
      u2 : parameter_value;
      v1 : parameter_value;
      v2 : parameter_value;
      usense : BOOLEAN;
      vsense : BOOLEAN;
   WHERE
      WR1:
         u1 <> u2;
      WR2:
         v1 <> v2;
      WR3:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(basis_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))) OR (usense = (u2 > u1));
      WR4:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR (vsense = (v2 > v1));
   END_ENTITY;



   ENTITY reference_graphic_registration_mark
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = FALSE;
   END_ENTITY;



   ENTITY reference_packaged_part_assembly_implementation
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         (SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1) AND (SELF\product_definition.name = 'assembly module');
      WR2:
         NOT (SELF.frame_of_reference.name = 'physical design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| (((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (prpc <* USEDIN(du.relating_product_definition.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1))) = 1);
   END_ENTITY;



   ENTITY reference_packaged_part_interconnect_implementation
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         (SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1) AND (SELF\product_definition.name = 'interconnect module');
      WR3:
         SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| (((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PHYSICAL_UNIT') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'interconnect module')) AND (SIZEOF(QUERY (prpc <* USEDIN(du.relating_product_definition.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1))) <= 1;
      WR4:
         SELF.frame_of_reference.name = 'physical design';
   END_ENTITY;



   ENTITY regular_table_function
   SUBTYPE OF (linearized_table_function);
      increments : LIST [1:?] OF INTEGER;
   WHERE
      WR1:
         SIZEOF(increments) = SIZEOF(SELF\explicit_table_function.shape);
      WR2:
         extremal_position_check(SELF);
   END_ENTITY;



   ENTITY reindexed_array_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      starting_indices : LIST [1:?] OF INTEGER;
   WHERE
      WR1:
         function_is_array(SELF\unary_generic_expression.operand);
      WR2:
         SIZEOF(starting_indices) = SIZEOF(shape_of_array(SELF\unary_generic_expression.operand));
   END_ENTITY;



   ENTITY repackaging_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_function;
      input_repack : repackage_options;
      output_repack : repackage_options;
      selected_output : nonnegative_integer;
   WHERE
      WR1:
         (input_repack <> ro_wrap_as_tuple) OR (space_dimension(operand.domain) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN TYPEOF(factor1(operand.domain)));
      WR2:
         (output_repack <> ro_unwrap_tuple) OR (space_dimension(operand.range) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN TYPEOF(factor1(operand.range)));
      WR3:
         selected_output <= space_dimension(repackage(operand.range,

 output_repack));
   END_ENTITY;



   ENTITY reparametrised_composite_curve_segment
   SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
   WHERE
      WR1:
         param_length > 0.00000;
   END_ENTITY;



   ENTITY representation;
      name : label;
      items : SET [1:?] OF representation_item;
      context_of_items : representation_context;
   DERIVE
      id : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY representation_context;
      context_identifier : identifier;
      context_type : text;
   INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
   END_ENTITY;



   ENTITY representation_context_defined_maths_space_context
   SUBTYPE OF (defined_maths_space_context);
      representation_basis : representation_context;
   END_ENTITY;



   ENTITY representation_item;
      name : label;
   WHERE
      WR1:
         SIZEOF(using_representations(SELF)) > 0;
   END_ENTITY;



   ENTITY representation_item_relationship;
      name : label;
      description : OPTIONAL text;
      relating_representation_item : representation_item;
      related_representation_item : representation_item;
   END_ENTITY;



   ENTITY representation_map;
      mapping_origin : representation_item;
      mapped_representation : representation;
   INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
   WHERE
      WR1:
         item_in_context(SELF.mapping_origin,

 SELF.mapped_representation.context_of_items);
   END_ENTITY;



   ENTITY representation_relationship;
      name : label;
      description : OPTIONAL text;
      rep_1 : representation;
      rep_2 : representation;
   END_ENTITY;



   ENTITY representation_relationship_with_transformation
   SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
   WHERE
      WR1:
         SELF\representation_relationship.rep_1.context_of_items :<>: SELF\representation_relationship.rep_2.context_of_items;
   END_ENTITY;



   ENTITY requirement_allocation_group
   SUBTYPE OF (group,

 property_definition_relationship);
   WHERE
      WR1:
         SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONFIGURATION_ITEM') ] * TYPEOF(aga.items)) = 1))) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(SELF\property_definition_relationship.relating_property_definition);
      WR4:
         NOT (SELF\property_definition_relationship.related_property_definition.description = 'test requirement') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION') ] * TYPEOF(aga.items)) = 1))) >= 1);
   END_ENTITY;



   ENTITY requirement_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\requirement_definition)) = 0;
      WR7:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'requirements model'))) >= 1;
   END_ENTITY;



   ENTITY requirements_property
   SUBTYPE OF (property_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'requirements property composition'))) <= 1;
      WR2:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'requirements description'))) = 1))) <= 1;
      WR3:
         SIZEOF(QUERY (dr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(dr.assigned_document)))) >= 1;
      WR4:
         NOT EXISTS(SELF\property_definition.description) OR (NOT (SELF\property_definition.description IN [ 'constraint',

 'part based constraint' ]) OR (SIZEOF(QUERY (dc <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'design constraint'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION' IN TYPEOF(dc.relating_property_definition.definition)))) = 1));
      WR5:
         NOT EXISTS(SELF\property_definition.description) OR (NOT (SELF\property_definition.description = 'part based constraint') OR (SIZEOF(QUERY (cp <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'constraining part'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(cp.relating_property_definition.definition)) AND (cp.relating_property_definition.definition\product_definition_relationship.name = 'constraining part')) AND (cp.relating_property_definition.definition.related_product_definition.frame_of_reference.name = 'design requirement'))) = 1));
      WR6:
         NOT EXISTS(SELF\property_definition.description) OR (NOT (SELF\property_definition.description = 'interface requirement') OR (SIZEOF(QUERY (itnha <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'interface to next higher assembly'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(itnha.relating_property_definition.definition)) AND (itnha.relating_property_definition.definition.frame_of_reference.name = 'design requirement')) AND (SIZEOF(QUERY (hai <* QUERY (pdr <* USEDIN(itnha.relating_property_definition.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'higher assembly interface'))| (SIZEOF(QUERY (pdr <* USEDIN(hai,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdr)))) = 1))) = 1))) = 1));
   END_ENTITY;



   ENTITY resistance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\resistance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = ohm;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_MEASURE' IN TYPEOF(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY resource_property;
      name : label;
      description : text;
      resource : characterized_resource_definition;
   END_ENTITY;



   ENTITY resource_requirement_type;
      name : label;
      description : text;
   END_ENTITY;



   ENTITY restriction_function
   SUBTYPE OF (maths_function,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : maths_space;
   END_ENTITY;



   ENTITY revolved_area_solid
   SUBTYPE OF (swept_area_solid);
      axis : axis1_placement;
      angle : plane_angle_measure;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis.location,

 representation_item('') || geometric_representation_item() || vector(axis.z,

 1.00000));
   END_ENTITY;



   ENTITY revolved_face_solid
   SUBTYPE OF (swept_face_solid);
      axis : axis1_placement;
      angle : plane_angle_measure;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis.location,

 representation_item('') || geometric_representation_item() || vector(axis.z,

 1.00000));
   END_ENTITY;



   ENTITY right_angular_wedge
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x : positive_length_measure;
      y : positive_length_measure;
      z : positive_length_measure;
      ltx : length_measure;
   WHERE
      WR1:
         (0.00000 <= ltx) AND (ltx < x);
   END_ENTITY;



   ENTITY right_circular_cone
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height : positive_length_measure;
      radius : length_measure;
      semi_angle : plane_angle_measure;
   WHERE
      WR1:
         radius >= 0.00000;
   END_ENTITY;



   ENTITY right_circular_cylinder
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height : positive_length_measure;
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY role_association;
      role : object_role;
      item_with_role : role_select;
   END_ENTITY;



   ENTITY routed_physical_component
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1;
      WR2:
         SELF\product_definition.description :<>: 'laminate component';
   END_ENTITY;



   ENTITY routed_printed_component
   SUBTYPE OF (printed_component);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'printed part cross section template')) AND (sar\shape_aspect_relationship.name = 'instantiated template'))) = 1))) = 1))) = 1;
      WR2:
         SIZEOF(QUERY (csa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(csa)) AND (SIZEOF(QUERY (sar <* USEDIN(csa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (SIZEOF(QUERY (pdr <* USEDIN(sar,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'inter stratum extent'))) = 1) AND (sar\shape_aspect_relationship.name = 'component extent'))) = 1))) = 1;
   END_ENTITY;



   ENTITY rule_action
   SUBTYPE OF (action);
   WHERE
      WR1:
         SIZEOF(QUERY (aaa <* QUERY (aa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ACTION_ASSIGNMENT' IN TYPEOF(aa)))| (SIZEOF(QUERY (it <* aaa.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it)) AND (it\product_definition_formation.description = 'rule version'))) = 1))) = 1;
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'participant date and time'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'participant date'))) = 1;
      WR3:
         NOT (SELF\action.name = 'rule justification') OR (SIZEOF(QUERY (ja <* QUERY (ar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| (ar\action_relationship.name = 'justified action'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION' IN TYPEOF(ja.relating_action)))) = 1);
      WR4:
         NOT (SELF\action.name = 'rule modification') OR (SIZEOF(QUERY (mr <* QUERY (ar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| (ar\action_relationship.name = 'modification rationale'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION' IN TYPEOF(mr.relating_action)) AND (mr.relating_action\action.name = 'rule change request'))) = 1);
      WR5:
         NOT (SELF\action.name = 'rule replacement from') OR (SIZEOF(QUERY (rrfa <* QUERY (aa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_REPLACEMENT_FROM_ASSIGNMENT' IN TYPEOF(aa)))| (SIZEOF(QUERY (it <* rrfa.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it)) AND (it\product_definition_formation.description = 'rule version'))) = 1))) = 1);
      WR6:
         NOT (SELF\action.name = 'rule replacement to') OR (SIZEOF(QUERY (rrta <* QUERY (aa <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_REPLACEMENT_TO_ASSIGNMENT' IN TYPEOF(aa)))| (SIZEOF(QUERY (it <* rrta.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it)) AND (it\product_definition_formation.description = 'rule version'))) = 1))) = 1);
   END_ENTITY;



   ENTITY rule_boolean_function_definition
   SUBTYPE OF (rule_function_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER' IN TYPEOF(it)))) >= 1;
   END_ENTITY;



   ENTITY rule_complex_clause
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr.rep_1)))) >= 1;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_complex_clause)) = 0;
   END_ENTITY;



   ENTITY rule_conclusion_definition
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))) = 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr\representation_relationship.rep_1)))) >= 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_conclusion_definition)) = 0;
   END_ENTITY;



   ENTITY rule_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF\product_definition.formation.description = 'rule version';
   END_ENTITY;



   ENTITY rule_function_definition
   SUPERTYPE OF (rule_boolean_function_definition)
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER' IN TYPEOF(it)))) >= 1;
      WR2:
         SIZEOF(QUERY (adf <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adf\document_reference.assigned_document.kind\document_type.product_data_type = 'reference document') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT') ] * TYPEOF(adf\document_reference.assigned_document)) >= 1))) = 1;
      WR3:
         SIZEOF(QUERY (adf <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adf\document_reference.assigned_document.kind\document_type.product_data_type = 'source code') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(adf\document_reference.assigned_document)))) = 1;
   END_ENTITY;



   ENTITY rule_function_domain_parameter
   SUBTYPE OF (model_parameter);
   WHERE
      WR1:
         SIZEOF(QUERY (cri <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri)))) = 1;
   END_ENTITY;



   ENTITY rule_function_range_parameter
   SUBTYPE OF (model_parameter);
   WHERE
      WR1:
         SIZEOF(QUERY (cri <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri)))) = 1;
   END_ENTITY;



   ENTITY rule_general_clause
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))) >= 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(rr.rep_1)))) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_general_clause)) = 0;
   END_ENTITY;



   ENTITY rule_premise_definition
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))) = 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_COMPLEX_CLAUSE' IN TYPEOF(rr\representation_relationship.rep_1)))) >= 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_premise_definition)) = 0;
   END_ENTITY;



   ENTITY rule_replacement_from_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF replacement_from_item;
   END_ENTITY;



   ENTITY rule_replacement_to_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF replacement_to_item;
   END_ENTITY;



   ENTITY rule_set
   SUBTYPE OF (product_definition);
   END_ENTITY;



   ENTITY rule_set_group
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (rsge <* QUERY (gr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (gr\product_definition_relationship.name = 'rule set group element'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_SET' IN TYPEOF(rsge.related_product_definition)))) >= 1;
   END_ENTITY;



   ENTITY rule_simple_clause
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))) >= 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_BOOLEAN_FUNCTION_DEFINITION' IN TYPEOF(rr.rep_1)))) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_simple_clause)) = 0;
   END_ENTITY;



   ENTITY ruled_surface_swept_area_solid
   SUBTYPE OF (surface_curve_swept_area_solid);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface)) AND (SELF.reference_surface\b_spline_surface.u_degree = 1);
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PCURVE' IN TYPEOF(SELF.directrix)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'B_SPLINE_CURVE' IN TYPEOF(SELF.directrix\surface_curve.curve_3d)) AND (SELF.directrix\surface_curve.curve_3d\b_spline_curve.degree = SELF.reference_surface\b_spline_surface.v_degree);
   END_ENTITY;



   ENTITY runout_zone_definition
   SUBTYPE OF (tolerance_zone_definition);
      orientation : runout_zone_orientation;
   END_ENTITY;



   ENTITY runout_zone_orientation;
      angle : measure_with_unit;
   END_ENTITY;



   ENTITY runout_zone_orientation_reference_direction
   SUBTYPE OF (runout_zone_orientation);
      orientation_defining_relationship : shape_aspect_relationship;
   END_ENTITY;



   ENTITY scalar_terminal_definition_link
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   UNIQUE
      UR1 : related_shape_aspect,

 relating_shape_aspect;
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\scalar_terminal_definition_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'scalar terminal';
      WR8:
         SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'scalar terminal';
   END_ENTITY;



   ENTITY scattering_parameter
   SUBTYPE OF (polar_complex_number_literal);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\polar_complex_number_literal || SELF\scattering_parameter)) = 0;
   END_ENTITY;



   ENTITY schema_based_model_parameter
   SUBTYPE OF (model_parameter);
   END_ENTITY;



   ENTITY seam_curve
   SUBTYPE OF (surface_curve);
   WHERE
      WR1:
         SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2:
         associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2]);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
   END_ENTITY;



   ENTITY seating_plane
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\seating_plane)) = 0;
   END_ENTITY;



   ENTITY secondary_orientation_feature
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_ORIENTATION_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ]) = 0;
      WR2:
         SELF.product_definitional = TRUE;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
      WR4:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY security_classification;
      name : label;
      purpose : text;
      security_level : security_classification_level;
   END_ENTITY;



   ENTITY security_classification_assignment
   ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY security_classification_level;
      name : label;
   END_ENTITY;



   ENTITY selector_function
   SUBTYPE OF (maths_function,

 generic_literal);
      selector : input_selector;
      source_of_domain : maths_space_or_function;
   WHERE
      WR1:
         no_cyclic_domain_reference(source_of_domain,

 [ SELF ]);
      WR2:
         expression_is_constant(domain_from(source_of_domain));
   END_ENTITY;



   ENTITY sequential_laminate_passage_based_fabrication_joint
   SUBTYPE OF (shape_aspect);
   END_ENTITY;



   ENTITY serial_numbered_effectivity
   SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id : OPTIONAL identifier;
   END_ENTITY;



   ENTITY series_composed_function
   SUBTYPE OF (maths_function,

 multiple_arity_generic_expression);
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF maths_function;
   WHERE
      WR1:
         composable_sequence(SELF\multiple_arity_generic_expression.operands);
   END_ENTITY;



   ENTITY shape_aspect;
      name : label;
      description : OPTIONAL text;
      of_shape : product_definition_shape;
      product_definitional : LOGICAL;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY shape_aspect_deriving_relationship
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DERIVED_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
   END_ENTITY;



   ENTITY shape_aspect_relationship;
      name : label;
      description : OPTIONAL text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect : shape_aspect;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY shape_definition_3d_intersection
   SUPERTYPE OF (ONEOF(edge_segment_cross_section,

 pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,

 pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,

 pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship))
   SUBTYPE OF (representation,

 shape_representation_relationship,

 representation_relationship_with_transformation);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,

 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
      WR2:
         ((((SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\representation_relationship_with_transformation || SELF\shape_definition_3d_intersection)) = 0) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_CROSS_SECTION' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_PARALLEL_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_PLANE_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF));
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF(SELF\representation_relationship_with_transformation.transformation_operator);
   END_ENTITY;



   ENTITY shape_definition_representation
   SUBTYPE OF (property_definition_representation);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF.definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition));
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
   END_ENTITY;



   ENTITY shape_dimension_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* SELF.items| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(temp)))) = 0;
      WR2:
         SIZEOF(SELF.items) <= 2;
      WR3:
         SIZEOF(QUERY (pos_mri <* QUERY (real_mri <* SELF.items| ('REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)))| NOT (pos_mri\measure_with_unit.value_component > 0.00000))) = 0;
   END_ENTITY;



   ENTITY shape_formed_terminal
   SUBTYPE OF (altered_package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document)) AND (ada.assigned_document.kind\document_type.product_data_type = 'lead form specification')) AND (SIZEOF(QUERY (dr <* USEDIN(ada.assigned_document,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT')| (dr.relating_document.kind\document_type.product_data_type = 'material specification'))) = 1))) = 1;
   END_ENTITY;



   ENTITY shape_item_relationship
   SUBTYPE OF (representation_item,

 representation_item_relationship);
   UNIQUE
      UR1 : SELF\representation_item_relationship.relating_representation_item,

 SELF\representation_item_relationship.related_representation_item;
   WHERE
      WR1:
         SELF\representation_item_relationship.relating_representation_item :<>: SELF\representation_item_relationship.related_representation_item;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation_item || SELF\representation_item_relationship || SELF\shape_item_relationship)) = 0;
   END_ENTITY;



   ENTITY shape_modification
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (dim <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design intent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(dim.relating_shape_aspect)))) = 1;
      WR2:
         (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)) AND (pd\property_definition.description = 'modification causal'))) = 1) OR (SIZEOF(QUERY (mcf <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'modification causal feature'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(mcf.relating_shape_aspect)) = 1) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(mcf.relating_shape_aspect.of_shape.definition)))) = 1);
      WR3:
         NOT (SELF\shape_aspect.description IN [ 'electrical isolation removal',

 'thermal isolation removal' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'spacing requirement') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'spacing requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition)))) = 1))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description IN [ 'electrical isolation removal',

 'thermal isolation removal' ]) OR (SIZEOF(QUERY (di <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design intent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(di.relating_shape_aspect)) AND (di.relating_shape_aspect\shape_aspect.description IN [ 'conductive filled area',

 'connected filled area' ]))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'thermal isolation removal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)) AND (pd\property_definition.description = 'angular orientation requirement'))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'thermal isolation removal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)) AND (pd\property_definition.description = 'effective current capacity requirement'))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'material addition feature') OR (SIZEOF(QUERY (dim <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material addition shape'))| (dim.relating_shape_aspect\shape_aspect.description = 'material addition feature template'))) = 1);
   END_ENTITY;



   ENTITY shape_representation
   SUBTYPE OF (representation);
   END_ENTITY;



   ENTITY shape_representation_relationship
   SUBTYPE OF (representation_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2);
   END_ENTITY;



   ENTITY shape_representation_relationship_with_transformation
   SUBTYPE OF (shape_representation_relationship,

 representation_relationship_with_transformation);
   END_ENTITY;



   ENTITY shell_based_2d_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF\representation.items| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D') ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF\representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM') ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_CURVE' IN TYPEOF(el.edge_element)))) = 0))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (pline_el <* QUERY (el <* eloop\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POLYLINE' IN TYPEOF(el.edge_element\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT valid_2d_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(el.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(el.edge_element.edge_end))))) = 0))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (con_edges <* QUERY (el <* eloop\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONIC' IN TYPEOF(el.edge_element\edge_curve.edge_geometry)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(con_edges.edge_element\edge_curve.edge_geometry\conic.position)))) = 0))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_LOOP' IN TYPEOF(wsb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(vloop\vertex_loop.loop_vertex)))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_LOOP' IN TYPEOF(wsb)))| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_SHELL' IN TYPEOF(sb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex)))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_SHELL' IN TYPEOF(sb)))| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0;
      WR13:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR14:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
   END_ENTITY;



   ENTITY shell_based_surface_model
   SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
   WHERE
      WR1:
         constraints_geometry_shell_based_surface_model(SELF);
   END_ENTITY;



   ENTITY shell_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
   WHERE
      WR1:
         constraints_geometry_shell_based_wireframe_model(SELF);
   END_ENTITY;



   ENTITY shell_based_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(el.edge_element)))) = 0))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (pline_el <* QUERY (el <* eloop\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(el.edge_element\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry))) = 0))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(el.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(el.edge_element.edge_end))))) = 0))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(wsb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vloop\vertex_loop.loop_vertex)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(wsb)))| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex)))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)))| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR13:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
   END_ENTITY;



   ENTITY shield_allocation
   SUBTYPE OF (electromagnetic_compatibility_requirement_allocation);
   END_ENTITY;



   ENTITY si_unit
   SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name : si_unit_name;
   DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
   END_ENTITY;



   ENTITY signal
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SIZEOF(QUERY (aca <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SIGNAL_CATEGORY' IN TYPEOF(aca.assigned_group)))) >= 1;
      WR2:
         SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'signal category'))) = 1))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY signal_category
   SUBTYPE OF (group,

 externally_defined_item);
   WHERE
      WR1:
         SELF\group.description IN [ 'signal characteristic category',

 'signal property category' ];
   END_ENTITY;



   ENTITY simple_boolean_expression
   ABSTRACT SUPERTYPE OF (ONEOF(boolean_literal,

 boolean_variable))
   SUBTYPE OF (boolean_expression,

 simple_generic_expression);
   END_ENTITY;



   ENTITY simple_generic_expression
   ABSTRACT SUPERTYPE OF (ONEOF(generic_literal,

 generic_variable))
   SUBTYPE OF (generic_expression);
   END_ENTITY;



   ENTITY simple_numeric_expression
   ABSTRACT SUPERTYPE OF (ONEOF(literal_number,

 numeric_variable))
   SUBTYPE OF (numeric_expression,

 simple_generic_expression);
   END_ENTITY;



   ENTITY simple_string_expression
   ABSTRACT SUPERTYPE OF (ONEOF(string_literal,

 string_variable))
   SUBTYPE OF (string_expression,

 simple_generic_expression);
   END_ENTITY;



   ENTITY sin_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY slash_expression
   SUBTYPE OF (binary_numeric_expression);
   END_ENTITY;



   ENTITY solid_angle_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY solid_angle_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY solid_curve_font
   SUBTYPE OF (pre_defined_curve_font);
   END_ENTITY;



   ENTITY solid_model
   SUPERTYPE OF (ONEOF(csg_solid,

 manifold_solid_brep,

 swept_face_solid,

 swept_area_solid,

 swept_disk_solid,

 solid_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY solid_replica
   SUBTYPE OF (solid_model);
      parent_solid : solid_model;
      transformation : cartesian_transformation_operator_3d;
   WHERE
      WR1:
         acyclic_solid_replica(SELF,

 parent_solid);
      WR2:
         parent_solid\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY specified_higher_usage_occurrence
   SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage : next_assembly_usage_occurrence;
   UNIQUE
      UR1 : upper_usage,

 next_usage;
   WHERE
      WR1:
         SELF :<>: upper_usage;
      WR2:
         SELF\product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition;
      WR3:
         SELF\product_definition_relationship.related_product_definition :=: next_usage.related_product_definition;
      WR4:
         (upper_usage.related_product_definition :=: next_usage.relating_product_definition) OR (SIZEOF(QUERY (pdr <* USEDIN(upper_usage.related_product_definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr.relating_product_definition :=: next_usage.relating_product_definition))) = 1);
      WR5:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NEXT_ASSEMBLY_USAGE_OCCURRENCE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPECIFIED_HIGHER_USAGE_OCCURRENCE' ] * TYPEOF(upper_usage)) = 1;
   END_ENTITY;



   ENTITY sphere
   SUBTYPE OF (geometric_representation_item);
      radius : positive_length_measure;
      centre : point;
   END_ENTITY;



   ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY square_root_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY standard_table_function
   SUBTYPE OF (linearized_table_function);
      order : ordering_type;
   WHERE
      WR1:
         extremal_position_check(SELF);
   END_ENTITY;



   ENTITY standard_uncertainty
   SUPERTYPE OF (expanded_uncertainty)
   SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : REAL;
   END_ENTITY;



   ENTITY start_request
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF start_request_item;
   END_ENTITY;



   ENTITY start_work
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIRECTED_ACTION' IN TYPEOF(SELF.assigned_action);
   END_ENTITY;



   ENTITY statistical_dimensional_location
   SUBTYPE OF (dimensional_location);
   END_ENTITY;



   ENTITY statistical_dimensional_size
   SUBTYPE OF (dimensional_size_property);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'substitutable dimension'))) <= 1))) <= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'dimensional tolerance statistical control requirement'))) <= 1))) <= 1;
      WR3:
         NOT (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'substitutable dimension'))) <= 1))) <= 1) OR NOT (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STATISTICAL_DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition))) AND (pdr\property_definition_relationship.name = 'substitutable dimension'))) <= 1))) <= 1);
   END_ENTITY;



   ENTITY statistical_geometric_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance'))) <= 1;
      WR2:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'geometric tolerance statistical control requirement'))) = 1;
      WR3:
         SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STATISTICAL_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance'))) <= 0;
   END_ENTITY;



   ENTITY stratum
   SUBTYPE OF (product_definition);
   UNIQUE
      UR1 : SELF\product_definition.id,

 SELF\product_definition.formation;
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1;
      WR3:
         (SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'attachment region size'))) = 1))) <= 1) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'stratum usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNAL_DEFINITION' IN TYPEOF(tu.relating_property_definition)))) = 1))) <= 1);
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR6:
         SIZEOF(QUERY (acu <* QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr)))| (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship'))) >= 1;
      WR7:
         NOT (SELF\product_definition.name = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)) AND (tu.relating_property_definition.definition\characterized_object.description = 'design layer'))) = 1))) = 1);
      WR8:
         NOT (SELF\product_definition.name = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sa)))) >= 1))) >= 1);
      WR9:
         NOT (SELF\product_definition.name = 'documentation layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)) AND (tu.relating_property_definition.definition\characterized_object.description = 'documentation layer'))) = 1))) = 1);
      WR10:
         NOT (SELF\product_definition.name = 'design layer') OR ((NOT (SELF\product_definition.description = 'primary design layer stratum') OR (SIZEOF(QUERY (imps <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(imps,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module primary surface'))) >= 0))) >= 0))) = 1)) OR (NOT (SELF\product_definition.description = 'non primary design layer stratum') OR (SIZEOF(QUERY (imps <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(imps,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module primary surface'))) >= 0))) >= 0))) = 0)));
   END_ENTITY;



   ENTITY stratum_concept_relationship
   SUBTYPE OF (shape_aspect,

 shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))) >= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1))) = 1;
      WR3:
         NOT (SELF\shape_aspect_relationship.name = 'dielectric crossover area') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(SELF.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(SELF.related_shape_aspect));
      WR4:
         NOT (SELF\shape_aspect_relationship.name = 'dielectric crossover area') OR (SIZEOF(QUERY (rdc <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'resulting dielectric crossover'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(rdc.relating_shape_aspect)))) = 1);
      WR5:
         NOT (SELF\shape_aspect_relationship.name = 'stratum feature conductive join') OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND' IN TYPEOF(SELF.relating_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.relating_shape_aspect)) AND (SELF.relating_shape_aspect\shape_aspect.description = 'stratum feature template component'));
      WR6:
         NOT (SELF\shape_aspect_relationship.name = 'stratum feature conductive join') OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND' IN TYPEOF(SELF.related_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description = 'stratum feature template component'));
      WR7:
         NOT (SELF\shape_aspect_relationship.name = 'stratum feature conductive join') OR (SIZEOF(QUERY (fj <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'features join'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(fj.related_shape_aspect)) AND (fj.related_shape_aspect\shape_aspect.description = 'bonded conductive base blind via'))) <= 1);
      WR8:
         NOT ((SELF\shape_aspect.description = 'physical network supporting stratum feature conductive join') AND (SELF\shape_aspect_relationship.name = 'stratum feature conductive join')) OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) = 1);
   END_ENTITY;



   ENTITY stratum_feature
   SUPERTYPE OF (fiducial_stratum_feature)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'feature of size')) AND (it\descriptive_representation_item.description IN [ 'true',

 'false' ]))) = 1))) = 1))) = 0;
      WR3:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'conductor') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'intra stratum join'))) = 1));
      WR4:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'connected filled area') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'intra stratum join'))) = 1));
      WR5:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'conductor') OR (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
      WR6:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'connected filled area') OR (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
   END_ENTITY;



   ENTITY stratum_specific_part_template_location_in_padstack_definition
   SUBTYPE OF (assembly_component_usage,

 property_definition);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\assembly_component_usage || SELF\product_definition_usage || SELF\product_definition_relationship || SELF\stratum_specific_part_template_location_in_padstack_definition || SELF\property_definition)) = 0;
      WR2:
         SELF\property_definition.name = '';
      WR3:
         SELF\property_definition.description = '';
      WR4:
         SELF\product_definition_relationship.name = 'part template location in padstack definition';
      WR5:
         SELF\product_definition_relationship.description = '';
   END_ENTITY;



   ENTITY stratum_surface
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'primary surface',

 'secondary surface',

 'average surface' ];
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
   END_ENTITY;



   ENTITY stratum_technology
   SUBTYPE OF (characterized_object);
   UNIQUE
      UR1 : SELF\characterized_object.name;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'stiffness class representation'))) <= 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))) = 1))) = 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (scr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'stratum class representation'))| NOT (SIZEOF(QUERY (it <* scr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'laminate stiffness class')) AND (it\descriptive_representation_item.description IN [ 'fluid like',

 'conformal coat',

 'stiff laminate' ]))) = 1))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT ((2 <= SIZEOF(pcr.used_representation.items)) AND (SIZEOF(pcr.used_representation.items) <= 8)))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| NOT (it\representation_item.name IN [ 'layer purpose',

 'layer position',

 'maximum feature size requirement',

 'minimum finished feature spacing',

 'minimum finished feature size',

 'maximum thickness',

 'minimum thickness' ]))) = 0))) = 0))) = 0;
      WR7:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum finished feature size'))) = 1))) = 0))) = 0));
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum thickness'))) = 1))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum thickness'))) = 1))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum feature size requirement'))) <= 1))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum finished feature spacing'))) <= 1))) = 0))) = 0;
      WR12:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'documentation layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'layer purpose'))) = 1))) = 0))) = 0));
      WR13:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum finished feature spacing'))) = 1))) = 0))) = 0));
      WR14:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'layer purpose')) AND (it\descriptive_representation_item.description IN [ 'power or ground',

 'other signal',

 'lands only' ]))) = 1))) = 0))) = 0));
      WR15:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'layer position')) AND (it\descriptive_representation_item.description IN [ 'primary',

 'secondary',

 'internal',

 'external',

 'all' ]))) = 1))) = 0))) = 0;
      WR16:
         NOT EXISTS(SELF\characterized_object.description) OR (SELF\characterized_object.description IN [ 'design layer',

 'documentation layer' ]);
   END_ENTITY;



   ENTITY stratum_technology_link
   SUPERTYPE OF (printed_part_template_link)
   SUBTYPE OF (property_definition,

 property_definition_relationship);
   WHERE
      WR1:
         SELF\property_definition_relationship.related_property_definition.definition :<>: SELF\property_definition_relationship.relating_property_definition.definition;
      WR2:
         (SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship || SELF\stratum_technology_link || SELF\property_definition)) = 0) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_LINK' IN TYPEOF(SELF));
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(SELF\property_definition_relationship.related_property_definition.definition);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(SELF\property_definition_relationship.relating_property_definition.definition);
      WR5:
         SELF\property_definition.name = '';
      WR6:
         SELF\property_definition.description = '';
      WR7:
         SELF\property_definition_relationship.name = '';
      WR8:
         SELF\property_definition_relationship.description = '';
      WR9:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\property_definition.definition)) AND (SELF\property_definition.definition.description = 'printed part template');
      WR10:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr.name = 'precedent stratum technology link'))) <= 1;
      WR11:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr.name = 'precedent stratum technology link'))) <= 1;
   END_ENTITY;



   ENTITY stratum_type_independent_padstack_definition
   SUBTYPE OF (padstack_definition);
   END_ENTITY;



   ENTITY strict_triangular_matrix
   SUBTYPE OF (triangular_matrix);
      main_diagonal_value : maths_value;
   END_ENTITY;



   ENTITY string_defined_function
   ABSTRACT SUPERTYPE
   SUBTYPE OF (defined_function,

 string_expression);
   END_ENTITY;



   ENTITY string_expression
   ABSTRACT SUPERTYPE OF (ONEOF(simple_string_expression,

 index_expression,

 substring_expression,

 concat_expression,

 format_function,

 string_defined_function))
   SUBTYPE OF (expression);
   END_ENTITY;



   ENTITY string_literal
   SUBTYPE OF (simple_string_expression,

 generic_literal);
      the_value : STRING;
   END_ENTITY;



   ENTITY string_variable
   SUBTYPE OF (simple_string_expression,

 variable);
   END_ENTITY;



   ENTITY structured_text_representation_context
   SUBTYPE OF (representation_context);
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.CONTEXT_OF_ITEMS')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rep)))) = 0;
   END_ENTITY;



   ENTITY structured_text_representation_item
   SUBTYPE OF (representation,

 descriptive_representation_item);
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rr.rep_1)))) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) >= 1;
      WR3:
         SIZEOF(QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 1;
   END_ENTITY;



   ENTITY styled_item
   SUBTYPE OF (representation_item);
      styles : SET [1:?] OF presentation_style_assignment;
      item : representation_item;
   WHERE
      WR1:
         (SIZEOF(SELF.styles) = 1) XOR (SIZEOF(QUERY (pres_style <* SELF.styles| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(pres_style)))) = 0);
   END_ENTITY;



   ENTITY subedge
   SUBTYPE OF (edge);
      parent_edge : edge;
   END_ENTITY;



   ENTITY subface
   SUBTYPE OF (face);
      parent_face : face;
   WHERE
      WR1:
         NOT mixed_loop_type_set((list_to_set(list_face_loops(SELF)) + list_to_set(list_face_loops(parent_face))));
   END_ENTITY;



   ENTITY substring_expression
   SUBTYPE OF (string_expression,

 multiple_arity_generic_expression);
   DERIVE
      operand : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
      index1 : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
      index2 : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
   WHERE
      WR1:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_EXPRESSION' IN TYPEOF(operand)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(index1))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(index2));
      WR2:
         SIZEOF(SELF\multiple_arity_generic_expression.operands) = 3;
      WR3:
         is_int_expr(index1);
      WR4:
         is_int_expr(index2);
   END_ENTITY;



   ENTITY supplied_part_relationship
   SUBTYPE OF (product_definition_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN TYPEOF(SELF.related_product_definition.formation);
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION' IN ROLESOF(SELF));
   END_ENTITY;



   ENTITY surface
   SUPERTYPE OF (ONEOF(elementary_surface,

 swept_surface,

 bounded_surface,

 offset_surface,

 surface_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY surface_curve
   SUPERTYPE OF (ONEOF(intersection_curve,

 seam_curve) ANDOR

 bounded_surface_curve)
   SUBTYPE OF (curve);
      curve_3d : curve;
      associated_geometry : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
   DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
   WHERE
      WR1:
         curve_3d.dim = 3;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation <> pcurve_s1);
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation <> pcurve_s2);
      WR4:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(curve_3d));
   END_ENTITY;



   ENTITY surface_curve_swept_area_solid
   SUBTYPE OF (swept_area_solid);
      directrix : curve;
      start_param : REAL;
      end_param : REAL;
      reference_surface : surface;
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface);
   END_ENTITY;



   ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
   END_ENTITY;



   ENTITY surface_of_revolution
   SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis_position.location,

 representation_item('') || geometric_representation_item() || vector(axis_position.z,

 1.00000));
   END_ENTITY;



   ENTITY surface_patch
   SUBTYPE OF (founded_item);
      parent_surface : bounded_surface;
      u_transition : transition_code;
      v_transition : transition_code;
      u_sense : BOOLEAN;
      v_sense : BOOLEAN;
   INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR segments;
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface));
   END_ENTITY;



   ENTITY surface_prepped_terminal
   SUBTYPE OF (altered_package_terminal);
   WHERE
      WR2:
         SIZEOF(QUERY (ada <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document)) AND (ada.assigned_document.kind\document_type.product_data_type = 'surface finish specification'))) = 1;
   END_ENTITY;



   ENTITY surface_profile_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         NOT (SELF\geometric_tolerance.name = 'surface profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND ((gtr.relating_geometric_tolerance\geometric_tolerance.name = 'surface profile locating') OR (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement'))) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 1);
      WR2:
         NOT (SELF\geometric_tolerance.name = 'surface profile locating') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 1);
      WR3:
         NOT (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(SELF)) AND (SELF\geometric_tolerance.name = 'surface profile refinement')) OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 0);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'surface profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 1);
      WR5:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY surface_replica
   SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
   WHERE
      WR1:
         acyclic_surface_replica(SELF,

 parent_surface);
   END_ENTITY;



   ENTITY surface_side_style;
      name : label;
      styles : SET [1:7] OF surface_style_element_select;
   WHERE
      WR1:
         SIZEOF(QUERY (style1 <* SELF.styles| (SIZEOF(QUERY (style2 <* SELF.styles - style1| (TYPEOF(style1) = TYPEOF(style2)))) > 0))) = 0;
   END_ENTITY;



   ENTITY surface_style_boundary;
      style_of_boundary : curve_or_render;
   END_ENTITY;



   ENTITY surface_style_control_grid;
      style_of_control_grid : curve_or_render;
   END_ENTITY;



   ENTITY surface_style_fill_area;
      fill_area : fill_area_style;
   END_ENTITY;



   ENTITY surface_style_parameter_line;
      style_of_parameter_lines : curve_or_render;
      direction_counts : SET [1:2] OF direction_count_select;
   WHERE
      WR1:
         (HIINDEX(SELF.direction_counts) = 1) XOR (TYPEOF(SELF.direction_counts[1]) <> TYPEOF(SELF.direction_counts[2]));
   END_ENTITY;



   ENTITY surface_style_rendering;
      rendering_method : shading_surface_method;
      surface_colour : colour;
   END_ENTITY;



   ENTITY surface_style_segmentation_curve;
      style_of_segmentation_curve : curve_or_render;
   END_ENTITY;



   ENTITY surface_style_silhouette;
      style_of_silhouette : curve_or_render;
   END_ENTITY;



   ENTITY surface_style_usage;
      side : surface_side;
      style : surface_side_style_select;
   END_ENTITY;



   ENTITY swept_area_solid
   SUPERTYPE OF (ONEOF(revolved_area_solid,

 extruded_area_solid,

 surface_curve_swept_area_solid))
   SUBTYPE OF (solid_model);
      swept_area : curve_bounded_surface;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(swept_area.basis_surface);
   END_ENTITY;



   ENTITY swept_disk_solid
   SUBTYPE OF (solid_model);
      directrix : curve;
      radius : positive_length_measure;
      inner_radius : OPTIONAL positive_length_measure;
      start_param : REAL;
      end_param : REAL;
   WHERE
      WR1:
         directrix.dim = 3;
      WR2:
         NOT EXISTS(inner_radius) OR (radius > inner_radius);
   END_ENTITY;



   ENTITY swept_face_solid
   SUPERTYPE OF (ONEOF(extruded_face_solid,

 revolved_face_solid))
   SUBTYPE OF (solid_model);
      swept_face : face_surface;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(swept_face.face_geometry);
   END_ENTITY;



   ENTITY swept_surface
   SUPERTYPE OF (ONEOF(surface_of_linear_extrusion,

 surface_of_revolution))
   SUBTYPE OF (surface);
      swept_curve : curve;
   END_ENTITY;



   ENTITY symbol_representation
   SUBTYPE OF (representation);
   END_ENTITY;



   ENTITY symbol_representation_map
   SUBTYPE OF (representation_map);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_REPRESENTATION' IN TYPEOF(SELF\representation_map.mapped_representation);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(SELF\representation_map.mapping_origin);
   END_ENTITY;



   ENTITY symbol_target
   SUBTYPE OF (geometric_representation_item);
      placement : axis2_placement;
      x_scale : positive_ratio_measure;
      y_scale : positive_ratio_measure;
   END_ENTITY;



   ENTITY symmetric_banded_matrix
   SUBTYPE OF (symmetric_matrix);
      default_entry : maths_value;
      above : nonnegative_integer;
   WHERE
      WR1:
         member_of(default_entry,

 factor1(SELF\linearized_table_function.source.range));
   END_ENTITY;



   ENTITY symmetric_matrix
   SUBTYPE OF (linearized_table_function);
      symmetry : symmetry_type;
      triangle : lower_upper;
      order : ordering_type;
   WHERE
      WR1:
         SIZEOF(SELF\explicit_table_function.shape) = 2;
      WR2:
         SELF\explicit_table_function.shape[1] = SELF\explicit_table_function.shape[2];
      WR3:
         NOT (symmetry = skew) OR (space_dimension(SELF\linearized_table_function.source.range) = 1) AND subspace_of_es(factor1(SELF\linearized_table_function.source.range),

 es_numbers);
      WR4:
         NOT ((symmetry = hermitian) OR (symmetry = skew_hermitian)) OR (space_dimension(SELF\linearized_table_function.source.range) = 1) AND subspace_of_es(factor1(SELF\linearized_table_function.source.range),

 es_complex_numbers);
   END_ENTITY;



   ENTITY symmetric_shape_aspect
   SUBTYPE OF (shape_aspect);
   INVERSE
      basis_relationships : SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
   WHERE
      WR1:
         SIZEOF(QUERY (X <* SELF.basis_relationships| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CENTRE_OF_SYMMETRY' IN TYPEOF(X.related_shape_aspect)))) >= 1;
   END_ENTITY;



   ENTITY symmetry_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'symmetry';
   END_ENTITY;



   ENTITY table_representation_item
   SUBTYPE OF (compound_representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')) > 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIST_REPRESENTATION_ITEM' IN TYPEOF(SELF\compound_representation_item.item_element);
   END_ENTITY;



   ENTITY tan_function
   SUBTYPE OF (unary_function_call);
   END_ENTITY;



   ENTITY tangent
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) = 1;
   END_ENTITY;



   ENTITY template_material_cross_section_boundary
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\template_material_cross_section_boundary)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(SELF.of_shape\property_definition.definition);
      WR3:
         SELF\shape_aspect.description IN [ 'top',

 'left',

 'right',

 'bottom' ];
   END_ENTITY;



   ENTITY tertiary_orientation_feature
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_ORIENTATION_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SECONDARY_ORIENTATION_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ]) = 0;
      WR2:
         SELF.product_definitional = TRUE;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
      WR4:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY test_point_part_feature
   SUBTYPE OF (part_tooling_feature);
   END_ENTITY;



   ENTITY text_font;
      id : identifier;
      name : label;
      description : text;
   INVERSE
      glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
   END_ENTITY;



   ENTITY text_font_family;
      id : identifier;
      name : label;
      description : text;
   INVERSE
      fonts : SET [1:?] OF text_font_in_family FOR family;
   END_ENTITY;



   ENTITY text_font_in_family;
      font : text_font;
      family : text_font_family;
   END_ENTITY;



   ENTITY text_literal
   SUBTYPE OF (geometric_representation_item);
      literal : presentable_text;
      placement : axis2_placement;
      alignment : text_alignment;
      path : text_path;
      font : font_select;
   END_ENTITY;



   ENTITY text_literal_with_associated_curves
   SUBTYPE OF (text_literal);
      associated_curves : SET [1:?] OF curve;
   END_ENTITY;



   ENTITY text_literal_with_extent
   SUBTYPE OF (text_literal);
      extent : planar_extent;
   END_ENTITY;



   ENTITY text_string_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (item <* SELF\representation.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' ] * TYPEOF(item)) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (item <* SELF\representation.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT' ] * TYPEOF(item)) = 0))) >= 1;
      WR3:
         SIZEOF(QUERY (a2p <* QUERY (item <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(item)))| NOT ((SIZEOF(QUERY (at <* QUERY (item <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_TEXT' IN TYPEOF(item)))| (at\mapped_item.mapping_target :=: a2p))) >= 1) OR (SIZEOF(QUERY (atc <* QUERY (item <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF(item)))| (atc\mapped_item.mapping_target :=: a2p))) >= 1)))) = 0;
   END_ENTITY;



   ENTITY text_style;
      name : label;
      character_appearance : character_style_select;
   END_ENTITY;



   ENTITY text_style_for_defined_font;
      text_colour : colour;
   END_ENTITY;



   ENTITY thermal_component
   SUBTYPE OF (component_definition);
   END_ENTITY;



   ENTITY thermal_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY thermal_feature
   SUBTYPE OF (shape_aspect);
   END_ENTITY;



   ENTITY thermal_isolation_component_shape_aspect
   SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY thermal_isolation_removal_template_definition
   SUBTYPE OF (part_template_definition);
   END_ENTITY;



   ENTITY thermal_network
   SUBTYPE OF (functional_unit);
   END_ENTITY;



   ENTITY thermal_requirement_allocation
   SUBTYPE OF (product_definition_relationship);
   END_ENTITY;



   ENTITY thermodynamic_temperature_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY thermodynamic_temperature_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY through_port_variable
   SUBTYPE OF (port_variable);
   END_ENTITY;



   ENTITY time_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY time_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 1.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY tolerance_value;
      lower_bound : measure_with_unit;
      upper_bound : measure_with_unit;
   WHERE
      WR1:
         upper_bound.value_component > lower_bound.value_component;
      WR2:
         upper_bound.unit_component = lower_bound.unit_component;
   END_ENTITY;



   ENTITY tolerance_zone
   SUBTYPE OF (shape_aspect);
      defining_tolerance : SET [1:?] OF geometric_tolerance;
      form : tolerance_zone_form;
   END_ENTITY;



   ENTITY tolerance_zone_boundary
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description = 'conical') OR NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
      WR2:
         NOT (SELF\shape_aspect.description = 'circular or cylindrical or spherical') OR NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
      WR3:
         SELF\shape_aspect.product_definitional = FALSE;
      WR4:
         NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'boundary zone definition with specified size') OR (pd\property_definition.description = 'conical tolerance zone boundary'))) = 1;
      WR6:
         SIZEOF(USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_DEFINITION.BOUNDARIES')) = 1;
   END_ENTITY;



   ENTITY tolerance_zone_definition
   SUPERTYPE OF (ONEOF(projected_zone_definition,

 runout_zone_definition));
      zone : tolerance_zone;
      boundaries : SET [1:?] OF shape_aspect;
   END_ENTITY;



   ENTITY tolerance_zone_explicit_opposing_boundary_set
   SUBTYPE OF (tolerance_zone_boundary);
   END_ENTITY;



   ENTITY tolerance_zone_form;
      name : label;
   END_ENTITY;



   ENTITY tolerance_zone_implicit_opposing_boundary_set
   SUBTYPE OF (tolerance_zone_boundary);
   END_ENTITY;



   ENTITY tool_registration_mark
   SUBTYPE OF (part_tooling_feature);
   END_ENTITY;



   ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex,

 edge,

 face_bound,

 face,

 vertex_shell,

 wire_shell,

 connected_edge_set,

 connected_face_set,

 loop ANDOR

 path))
   SUBTYPE OF (representation_item);
   END_ENTITY;



   ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
   END_ENTITY;



   ENTITY torus
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
   WHERE
      WR1:
         major_radius > minor_radius;
   END_ENTITY;



   ENTITY total_runout_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'total runout';
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY transform_port_variable
   SUBTYPE OF (port_variable);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'nominal signal flow direction')) AND (it\descriptive_representation_item.description IN [ 'input direction',

 'output direction',

 'unknown direction' ]))) = 1;
   END_ENTITY;



   ENTITY triangular_matrix
   SUBTYPE OF (linearized_table_function);
      default_entry : maths_value;
      lo_up : lower_upper;
      order : ordering_type;
   WHERE
      WR1:
         SIZEOF(SELF\explicit_table_function.shape) = 2;
      WR2:
         member_of(default_entry,

 SELF\maths_function.range);
   END_ENTITY;



   ENTITY trimmed_curve
   SUBTYPE OF (bounded_curve);
      basis_curve : curve;
      trim_1 : SET [1:2] OF trimming_select;
      trim_2 : SET [1:2] OF trimming_select;
      sense_agreement : BOOLEAN;
      master_representation : trimming_preference;
   WHERE
      WR1:
         (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
      WR2:
         (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
   END_ENTITY;



   ENTITY two_direction_repeat_factor
   SUBTYPE OF (one_direction_repeat_factor);
      second_repeat_factor : vector;
   END_ENTITY;



   ENTITY type_qualifier;
      name : label;
   END_ENTITY;



   ENTITY unary_boolean_expression
   ABSTRACT SUPERTYPE OF (ONEOF(not_expression,

 odd_function))
   SUBTYPE OF (boolean_expression,

 unary_generic_expression);
   END_ENTITY;



   ENTITY unary_function_call
   ABSTRACT SUPERTYPE OF (ONEOF(abs_function,

 minus_function,

 sin_function,

 cos_function,

 tan_function,

 asin_function,

 acos_function,

 exp_function,

 log_function,

 log2_function,

 log10_function,

 square_root_function))
   SUBTYPE OF (unary_numeric_expression);
   END_ENTITY;



   ENTITY unary_generic_expression
   ABSTRACT SUPERTYPE
   SUBTYPE OF (generic_expression);
      operand : generic_expression;
   END_ENTITY;



   ENTITY unary_numeric_expression
   ABSTRACT SUPERTYPE OF (unary_function_call)
   SUBTYPE OF (numeric_expression,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : numeric_expression;
   END_ENTITY;



   ENTITY uncertainty_measure_with_unit
   SUBTYPE OF (measure_with_unit);
      name : label;
      description : OPTIONAL text;
   WHERE
      WR1:
         valid_measure_value(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY uncertainty_qualifier
   SUPERTYPE OF (ONEOF(standard_uncertainty,

 qualitative_uncertainty));
      measure_name : label;
      description : text;
   END_ENTITY;



   ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY uniform_product_space
   SUBTYPE OF (maths_space,

 generic_literal);
      base : maths_space;
      exponent : positive_integer;
   WHERE
      WR1:
         expression_is_constant(base);
      WR2:
         no_cyclic_space_reference(SELF,

 []);
      WR3:
         base <> the_empty_space;
   END_ENTITY;



   ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY unit_defined_maths_space_context
   SUBTYPE OF (defined_maths_space_context);
      unit_basis : unit;
   END_ENTITY;



   ENTITY usage_view_connection_zone_terminal_shape_relationship
   SUBTYPE OF (representation,

 representation_relationship_with_transformation);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,

 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION') ] * TYPEOF(SELF.rep_1)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION') ] * TYPEOF(SELF.rep_2)) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\representation_relationship_with_transformation || SELF\usage_view_connection_zone_terminal_shape_relationship)) = 0;
      WR4:
         SELF\representation_relationship.rep_1 <> SELF\representation_relationship.rep_2;
   END_ENTITY;



   ENTITY value_function
   SUPERTYPE OF (int_value_function)
   SUBTYPE OF (numeric_expression,

 unary_generic_expression);
      SELF\unary_generic_expression.operand : string_expression;
   END_ENTITY;



   ENTITY variable
   ABSTRACT SUPERTYPE OF (ONEOF(numeric_variable,

 boolean_variable,

 string_variable))
   SUBTYPE OF (generic_variable);
   END_ENTITY;



   ENTITY variable_semantics
   ABSTRACT SUPERTYPE;
   END_ENTITY;



   ENTITY vector
   SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude : length_measure;
   WHERE
      WR1:
         magnitude >= 0.00000;
   END_ENTITY;



   ENTITY versioned_action_request;
      id : identifier;
      version : label;
      purpose : text;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY vertex
   SUBTYPE OF (topological_representation_item);
   END_ENTITY;



   ENTITY vertex_loop
   SUBTYPE OF (loop);
      loop_vertex : vertex;
   END_ENTITY;



   ENTITY vertex_point
   SUBTYPE OF (vertex,

 geometric_representation_item);
      vertex_geometry : point;
   END_ENTITY;



   ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
   END_ENTITY;



   ENTITY viewing_plane
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description = 'affected plane';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')| (pd\property_definition.description = 'viewing plane property'))) = 1;
      WR3:
         NOT SELF\shape_aspect.product_definitional;
   END_ENTITY;



   ENTITY volume
   SUBTYPE OF (geometric_representation_item);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY volume_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY volume_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 3.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
   WHERE
      WR1:
         NOT mixed_loop_type_set(wire_shell_extent);
   END_ENTITY;



   ENTITY wire_terminal
   SUBTYPE OF (package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 2))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'maximum wire terminal length')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 1))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'minimum wire terminal length')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 1))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'internal connection zone') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY xor_expression
   SUBTYPE OF (binary_boolean_expression);
      SELF\binary_generic_expression.operands : LIST [2:2] OF boolean_expression;
   END_ENTITY;


(* ***********************************
Types in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   TYPE action_assigned_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE ahead_or_behind = ENUMERATION OF
      (ahead,


       exact,


       behind);
   END_TYPE;



   TYPE amount_of_substance_measure = REAL;
   END_TYPE;



   TYPE angle_relator = ENUMERATION OF
      (equal,


       large,


       small);
   END_TYPE;



   TYPE approval_assigned_item = SELECT
      (action,


       action_directive,


       certification,


       change,


       change_request,


       configuration_effectivity,


       configuration_item,


       contract,


       date,


       directed_action,


       document,


       model_parameter_relationship,


       product,


       product_definition,


       product_definition_relationship,


       product_definition_formation,


       product_definition_formation_with_specified_source,


       representation,


       requirement_allocation_group,


       security_classification,


       shape_aspect_relationship,


       start_request,


       start_work,


       versioned_action_request);
   END_TYPE;



   TYPE area_measure = REAL;
   END_TYPE;



   TYPE atom_based_value = SELECT
      (maths_atom);
   END_TYPE;



   TYPE attribute_type = SELECT
      (label,


       text);
   END_TYPE;



   TYPE axial_geometry_constraint_element = SELECT
      (point,


       line,


       circle,


       plane,


       cylindrical_surface,


       conical_surface,


       spherical_surface,


       toroidal_surface,


       surface_of_revolution,


       sphere,


       right_circular_cone,


       right_circular_cylinder,


       torus,


       revolved_face_solid,


       revolved_area_solid);
   END_TYPE;



   TYPE axis2_placement = SELECT
      (axis2_placement_2d,


       axis2_placement_3d);
   END_TYPE;



   TYPE b_spline_curve_form = ENUMERATION OF
      (polyline_form,


       circular_arc,


       elliptic_arc,


       parabolic_arc,


       hyperbolic_arc,


       unspecified);
   END_TYPE;



   TYPE b_spline_surface_form = ENUMERATION OF
      (plane_surf,


       cylindrical_surf,


       conical_surf,


       spherical_surf,


       toroidal_surf,


       surf_of_revolution,


       ruled_surf,


       generalised_cone,


       quadric_surf,


       surf_of_linear_extrusion,


       unspecified);
   END_TYPE;



   TYPE boolean_operand = SELECT
      (solid_model,


       half_space_solid,


       csg_primitive,


       boolean_result,


       half_space_2d);
   END_TYPE;



   TYPE boolean_operator = ENUMERATION OF
      (union,


       intersection,


       difference);
   END_TYPE;



   TYPE box_characteristic_select = SELECT
      (box_height,


       box_width,


       box_slant_angle,


       box_rotate_angle);
   END_TYPE;



   TYPE box_height = positive_ratio_measure;
   END_TYPE;



   TYPE box_rotate_angle = plane_angle_measure;
   END_TYPE;



   TYPE box_slant_angle = plane_angle_measure;
   END_TYPE;



   TYPE box_width = positive_ratio_measure;
   END_TYPE;



   TYPE celsius_temperature_measure = REAL;
   END_TYPE;



   TYPE certification_assigned_item = SELECT
      (supplied_part_relationship,


       make_from_usage_option,


       product_definition_formation_with_specified_source);
   END_TYPE;



   TYPE change_request_item = SELECT
      (product_definition_formation,


       representation_relationship);
   END_TYPE;



   TYPE character_spacing_select = SELECT
      (length_measure,


       ratio_measure,


       measure_with_unit,


       descriptive_measure);
   END_TYPE;



   TYPE character_style_select = SELECT
      (character_glyph_style_stroke,


       character_glyph_style_outline,


       text_style_for_defined_font);
   END_TYPE;



   TYPE characterized_action_definition = SELECT
      (action,


       action_method,


       action_method_relationship,


       action_relationship);
   END_TYPE;



   TYPE characterized_definition = SELECT
      (characterized_object,


       characterized_product_definition,


       shape_definition);
   END_TYPE;



   TYPE characterized_material_property = SELECT
      (material_property_representation,


       product_material_composition_relationship);
   END_TYPE;



   TYPE characterized_product_definition = SELECT
      (product_definition,


       product_definition_relationship);
   END_TYPE;



   TYPE characterized_resource_definition = SELECT
      (action_resource,


       action_resource_relationship,


       action_resource_requirement,


       action_resource_requirement_relationship);
   END_TYPE;



   TYPE classification_assigned_item = SELECT
      (material_designation,


       requirements_property,


       signal,


       stratum);
   END_TYPE;



   TYPE compound_item_definition = SELECT
      (list_representation_item,


       set_representation_item);
   END_TYPE;



   TYPE configuration_design_item = SELECT
      (product_definition,


       product_definition_formation);
   END_TYPE;



   TYPE context_dependent_measure = REAL;
   END_TYPE;



   TYPE contract_assigned_item = SELECT
      (alternate_product_relationship,


       directed_action,


       product,


       product_definition_formation);
   END_TYPE;



   TYPE count_measure = NUMBER;
   END_TYPE;



   TYPE csg_primitive = SELECT
      (sphere,


       ellipsoid,


       block,


       right_angular_wedge,


       faceted_primitive,


       rectangular_pyramid,


       torus,


       right_circular_cone,


       eccentric_cone,


       right_circular_cylinder,


       cyclide_segment_solid,


       primitive_2d);
   END_TYPE;



   TYPE csg_select = SELECT
      (boolean_result,


       csg_primitive);
   END_TYPE;



   TYPE curve_font_or_scaled_curve_font_select = SELECT
      (curve_style_font_select,


       curve_style_font_and_scaling);
   END_TYPE;



   TYPE curve_on_surface = SELECT
      (pcurve,


       surface_curve,


       composite_curve_on_surface);
   END_TYPE;



   TYPE curve_or_annotation_curve_occurrence = SELECT
      (curve,


       annotation_curve_occurrence);
   END_TYPE;



   TYPE curve_or_render = SELECT
      (curve_style);
   END_TYPE;



   TYPE curve_or_surface_constraint_element = SELECT
      (curve,


       surface);
   END_TYPE;



   TYPE curve_style_font_select = SELECT
      (curve_style_font,


       pre_defined_curve_font,


       externally_defined_curve_font);
   END_TYPE;



   TYPE date_and_time_assigned_item = SELECT
      (approval_person_organization,


       certification,


       change,


       contract,


       directed_action,


       document,


       product_definition,


       rule_action,


       security_classification,


       versioned_action_request);
   END_TYPE;



   TYPE date_assigned_item = SELECT
      (product_definition,


       versioned_action_request,


       directed_action,


       approval_person_organization,


       contract,


       security_classification,


       certification);
   END_TYPE;



   TYPE date_time_or_event_occurrence = SELECT
      (date_time_select);
   END_TYPE;



   TYPE date_time_select = SELECT
      (date,


       local_time,


       date_and_time);
   END_TYPE;



   TYPE day_in_month_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 31);
   END_TYPE;



   TYPE defined_glyph_select = SELECT
      (pre_defined_character_glyph,


       externally_defined_character_glyph);
   END_TYPE;



   TYPE defined_symbol_select = SELECT
      (externally_defined_symbol);
   END_TYPE;



   TYPE derived_property_select = SELECT
      (property_definition,


       action_property,


       resource_property);
   END_TYPE;



   TYPE description_attribute_select = SELECT
      (action_request_solution,


       application_context,


       approval_role,


       configuration_design,


       date_role,


       date_time_role,


       context_dependent_shape_representation,


       effectivity,


       external_source,


       organization_role,


       person_and_organization_role,


       person_and_organization,


       person_role,


       property_definition_representation,


       representation);
   END_TYPE;



   TYPE descriptive_measure = STRING;
   END_TYPE;



   TYPE dimension_count = INTEGER;
   WHERE
      WR1:
         SELF > 0;
   END_TYPE;



   TYPE dimensional_characteristic = SELECT
      (dimensional_location,


       dimensional_size);
   END_TYPE;



   TYPE direction_count_select = SELECT
      (u_direction_count,


       v_direction_count);
   END_TYPE;



   TYPE document_assigned_item = SELECT
      (action_method,


       assembly_component_usage,


       bond_category,


       characterized_object,


       component_definition,


       component_feature,


       component_interface_terminal,


       component_shape_aspect,


       component_terminal,


       coordinated_representation_item,


       configuration_item,


       descriptive_representation_item,


       externally_defined_item,


       functional_unit_terminal_definition,


       inter_stratum_feature,


       interconnect_module_component_surface_feature,


       layer,


       laminate_component_interface_terminal,


       material_designation,


       measure_representation_item,


       package_terminal,


       part_template_definition,


       physical_connectivity_definition,


       physical_connectivity_element,


       product,


       product_definition,


       product_definition_formation,


       product_definition_formation_relationship,


       property_definition,


       representation,


       representation_item,


       requirements_property,


       rule_definition,


       shape_aspect,


       signal,


       stratum,


       stratum_feature);
   END_TYPE;



   TYPE document_identifier_assigned_item = SELECT
      (document);
   END_TYPE;



   TYPE electric_current_measure = REAL;
   END_TYPE;



   TYPE elementary_function_enumerators = ENUMERATION OF
      (ef_and,


       ef_or,


       ef_not,


       ef_xor,


       ef_negate_i,


       ef_add_i,


       ef_subtract_i,


       ef_multiply_i,


       ef_divide_i,


       ef_mod_i,


       ef_exponentiate_i,


       ef_eq_i,


       ef_ne_i,


       ef_gt_i,


       ef_lt_i,


       ef_ge_i,


       ef_le_i,


       ef_abs_i,


       ef_max_i,


       ef_min_i,


       ef_if_i,


       ef_negate_r,


       ef_reciprocal_r,


       ef_add_r,


       ef_subtract_r,


       ef_multiply_r,


       ef_divide_r,


       ef_mod_r,


       ef_exponentiate_r,


       ef_exponentiate_ri,


       ef_eq_r,


       ef_ne_r,


       ef_gt_r,


       ef_lt_r,


       ef_ge_r,


       ef_le_r,


       ef_abs_r,


       ef_max_r,


       ef_min_r,


       ef_acos_r,


       ef_asin_r,


       ef_atan2_r,


       ef_cos_r,


       ef_exp_r,


       ef_ln_r,


       ef_log2_r,


       ef_log10_r,


       ef_sin_r,


       ef_sqrt_r,


       ef_tan_r,


       ef_if_r,


       ef_form_c,


       ef_rpart_c,


       ef_ipart_c,


       ef_negate_c,


       ef_reciprocal_c,


       ef_add_c,


       ef_subtract_c,


       ef_multiply_c,


       ef_divide_c,


       ef_exponentiate_c,


       ef_exponentiate_ci,


       ef_eq_c,


       ef_ne_c,


       ef_conjugate_c,


       ef_abs_c,


       ef_arg_c,


       ef_cos_c,


       ef_exp_c,


       ef_ln_c,


       ef_sin_c,


       ef_sqrt_c,


       ef_tan_c,


       ef_if_c,


       ef_subscript_s,


       ef_eq_s,


       ef_ne_s,


       ef_gt_s,


       ef_lt_s,


       ef_ge_s,


       ef_le_s,


       ef_subsequence_s,


       ef_concat_s,


       ef_size_s,


       ef_format,


       ef_value,


       ef_like,


       ef_if_s,


       ef_subscript_b,


       ef_eq_b,


       ef_ne_b,


       ef_gt_b,


       ef_lt_b,


       ef_ge_b,


       ef_le_b,


       ef_subsequence_b,


       ef_concat_b,


       ef_size_b,


       ef_if_b,


       ef_subscript_t,


       ef_eq_t,


       ef_ne_t,


       ef_concat_t,


       ef_size_t,


       ef_entuple,


       ef_detuple,


       ef_insert,


       ef_remove,


       ef_if_t,


       ef_sum_it,


       ef_product_it,


       ef_add_it,


       ef_subtract_it,


       ef_scalar_mult_it,


       ef_dot_prod_it,


       ef_sum_rt,


       ef_product_rt,


       ef_add_rt,


       ef_subtract_rt,


       ef_scalar_mult_rt,


       ef_dot_prod_rt,


       ef_norm_rt,


       ef_sum_ct,


       ef_product_ct,


       ef_add_ct,


       ef_subtract_ct,


       ef_scalar_mult_ct,


       ef_dot_prod_ct,


       ef_norm_ct,


       ef_if,


       ef_ensemble,


       ef_member_of);
   END_TYPE;



   TYPE elementary_space_enumerators = ENUMERATION OF
      (es_numbers,


       es_complex_numbers,


       es_reals,


       es_integers,


       es_logicals,


       es_booleans,


       es_strings,


       es_binarys,


       es_maths_spaces,


       es_maths_functions,


       es_generics);
   END_TYPE;



   TYPE extension_options = ENUMERATION OF
      (eo_none,


       eo_cont,


       eo_cont_right,


       eo_cont_left);
   END_TYPE;



   TYPE fill_area_style_tile_shape_select = SELECT
      (fill_area_style_tile_curve_with_style,


       fill_area_style_tile_coloured_region,


       fill_area_style_tile_symbol_with_style,


       externally_defined_tile);
   END_TYPE;



   TYPE fill_style_select = SELECT
      (fill_area_style_colour,


       externally_defined_tile_style,


       fill_area_style_tiles,


       externally_defined_hatch_style,


       fill_area_style_hatching);
   END_TYPE;



   TYPE font_select = SELECT
      (pre_defined_text_font,


       externally_defined_text_font);
   END_TYPE;



   TYPE founded_item_select = SELECT
      (founded_item,


       representation_item);
   END_TYPE;



   TYPE frozen_assigned_item = SELECT
      (alternate_product_relationship,


       applied_date_and_time_assignment,


       applied_document_reference,


       applied_group_assignment,


       characterized_object,


       colour,


       component_definition,


       component_shape_aspect,


       composite_curve_segment,


       curve_style,


       curve_style_font,


       curve_style_font_and_scaling,


       dimension_related_tolerance_zone_element,


       dimensional_characteristic_representation,


       dimensional_size,


       document_usage_constraint,


       externally_defined_item,


       fill_area_style,


       fill_area_style_colour,


       geometric_tolerance,


       geometric_tolerance_relationship,


       group,


       inter_stratum_feature,


       material_designation,


       measure_with_unit,


       plus_minus_tolerance,


       pre_defined_item,


       product_concept,


       product_definition_formation_relationship,


       product_definition_relationship,


       property_definition,


       property_definition_relationship,


       property_definition_representation,


       representation,


       representation_context,


       representation_item,


       representation_relationship,


       runout_zone_orientation,


       shape_aspect,


       shape_aspect_relationship,


       stratum_feature,


       tolerance_value,


       tolerance_zone_form);
   END_TYPE;



   TYPE geometric_constraint_element = SELECT
      (point,


       curve,


       surface,


       vector,


       direction);
   END_TYPE;



   TYPE geometric_set_select = SELECT
      (point,


       curve,


       surface);
   END_TYPE;



   TYPE group_assigned_item = SELECT
      (assembly_bond_definition,


       design_object,


       component_definition,


       component_feature,


       component_interface_terminal,


       component_shape_aspect,


       component_terminal,


       compound_representation_item,


       configuration_item,


       inter_stratum_feature,


       laminate_component_interface_terminal,


       printed_part_template_terminal,


       product,


       product_definition_formation,


       property_definition_representation,


       representation,


       representation_item,


       requirements_property,


       rule_definition,


       shape_aspect,


       shape_aspect_relationship,


       stratum,


       stratum_feature,


       stratum_surface);
   END_TYPE;



   TYPE hiding_or_blanking_select = SELECT
      (annotation_fill_area,


       character_glyph_symbol_outline);
   END_TYPE;



   TYPE hour_in_day = INTEGER;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF < 24);
   END_TYPE;



   TYPE id_attribute_select = SELECT
      (action,


       address,


       product_category,


       property_definition,


       shape_aspect,


       shape_aspect_relationship,


       application_context,


       group,


       organizational_project,


       representation);
   END_TYPE;



   TYPE identification_item = SELECT
      (characterized_product_category,


       configuration_item,


       material_designation,


       person_and_organization,


       product,


       product_concept,


       product_definition_formation,


       organization);
   END_TYPE;



   TYPE identifier = STRING;
   END_TYPE;



   TYPE input_selector = positive_integer;
   END_TYPE;



   TYPE invisibility_context = SELECT
      (presentation_representation);
   END_TYPE;



   TYPE invisible_item = SELECT
      (styled_item,


       representation);
   END_TYPE;



   TYPE knot_type = ENUMERATION OF
      (uniform_knots,


       quasi_uniform_knots,


       piecewise_bezier_knots,


       unspecified);
   END_TYPE;



   TYPE label = STRING;
   END_TYPE;



   TYPE layered_item = SELECT
      (presentation_representation,


       representation_item);
   END_TYPE;



   TYPE length_measure = REAL;
   END_TYPE;



   TYPE limit_condition = ENUMERATION OF
      (maximum_material_condition,


       least_material_condition,


       regardless_of_feature_size);
   END_TYPE;



   TYPE linear_geometry_constraint_element = SELECT
      (line,


       plane,


       direction,


       vector);
   END_TYPE;



   TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
   END_TYPE;



   TYPE list_representation_item = LIST [1:?] OF representation_item;
   END_TYPE;



   TYPE lower_upper = ENUMERATION OF
      (lower,


       upper);
   END_TYPE;



   TYPE luminous_intensity_measure = REAL;
   END_TYPE;



   TYPE managed_design_object = SELECT
      (action,


       alternate_product_relationship,


       applied_approval_assignment,


       applied_date_and_time_assignment,


       applied_document_reference,


       applied_group_assignment,


       approval,


       approval_status,


       certification,


       characterized_object,


       colour,


       composite_curve_segment,


       configuration_effectivity,


       configuration_item,


       contract,


       curve_style,


       curve_style_font,


       curve_style_font_and_scaling,


       date,


       dimension_related_tolerance_zone_element,


       dimensional_characteristic_representation,


       dimensional_size,


       document,


       document_usage_constraint,


       externally_defined_item,


       fill_area_style,


       fill_area_style_colour,


       geometric_tolerance,


       geometric_tolerance_relationship,


       group,


       layer_connection_point,


       material_designation,


       measure_with_unit,


       organization,


       person,


       person_and_organization,


       plus_minus_tolerance,


       pre_defined_item,


       product,


       product_concept,


       product_definition,


       product_definition_formation,


       product_definition_formation_relationship,


       product_definition_relationship,


       property_definition,


       property_definition_relationship,


       property_definition_representation,


       representation,


       representation_context,


       representation_item,


       representation_relationship,


       runout_zone_orientation,


       security_classification,


       shape_aspect,


       shape_aspect_relationship,


       tolerance_value,


       tolerance_zone_form,


       versioned_action_request);
   END_TYPE;



   TYPE mass_measure = REAL;
   END_TYPE;



   TYPE maths_atom = SELECT
      (maths_simple_atom,


       maths_enum_atom);
   END_TYPE;



   TYPE maths_binary = BINARY;
   END_TYPE;



   TYPE maths_boolean = BOOLEAN;
   END_TYPE;



   TYPE maths_enum_atom = SELECT
      (elementary_space_enumerators,


       ordering_type,


       lower_upper,


       symmetry_type,


       elementary_function_enumerators,


       open_closed,


       space_constraint_type,


       repackage_options,


       extension_options);
   END_TYPE;



   TYPE maths_expression = SELECT
      (atom_based_value,


       maths_tuple,


       generic_expression);
   END_TYPE;



   TYPE maths_function_select = SELECT
      (maths_function,


       elementary_function_enumerators);
   END_TYPE;



   TYPE maths_integer = INTEGER;
   END_TYPE;



   TYPE maths_logical = LOGICAL;
   END_TYPE;



   TYPE maths_number = NUMBER;
   END_TYPE;



   TYPE maths_real = REAL;
   END_TYPE;



   TYPE maths_simple_atom = SELECT
      (maths_number,


       maths_real,


       maths_logical,


       maths_boolean,


       maths_string,


       maths_binary);
   END_TYPE;



   TYPE maths_space_or_function = SELECT
      (maths_space,


       maths_function);
   END_TYPE;



   TYPE maths_string = STRING;
   END_TYPE;



   TYPE maths_tuple = LIST [0:?] OF maths_value;
   END_TYPE;



   TYPE maths_value = SELECT
      (atom_based_value,


       maths_tuple,


       generic_expression);
   WHERE
      constancy:
         NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR expression_is_constant(SELF);
   END_TYPE;



   TYPE measure_value = SELECT
      (length_measure,


       mass_measure,


       time_measure,


       electric_current_measure,


       thermodynamic_temperature_measure,


       celsius_temperature_measure,


       amount_of_substance_measure,


       luminous_intensity_measure,


       plane_angle_measure,


       solid_angle_measure,


       area_measure,


       volume_measure,


       ratio_measure,


       parameter_value,


       numeric_measure,


       context_dependent_measure,


       descriptive_measure,


       positive_length_measure,


       positive_plane_angle_measure,


       positive_ratio_measure,


       count_measure);
   END_TYPE;



   TYPE minute_in_hour = INTEGER;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF <= 59);
   END_TYPE;



   TYPE model_parameter_assigned_item = SELECT
      (unit);
   END_TYPE;



   TYPE month_in_year_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 12);
   END_TYPE;



   TYPE name_attribute_select = SELECT
      (action_request_solution,


       address,


       configuration_design,


       context_dependent_shape_representation,


       derived_unit,


       effectivity,


       person_and_organization,


       product_definition,


       property_definition_representation);
   END_TYPE;



   TYPE nonnegative_integer = INTEGER;
   WHERE
      nonnegativity:
         SELF >= 0;
   END_TYPE;



   TYPE numeric_measure = NUMBER;
   END_TYPE;



   TYPE one_or_two = positive_integer;
   WHERE
      in_range:
         (SELF = 1) OR (SELF = 2);
   END_TYPE;



   TYPE open_closed = ENUMERATION OF
      (open,


       closed);
   END_TYPE;



   TYPE ordering_type = ENUMERATION OF
      (by_rows,


       by_columns);
   END_TYPE;



   TYPE organization_assigned_item = SELECT
      (applied_identification_assignment,


       configuration_item,


       contract,


       directed_action,


       document,


       versioned_action_request,


       product,


       product_definition,


       product_definition_formation,


       product_definition_formation_with_specified_source,


       rule_definition,


       representation,


       security_classification);
   END_TYPE;



   TYPE owner_assigned_item = SELECT
      (alternate_product_relationship,


       characterized_object,


       colour,


       component_definition,


       component_shape_aspect,


       composite_curve_segment,


       curve_style,


       curve_style_font,


       curve_style_font_and_scaling,


       dimension_related_tolerance_zone_element,


       dimensional_characteristic_representation,


       dimensional_size,


       document_usage_constraint,


       externally_defined_item,


       fill_area_style,


       fill_area_style_colour,


       geometric_tolerance,


       geometric_tolerance_relationship,


       group,


       inter_stratum_feature,


       material_designation,


       measure_with_unit,


       plus_minus_tolerance,


       pre_defined_item,


       product_concept,


       product_definition_formation_relationship,


       product_definition_relationship,


       property_definition,


       property_definition_relationship,


       property_definition_representation,


       representation,


       representation_context,


       representation_item,


       representation_relationship,


       runout_zone_orientation,


       shape_aspect,


       shape_aspect_relationship,


       stratum_feature,


       tolerance_value,


       tolerance_zone_form);
   END_TYPE;



   TYPE parameter_value = REAL;
   END_TYPE;



   TYPE pcurve_or_surface = SELECT
      (pcurve,


       surface);
   END_TYPE;



   TYPE person_and_organization_assigned_item = SELECT
      (change,


       configuration_item,


       contract,


       document,


       product,


       product_definition_formation,


       product_definition,


       directed_action,


       rule_action,


       security_classification,


       versioned_action_request);
   END_TYPE;



   TYPE person_assigned_item = SELECT
      (document);
   END_TYPE;



   TYPE person_organization_select = SELECT
      (person,


       organization,


       person_and_organization);
   END_TYPE;



   TYPE plane_angle_measure = REAL;
   END_TYPE;



   TYPE point_curve_or_surface_constraint_element = SELECT
      (point,


       curve,


       surface);
   END_TYPE;



   TYPE positive_integer = nonnegative_integer;
   WHERE
      positivity:
         SELF > 0;
   END_TYPE;



   TYPE positive_length_measure = length_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE positive_plane_angle_measure = plane_angle_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE positive_ratio_measure = ratio_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE preferred_surface_curve_representation = ENUMERATION OF
      (curve_3d,


       pcurve_s1,


       pcurve_s2);
   END_TYPE;



   TYPE presentable_text = STRING;
   END_TYPE;



   TYPE presentation_representation_select = SELECT
      (presentation_representation);
   END_TYPE;



   TYPE presentation_style_select = SELECT
      (curve_style,


       surface_style_usage,


       fill_area_style,


       text_style,


       externally_defined_style);
   END_TYPE;



   TYPE process_or_process_relationship = SELECT
      (relationship_with_condition);
   END_TYPE;



   TYPE product_or_formation_or_definition = SELECT
      (product,


       product_definition_formation,


       product_definition);
   END_TYPE;



   TYPE product_space = SELECT
      (uniform_product_space,


       listed_product_space);
   END_TYPE;



   TYPE promissory_usage_in_product_model_assigned_item = SELECT
      (product_concept,


       product_definition);
   END_TYPE;



   TYPE property_distribution_select = SELECT
      (action_property,


       general_property_relationship,


       property_definition,


       resource_property);
   END_TYPE;



   TYPE property_or_shape_select = SELECT
      (property_definition,


       shape_definition);
   END_TYPE;



   TYPE radial_geometry_constraint_element = SELECT
      (circle,


       cylindrical_surface,


       conical_surface,


       spherical_surface,


       right_circular_cylinder,


       right_circular_cone,


       sphere);
   END_TYPE;



   TYPE ratio_measure = REAL;
   END_TYPE;



   TYPE real_interval = SELECT
      (real_interval_from_min,


       real_interval_to_max,


       finite_real_interval,


       elementary_space);
   WHERE
      WR1:
         NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR (SELF\elementary_space.space_id = es_reals);
   END_TYPE;



   TYPE relationship_with_condition = SELECT
      (action_method_relationship,


       action_relationship);
   END_TYPE;



   TYPE repackage_options = ENUMERATION OF
      (ro_nochange,


       ro_wrap_as_tuple,


       ro_unwrap_tuple);
   END_TYPE;



   TYPE replacement_from_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE replacement_to_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE represented_definition = SELECT
      (general_property,


       property_definition,


       property_definition_relationship,


       shape_aspect,


       shape_aspect_relationship);
   END_TYPE;



   TYPE reversible_topology = SELECT
      (reversible_topology_item,


       list_of_reversible_topology_item,


       set_of_reversible_topology_item);
   END_TYPE;



   TYPE reversible_topology_item = SELECT
      (edge,


       path,


       face,


       face_bound,


       closed_shell,


       open_shell);
   END_TYPE;



   TYPE role_select = SELECT
      (action_assignment,


       action_request_assignment,


       approval_assignment,


       approval_date_time,


       certification_assignment,


       contract_assignment,


       document_reference,


       effectivity_assignment,


       group_assignment,


       security_classification_assignment);
   END_TYPE;



   TYPE second_in_minute = REAL;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF <= 60.0000);
   END_TYPE;



   TYPE security_classification_assigned_item = SELECT
      (applied_promissory_usage_in_product_model_assignment,


       assembly_component_usage,


       document,


       make_from_usage_option,


       product_definition_formation,


       product_definition);
   END_TYPE;



   TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
   END_TYPE;



   TYPE set_representation_item = SET [1:?] OF representation_item;
   END_TYPE;



   TYPE shading_surface_method = ENUMERATION OF
      (constant_shading,


       colour_shading,


       dot_shading,


       normal_shading);
   END_TYPE;



   TYPE shape_definition = SELECT
      (product_definition_shape,


       shape_aspect,


       shape_aspect_relationship);
   END_TYPE;



   TYPE shell = SELECT
      (vertex_shell,


       wire_shell,


       open_shell,


       closed_shell);
   END_TYPE;



   TYPE si_prefix = ENUMERATION OF
      (exa,


       peta,


       tera,


       giga,


       mega,


       kilo,


       hecto,


       deca,


       deci,


       centi,


       milli,


       micro,


       nano,


       pico,


       femto,


       atto);
   END_TYPE;



   TYPE si_unit_name = ENUMERATION OF
      (metre,


       gram,


       second,


       ampere,


       kelvin,


       mole,


       candela,


       radian,


       steradian,


       hertz,


       newton,


       pascal,


       joule,


       watt,


       coulomb,


       volt,


       farad,


       ohm,


       siemens,


       weber,


       tesla,


       henry,


       degree_Celsius,


       lumen,


       lux,


       becquerel,


       gray,


       sievert);
   END_TYPE;



   TYPE size_select = SELECT
      (positive_length_measure,


       measure_with_unit,


       descriptive_measure);
   END_TYPE;



   TYPE solid_angle_measure = REAL;
   END_TYPE;



   TYPE source = ENUMERATION OF
      (made,


       bought,


       not_known);
   END_TYPE;



   TYPE source_item = SELECT
      (identifier);
   END_TYPE;



   TYPE space_constraint_type = ENUMERATION OF
      (sc_equal,


       sc_subspace,


       sc_member);
   END_TYPE;



   TYPE space_context_select = SELECT
      (action,


       action_method,


       general_property,


       product_definition,


       representation_item,


       shape_aspect);
   END_TYPE;



   TYPE squared_or_rounded = ENUMERATION OF
      (squared,


       rounded);
   END_TYPE;



   TYPE start_request_item = SELECT
      (product_definition_formation,


       representation_relationship);
   END_TYPE;



   TYPE style_context_select = SELECT
      (group,


       representation,


       representation_item);
   END_TYPE;



   TYPE supported_item = SELECT
      (action_directive,


       action,


       action_method);
   END_TYPE;



   TYPE surface_boundary = SELECT
      (boundary_curve,


       degenerate_pcurve);
   END_TYPE;



   TYPE surface_model = SELECT
      (shell_based_surface_model);
   END_TYPE;



   TYPE surface_or_solid_model = SELECT
      (surface_model,


       solid_model);
   END_TYPE;



   TYPE surface_side = ENUMERATION OF
      (positive,


       negative,


       both);
   END_TYPE;



   TYPE surface_side_style_select = SELECT
      (surface_side_style,


       pre_defined_surface_side_style);
   END_TYPE;



   TYPE surface_style_element_select = SELECT
      (surface_style_fill_area,


       surface_style_boundary,


       surface_style_silhouette,


       surface_style_segmentation_curve,


       surface_style_control_grid,


       surface_style_parameter_line,


       surface_style_rendering);
   END_TYPE;



   TYPE swept_surface_or_solid = SELECT
      (swept_surface,


       swept_face_solid,


       swept_area_solid);
   END_TYPE;



   TYPE symmetry_type = ENUMERATION OF
      (identity,


       skew,


       hermitian,


       skew_hermitian);
   END_TYPE;



   TYPE text = STRING;
   END_TYPE;



   TYPE text_alignment = label;
   END_TYPE;



   TYPE text_or_character = SELECT
      (annotation_text,


       annotation_text_character,


       defined_character_glyph,


       composite_text,


       text_literal);
   END_TYPE;



   TYPE text_path = ENUMERATION OF
      (left,


       right,


       up,


       down);
   END_TYPE;



   TYPE thermodynamic_temperature_measure = REAL;
   END_TYPE;



   TYPE time_measure = REAL;
   END_TYPE;



   TYPE tolerance_method_definition = SELECT
      (tolerance_value);
   END_TYPE;



   TYPE tolerance_select = SELECT
      (geometric_tolerance,


       plus_minus_tolerance);
   END_TYPE;



   TYPE transformation = SELECT
      (item_defined_transformation,


       functionally_defined_transformation);
   END_TYPE;



   TYPE transition_code = ENUMERATION OF
      (discontinuous,


       continuous,


       cont_same_gradient,


       cont_same_gradient_same_curvature);
   END_TYPE;



   TYPE trimming_preference = ENUMERATION OF
      (cartesian,


       parameter,


       unspecified);
   END_TYPE;



   TYPE trimming_select = SELECT
      (cartesian_point,


       parameter_value);
   END_TYPE;



   TYPE tuple_space = SELECT
      (product_space,


       extended_tuple_space);
   END_TYPE;



   TYPE u_direction_count = INTEGER;
   WHERE
      WR1:
         SELF > 1;
   END_TYPE;



   TYPE unit = SELECT
      (named_unit,


       derived_unit);
   END_TYPE;



   TYPE v_direction_count = INTEGER;
   WHERE
      WR1:
         SELF > 1;
   END_TYPE;



   TYPE value_context_select = SELECT
      (action,


       action_method,


       general_property,


       product_definition,


       representation_item,


       shape_aspect);
   END_TYPE;



   TYPE value_qualifier = SELECT
      (precision_qualifier,


       type_qualifier,


       uncertainty_qualifier);
   END_TYPE;



   TYPE vector_or_direction = SELECT
      (vector,


       direction);
   END_TYPE;



   TYPE volume_measure = REAL;
   END_TYPE;



   TYPE wireframe_model = SELECT
      (shell_based_wireframe_model,


       edge_based_wireframe_model);
   END_TYPE;



   TYPE work_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE year_number = INTEGER;
   END_TYPE;



   TYPE zero_or_one = nonnegative_integer;
   WHERE
      in_range:
         (SELF = 0) OR (SELF = 1);
   END_TYPE;


(* ***********************************
Functions in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   FUNCTION acyclic
      (arg1 : generic_expression;
       arg2 : SET OF generic_expression ) : BOOLEAN;
   LOCAL
      result : BOOLEAN;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SIMPLE_GENERIC_EXPRESSION' IN TYPEOF(arg1) THEN
         RETURN (TRUE);
      END_IF;
      IF arg1 IN arg2 THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg1) THEN
         RETURN (acyclic(arg1\unary_generic_expression.operand,

 arg2 + [ arg1 ]));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg1) THEN
         RETURN (acyclic(arg1\binary_generic_expression.operands[1],

 (arg2 + [ arg1 ])) AND acyclic(arg1\binary_generic_expression.operands[2],

 (arg2 + [ arg1 ])));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg1) THEN
         result := TRUE;
         REPEAT i := 1 TO SIZEOF(arg1\multiple_arity_generic_expression.operands);
            result := result AND acyclic(arg1\multiple_arity_generic_expression.operands[i],

 (arg2 + [ arg1 ]));
         END_REPEAT;
         RETURN (result);
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_composite_text
      (start_composite : composite_text;
       child_text : SET [1:?] OF text_or_character ) : LOGICAL;
   LOCAL
      i : INTEGER;
      local_composite_text : SET [0:?] OF composite_text;
      local_annotation_text : SET [0:?] OF annotation_text;
      local_children : SET [0:?] OF text_or_character;
   END_LOCAL;
      local_composite_text := QUERY (child <* child_text| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT' IN TYPEOF(child));
      IF SIZEOF(local_composite_text) > 0 THEN
         REPEAT i := 1 TO HIINDEX(local_composite_text);
            IF start_composite :=: local_composite_text[i] THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      local_children := child_text;
      IF SIZEOF(local_composite_text) > 0 THEN
         REPEAT i := 1 TO HIINDEX(local_composite_text);
            local_children := local_children + local_composite_text[i].collected_text;
         END_REPEAT;
      END_IF;
      local_annotation_text := QUERY (child <* child_text| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT' IN TYPEOF(child));
      IF SIZEOF(local_annotation_text) > 0 THEN
         REPEAT i := 1 TO HIINDEX(local_annotation_text);
            local_children := local_children + QUERY (item <* local_annotation_text[i]\mapped_item.mapping_source.mapped_representation.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT' ] * TYPEOF(item)) > 0));
         END_REPEAT;
      END_IF;
      IF local_children :<>: child_text THEN
         RETURN (acyclic_composite_text(start_composite,

 local_children));
      ELSE
         RETURN (TRUE);
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_curve_replica
      (rep : curve_replica;
       parent : curve ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_curve_replica(rep,

 parent\curve_replica.parent_curve));
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_mapped_representation
      (parent_set : SET OF representation;
       children_set : SET OF representation_item ) : BOOLEAN;
   LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
   END_LOCAL;
      x := QUERY (z <* children_set| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(z));
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            IF x[i]\mapped_item.mapping_source.mapped_representation IN parent_set THEN
               RETURN (FALSE);
            END_IF;
            IF NOT acyclic_mapped_representation((parent_set + x[i]\mapped_item.mapping_source.mapped_representation),

 x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      x := children_set - x;
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            y := QUERY (z <* bag_to_set(USEDIN(x[i],

 ''))| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z));
            IF NOT acyclic_mapped_representation(parent_set,

 y) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_point_replica
      (rep : point_replica;
       parent : point ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_point_replica(rep,

 parent\point_replica.parent_pt));
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_product_category_relationship
      (relation : product_category_relationship;
       children : SET OF product_category ) : BOOLEAN;
   LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(children);
         IF relation.category :=: children[i] THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      x := bag_to_set(USEDIN(relation.category,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
      local_children := children + relation.category;
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            IF NOT acyclic_product_category_relationship(x[i],

 local_children) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_product_definition_relationship
      (relation : product_definition_relationship;
       relatives : SET [1:?] OF product_definition;
       specific_relation : STRING ) : BOOLEAN;
   LOCAL
      x : SET OF product_definition_relationship;
   END_LOCAL;
      IF relation.relating_product_definition IN relatives THEN
         RETURN (FALSE);
      END_IF;
      x := QUERY (pd <* bag_to_set(USEDIN(relation.relating_product_definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))| specific_relation IN TYPEOF(pd));
      REPEAT i := 1 TO HIINDEX(x);
         IF NOT acyclic_product_definition_relationship(x[i],

 (relatives + relation.relating_product_definition),

 specific_relation) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_shape_aspect_relationship
      (relation : shape_aspect_relationship;
       relatives : SET [1:?] OF shape_aspect;
       specific_relation : STRING ) : BOOLEAN;
   LOCAL
      x : SET OF shape_aspect_relationship;
   END_LOCAL;
      IF relation.relating_shape_aspect IN relatives THEN
         RETURN (FALSE);
      END_IF;
      x := QUERY (sa <* bag_to_set(USEDIN(relation.relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT'))| specific_relation IN TYPEOF(sa));
      REPEAT i := 1 TO HIINDEX(x);
         IF NOT acyclic_shape_aspect_relationship(x[i],

 (relatives + relation.relating_shape_aspect),

 specific_relation) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_solid_replica
      (rep : solid_replica;
       parent : solid_model ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_solid_replica(rep,

 parent\solid_replica.parent_solid));
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_surface_replica
      (rep : surface_replica;
       parent : surface ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_surface_replica(rep,

 parent\surface_replica.parent_surface));
      END_IF;
   END_FUNCTION;



   FUNCTION advanced_face_properties
      (testface : face ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(testface) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(testface) THEN
         RETURN (advanced_face_properties(testface.parent_face));
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION all_members_of_es
      (sv : SET OF maths_value;
       es : elementary_space_enumerators ) : LOGICAL;
   CONSTANT
      base_types : SET OF STRING := [ 'NUMBER',

 'COMPLEX_NUMBER_LITERAL',

 'REAL',

 'INTEGER',

 'LOGICAL',

 'BOOLEAN',

 'STRING',

 'BINARY',

 'MATHS_SPACE',

 'MATHS_FUNCTION',

 'LIST',

 'ELEMENTARY_SPACE_ENUMERATORS',

 'ORDERING_TYPE',

 'LOWER_UPPER',

 'SYMMETRY_TYPE',

 'ELEMENTARY_FUNCTION_ENUMERATORS',

 'OPEN_CLOSED',

 'SPACE_CONSTRAINT_TYPE',

 'REPACKAGE_OPTIONS',

 'EXTENSION_OPTIONS' ];
   END_CONSTANT;
   LOCAL
      v : maths_value;
      key_type : STRING := '';
      types : SET OF STRING;
      ge : generic_expression;
      cum : LOGICAL := TRUE;
      vspc : maths_space;
   END_LOCAL;
      IF NOT EXISTS(sv) OR NOT EXISTS(es) THEN
         RETURN (FALSE);
      END_IF;
      CASE es OF
         es_numbers :
               key_type := 'NUMBER';
         es_complex_numbers :
               key_type := 'COMPLEX_NUMBER_LITERAL';
         es_reals :
               key_type := 'REAL';
         es_integers :
               key_type := 'INTEGER';
         es_logicals :
               key_type := 'LOGICAL';
         es_booleans :
               key_type := 'BOOLEAN';
         es_strings :
               key_type := 'STRING';
         es_binarys :
               key_type := 'BINARY';
         es_maths_spaces :
               key_type := 'MATHS_SPACE';
         es_maths_functions :
               key_type := 'MATHS_FUNCTION';
         es_generics :
               RETURN (TRUE);
      END_CASE;
      REPEAT i := 1 TO SIZEOF(sv);
         IF NOT EXISTS(sv[i]) THEN
            RETURN (FALSE);
         END_IF;
         v := simplify_maths_value(sv[i]);
         types := stripped_typeof(v);
         IF key_type IN types THEN
            SKIP;
         END_IF;
         IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN
            SKIP;
         END_IF;
         IF SIZEOF(base_types * types) > 0 THEN
            RETURN (FALSE);
         END_IF;
         ge := v;
         IF has_values_space(ge) THEN
            vspc := values_space_of(ge);
            IF NOT subspace_of_es(vspc,

 es) THEN
               IF NOT compatible_spaces(vspc,

 make_elementary_space(es)) THEN
                  RETURN (FALSE);
               END_IF;
               cum := UNKNOWN;
            END_IF;
         ELSE
            cum := UNKNOWN;
         END_IF;
         IF cum = FALSE THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (cum);
   END_FUNCTION;



   FUNCTION any_space_satisfies
      (sc : space_constraint_type;
       spc : maths_space ) : BOOLEAN;
   LOCAL
      spc_id : elementary_space_enumerators;
   END_LOCAL;
      IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
         RETURN (FALSE);
      END_IF;
      spc_id := spc\elementary_space.space_id;
      IF sc = sc_subspace THEN
         RETURN (bool(spc_id = es_generics));
      END_IF;
      IF sc = sc_member THEN
         RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION applied_date_correlation
      (e : applied_date_assignment;
       schema_name : STRING ) : BOOLEAN;
   LOCAL
      d_role : STRING;
   END_LOCAL;
      d_role := e\date_assignment.role\date_role.name;
      CASE d_role OF
         'creation date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.PRODUCT_DEFINITION'),

 (schema_name + '.DOCUMENT') ] * TYPEOF(x)) >= 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'request date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.VERSIONED_ACTION_REQUEST' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'release date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),

 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'start date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),

 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'sign off date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.APPROVAL_PERSON_ORGANIZATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'contract date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CONTRACT' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'certification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CERTIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'classification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'declassification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
      OTHERWISE :
            RETURN (TRUE);
      END_CASE;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION applied_date_time_correlation
      (e : applied_date_and_time_assignment;
       schema_name : STRING ) : BOOLEAN;
   LOCAL
      dt_role : STRING;
   END_LOCAL;
      dt_role := e\date_and_time_assignment.role\date_time_role.name;
      CASE dt_role OF
         'creation date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.PRODUCT_DEFINITION'),

 (schema_name + '.DOCUMENT') ] * TYPEOF(x)) >= 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'request date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.VERSIONED_ACTION_REQUEST' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'release date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),

 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'start date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),

 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'sign off date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.APPROVAL_PERSON_ORGANIZATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'contract date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CONTRACT' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'certification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CERTIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'classification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'declassification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'participant date and time' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.RULE_ACTION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
      OTHERWISE :
            RETURN (TRUE);
      END_CASE;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION assoc_product_space
      (ts1 : tuple_space;
       ts2 : tuple_space ) : tuple_space;
   LOCAL
      types1 : SET OF STRING := stripped_typeof(ts1);
      types2 : SET OF STRING := stripped_typeof(ts2);
      up1 : uniform_product_space := make_uniform_product_space(the_reals,

 1);
      up2 : uniform_product_space := make_uniform_product_space(the_reals,

 1);
      lp1 : listed_product_space := the_zero_tuple_space;
      lp2 : listed_product_space := the_zero_tuple_space;
      lps : listed_product_space := the_zero_tuple_space;
      et1 : extended_tuple_space := the_tuples;
      et2 : extended_tuple_space := the_tuples;
      ets : extended_tuple_space := the_tuples;
      use_up1 : BOOLEAN;
      use_up2 : BOOLEAN;
      use_lp1 : BOOLEAN;
      use_lp2 : BOOLEAN;
      factors : LIST OF maths_space := [];
      tspace : tuple_space;
   END_LOCAL;
      IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
         up1 := ts1;
         use_up1 := TRUE;
         use_lp1 := TRUE;
      ELSE
         IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
            lp1 := ts1;
            use_up1 := TRUE;
            use_lp1 := TRUE;
         ELSE
            IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
               RETURN (?);
            END_IF;
            et1 := ts1;
            use_up1 := TRUE;
            use_lp1 := TRUE;
         END_IF;
      END_IF;
      IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
         up2 := ts2;
         use_up2 := TRUE;
         use_lp2 := TRUE;
      ELSE
         IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
            lp2 := ts2;
            use_up2 := TRUE;
            use_lp2 := TRUE;
         ELSE
            IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
               RETURN (?);
            END_IF;
            et2 := ts2;
            use_up2 := TRUE;
            use_lp2 := TRUE;
         END_IF;
      END_IF;
      IF use_up1 THEN
         IF use_up2 THEN
            IF up1.base = up2.base THEN
               tspace := make_uniform_product_space(up1.base,

 up1.exponent + up2.exponent);
            ELSE
               factors := [ up1.base,

 up2.base ];
               tspace := make_listed_product_space(factors);
            END_IF;
         ELSE
            IF use_lp2 THEN
               factors := [ up1.base ];
               factors := factors + lp2.factors;
               tspace := make_listed_product_space(factors);
            ELSE
               tspace := assoc_product_space(up1,

 et2.base);
               tspace := make_extended_tuple_space(tspace,

 et2.extender);
            END_IF;
         END_IF;
      ELSE
         IF use_lp1 THEN
            IF use_up2 THEN
               factors := [ up2.base ];
               factors := lp1.factors + factors;
               tspace := make_listed_product_space(factors);
            ELSE
               IF use_lp2 THEN
                  tspace := make_listed_product_space(lp1.factors + lp2.factors);
               ELSE
                  tspace := assoc_product_space(lp1,

 et2.base);
                  tspace := make_extended_tuple_space(tspace,

 et2.extender);
               END_IF;
            END_IF;
         ELSE
            IF use_up2 THEN
               IF et1.extender = up2.base THEN
                  tspace := assoc_product_space(et1.base,

 up2);
                  tspace := make_extended_tuple_space(tspace,

 et1.extender);
               ELSE
                  RETURN (?);
               END_IF;
            ELSE
               IF use_lp2 THEN
                  factors := lp2.factors;
                  REPEAT i := 1 TO SIZEOF(factors);
                     IF et1.extender <> factors[i] THEN
                        RETURN (?);
                     END_IF;
                  END_REPEAT;
                  tspace := assoc_product_space(et1.base,

 lp2);
                  tspace := make_extended_tuple_space(tspace,

 et1.extender);
               ELSE
                  IF et1.extender = et2.extender THEN
                     tspace := assoc_product_space(et1,

 et2.base);
                  ELSE
                     RETURN (?);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (tspace);
   END_FUNCTION;



   FUNCTION associated_surface
      (arg : pcurve_or_surface ) : surface;
   LOCAL
      surf : surface;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(arg) THEN
         surf := arg.basis_surface;
      ELSE
         surf := arg;
      END_IF;
      RETURN (surf);
   END_FUNCTION;



   FUNCTION atan2
      (y : REAL;
       x : REAL ) : REAL;
   LOCAL
      r : REAL;
   END_LOCAL;
      IF (y = 0.00000) AND (x = 0.00000) THEN
         RETURN (?);
      END_IF;
      r := atan(y,

 x);
      IF x < 0.00000 THEN
         IF y < 0.00000 THEN
            r := r - 3.14159;
         ELSE
            r := r + 3.14159;
         END_IF;
      END_IF;
      RETURN (r);
   END_FUNCTION;



   FUNCTION bag_to_set
      (the_bag : BAG OF GENERIC : intype ) : SET OF GENERIC : intype;
   LOCAL
      the_set : SET OF GENERIC : intype := [];
      i : INTEGER;
   END_LOCAL;
      IF SIZEOF(the_bag) > 0 THEN
         REPEAT i := 1 TO HIINDEX(the_bag);
            the_set := the_set + the_bag[i];
         END_REPEAT;
      END_IF;
      RETURN (the_set);
   END_FUNCTION;



   FUNCTION base_axis
      (dim : INTEGER;
       axis1 : direction;
       axis2 : direction;
       axis3 : direction ) : LIST [2:3] OF direction;
   LOCAL
      u : LIST [2:3] OF direction;
      factor : REAL;
      d1 : direction;
      d2 : direction;
   END_LOCAL;
      IF dim = 3 THEN
         d1 := NVL(normalise(axis3),

 dummy_gri || direction([ 0.00000,

 0.00000,

 1.00000 ]));
         d2 := first_proj_axis(d1,

 axis1);
         u := [ d2,

 second_proj_axis(d1,

 d2,

 axis2),

 d1 ];
      ELSE
         IF EXISTS(axis1) THEN
            d1 := normalise(axis1);
            u := [ d1,

 orthogonal_complement(d1) ];
            IF EXISTS(axis2) THEN
               factor := dot_product(axis2,

 u[2]);
               IF factor < 0.00000 THEN
                  u[2].direction_ratios[1] := -u[2].direction_ratios[1];
                  u[2].direction_ratios[2] := -u[2].direction_ratios[2];
               END_IF;
            END_IF;
         ELSE
            IF EXISTS(axis2) THEN
               d1 := normalise(axis2);
               u := [ orthogonal_complement(d1),

 d1 ];
               u[1].direction_ratios[1] := -u[1].direction_ratios[1];
               u[1].direction_ratios[2] := -u[1].direction_ratios[2];
            ELSE
               u := [ dummy_gri || direction([ 1.00000,

 0.00000 ]),

 dummy_gri || direction([ 0.00000,

 1.00000 ]) ];
            END_IF;
         END_IF;
      END_IF;
      RETURN (u);
   END_FUNCTION;



   FUNCTION bool
      (lgcl : LOGICAL ) : BOOLEAN;
      IF NOT EXISTS(lgcl) THEN
         RETURN (FALSE);
      END_IF;
      IF lgcl <> TRUE THEN
         RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION boolean_choose
      (b : BOOLEAN;
       choice1 : GENERIC : item;
       choice2 : GENERIC : item ) : GENERIC : item;
      IF b THEN
         RETURN (choice1);
      ELSE
         RETURN (choice2);
      END_IF;
   END_FUNCTION;



   FUNCTION build_2axes
      (ref_direction : direction ) : LIST [2:2] OF direction;
   LOCAL
      d : direction := NVL(normalise(ref_direction),

 dummy_gri || direction([ 1.00000,

 0.00000 ]));
   END_LOCAL;
      RETURN ([ d,

 orthogonal_complement(d) ]);
   END_FUNCTION;



   FUNCTION build_axes
      (axis : direction;
       ref_direction : direction ) : LIST [3:3] OF direction;
   LOCAL
      d1 : direction;
      d2 : direction;
   END_LOCAL;
      d1 := NVL(normalise(axis),

 dummy_gri || direction([ 0.00000,

 0.00000,

 1.00000 ]));
      d2 := first_proj_axis(d1,

 ref_direction);
      RETURN ([ d2,

 normalise(cross_product(d1,

 d2)).orientation,

 d1 ]);
   END_FUNCTION;



   FUNCTION check_sparse_index_domain
      (idxdom : tuple_space;
       base : zero_or_one;
       shape : LIST [1:?] OF positive_integer;
       order : ordering_type ) : BOOLEAN;
   LOCAL
      mthspc : maths_space;
      interval : finite_integer_interval;
      i : INTEGER;
   END_LOCAL;
      mthspc := factor1(idxdom);
      interval := mthspc;
      IF order = by_rows THEN
         i := 1;
      ELSE
         i := 2;
      END_IF;
      RETURN (bool((interval.min <= base) AND (interval.max >= base + shape[i])));
   END_FUNCTION;



   FUNCTION check_sparse_index_to_loc
      (index_range : tuple_space;
       loc_domain : tuple_space ) : BOOLEAN;
   LOCAL
      temp : maths_space;
      idx_rng_itvl : finite_integer_interval;
      loc_dmn_itvl : finite_integer_interval;
   END_LOCAL;
      temp := factor1(index_range);
      IF schema_prefix + 'TUPLE_SPACE' IN TYPEOF(temp) THEN
         temp := factor1(temp);
      END_IF;
      IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp)) THEN
         RETURN (FALSE);
      END_IF;
      idx_rng_itvl := temp;
      temp := factor1(loc_domain);
      IF schema_prefix + 'TUPLE_SPACE' IN TYPEOF(temp) THEN
         temp := factor1(temp);
      END_IF;
      IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp)) THEN
         RETURN (FALSE);
      END_IF;
      loc_dmn_itvl := temp;
      RETURN (bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND (idx_rng_itvl.max <= loc_dmn_itvl.max + 1)));
   END_FUNCTION;



   FUNCTION check_sparse_loc_range
      (locrng : tuple_space;
       base : zero_or_one;
       shape : LIST [1:?] OF positive_integer;
       order : ordering_type ) : BOOLEAN;
   LOCAL
      mthspc : maths_space;
      interval : finite_integer_interval;
      i : INTEGER;
   END_LOCAL;
      IF space_dimension(locrng) <> 1 THEN
         RETURN (FALSE);
      END_IF;
      mthspc := factor1(locrng);
      IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(mthspc)) THEN
         RETURN (FALSE);
      END_IF;
      interval := mthspc;
      IF order = by_rows THEN
         i := 2;
      ELSE
         i := 1;
      END_IF;
      RETURN (bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
   END_FUNCTION;



   FUNCTION closed_shell_reversed
      (a_shell : closed_shell ) : oriented_closed_shell;
   LOCAL
      the_reverse : oriented_closed_shell;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell) THEN
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() || oriented_closed_shell(a_shell\oriented_closed_shell.closed_shell_element,

 NOT a_shell\oriented_closed_shell.orientation);
      ELSE
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() || oriented_closed_shell(a_shell,

 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION compare_basis_and_coef
      (basis : LIST [1:?] OF b_spline_basis;
       coef : maths_function ) : BOOLEAN;
   LOCAL
      shape : LIST OF positive_integer;
   END_LOCAL;
      IF NOT EXISTS(basis) OR NOT EXISTS(coef) THEN
         RETURN (FALSE);
      END_IF;
      shape := shape_of_array(coef);
      IF NOT EXISTS(shape) THEN
         RETURN (FALSE);
      END_IF;
      IF SIZEOF(shape) < SIZEOF(basis) THEN
         RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(basis);
         IF (basis[i].num_basis = shape[i]) <> TRUE THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION compatible_complex_number_regions
      (sp1 : maths_space;
       sp2 : maths_space ) : BOOLEAN;
   LOCAL
      typenames : SET OF STRING := stripped_typeof(sp1);
      crgn1 : cartesian_complex_number_region;
      crgn2 : cartesian_complex_number_region;
      prgn1 : polar_complex_number_region;
      prgn2 : polar_complex_number_region;
      prgn1c2 : polar_complex_number_region;
      prgn2c1 : polar_complex_number_region;
      sp1_is_crgn : BOOLEAN;
      sp2_is_crgn : BOOLEAN;
   END_LOCAL;
      IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
         sp1_is_crgn := TRUE;
         crgn1 := sp1;
      ELSE
         IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
            sp1_is_crgn := FALSE;
            prgn1 := sp1;
         ELSE
            RETURN (TRUE);
         END_IF;
      END_IF;
      typenames := stripped_typeof(sp2);
      IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
         sp2_is_crgn := TRUE;
         crgn2 := sp2;
      ELSE
         IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
            sp2_is_crgn := FALSE;
            prgn2 := sp2;
         ELSE
            RETURN (TRUE);
         END_IF;
      END_IF;
      IF sp1_is_crgn AND sp2_is_crgn THEN
         RETURN (compatible_intervals(crgn1.real_constraint,

 crgn2.real_constraint) AND compatible_intervals(crgn1.imag_constraint,

 crgn2.imag_constraint));
      END_IF;
      IF ((NOT sp1_is_crgn AND NOT sp2_is_crgn) AND (prgn1.centre.real_part = prgn2.centre.real_part)) AND (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
         IF NOT compatible_intervals(prgn1.distance_constraint,

 prgn2.distance_constraint) THEN
            RETURN (FALSE);
         END_IF;
         IF compatible_intervals(prgn1.direction_constraint,

 prgn2.direction_constraint) THEN
            RETURN (TRUE);
         END_IF;
         IF (prgn1.direction_constraint.max > 3.14159) AND (prgn2.direction_constraint.max < 3.14159) THEN
            RETURN (compatible_intervals(prgn2.direction_constraint,

 make_finite_real_interval(-3.14159,

 open,

 prgn1.direction_constraint.max - 2.00000 * 3.14159,

 prgn1.direction_constraint.max_closure)));
         END_IF;
         IF (prgn2.direction_constraint.max > 3.14159) AND (prgn1.direction_constraint.max < 3.14159) THEN
            RETURN (compatible_intervals(prgn1.direction_constraint,

 make_finite_real_interval(-3.14159,

 open,

 prgn2.direction_constraint.max - 2.00000 * 3.14159,

 prgn2.direction_constraint.max_closure)));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF sp1_is_crgn AND NOT sp2_is_crgn THEN
         crgn2 := enclose_pregion_in_cregion(prgn2);
         prgn1 := enclose_cregion_in_pregion(crgn1,

 prgn2.centre);
         RETURN (compatible_complex_number_regions(crgn1,

 crgn2) AND compatible_complex_number_regions(prgn1,

 prgn2));
      END_IF;
      IF NOT sp1_is_crgn AND sp2_is_crgn THEN
         crgn1 := enclose_pregion_in_cregion(prgn1);
         prgn2 := enclose_cregion_in_pregion(crgn2,

 prgn1.centre);
         RETURN (compatible_complex_number_regions(crgn1,

 crgn2) AND compatible_complex_number_regions(prgn1,

 prgn2));
      END_IF;
      prgn1c2 := enclose_pregion_in_pregion(prgn1,

 prgn2.centre);
      prgn2c1 := enclose_pregion_in_pregion(prgn2,

 prgn1.centre);
      RETURN (compatible_complex_number_regions(prgn1,

 prgn2c1) AND compatible_complex_number_regions(prgn1c2,

 prgn2));
   END_FUNCTION;



   FUNCTION compatible_es_values
      (esval1 : elementary_space_enumerators;
       esval2 : elementary_space_enumerators ) : BOOLEAN;
   LOCAL
      esval1_is_numeric : LOGICAL;
      esval2_is_numeric : LOGICAL;
   END_LOCAL;
      IF ((esval1 = esval2) OR (esval1 = es_generics)) OR (esval2 = es_generics) THEN
         RETURN (TRUE);
      END_IF;
      esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
      esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
      IF esval1_is_numeric AND (esval2 = es_numbers) OR esval2_is_numeric AND (esval1 = es_numbers) THEN
         RETURN (TRUE);
      END_IF;
      IF esval1_is_numeric XOR esval2_is_numeric THEN
         RETURN (FALSE);
      END_IF;
      IF (esval1 = es_logicals) AND (esval2 = es_booleans) OR (esval1 = es_booleans) AND (esval2 = es_logicals) THEN
         RETURN (TRUE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION compatible_intervals
      (sp1 : maths_space;
       sp2 : maths_space ) : BOOLEAN;
   LOCAL
      amin : REAL;
      amax : REAL;
   END_LOCAL;
      IF min_exists(sp1) AND max_exists(sp2) THEN
         amin := real_min(sp1);
         amax := real_max(sp2);
         IF amin > amax THEN
            RETURN (FALSE);
         END_IF;
         IF amin = amax THEN
            RETURN (min_included(sp1) AND max_included(sp2));
         END_IF;
      END_IF;
      IF min_exists(sp2) AND max_exists(sp1) THEN
         amin := real_min(sp2);
         amax := real_max(sp1);
         IF amin > amax THEN
            RETURN (FALSE);
         END_IF;
         IF amin = amax THEN
            RETURN (min_included(sp2) AND max_included(sp1));
         END_IF;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION compatible_spaces
      (sp1 : maths_space;
       sp2 : maths_space ) : BOOLEAN;
   LOCAL
      types1 : SET OF STRING := stripped_typeof(sp1);
      types2 : SET OF STRING := stripped_typeof(sp2);
      lgcl : LOGICAL := UNKNOWN;
      m : INTEGER;
      n : INTEGER;
      s1 : maths_space;
      s2 : maths_space;
   END_LOCAL;
      IF 'FINITE_SPACE' IN types1 THEN
         REPEAT i := 1 TO SIZEOF(sp1\finite_space.members);
            lgcl := member_of(sp1\finite_space.members[i],

 sp2);
            IF lgcl <> FALSE THEN
               RETURN (TRUE);
            END_IF;
         END_REPEAT;
         RETURN (FALSE);
      END_IF;
      IF 'FINITE_SPACE' IN types2 THEN
         REPEAT i := 1 TO SIZEOF(sp2\finite_space.members);
            lgcl := member_of(sp2\finite_space.members[i],

 sp1);
            IF lgcl <> FALSE THEN
               RETURN (TRUE);
            END_IF;
         END_REPEAT;
         RETURN (FALSE);
      END_IF;
      IF 'ELEMENTARY_SPACE' IN types1 THEN
         IF sp1\elementary_space.space_id = es_generics THEN
            RETURN (TRUE);
         END_IF;
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            RETURN (compatible_es_values(sp1\elementary_space.space_id,

 sp2\elementary_space.space_id));
         END_IF;
         IF (('FINITE_INTEGER_INTERVAL' IN types2) OR ('INTEGER_INTERVAL_FROM_MIN' IN types2)) OR ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
            RETURN (compatible_es_values(sp1\elementary_space.space_id,

 es_integers));
         END_IF;
         IF (('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2)) OR ('REAL_INTERVAL_TO_MAX' IN types2) THEN
            RETURN (compatible_es_values(sp1\elementary_space.space_id,

 es_reals));
         END_IF;
         IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
            RETURN (compatible_es_values(sp1\elementary_space.space_id,

 es_complex_numbers));
         END_IF;
         IF 'TUPLE_SPACE' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'FUNCTION_SPACE' IN types2 THEN
            RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
         END_IF;
         RETURN (TRUE);
      END_IF;
      IF 'ELEMENTARY_SPACE' IN types2 THEN
         IF sp2\elementary_space.space_id = es_generics THEN
            RETURN (TRUE);
         END_IF;
         IF (('FINITE_INTEGER_INTERVAL' IN types1) OR ('INTEGER_INTERVAL_FROM_MIN' IN types1)) OR ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
            RETURN (compatible_es_values(sp2\elementary_space.space_id,

 es_integers));
         END_IF;
         IF (('FINITE_REAL_INTERVAL' IN types1) OR ('REAL_INTERVAL_FROM_MIN' IN types1)) OR ('REAL_INTERVAL_TO_MAX' IN types1) THEN
            RETURN (compatible_es_values(sp2\elementary_space.space_id,

 es_reals));
         END_IF;
         IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
            RETURN (compatible_es_values(sp2\elementary_space.space_id,

 es_complex_numbers));
         END_IF;
         IF 'TUPLE_SPACE' IN types1 THEN
            RETURN (FALSE);
         END_IF;
         IF 'FUNCTION_SPACE' IN types1 THEN
            RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
         END_IF;
         RETURN (TRUE);
      END_IF;
      IF subspace_of_es(sp1,

 es_integers) THEN
         IF subspace_of_es(sp2,

 es_integers) THEN
            RETURN (compatible_intervals(sp1,

 sp2));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF subspace_of_es(sp2,

 es_integers) THEN
         RETURN (FALSE);
      END_IF;
      IF subspace_of_es(sp1,

 es_reals) THEN
         IF subspace_of_es(sp2,

 es_reals) THEN
            RETURN (compatible_intervals(sp1,

 sp2));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF subspace_of_es(sp2,

 es_reals) THEN
         RETURN (FALSE);
      END_IF;
      IF subspace_of_es(sp1,

 es_complex_numbers) THEN
         IF subspace_of_es(sp2,

 es_complex_numbers) THEN
            RETURN (compatible_complex_number_regions(sp1,

 sp2));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF subspace_of_es(sp2,

 es_complex_numbers) THEN
         RETURN (FALSE);
      END_IF;
      IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
         IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
            IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent THEN
               RETURN (FALSE);
            END_IF;
            RETURN (compatible_spaces(sp1\uniform_product_space.base,

 sp2\uniform_product_space.base));
         END_IF;
         IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
            n := SIZEOF(sp2\listed_product_space.factors);
            IF sp1\uniform_product_space.exponent <> n THEN
               RETURN (FALSE);
            END_IF;
            REPEAT i := 1 TO n;
               IF NOT compatible_spaces(sp1\uniform_product_space.base,

 sp2\listed_product_space.factors[i]) THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (TRUE);
         END_IF;
         IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
            m := sp1\uniform_product_space.exponent;
            n := space_dimension(sp2\extended_tuple_space.base);
            IF m < n THEN
               RETURN (FALSE);
            END_IF;
            IF m = n THEN
               RETURN (compatible_spaces(sp1,

 sp2\extended_tuple_space.base));
            END_IF;
            RETURN (compatible_spaces(sp1,

 assoc_product_space(sp2\extended_tuple_space.base,

 make_uniform_product_space(sp2\extended_tuple_space.extender,

 m - n))));
         END_IF;
         IF 'FUNCTION_SPACE' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         RETURN (TRUE);
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
         n := SIZEOF(sp1\listed_product_space.factors);
         IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
            IF n <> sp2\uniform_product_space.exponent THEN
               RETURN (FALSE);
            END_IF;
            REPEAT i := 1 TO n;
               IF NOT compatible_spaces(sp2\uniform_product_space.base,

 sp1\listed_product_space.factors[i]) THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (TRUE);
         END_IF;
         IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
            IF n <> SIZEOF(sp2\listed_product_space.factors) THEN
               RETURN (FALSE);
            END_IF;
            REPEAT i := 1 TO n;
               IF NOT compatible_spaces(sp1\listed_product_space.factors[i],

 sp2\listed_product_space.factors[i]) THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (TRUE);
         END_IF;
         IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
            m := space_dimension(sp2\extended_tuple_space.base);
            IF n < m THEN
               RETURN (FALSE);
            END_IF;
            IF n = m THEN
               RETURN (compatible_spaces(sp1,

 sp2\extended_tuple_space.base));
            END_IF;
            RETURN (compatible_spaces(sp1,

 assoc_product_space(sp2\extended_tuple_space.base,

 make_uniform_product_space(sp2\extended_tuple_space.extender,

 n - m))));
         END_IF;
         IF schema_prefix + 'FUNCTION_SPACE' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         RETURN (TRUE);
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
         IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR ('LISTED_PRODUCT_SPACE' IN types2) THEN
            RETURN (compatible_spaces(sp2,

 sp1));
         END_IF;
         IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
            IF NOT compatible_spaces(sp1\extended_tuple_space.extender,

 sp2\extended_tuple_space.extender) THEN
               RETURN (FALSE);
            END_IF;
            n := space_dimension(sp1\extended_tuple_space.base);
            m := space_dimension(sp2\extended_tuple_space.base);
            IF n < m THEN
               RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,

 make_uniform_product_space(sp1\extended_tuple_space.extender,

 m - n)),

 sp2\extended_tuple_space.base));
            END_IF;
            IF n = m THEN
               RETURN (compatible_spaces(sp1\extended_tuple_space.base,

 sp2\extended_tuple_space.base));
            END_IF;
            IF n > m THEN
               RETURN (compatible_spaces(sp1\extended_tuple_space.base,

 assoc_product_space(sp2\extended_tuple_space.base,

 make_uniform_product_space(sp2\extended_tuple_space.extender,

 n - m))));
            END_IF;
         END_IF;
         IF 'FUNCTION_SPACE' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         RETURN (TRUE);
      END_IF;
      IF 'FUNCTION_SPACE' IN types1 THEN
         IF 'FUNCTION_SPACE' IN types2 THEN
            s1 := sp1\function_space.domain_argument;
            s2 := sp2\function_space.domain_argument;
            CASE sp1\function_space.domain_constraint OF
               sc_equal :
                     BEGIN
                        CASE sp2\function_space.domain_constraint OF
                           sc_equal :
                                 lgcl := subspace_of(s1,

 s2) AND subspace_of(s2,

 s1);
                           sc_subspace :
                                 lgcl := subspace_of(s1,

 s2);
                           sc_member :
                                 lgcl := member_of(s1,

 s2);
                        END_CASE;
                     END;
               sc_subspace :
                     BEGIN
                        CASE sp2\function_space.domain_constraint OF
                           sc_equal :
                                 lgcl := subspace_of(s2,

 s1);
                           sc_subspace :
                                 lgcl := compatible_spaces(s1,

 s2);
                           sc_member :
                                 lgcl := UNKNOWN;
                        END_CASE;
                     END;
               sc_member :
                     BEGIN
                        CASE sp2\function_space.domain_constraint OF
                           sc_equal :
                                 lgcl := member_of(s2,

 s1);
                           sc_subspace :
                                 lgcl := UNKNOWN;
                           sc_member :
                                 lgcl := compatible_spaces(s1,

 s2);
                        END_CASE;
                     END;
            END_CASE;
            IF lgcl = FALSE THEN
               RETURN (FALSE);
            END_IF;
            s1 := sp1\function_space.range_argument;
            s2 := sp2\function_space.range_argument;
            CASE sp1\function_space.range_constraint OF
               sc_equal :
                     BEGIN
                        CASE sp2\function_space.range_constraint OF
                           sc_equal :
                                 lgcl := subspace_of(s1,

 s2) AND subspace_of(s2,

 s1);
                           sc_subspace :
                                 lgcl := subspace_of(s1,

 s2);
                           sc_member :
                                 lgcl := member_of(s1,

 s2);
                        END_CASE;
                     END;
               sc_subspace :
                     BEGIN
                        CASE sp2\function_space.range_constraint OF
                           sc_equal :
                                 lgcl := subspace_of(s2,

 s1);
                           sc_subspace :
                                 lgcl := compatible_spaces(s1,

 s2);
                           sc_member :
                                 lgcl := UNKNOWN;
                        END_CASE;
                     END;
               sc_member :
                     BEGIN
                        CASE sp2\function_space.range_constraint OF
                           sc_equal :
                                 lgcl := member_of(s2,

 s1);
                           sc_subspace :
                                 lgcl := UNKNOWN;
                           sc_member :
                                 lgcl := compatible_spaces(s1,

 s2);
                        END_CASE;
                     END;
            END_CASE;
            IF lgcl = FALSE THEN
               RETURN (FALSE);
            END_IF;
            RETURN (TRUE);
         END_IF;
         RETURN (TRUE);
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION component_definition_located_by_component_location
      (cl : component_location ) : component_definition;
   LOCAL
      pdr : BAG OF property_definition_representation := USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(pdr) BY 1;
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr[i].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr[i].definition.definition\product_definition_relationship.related_product_definition)) THEN
            RETURN (pdr[i].definition.definition\product_definition_relationship.related_product_definition);
         END_IF;
      END_REPEAT;
      RETURN (?);
   END_FUNCTION;



   FUNCTION composable_sequence
      (operands : LIST [2:?] OF maths_function ) : BOOLEAN;
      REPEAT i := 1 TO SIZEOF(operands) - 1;
         IF NOT compatible_spaces(operands[i].range,

 operands[(i + 1)].domain) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION conditional_reverse
      (p : BOOLEAN;
       an_item : reversible_topology ) : reversible_topology;
      IF p THEN
         RETURN (an_item);
      ELSE
         RETURN (topology_reversed(an_item));
      END_IF;
   END_FUNCTION;



   FUNCTION consistent_bus_structural_definition
      (input_rel : SET [1:?] OF product_definition_relationship ) : BOOLEAN;
   LOCAL
      input : SET OF product_definition := [];
      vertex : SET OF product_definition := [];
      edge : INTEGER := SIZEOF(input);
      vc : INTEGER := 0;
      vertex_degree : INTEGER := 0;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(input_rel) BY 1;
         input := input + input_rel[i].related_product_definition;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(input) BY 1;
         vertex := vertex + input[i]\product_definition_relationship.relating_product_definition;
         vertex := vertex + input[i]\product_definition_relationship.related_product_definition;
      END_REPEAT;
      vc := SIZEOF(vertex);
      IF vc <> edge + 1 THEN
         RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO vc BY 1;
         vertex_degree := 0;
         REPEAT j := 1 TO SIZEOF(input) BY 1;
            IF input[j]\product_definition_relationship.relating_product_definition = vertex[i] THEN
               vertex_degree := vertex_degree + 1;
            END_IF;
            IF input[j]\product_definition_relationship.related_product_definition = vertex[i] THEN
               vertex_degree := vertex_degree + 1;
            END_IF;
         END_REPEAT;
         IF vertex_degree > 2 THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION constraints_composite_curve_on_surface
      (c : composite_curve_on_surface ) : BOOLEAN;
   LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
      REPEAT k := 1 TO n_segments;
         IF (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\composite_curve.segments[k].parent_curve)) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION constraints_geometry_shell_based_surface_model
      (m : shell_based_surface_model ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
         IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[j])) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary[j])) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION constraints_geometry_shell_based_wireframe_model
      (m : shell_based_wireframe_model ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
         IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[j])) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary[j])) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION constraints_param_b_spline
      (degree : INTEGER;
       up_knots : INTEGER;
       up_cp : INTEGER;
       knot_mult : LIST OF INTEGER;
       knots : LIST OF parameter_value ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
      k : INTEGER;
      sum : INTEGER;
   END_LOCAL;
      sum := knot_mult[1];
      REPEAT i := 2 TO up_knots;
         sum := sum + knot_mult[i];
      END_REPEAT;
      IF (((degree < 1) OR (up_knots < 2)) OR (up_cp < degree)) OR (sum <> degree + up_cp + 2) THEN
         result := FALSE;
         RETURN (result);
      END_IF;
      k := knot_mult[1];
      IF (k < 1) OR (k > degree + 1) THEN
         result := FALSE;
         RETURN (result);
      END_IF;
      REPEAT i := 2 TO up_knots;
         IF (knot_mult[i] < 1) OR (knots[i] <= knots[(i - 1)]) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
         k := knot_mult[i];
         IF (i < up_knots) AND (k > degree) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
         IF (i = up_knots) AND (k > degree + 1) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION constraints_rectangular_composite_surface
      (s : rectangular_composite_surface ) : BOOLEAN;
      REPEAT i := 1 TO s.n_u;
         REPEAT j := 1 TO s.n_v;
            IF NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.segments[i][j].parent_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.segments[i][j].parent_surface))) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO s.n_u - 1;
         REPEAT j := 1 TO s.n_v;
            IF s.segments[i][j].u_transition = discontinuous THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO s.n_u;
         REPEAT j := 1 TO s.n_v - 1;
            IF s.segments[i][j].v_transition = discontinuous THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION convert_to_literal
      (val : maths_atom ) : generic_literal;
   LOCAL
      types : SET OF STRING := TYPEOF(val);
   END_LOCAL;
      IF 'INTEGER' IN types THEN
         RETURN (make_int_literal(val));
      END_IF;
      IF 'REAL' IN types THEN
         RETURN (make_real_literal(val));
      END_IF;
      IF 'BOOLEAN' IN types THEN
         RETURN (make_boolean_literal(val));
      END_IF;
      IF 'STRING' IN types THEN
         RETURN (make_string_literal(val));
      END_IF;
      IF 'LOGICAL' IN types THEN
         RETURN (make_logical_literal(val));
      END_IF;
      IF 'BINARY' IN types THEN
         RETURN (make_binary_literal(val));
      END_IF;
      IF schema_prefix + 'MATHS_ENUM_ATOM' IN types THEN
         RETURN (make_maths_enum_literal(val));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION convert_to_maths_function
      (func : maths_function_select ) : maths_function;
   LOCAL
      efenum : elementary_function_enumerators;
      mthfun : maths_function;
   END_LOCAL;
      IF schema_prefix + 'MATHS_FUNCTION' IN TYPEOF(func) THEN
         mthfun := func;
      ELSE
         efenum := func;
         mthfun := make_elementary_function(efenum);
      END_IF;
      RETURN (mthfun);
   END_FUNCTION;



   FUNCTION convert_to_maths_value
      (val : GENERIC : G ) : maths_value;
   LOCAL
      types : SET OF STRING := TYPEOF(val);
      ival : maths_integer;
      rval : maths_real;
      nval : maths_number;
      tfval : maths_boolean;
      lval : maths_logical;
      sval : maths_string;
      bval : maths_binary;
      tval : maths_tuple := the_empty_maths_tuple;
      mval : maths_value;
   END_LOCAL;
      IF schema_prefix + 'MATHS_VALUE' IN types THEN
         RETURN (val);
      END_IF;
      IF 'INTEGER' IN types THEN
         ival := val;
         RETURN (ival);
      END_IF;
      IF 'REAL' IN types THEN
         rval := val;
         RETURN (rval);
      END_IF;
      IF 'NUMBER' IN types THEN
         nval := val;
         RETURN (nval);
      END_IF;
      IF 'BOOLEAN' IN types THEN
         tfval := val;
         RETURN (tfval);
      END_IF;
      IF 'LOGICAL' IN types THEN
         lval := val;
         RETURN (lval);
      END_IF;
      IF 'STRING' IN types THEN
         sval := val;
         RETURN (sval);
      END_IF;
      IF 'BINARY' IN types THEN
         bval := val;
         RETURN (bval);
      END_IF;
      IF 'LIST' IN types THEN
         REPEAT i := 1 TO SIZEOF(val);
            mval := convert_to_maths_value(val[i]);
            IF NOT EXISTS(mval) THEN
               RETURN (?);
            END_IF;
            INSERT( tval,

 mval,

 i - 1 );
         END_REPEAT;
         RETURN (tval);
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION convert_to_operand
      (val : maths_value ) : generic_expression;
   LOCAL
      types : SET OF STRING := stripped_typeof(val);
   END_LOCAL;
      IF 'GENERIC_EXPRESSION' IN types THEN
         RETURN (val);
      END_IF;
      IF 'MATHS_ATOM' IN types THEN
         RETURN (convert_to_literal(val));
      END_IF;
      IF 'ATOM_BASED_VALUE' IN types THEN
         RETURN (make_atom_based_literal(val));
      END_IF;
      IF 'MATHS_TUPLE' IN types THEN
         RETURN (make_maths_tuple_literal(val));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION convert_to_operands
      (values : AGGREGATE OF maths_value ) : LIST OF generic_expression;
   LOCAL
      operands : LIST OF generic_expression := [];
      loc : INTEGER := 0;
   END_LOCAL;
      IF NOT EXISTS(values) THEN
         RETURN (?);
      END_IF;
      REPEAT i := LOINDEX(values) TO HIINDEX(values);
         INSERT( operands,

 convert_to_operand(values[i]),

 loc );
         loc := loc + 1;
      END_REPEAT;
      RETURN (operands);
   END_FUNCTION;



   FUNCTION convert_to_operands_prcmfn
      (srcdom : maths_space_or_function;
       prepfun : LIST OF maths_function;
       finfun : maths_function_select ) : LIST [2:?] OF generic_expression;
   LOCAL
      operands : LIST OF generic_expression := [];
   END_LOCAL;
      INSERT( operands,

 srcdom,

 0 );
      REPEAT i := 1 TO SIZEOF(prepfun);
         INSERT( operands,

 prepfun[i],

 i );
      END_REPEAT;
      INSERT( operands,

 convert_to_maths_function(finfun),

 SIZEOF(prepfun) + 1 );
      RETURN (operands);
   END_FUNCTION;



   FUNCTION cross_product
      (arg1 : direction;
       arg2 : direction ) : vector;
   LOCAL
      mag : REAL;
      res : direction;
      v1 : LIST [3:3] OF REAL;
      v2 : LIST [3:3] OF REAL;
      result : vector;
   END_LOCAL;
      IF (NOT EXISTS(arg1) OR (arg1.dim = 2)) OR (NOT EXISTS(arg2) OR (arg2.dim = 2)) THEN
         RETURN (?);
      ELSE
         BEGIN
            v1 := normalise(arg1).direction_ratios;
            v2 := normalise(arg2).direction_ratios;
            res := dummy_gri || direction([ (v1[2] * v2[3] - v1[3] * v2[2]),

 (v1[3] * v2[1] - v1[1] * v2[3]),

 (v1[1] * v2[2] - v1[2] * v2[1]) ]);
            mag := 0.00000;
            REPEAT i := 1 TO 3;
               mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
            END_REPEAT;
            IF mag > 0.00000 THEN
               result := dummy_gri || vector(res,

 sqrt(mag));
            ELSE
               result := dummy_gri || vector(arg1,

 0.00000);
            END_IF;
            RETURN (result);
         END;
      END_IF;
   END_FUNCTION;



   FUNCTION cto2d_determinant_test
      (cto2d : cartesian_transformation_operator_2d;
       expected_value : REAL;
       delta : REAL ) : BOOLEAN;
   LOCAL
      det : REAL := 0.00000;
      DRs : LIST [4:4] OF REAL := [];
   END_LOCAL;
      DRs[1] := cto2d.u[1].direction_ratios[1];
      DRs[2] := cto2d.u[1].direction_ratios[2];
      DRs[3] := cto2d.u[2].direction_ratios[1];
      DRs[4] := cto2d.u[2].direction_ratios[2];
      det := DRs[1] * DRs[4] - DRs[2] * DRs[3];
      IF abs(expected_value - det) < abs(delta) THEN
         RETURN (TRUE);
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION curve_weights_positive
      (b : rational_b_spline_curve ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 0 TO b.upper_index_on_control_points;
         IF b.weights[i] <= 0.00000 THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION definite_integral_check
      (domain : tuple_space;
       vrblint : input_selector;
       lowerinf : BOOLEAN;
       upperinf : BOOLEAN ) : BOOLEAN;
   LOCAL
      domn : tuple_space := domain;
      fspc : maths_space;
      dim : nonnegative_integer;
      k : positive_integer;
   END_LOCAL;
      IF (space_dimension(domain) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN TYPEOF(factor1(domain))) THEN
         domn := factor1(domain);
      END_IF;
      dim := space_dimension(domn);
      k := vrblint;
      IF k > dim THEN
         RETURN (FALSE);
      END_IF;
      fspc := factor_space(domn,

 k);
      IF NOT (schema_prefix + 'REAL_INTERVAL' IN TYPEOF(fspc)) THEN
         RETURN (FALSE);
      END_IF;
      IF lowerinf AND min_exists(fspc) THEN
         RETURN (FALSE);
      END_IF;
      IF upperinf AND max_exists(fspc) THEN
         RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION definite_integral_expr_check
      (operands : LIST [2:?] OF generic_expression;
       lowerinf : BOOLEAN;
       upperinf : BOOLEAN ) : BOOLEAN;
   LOCAL
      nops : INTEGER := 2;
      vspc : maths_space;
      dim : nonnegative_integer;
      k : positive_integer;
      bspc : maths_space;
   END_LOCAL;
      IF NOT lowerinf THEN
         nops := nops + 1;
      END_IF;
      IF NOT upperinf THEN
         nops := nops + 1;
      END_IF;
      IF SIZEOF(operands) <> nops THEN
         RETURN (FALSE);
      END_IF;
      IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
         RETURN (FALSE);
      END_IF;
      IF NOT has_values_space(operands[2]) THEN
         RETURN (FALSE);
      END_IF;
      vspc := values_space_of(operands[2]);
      IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN
         RETURN (FALSE);
      END_IF;
      IF lowerinf THEN
         IF min_exists(vspc) THEN
            RETURN (FALSE);
         END_IF;
         k := 3;
      ELSE
         IF NOT has_values_space(operands[3]) THEN
            RETURN (FALSE);
         END_IF;
         bspc := values_space_of(operands[3]);
         IF NOT compatible_spaces(bspc,

 vspc) THEN
            RETURN (FALSE);
         END_IF;
         k := 4;
      END_IF;
      IF upperinf THEN
         IF max_exists(vspc) THEN
            RETURN (FALSE);
         END_IF;
      ELSE
         IF NOT has_values_space(operands[k]) THEN
            RETURN (FALSE);
         END_IF;
         bspc := values_space_of(operands[k]);
         IF NOT compatible_spaces(bspc,

 vspc) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION derive_definite_integral_domain
      (igrl : definite_integral_function ) : tuple_space;
      FUNCTION process_product_space
         (spc : product_space;
          idx : INTEGER;
          prefix : INTEGER;
          vdomn : maths_space ) : product_space;
      LOCAL
         uspc : uniform_product_space;
         expnt : INTEGER;
         factors : LIST OF maths_space;
      END_LOCAL;
         IF schema_prefix + 'UNIFORM_PRODUCT_SPACE' IN TYPEOF(spc) THEN
            uspc := spc;
            expnt := uspc.exponent + prefix;
            IF idx <= uspc.exponent THEN
               expnt := expnt - 1;
            END_IF;
            IF expnt = 0 THEN
               RETURN (make_listed_product_space([]));
            ELSE
               RETURN (make_uniform_product_space(uspc.base,

 expnt));
            END_IF;
         ELSE
            factors := spc\listed_product_space.factors;
            IF idx <= SIZEOF(factors) THEN
               REMOVE( factors,

 idx );
            END_IF;
            IF prefix > 0 THEN
               INSERT( factors,

 vdomn,

 0 );
               IF prefix > 1 THEN
                  INSERT( factors,

 vdomn,

 0 );
               END_IF;
            END_IF;
            RETURN (make_listed_product_space(factors));
         END_IF;
      END_FUNCTION;
   LOCAL
      idomn : tuple_space := igrl.integrand.domain;
      types : SET OF STRING := TYPEOF(idomn);
      idx : INTEGER := igrl.variable_of_integration;
      tupled : BOOLEAN := bool((space_dimension(idomn) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN types));
      prefix : INTEGER := 0;
      espc : extended_tuple_space;
      vdomn : maths_space;
   END_LOCAL;
      IF tupled THEN
         idomn := factor1(idomn);
         types := TYPEOF(idomn);
      END_IF;
      IF igrl.lower_limit_neg_infinity THEN
         prefix := prefix + 1;
      END_IF;
      IF igrl.upper_limit_pos_infinity THEN
         prefix := prefix + 1;
      END_IF;
      vdomn := factor_space(idomn,

 idx);
      IF schema_prefix + 'EXTENDED_TUPLE_SPACE' IN types THEN
         espc := idomn;
         idomn := make_extended_tuple_space(process_product_space(espc.base,

 idx,

 prefix,

 vdomn),

 espc.extender);
      ELSE
         idomn := process_product_space(idomn,

 idx,

 prefix,

 vdomn);
      END_IF;
      IF tupled THEN
         RETURN (one_tuples_of(idomn));
      ELSE
         RETURN (idomn);
      END_IF;
   END_FUNCTION;



   FUNCTION derive_dimensional_exponents
      (x : unit ) : dimensional_exponents;
   LOCAL
      result : dimensional_exponents := dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000);
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DERIVED_UNIT' IN TYPEOF(x) THEN
         REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
            result.length_exponent := result.length_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent;
            result.mass_exponent := result.mass_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent;
            result.time_exponent := result.time_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent;
            result.electric_current_exponent := result.electric_current_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent;
            result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent;
            result.amount_of_substance_exponent := result.amount_of_substance_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent;
            result.luminous_intensity_exponent := result.luminous_intensity_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent;
         END_REPEAT;
      ELSE
         result := x.dimensions;
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION derive_elementary_function_domain
      (ef_val : elementary_function_enumerators ) : tuple_space;
      IF NOT EXISTS(ef_val) THEN
         RETURN (?);
      END_IF;
      CASE ef_val OF
         ef_and :
               RETURN (make_extended_tuple_space(the_zero_tuple_space,

 the_logicals));
         ef_or :
               RETURN (make_extended_tuple_space(the_zero_tuple_space,

 the_logicals));
         ef_not :
               RETURN (make_uniform_product_space(the_logicals,

 1));
         ef_xor :
               RETURN (make_uniform_product_space(the_logicals,

 2));
         ef_negate_i :
               RETURN (make_uniform_product_space(the_integers,

 1));
         ef_add_i :
               RETURN (the_integer_tuples);
         ef_subtract_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_multiply_i :
               RETURN (the_integer_tuples);
         ef_divide_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_mod_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_exponentiate_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_eq_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_ne_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_gt_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_lt_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_ge_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_le_i :
               RETURN (make_uniform_product_space(the_integers,

 2));
         ef_abs_i :
               RETURN (make_uniform_product_space(the_integers,

 1));
         ef_if_i :
               RETURN (make_listed_product_space([ the_logicals,

 the_integers,

 the_integers ]));
         ef_negate_r :
               RETURN (make_uniform_product_space(the_reals,

 1));
         ef_reciprocal_r :
               RETURN (make_uniform_product_space(the_reals,

 1));
         ef_add_r :
               RETURN (the_real_tuples);
         ef_subtract_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_multiply_r :
               RETURN (the_real_tuples);
         ef_divide_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_mod_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_exponentiate_r :
               RETURN (make_listed_product_space([ the_nonnegative_reals,

 the_reals ]));
         ef_exponentiate_ri :
               RETURN (make_listed_product_space([ the_reals,

 the_integers ]));
         ef_eq_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_ne_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_gt_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_lt_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_ge_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_le_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_abs_r :
               RETURN (make_uniform_product_space(the_reals,

 1));
         ef_acos_r :
               RETURN (make_uniform_product_space(the_neg1_one_interval,

 1));
         ef_asin_r :
               RETURN (make_uniform_product_space(the_neg1_one_interval,

 1));
         ef_atan2_r :
               RETURN (make_uniform_product_space(the_reals,

 2));
         ef_cos_r :
               RETURN (make_uniform_product_space(the_reals,

 1));
         ef_exp_r :
               RETURN (make_uniform_product_space(the_reals,

 1));
         ef_ln_r :
               RETURN (make_uniform_product_space(the_nonnegative_reals,

 1));
         ef_log2_r :
               RETURN (make_uniform_product_space(the_nonnegative_reals,

 1));
         ef_log10_r :
               RETURN (make_uniform_product_space(the_nonnegative_reals,

 1));
         ef_sin_r :
               RETURN (make_uniform_product_space(the_reals,

 1));
         ef_sqrt_r :
               RETURN (make_uniform_product_space(the_nonnegative_reals,

 1));
         ef_tan_r :
               RETURN (make_uniform_product_space(the_reals,

 1));
         ef_if_r :
               RETURN (make_listed_product_space([ the_logicals,

 the_reals,

 the_reals ]));
         ef_negate_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_reciprocal_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_add_c :
               RETURN (the_complex_tuples);
         ef_subtract_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 2));
         ef_multiply_c :
               RETURN (the_complex_tuples);
         ef_divide_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 2));
         ef_exponentiate_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 2));
         ef_exponentiate_ci :
               RETURN (make_listed_product_space([ the_complex_numbers,

 the_integers ]));
         ef_eq_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 2));
         ef_ne_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 2));
         ef_conjugate_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_abs_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_arg_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_cos_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_exp_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_ln_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_sin_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_sqrt_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_tan_c :
               RETURN (make_uniform_product_space(the_complex_numbers,

 1));
         ef_if_c :
               RETURN (make_listed_product_space([ the_logicals,

 the_complex_numbers,

 the_complex_numbers ]));
         ef_subscript_s :
               RETURN (make_listed_product_space([ the_strings,

 the_integers ]));
         ef_eq_s :
               RETURN (make_uniform_product_space(the_strings,

 2));
         ef_ne_s :
               RETURN (make_uniform_product_space(the_strings,

 2));
         ef_gt_s :
               RETURN (make_uniform_product_space(the_strings,

 2));
         ef_lt_s :
               RETURN (make_uniform_product_space(the_strings,

 2));
         ef_ge_s :
               RETURN (make_uniform_product_space(the_strings,

 2));
         ef_le_s :
               RETURN (make_uniform_product_space(the_strings,

 2));
         ef_subsequence_s :
               RETURN (make_listed_product_space([ the_strings,

 the_integers,

 the_integers ]));
         ef_concat_s :
               RETURN (make_extended_tuple_space(the_zero_tuple_space,

 the_strings));
         ef_size_s :
               RETURN (make_uniform_product_space(the_strings,

 1));
         ef_format :
               RETURN (make_listed_product_space([ the_numbers,

 the_strings ]));
         ef_value :
               RETURN (make_uniform_product_space(the_strings,

 1));
         ef_like :
               RETURN (make_uniform_product_space(the_strings,

 2));
         ef_if_s :
               RETURN (make_listed_product_space([ the_logicals,

 the_strings,

 the_strings ]));
         ef_subscript_b :
               RETURN (make_listed_product_space([ the_binarys,

 the_integers ]));
         ef_eq_b :
               RETURN (make_uniform_product_space(the_binarys,

 2));
         ef_ne_b :
               RETURN (make_uniform_product_space(the_binarys,

 2));
         ef_gt_b :
               RETURN (make_uniform_product_space(the_binarys,

 2));
         ef_lt_b :
               RETURN (make_uniform_product_space(the_binarys,

 2));
         ef_ge_b :
               RETURN (make_uniform_product_space(the_binarys,

 2));
         ef_le_b :
               RETURN (make_uniform_product_space(the_binarys,

 2));
         ef_subsequence_b :
               RETURN (make_listed_product_space([ the_binarys,

 the_integers,

 the_integers ]));
         ef_concat_b :
               RETURN (make_extended_tuple_space(the_zero_tuple_space,

 the_binarys));
         ef_size_b :
               RETURN (make_uniform_product_space(the_binarys,

 1));
         ef_if_b :
               RETURN (make_listed_product_space([ the_logicals,

 the_binarys,

 the_binarys ]));
         ef_subscript_t :
               RETURN (make_listed_product_space([ the_tuples,

 the_integers ]));
         ef_eq_t :
               RETURN (make_uniform_product_space(the_tuples,

 2));
         ef_ne_t :
               RETURN (make_uniform_product_space(the_tuples,

 2));
         ef_concat_t :
               RETURN (make_extended_tuple_space(the_zero_tuple_space,

 the_tuples));
         ef_size_t :
               RETURN (make_uniform_product_space(the_tuples,

 1));
         ef_entuple :
               RETURN (the_tuples);
         ef_detuple :
               RETURN (make_uniform_product_space(the_generics,

 1));
         ef_insert :
               RETURN (make_listed_product_space([ the_tuples,

 the_generics,

 the_integers ]));
         ef_remove :
               RETURN (make_listed_product_space([ the_tuples,

 the_integers ]));
         ef_if_t :
               RETURN (make_listed_product_space([ the_logicals,

 the_tuples,

 the_tuples ]));
         ef_sum_it :
               RETURN (make_uniform_product_space(the_integer_tuples,

 1));
         ef_product_it :
               RETURN (make_uniform_product_space(the_integer_tuples,

 1));
         ef_add_it :
               RETURN (make_extended_tuple_space(the_integer_tuples,

 the_integer_tuples));
         ef_subtract_it :
               RETURN (make_uniform_product_space(the_integer_tuples,

 2));
         ef_scalar_mult_it :
               RETURN (make_listed_product_space([ the_integers,

 the_integer_tuples ]));
         ef_dot_prod_it :
               RETURN (make_uniform_product_space(the_integer_tuples,

 2));
         ef_sum_rt :
               RETURN (make_uniform_product_space(the_real_tuples,

 1));
         ef_product_rt :
               RETURN (make_uniform_product_space(the_real_tuples,

 1));
         ef_add_rt :
               RETURN (make_extended_tuple_space(the_real_tuples,

 the_real_tuples));
         ef_subtract_rt :
               RETURN (make_uniform_product_space(the_real_tuples,

 2));
         ef_scalar_mult_rt :
               RETURN (make_listed_product_space([ the_reals,

 the_real_tuples ]));
         ef_dot_prod_rt :
               RETURN (make_uniform_product_space(the_real_tuples,

 2));
         ef_norm_rt :
               RETURN (make_uniform_product_space(the_real_tuples,

 1));
         ef_sum_ct :
               RETURN (make_uniform_product_space(the_complex_tuples,

 1));
         ef_product_ct :
               RETURN (make_uniform_product_space(the_complex_tuples,

 1));
         ef_add_ct :
               RETURN (make_extended_tuple_space(the_complex_tuples,

 the_complex_tuples));
         ef_subtract_ct :
               RETURN (make_uniform_product_space(the_complex_tuples,

 2));
         ef_scalar_mult_ct :
               RETURN (make_listed_product_space([ the_complex_numbers,

 the_complex_tuples ]));
         ef_dot_prod_ct :
               RETURN (make_uniform_product_space(the_complex_tuples,

 2));
         ef_norm_ct :
               RETURN (make_uniform_product_space(the_complex_tuples,

 1));
         ef_if :
               RETURN (make_listed_product_space([ the_logicals,

 the_generics,

 the_generics ]));
         ef_ensemble :
               RETURN (the_tuples);
         ef_member_of :
               RETURN (make_listed_product_space([ the_generics,

 the_maths_spaces ]));
      OTHERWISE :
            RETURN (?);
      END_CASE;
   END_FUNCTION;



   FUNCTION derive_finite_function_domain
      (pairs : SET [1:?] OF LIST [2:2] OF maths_value ) : tuple_space;
   LOCAL
      result : SET OF maths_value := [];
   END_LOCAL;
      result := result + list_selected_components(pairs,

 1);
      RETURN (one_tuples_of(make_finite_space(result)));
   END_FUNCTION;



   FUNCTION derive_finite_function_range
      (pairs : SET [1:?] OF LIST [2:2] OF maths_value ) : tuple_space;
   LOCAL
      result : SET OF maths_value := [];
   END_LOCAL;
      result := result + list_selected_components(pairs,

 2);
      RETURN (one_tuples_of(make_finite_space(result)));
   END_FUNCTION;



   FUNCTION derive_function_domain
      (func : maths_function ) : tuple_space;
   LOCAL
      typenames : SET OF STRING := stripped_typeof(func);
      tspace : tuple_space := make_listed_product_space([]);
      shape : LIST OF positive_integer;
      sidxs : LIST OF INTEGER := [ 0 ];
      itvl : finite_integer_interval;
      factors : LIST OF finite_integer_interval := [];
      is_uniform : BOOLEAN := TRUE;
   END_LOCAL;
      IF 'FINITE_FUNCTION' IN typenames THEN
         RETURN (derive_finite_function_domain(func\finite_function.pairs));
      END_IF;
      IF 'CONSTANT_FUNCTION' IN typenames THEN
         RETURN (domain_from(func\constant_function.source_of_domain));
      END_IF;
      IF 'SELECTOR_FUNCTION' IN typenames THEN
         RETURN (domain_from(func\selector_function.source_of_domain));
      END_IF;
      IF 'ELEMENTARY_FUNCTION' IN typenames THEN
         RETURN (derive_elementary_function_domain(func\elementary_function.func_id));
      END_IF;
      IF 'RESTRICTION_FUNCTION' IN typenames THEN
         RETURN (one_tuples_of(func\restriction_function.operand));
      END_IF;
      IF 'REPACKAGING_FUNCTION' IN typenames THEN
         IF func\repackaging_function.input_repack = ro_nochange THEN
            RETURN (func\repackaging_function.operand.domain);
         END_IF;
         IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
            RETURN (factor1(func\repackaging_function.operand.domain));
         END_IF;
         IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
            RETURN (one_tuples_of(func\repackaging_function.operand.domain));
         END_IF;
         RETURN (?);
      END_IF;
      IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
         shape := shape_of_array(func\unary_generic_expression.operand);
         sidxs := func\reindexed_array_function.starting_indices;
         REPEAT i := 1 TO SIZEOF(shape);
            itvl := make_finite_integer_interval(sidxs[i],

 sidxs[i] + shape[i] - 1);
            INSERT( factors,

 itvl,

 i - 1 );
            IF shape[i] <> shape[1] THEN
               is_uniform := FALSE;
            END_IF;
         END_REPEAT;
         IF is_uniform THEN
            RETURN (make_uniform_product_space(factors[1],

 SIZEOF(shape)));
         END_IF;
         RETURN (make_listed_product_space(factors));
      END_IF;
      IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
         RETURN (func\series_composed_function.operands[1].domain);
      END_IF;
      IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
         RETURN (domain_from(func\parallel_composed_function.source_of_domain));
      END_IF;
      IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
         shape := func\explicit_table_function.shape;
         sidxs[1] := func\explicit_table_function.index_base;
         REPEAT i := 1 TO SIZEOF(shape);
            itvl := make_finite_integer_interval(sidxs[1],

 sidxs[1] + shape[i] - 1);
            INSERT( factors,

 itvl,

 i - 1 );
            IF shape[i] <> shape[1] THEN
               is_uniform := FALSE;
            END_IF;
         END_REPEAT;
         IF is_uniform THEN
            RETURN (make_uniform_product_space(factors[1],

 SIZEOF(shape)));
         END_IF;
         RETURN (make_listed_product_space(factors));
      END_IF;
      IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
         RETURN (one_tuples_of(make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range),

 func\homogeneous_linear_function.mat\explicit_table_function.shape[func\homogeneous_linear_function.sum_index])));
      END_IF;
      IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
         RETURN (one_tuples_of(make_uniform_product_space(factor1(func\general_linear_function.mat.range),

 func\general_linear_function.mat\explicit_table_function.shape[func\general_linear_function.sum_index] - 1)));
      END_IF;
      IF 'B_SPLINE_BASIS' IN typenames THEN
         RETURN (one_tuples_of(make_finite_real_interval(func\b_spline_basis.repeated_knots[func\b_spline_basis.order],

 closed,

 func\b_spline_basis.repeated_knots[(func\b_spline_basis.num_basis + 1)],

 closed)));
      END_IF;
      IF 'B_SPLINE_FUNCTION' IN typenames THEN
         REPEAT i := 1 TO SIZEOF(func\b_spline_function.basis);
            tspace := assoc_product_space(tspace,

 func\b_spline_function.basis[i].domain);
         END_REPEAT;
         RETURN (one_tuples_of(tspace));
      END_IF;
      IF 'RATIONALIZE_FUNCTION' IN typenames THEN
         RETURN (func\rationalize_function.fun.domain);
      END_IF;
      IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
         RETURN (func\partial_derivative_function.derivand.domain);
      END_IF;
      IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
         RETURN (derive_definite_integral_domain(func));
      END_IF;
      IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
         REPEAT i := 1 TO SIZEOF(func\abstracted_expression_function.variables);
            tspace := assoc_product_space(tspace,

 one_tuples_of(values_space_of(func\abstracted_expression_function.variables[i])));
         END_REPEAT;
         RETURN (tspace);
      END_IF;
      IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
         RETURN (values_space_of(func\expression_denoted_function.expr)\function_space.domain_argument);
      END_IF;
      IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
         RETURN (one_tuples_of(make_listed_product_space([])));
      END_IF;
      IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
         RETURN (func\imported_curve_function.parametric_domain);
      END_IF;
      IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
         RETURN (func\imported_surface_function.parametric_domain);
      END_IF;
      IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
         RETURN (func\imported_volume_function.parametric_domain);
      END_IF;
      IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
         RETURN (func\application_defined_function.explicit_domain);
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION derive_function_range
      (func : maths_function ) : tuple_space;
   LOCAL
      typenames : SET OF STRING := stripped_typeof(func);
      tspace : tuple_space := make_listed_product_space([]);
      m : nonnegative_integer := 0;
      n : nonnegative_integer := 0;
   END_LOCAL;
      IF 'FINITE_FUNCTION' IN typenames THEN
         RETURN (derive_finite_function_range(func\finite_function.pairs));
      END_IF;
   END_FUNCTION;



   FUNCTION dimension_of
      (item : geometric_representation_item ) : dimension_count;
   LOCAL
      x : SET OF representation;
      y : representation_context;
      dim : dimension_count;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(item) THEN
         dim := SIZEOF(item\cartesian_point.coordinates);
         RETURN (dim);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DIRECTION' IN TYPEOF(item) THEN
         dim := SIZEOF(item\direction.direction_ratios);
         RETURN (dim);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(item) THEN
         dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
         RETURN (dim);
      END_IF;
      x := using_representations(item);
      y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
      RETURN (dim);
   END_FUNCTION;



   FUNCTION dimensions_for_si_unit
      (n : si_unit_name ) : dimensional_exponents;
      CASE n OF
         metre :
               RETURN (dimensional_exponents(1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         gram :
               RETURN (dimensional_exponents(0.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         second :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         ampere :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000));
         kelvin :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000));
         mole :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000));
         candela :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000));
         radian :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         steradian :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         hertz :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 -1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         newton :
               RETURN (dimensional_exponents(1.00000,

 1.00000,

 -2.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         pascal :
               RETURN (dimensional_exponents(-1.00000,

 1.00000,

 -2.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         joule :
               RETURN (dimensional_exponents(2.00000,

 1.00000,

 -2.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         watt :
               RETURN (dimensional_exponents(2.00000,

 1.00000,

 -3.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         coulomb :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 1.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000));
         volt :
               RETURN (dimensional_exponents(2.00000,

 1.00000,

 -3.00000,

 -1.00000,

 0.00000,

 0.00000,

 0.00000));
         farad :
               RETURN (dimensional_exponents(-2.00000,

 -1.00000,

 4.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000));
         ohm :
               RETURN (dimensional_exponents(2.00000,

 1.00000,

 -3.00000,

 -2.00000,

 0.00000,

 0.00000,

 0.00000));
         siemens :
               RETURN (dimensional_exponents(-2.00000,

 -1.00000,

 3.00000,

 2.00000,

 0.00000,

 0.00000,

 0.00000));
         weber :
               RETURN (dimensional_exponents(2.00000,

 1.00000,

 -2.00000,

 -1.00000,

 0.00000,

 0.00000,

 0.00000));
         tesla :
               RETURN (dimensional_exponents(0.00000,

 1.00000,

 -2.00000,

 -1.00000,

 0.00000,

 0.00000,

 0.00000));
         henry :
               RETURN (dimensional_exponents(2.00000,

 1.00000,

 -2.00000,

 -2.00000,

 0.00000,

 0.00000,

 0.00000));
         degree_Celsius :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000));
         lumen :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000));
         lux :
               RETURN (dimensional_exponents(-2.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000));
         becquerel :
               RETURN (dimensional_exponents(0.00000,

 0.00000,

 -1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         gray :
               RETURN (dimensional_exponents(2.00000,

 0.00000,

 -2.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
         sievert :
               RETURN (dimensional_exponents(2.00000,

 0.00000,

 -2.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000));
      OTHERWISE :
            RETURN (?);
      END_CASE;
   END_FUNCTION;



   FUNCTION domain_from
      (ref : maths_space_or_function ) : tuple_space;
   LOCAL
      typenames : SET OF STRING := stripped_typeof(ref);
      func : maths_function;
   END_LOCAL;
      IF NOT EXISTS(ref) THEN
         RETURN (?);
      END_IF;
      IF 'TUPLE_SPACE' IN typenames THEN
         RETURN (ref);
      END_IF;
      IF 'MATHS_SPACE' IN typenames THEN
         RETURN (one_tuples_of(ref));
      END_IF;
      func := ref;
      IF 'CONSTANT_FUNCTION' IN typenames THEN
         RETURN (domain_from(func\constant_function.source_of_domain));
      END_IF;
      IF 'SELECTOR_FUNCTION' IN typenames THEN
         RETURN (domain_from(func\selector_function.source_of_domain));
      END_IF;
      IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
         RETURN (domain_from(func\parallel_composed_function.source_of_domain));
      END_IF;
      RETURN (func.domain);
   END_FUNCTION;



   FUNCTION dot_product
      (arg1 : direction;
       arg2 : direction ) : REAL;
   LOCAL
      scalar : REAL;
      vec1 : direction;
      vec2 : direction;
      ndim : INTEGER;
   END_LOCAL;
      IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) THEN
         scalar := ?;
      ELSE
         IF arg1.dim <> arg2.dim THEN
            scalar := ?;
         ELSE
            BEGIN
               vec1 := normalise(arg1);
               vec2 := normalise(arg2);
               ndim := arg1.dim;
               scalar := 0.00000;
               REPEAT i := 1 TO ndim;
                  scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
               END_REPEAT;
            END;
         END_IF;
      END_IF;
      RETURN (scalar);
   END_FUNCTION;



   FUNCTION drop_numeric_constraints
      (spc : maths_space ) : maths_space;
   LOCAL
      typenames : SET OF STRING := stripped_typeof(spc);
      tspc : listed_product_space;
      factors : LIST OF maths_space := [];
      xspc : extended_tuple_space;
   END_LOCAL;
      IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
         RETURN (make_uniform_product_space(drop_numeric_constraints(spc\uniform_product_space.base),

 spc\uniform_product_space.exponent));
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
         tspc := spc;
         REPEAT i := 1 TO SIZEOF(tspc.factors);
            INSERT( factors,

 drop_numeric_constraints(tspc.factors[i]),

 i - 1 );
         END_REPEAT;
         RETURN (make_listed_product_space(factors));
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
         xspc := spc;
         RETURN (make_extended_tuple_space(drop_numeric_constraints(xspc.base),

 drop_numeric_constraints(xspc.extender)));
      END_IF;
      IF subspace_of_es(spc,

 es_numbers) THEN
         RETURN (number_superspace_of(spc));
      END_IF;
      RETURN (spc);
   END_FUNCTION;



   FUNCTION edge_reversed
      (an_edge : edge ) : oriented_edge;
   LOCAL
      the_reverse : oriented_edge;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
         the_reverse := dummy_tri || edge(an_edge.edge_end,

 an_edge.edge_start) || oriented_edge(an_edge\oriented_edge.edge_element,

 NOT an_edge\oriented_edge.orientation);
      ELSE
         the_reverse := dummy_tri || edge(an_edge.edge_end,

 an_edge.edge_start) || oriented_edge(an_edge,

 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION enclose_cregion_in_pregion
      (crgn : cartesian_complex_number_region;
       centre : complex_number_literal ) : polar_complex_number_region;
      FUNCTION angle
         (a : REAL ) : REAL;
         REPEAT WHILE a > 3.14159;
            a := a - 2.00000 * 3.14159;
         END_REPEAT;
         REPEAT WHILE a <= -3.14159;
            a := a + 2.00000 * 3.14159;
         END_REPEAT;
         RETURN (a);
      END_FUNCTION;
      FUNCTION strictly_in
         (z : REAL;
          zitv : real_interval ) : LOGICAL;
         RETURN ((NOT min_exists(zitv) OR (z > real_min(zitv))) AND (NOT max_exists(zitv) OR (z < real_max(zitv))));
      END_FUNCTION;
      PROCEDURE angle_minmax
         (ab : REAL;
          a : REAL;
          a_in : BOOLEAN;
          VAR amin : REAL;
          VAR amax : REAL;
          VAR amin_in : BOOLEAN;
          VAR amax_in : BOOLEAN );
         a := angle(a - ab);
         IF amin = a THEN
            amin_in := amin_in OR a_in;
         END_IF;
         IF amin > a THEN
            amin := a;
            amin_in := a_in;
         END_IF;
         IF amax = a THEN
            amax_in := amax_in OR a_in;
         END_IF;
         IF amax < a THEN
            amax := a;
            amax_in := a_in;
         END_IF;
      END_PROCEDURE;
      PROCEDURE range_max
         (r : REAL;
          incl : BOOLEAN;
          VAR rmax : REAL;
          VAR rmax_in : BOOLEAN );
         IF rmax = r THEN
            rmax_in := rmax_in OR incl;
         END_IF;
         IF rmax < r THEN
            rmax := r;
            rmax_in := incl;
         END_IF;
      END_PROCEDURE;
      PROCEDURE range_min
         (r : REAL;
          incl : BOOLEAN;
          VAR rmin : REAL;
          VAR rmin_in : BOOLEAN );
         IF rmin = r THEN
            rmin_in := rmin_in OR incl;
         END_IF;
         IF (rmin < 0.00000) OR (rmin > r) THEN
            rmin := r;
            rmin_in := incl;
         END_IF;
      END_PROCEDURE;
   LOCAL
      xitv : real_interval;
      yitv : real_interval;
      is_xmin : BOOLEAN;
      is_xmax : BOOLEAN;
      is_ymin : BOOLEAN;
      is_ymax : BOOLEAN;
      xmin : REAL := 0.00000;
      xmax : REAL := 0.00000;
      ymin : REAL := 0.00000;
      ymax : REAL := 0.00000;
      xc : REAL := 0.00000;
      yc : REAL := 0.00000;
      xmin_in : BOOLEAN := FALSE;
      xmax_in : BOOLEAN := FALSE;
      ymin_in : BOOLEAN := FALSE;
      ymax_in : BOOLEAN := FALSE;
      rmin : REAL := -1.00000;
      rmax : REAL := -1.00000;
      amin : REAL := 4.00000;
      amax : REAL := -4.00000;
      rmax_exists : BOOLEAN := TRUE;
      outside : BOOLEAN := TRUE;
      rmin_in : BOOLEAN := FALSE;
      rmax_in : BOOLEAN := FALSE;
      amin_in : BOOLEAN := FALSE;
      amax_in : BOOLEAN := FALSE;
      ab : REAL := 0.00000;
      a : REAL := 0.00000;
      r : REAL := 0.00000;
      incl : BOOLEAN;
      ritv : real_interval;
      aitv : finite_real_interval;
      minclo : open_closed := open;
      maxclo : open_closed := open;
   END_LOCAL;
      IF NOT EXISTS(crgn) OR NOT EXISTS(centre) THEN
         RETURN (?);
      END_IF;
      xitv := crgn.real_constraint;
      yitv := crgn.imag_constraint;
      xc := centre.real_part;
      yc := centre.imag_part;
      is_xmin := min_exists(xitv);
      is_xmax := max_exists(xitv);
      is_ymin := min_exists(yitv);
      is_ymax := max_exists(yitv);
      IF is_xmin THEN
         xmin := real_min(xitv);
         xmin_in := min_included(xitv);
      END_IF;
      IF is_xmax THEN
         xmax := real_max(xitv);
         xmax_in := max_included(xitv);
      END_IF;
      IF is_ymin THEN
         ymin := real_min(yitv);
         ymin_in := min_included(yitv);
      END_IF;
      IF is_ymax THEN
         ymax := real_max(yitv);
         ymax_in := max_included(yitv);
      END_IF;
      rmax_exists := ((is_xmin AND is_xmax) AND is_ymin) AND is_ymax;
      IF is_xmin AND (xc <= xmin) THEN
         ab := 0.00000;
      ELSE
         IF is_ymin AND (yc <= ymin) THEN
            ab := 0.500000 * 3.14159;
         ELSE
            IF is_ymax AND (yc >= ymax) THEN
               ab := -0.500000 * 3.14159;
            ELSE
               IF is_xmax AND (xc >= xmax) THEN
                  ab := 3.14159;
               ELSE
                  outside := FALSE;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      IF NOT outside AND NOT rmax_exists THEN
         RETURN (?);
      END_IF;
      IF (is_xmin AND (xc <= xmin)) AND strictly_in(yc,

 yitv) THEN
         rmin := xmin - xc;
         rmin_in := xmin_in;
      ELSE
         IF (is_ymin AND (yc <= ymin)) AND strictly_in(xc,

 xitv) THEN
            rmin := ymin - yc;
            rmin_in := ymin_in;
         ELSE
            IF (is_ymax AND (yc >= ymax)) AND strictly_in(xc,

 xitv) THEN
               rmin := yc - ymax;
               rmin_in := ymax_in;
            ELSE
               IF (is_xmax AND (xc >= xmax)) AND strictly_in(yc,

 yitv) THEN
                  rmin := xc - xmax;
                  rmin_in := xmax_in;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      IF is_xmin THEN
         IF is_ymin THEN
            r := SQRT((xmin - xc) ** 2 + (ymin - yc) ** 2);
            incl := xmin_in AND ymin_in;
            IF rmax_exists THEN
               range_max( r,

 incl,

 rmax,

 rmax_in );
            END_IF;
            IF outside THEN
               IF r > 0.00000 THEN
                  range_min( r,

 incl,

 rmin,

 rmin_in );
                  a := angle(atan2(ymin - yc,

 xmin - xc) - ab);
                  IF xc = xmin THEN
                     incl := xmin_in;
                  END_IF;
                  IF yc = ymin THEN
                     incl := ymin_in;
                  END_IF;
                  angle_minmax( ab,

 a,

 incl,

 amin,

 amax,

 amin_in,

 amax_in );
               ELSE
                  rmin := 0.00000;
                  rmin_in := xmin_in AND ymin_in;
                  amin := angle(0.00000 - ab);
                  amin_in := ymin_in;
                  amax := angle(0.500000 * 3.14159 - ab);
                  amax_in := xmin_in;
               END_IF;
            END_IF;
         ELSE
            IF xc <= xmin THEN
               angle_minmax( ab,

 -0.500000 * 3.14159,

 (xc = xmin) AND xmin_in,

 amin,

 amax,

 amin_in,

 amax_in );
            END_IF;
         END_IF;
         IF NOT is_ymax AND (xc <= xmin) THEN
            angle_minmax( ab,

 0.500000 * 3.14159,

 (xc = xmin) AND xmin_in,

 amin,

 amax,

 amin_in,

 amax_in );
         END_IF;
      END_IF;
      IF is_ymin THEN
         IF is_xmax THEN
            r := SQRT((xmax - xc) ** 2 + (ymin - yc) ** 2);
            incl := xmax_in AND ymin_in;
            IF rmax_exists THEN
               range_max( r,

 incl,

 rmax,

 rmax_in );
            END_IF;
            IF outside THEN
               IF r > 0.00000 THEN
                  range_min( r,

 incl,

 rmin,

 rmin_in );
                  a := angle(atan2(ymin - yc,

 xmax - xc) - ab);
                  IF xc = xmax THEN
                     incl := xmax_in;
                  END_IF;
                  IF yc = ymin THEN
                     incl := ymin_in;
                  END_IF;
                  angle_minmax( ab,

 a,

 incl,

 amin,

 amax,

 amin_in,

 amax_in );
               ELSE
                  rmin := 0.00000;
                  rmin_in := xmax_in AND ymin_in;
                  amin := angle(0.500000 * 3.14159 - ab);
                  amin_in := ymin_in;
                  amax := angle(3.14159 - ab);
                  amax_in := xmax_in;
               END_IF;
            END_IF;
         ELSE
            IF yc <= ymin THEN
               angle_minmax( ab,

 0.00000,

 (yc = ymin) AND ymin_in,

 amin,

 amax,

 amin_in,

 amax_in );
            END_IF;
         END_IF;
         IF NOT is_xmin AND (yc <= ymin) THEN
            angle_minmax( ab,

 3.14159,

 (yc = ymin) AND ymin_in,

 amin,

 amax,

 amin_in,

 amax_in );
         END_IF;
      END_IF;
      IF is_xmax THEN
         IF is_ymax THEN
            r := SQRT((xmax - xc) ** 2 + (ymax - yc) ** 2);
            incl := xmax_in AND ymax_in;
            IF rmax_exists THEN
               range_max( r,

 incl,

 rmax,

 rmax_in );
            END_IF;
            IF outside THEN
               IF r > 0.00000 THEN
                  range_min( r,

 incl,

 rmin,

 rmin_in );
                  a := angle(atan2(ymax - yc,

 xmax - xc) - ab);
                  IF xc = xmax THEN
                     incl := xmax_in;
                  END_IF;
                  IF yc = ymax THEN
                     incl := ymax_in;
                  END_IF;
                  angle_minmax( ab,

 a,

 incl,

 amin,

 amax,

 amin_in,

 amax_in );
               ELSE
                  rmin := 0.00000;
                  rmin_in := xmax_in AND ymax_in;
                  amin := angle(-3.14159 - ab);
                  amin_in := ymax_in;
                  amax := angle(-0.500000 * 3.14159 - ab);
                  amax_in := xmax_in;
               END_IF;
            END_IF;
         ELSE
            IF xc >= xmax THEN
               angle_minmax( ab,

 0.500000 * 3.14159,

 (xc = xmax) AND xmax_in,

 amin,

 amax,

 amin_in,

 amax_in );
            END_IF;
         END_IF;
         IF NOT is_ymin AND (xc >= xmax) THEN
            angle_minmax( ab,

 -0.500000 * 3.14159,

 (xc = xmax) AND xmax_in,

 amin,

 amax,

 amin_in,

 amax_in );
         END_IF;
      END_IF;
      IF is_ymax THEN
         IF is_xmin THEN
            r := SQRT((xmin - xc) ** 2 + (ymax - yc) ** 2);
            incl := xmin_in AND ymax_in;
            IF rmax_exists THEN
               range_max( r,

 incl,

 rmax,

 rmax_in );
            END_IF;
            IF outside THEN
               IF r > 0.00000 THEN
                  range_min( r,

 incl,

 rmin,

 rmin_in );
                  a := angle(atan2(ymax - yc,

 xmin - xc) - ab);
                  IF xc = xmin THEN
                     incl := xmin_in;
                  END_IF;
                  IF yc = ymax THEN
                     incl := ymax_in;
                  END_IF;
                  angle_minmax( ab,

 a,

 incl,

 amin,

 amax,

 amin_in,

 amax_in );
               ELSE
                  rmin := 0.00000;
                  rmin_in := xmin_in AND ymax_in;
                  amin := angle(0.500000 * 3.14159 - ab);
                  amin_in := ymax_in;
                  amax := angle(3.14159 - ab);
                  amax_in := xmin_in;
               END_IF;
            END_IF;
         ELSE
            IF yc >= ymax THEN
               angle_minmax( ab,

 3.14159,

 (yc = ymax) AND ymax_in,

 amin,

 amax,

 amin_in,

 amax_in );
            END_IF;
         END_IF;
         IF NOT is_xmax AND (yc >= ymax) THEN
            angle_minmax( ab,

 0.00000,

 (yc = ymax) AND ymax_in,

 amin,

 amax,

 amin_in,

 amax_in );
         END_IF;
      END_IF;
      IF outside THEN
         amin := angle(amin + ab);
         IF amin = 3.14159 THEN
            amin := -3.14159;
         END_IF;
         amax := angle(amax + ab);
         IF amax <= amin THEN
            amax := amax + 2.00000 * 3.14159;
         END_IF;
      ELSE
         amin := -3.14159;
         amin_in := FALSE;
         amax := 3.14159;
         amax_in := FALSE;
      END_IF;
      IF amin_in THEN
         minclo := closed;
      END_IF;
      IF amax_in THEN
         maxclo := closed;
      END_IF;
      aitv := make_finite_real_interval(amin,

 minclo,

 amax,

 maxclo);
      minclo := open;
      IF rmin_in THEN
         minclo := closed;
      END_IF;
      IF rmax_exists THEN
         maxclo := open;
         IF rmax_in THEN
            maxclo := closed;
         END_IF;
         ritv := make_finite_real_interval(rmin,

 minclo,

 rmax,

 maxclo);
      ELSE
         ritv := make_real_interval_from_min(rmin,

 minclo);
      END_IF;
      RETURN (make_polar_complex_number_region(centre,

 ritv,

 aitv));
   END_FUNCTION;



   FUNCTION enclose_pregion_in_cregion
      (prgn : polar_complex_number_region ) : cartesian_complex_number_region;
      PROCEDURE nearest_good_direction
         (acart : REAL;
          aitv : finite_real_interval;
          VAR a : REAL;
          VAR a_in : BOOLEAN );
         a := acart;
         a_in := TRUE;
         IF a < aitv.min THEN
            IF a + 2.00000 * 3.14159 < aitv.max THEN
               RETURN;
            END_IF;
            IF a + 2.00000 * 3.14159 = aitv.max THEN
               a_in := max_included(aitv);
               RETURN;
            END_IF;
         ELSE
            IF a = aitv.min THEN
               a_in := min_included(aitv);
               RETURN;
            ELSE
               IF a < aitv.max THEN
                  RETURN;
               ELSE
                  IF a = aitv.max THEN
                     a_in := max_included(aitv);
                     RETURN;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
         IF COS(acart - aitv.max) >= COS(acart - aitv.min) THEN
            a := aitv.max;
            a_in := max_included(aitv);
         ELSE
            a := aitv.min;
            a_in := min_included(aitv);
         END_IF;
      END_PROCEDURE;
   LOCAL
      xc : REAL := 0.00000;
      yc : REAL := 0.00000;
      xmin : REAL := 0.00000;
      xmax : REAL := 0.00000;
      ymin : REAL := 0.00000;
      ymax : REAL := 0.00000;
      ritv : real_interval;
      xitv : real_interval;
      yitv : real_interval;
      aitv : finite_real_interval;
      xmin_exists : BOOLEAN;
      xmax_exists : BOOLEAN;
      ymin_exists : BOOLEAN;
      ymax_exists : BOOLEAN;
      xmin_in : BOOLEAN := FALSE;
      xmax_in : BOOLEAN := FALSE;
      ymin_in : BOOLEAN := FALSE;
      ymax_in : BOOLEAN := FALSE;
      a : REAL := 0.00000;
      r : REAL := 0.00000;
      a_in : BOOLEAN := FALSE;
      min_clo : open_closed := open;
      max_clo : open_closed := open;
   END_LOCAL;
      IF NOT EXISTS(prgn) THEN
         RETURN (?);
      END_IF;
      xc := prgn.centre.real_part;
      yc := prgn.centre.imag_part;
      ritv := prgn.distance_constraint;
      aitv := prgn.direction_constraint;
      nearest_good_direction( 3.14159,

 aitv,

 a,

 a_in );
      IF COS(a) >= 0.00000 THEN
         xmin_exists := TRUE;
         xmin := xc + real_min(ritv) * COS(a);
         xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.00000));
      ELSE
         IF max_exists(ritv) THEN
            xmin_exists := TRUE;
            xmin := xc + real_max(ritv) * COS(a);
            xmin_in := a_in AND max_included(ritv);
         ELSE
            xmin_exists := FALSE;
         END_IF;
      END_IF;
      nearest_good_direction( 0.00000,

 aitv,

 a,

 a_in );
      IF COS(a) <= 0.00000 THEN
         xmax_exists := TRUE;
         xmax := xc + real_min(ritv) * COS(a);
         xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.00000));
      ELSE
         IF max_exists(ritv) THEN
            xmax_exists := TRUE;
            xmax := xc + real_max(ritv) * COS(a);
            xmax_in := a_in AND max_included(ritv);
         ELSE
            xmax_exists := FALSE;
         END_IF;
      END_IF;
      nearest_good_direction( -0.500000 * 3.14159,

 aitv,

 a,

 a_in );
      IF SIN(a) >= 0.00000 THEN
         ymin_exists := TRUE;
         ymin := yc + real_min(ritv) * SIN(a);
         ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.00000));
      ELSE
         IF max_exists(ritv) THEN
            ymin_exists := TRUE;
            ymin := yc + real_max(ritv) * SIN(a);
            ymin_in := a_in AND max_included(ritv);
         ELSE
            ymin_exists := FALSE;
         END_IF;
      END_IF;
      nearest_good_direction( 0.500000 * 3.14159,

 aitv,

 a,

 a_in );
      IF SIN(a) <= 0.00000 THEN
         ymax_exists := TRUE;
         ymax := yc + real_min(ritv) * SIN(a);
         ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.00000));
      ELSE
         IF max_exists(ritv) THEN
            ymax_exists := TRUE;
            ymax := yc + real_max(ritv) * SIN(a);
            ymax_in := a_in AND max_included(ritv);
         ELSE
            ymax_exists := FALSE;
         END_IF;
      END_IF;
      IF NOT (((xmin_exists OR xmax_exists) OR ymin_exists) OR ymax_exists) THEN
         RETURN (?);
      END_IF;
      IF xmin_exists THEN
         IF xmin_in THEN
            min_clo := closed;
         ELSE
            min_clo := open;
         END_IF;
         IF xmax_exists THEN
            IF xmax_in THEN
               max_clo := closed;
            ELSE
               max_clo := open;
            END_IF;
            xitv := make_finite_real_interval(xmin,

 min_clo,

 xmax,

 max_clo);
         ELSE
            xitv := make_real_interval_from_min(xmin,

 min_clo);
         END_IF;
      ELSE
         IF xmax_exists THEN
            IF xmax_in THEN
               max_clo := closed;
            ELSE
               max_clo := open;
            END_IF;
            xitv := make_real_interval_to_max(xmax,

 max_clo);
         ELSE
            xitv := the_reals;
         END_IF;
      END_IF;
      IF ymin_exists THEN
         IF ymin_in THEN
            min_clo := closed;
         ELSE
            min_clo := open;
         END_IF;
         IF ymax_exists THEN
            IF ymax_in THEN
               max_clo := closed;
            ELSE
               max_clo := open;
            END_IF;
            yitv := make_finite_real_interval(ymin,

 min_clo,

 ymax,

 max_clo);
         ELSE
            yitv := make_real_interval_from_min(ymin,

 min_clo);
         END_IF;
      ELSE
         IF ymax_exists THEN
            IF ymax_in THEN
               max_clo := closed;
            ELSE
               max_clo := open;
            END_IF;
            yitv := make_real_interval_to_max(ymax,

 max_clo);
         ELSE
            yitv := the_reals;
         END_IF;
      END_IF;
      RETURN (make_cartesian_complex_number_region(xitv,

 yitv));
   END_FUNCTION;



   FUNCTION enclose_pregion_in_pregion
      (prgn : polar_complex_number_region;
       centre : complex_number_literal ) : polar_complex_number_region;
      FUNCTION angle
         (a : REAL ) : REAL;
         REPEAT WHILE a > 3.14159;
            a := a - 2.00000 * 3.14159;
         END_REPEAT;
         REPEAT WHILE a <= -3.14159;
            a := a + 2.00000 * 3.14159;
         END_REPEAT;
         RETURN (a);
      END_FUNCTION;
      PROCEDURE angle_range
         (VAR amin : REAL;
          VAR amax : REAL );
         amin := angle(amin);
         IF amin = 3.14159 THEN
            amin := -3.14159;
         END_IF;
         amax := angle(amax);
         IF amax <= amin THEN
            amax := amax + 2.00000 * 3.14159;
         END_IF;
      END_PROCEDURE;
      FUNCTION strictly_in
         (a : REAL;
          aitv : finite_real_interval ) : LOGICAL;
         a := angle(a);
         RETURN ((aitv.min < a) AND (a < aitv.max) OR (aitv.min < a + 2.00000 * 3.14159) AND (a + 2.00000 * 3.14159 < aitv.max));
      END_FUNCTION;
      PROCEDURE find_aminmax
         (ab : REAL;
          a0 : REAL;
          a1 : REAL;
          a2 : REAL;
          a3 : REAL;
          in0 : BOOLEAN;
          in1 : BOOLEAN;
          in2 : BOOLEAN;
          in3 : BOOLEAN;
          VAR amin : REAL;
          VAR amax : REAL;
          VAR amin_in : BOOLEAN;
          VAR amax_in : BOOLEAN );
      LOCAL
         a : REAL;
      END_LOCAL;
         amin := angle(a0 - ab);
         amin_in := in0;
         amax := amin;
         amax_in := in0;
         a := angle(a1 - ab);
         IF a = amin THEN
            amin_in := amin_in OR in1;
         END_IF;
         IF a < amin THEN
            amin := a;
            amin_in := in1;
         END_IF;
         IF a = amax THEN
            amax_in := amax_in OR in1;
         END_IF;
         IF a > amax THEN
            amax := a;
            amax_in := in1;
         END_IF;
         a := angle(a2 - ab);
         IF a = amin THEN
            amin_in := amin_in OR in2;
         END_IF;
         IF a < amin THEN
            amin := a;
            amin_in := in2;
         END_IF;
         IF a = amax THEN
            amax_in := amax_in OR in2;
         END_IF;
         IF a > amax THEN
            amax := a;
            amax_in := in2;
         END_IF;
         a := angle(a3 - ab);
         IF a = amin THEN
            amin_in := amin_in OR in3;
         END_IF;
         IF a < amin THEN
            amin := a;
            amin_in := in3;
         END_IF;
         IF a = amax THEN
            amax_in := amax_in OR in3;
         END_IF;
         IF a > amax THEN
            amax := a;
            amax_in := in3;
         END_IF;
         amin := amin + ab;
         amax := amax + ab;
         angle_range( amin,

 amax );
      END_PROCEDURE;
   LOCAL
      ritp : real_interval;
      ritv : real_interval;
      aitp : finite_real_interval;
      aitv : finite_real_interval;
      xp : REAL := 0.00000;
      yp : REAL := 0.00000;
      xc : REAL := 0.00000;
      yc : REAL := 0.00000;
      rmax : REAL := 0.00000;
      rmin : REAL := 0.00000;
      amin : REAL := 0.00000;
      amax : REAL := 0.00000;
      rc : REAL := 0.00000;
      acp : REAL := 0.00000;
      apc : REAL := 0.00000;
      rmax_in : BOOLEAN := FALSE;
      rmin_in : BOOLEAN := FALSE;
      amin_in : BOOLEAN := FALSE;
      amax_in : BOOLEAN := FALSE;
      rmxp : REAL := 0.00000;
      rmnp : REAL := 0.00000;
      x : REAL := 0.00000;
      y : REAL := 0.00000;
      r : REAL := 0.00000;
      a : REAL := 0.00000;
      ab : REAL := 0.00000;
      r0 : REAL := 0.00000;
      a0 : REAL := 0.00000;
      r1 : REAL := 0.00000;
      a1 : REAL := 0.00000;
      r2 : REAL := 0.00000;
      a2 : REAL := 0.00000;
      r3 : REAL := 0.00000;
      a3 : REAL := 0.00000;
      in0 : BOOLEAN := FALSE;
      in1 : BOOLEAN := FALSE;
      in2 : BOOLEAN := FALSE;
      in3 : BOOLEAN := FALSE;
      inn : BOOLEAN := FALSE;
      minclo : open_closed := open;
      maxclo : open_closed := open;
   END_LOCAL;
      IF NOT EXISTS(prgn) OR NOT EXISTS(centre) THEN
         RETURN (?);
      END_IF;
      xp := prgn.centre.real_part;
      yp := prgn.centre.imag_part;
      ritp := prgn.distance_constraint;
      aitp := prgn.direction_constraint;
      xc := centre.real_part;
      yc := centre.imag_part;
      IF (xc = xp) AND (yc = yp) THEN
         RETURN (prgn);
      END_IF;
      rc := SQRT((xp - xc) ** 2 + (yp - yc) ** 2);
      acp := atan2(yp - yc,

 xp - xc);
      apc := atan2(yc - yp,

 xc - xp);
      rmnp := real_min(ritp);
      IF max_exists(ritp) THEN
         rmxp := real_max(ritp);
         IF aitp.max - aitp.min = 2.00000 * 3.14159 THEN
            inn := NOT max_included(aitp);
            a := angle(aitp.min);
            rmax := rc + rmxp;
            rmax_in := max_included(ritp);
            IF inn AND (acp = a) THEN
               rmax_in := FALSE;
            END_IF;
            IF rc > rmxp THEN
               a0 := ASIN(rmxp / rc);
               amin := angle(acp - a0);
               amin_in := max_included(ritp);
               IF amin = 3.14159 THEN
                  amin := -3.14159;
               END_IF;
               amax := angle(acp + a0);
               amax_in := amin_in;
               IF amax < amin THEN
                  amax := amax + 2.00000 * 3.14159;
               END_IF;
               rmin := rc - rmxp;
               rmin_in := amin_in;
               IF inn THEN
                  IF apc = a THEN
                     rmin_in := FALSE;
                  END_IF;
                  IF angle(amin + 0.500000 * 3.14159) = a THEN
                     amin_in := FALSE;
                  END_IF;
                  IF angle(amax - 0.500000 * 3.14159) = a THEN
                     amax_in := FALSE;
                  END_IF;
               END_IF;
            ELSE
               IF rc = rmxp THEN
                  amin := angle(acp - 0.500000 * 3.14159);
                  amin_in := FALSE;
                  IF amin = 3.14159 THEN
                     amin := -3.14159;
                  END_IF;
                  amax := angle(acp + 0.500000 * 3.14159);
                  amax_in := FALSE;
                  IF amax < amin THEN
                     amax := amax + 2.00000 * 3.14159;
                  END_IF;
                  rmin := 0.00000;
                  rmin_in := max_included(ritp);
                  IF inn AND (apc = a) THEN
                     rmin_in := FALSE;
                  END_IF;
               ELSE
                  IF rc > rmnp THEN
                     IF inn AND (apc = a) THEN
                        rmin := 0.00000;
                        rmin_in := FALSE;
                        amin := aitp.min;
                        amin_in := FALSE;
                        amax := aitp.max;
                        amax_in := FALSE;
                     ELSE
                        rmin := 0.00000;
                        rmin_in := TRUE;
                        amin := -3.14159;
                        amin_in := FALSE;
                        amax := 3.14159;
                        amax_in := TRUE;
                     END_IF;
                  ELSE
                     rmin := rmnp - rc;
                     rmin_in := min_included(ritp);
                     amin := -3.14159;
                     amin_in := FALSE;
                     amax := 3.14159;
                     amax_in := TRUE;
                     IF inn THEN
                        IF apc = a THEN
                           rmin_in := FALSE;
                           amin := aitp.min;
                           amin_in := FALSE;
                           amax := aitp.max;
                           amax_in := FALSE;
                        ELSE
                           IF acp = a THEN
                              amin := aitp.min;
                              amin_in := FALSE;
                              amax := aitp.max;
                              amax_in := FALSE;
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         ELSE
            x := xp + rmxp * COS(aitp.min) - xc;
            y := yp + rmxp * SIN(aitp.min) - yc;
            r0 := SQRT(x ** 2 + y ** 2);
            in0 := max_included(ritp) AND min_included(aitp);
            IF r0 <> 0.00000 THEN
               a0 := atan2(y,

 x);
            END_IF;
            x := xp + rmxp * COS(aitp.max) - xc;
            y := yp + rmxp * SIN(aitp.max) - yc;
            r1 := SQRT(x ** 2 + y ** 2);
            in1 := max_included(ritp) AND max_included(aitp);
            IF r1 <> 0.00000 THEN
               a1 := atan2(y,

 x);
            END_IF;
            x := xp + rmnp * COS(aitp.max) - xc;
            y := yp + rmnp * SIN(aitp.max) - yc;
            r2 := SQRT(x ** 2 + y ** 2);
            in2 := min_included(ritp) AND max_included(aitp);
            IF r2 <> 0.00000 THEN
               a2 := atan2(y,

 x);
            ELSE
               a2 := a1;
               in2 := in1;
            END_IF;
            IF r1 = 0.00000 THEN
               a1 := a2;
               in1 := in2;
            END_IF;
            x := xp + rmnp * COS(aitp.min) - xc;
            y := yp + rmnp * SIN(aitp.min) - yc;
            r3 := SQRT(x ** 2 + y ** 2);
            in3 := min_included(ritp) AND min_included(aitp);
            IF r3 <> 0.00000 THEN
               a3 := atan2(y,

 x);
            ELSE
               a3 := a0;
               in3 := in0;
            END_IF;
            IF r0 = 0.00000 THEN
               a0 := a3;
               in0 := in3;
            END_IF;
            IF rmnp = 0.00000 THEN
               in2 := min_included(ritp);
               in3 := in2;
            END_IF;
            IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
               in0 := min_included(aitp);
               in3 := in0;
            ELSE
               IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
                  in1 := max_included(aitp);
                  in2 := in1;
               END_IF;
            END_IF;
            IF strictly_in(acp,

 aitp) THEN
               rmax := rc + rmxp;
               rmax_in := max_included(ritp);
            ELSE
               rmax := r0;
               rmax_in := in0;
               IF rmax = r1 THEN
                  rmax_in := rmax_in OR in1;
               END_IF;
               IF rmax < r1 THEN
                  rmax := r1;
                  rmax_in := in1;
               END_IF;
               IF rmax = r2 THEN
                  rmax_in := rmax_in OR in2;
               END_IF;
               IF rmax < r2 THEN
                  rmax := r2;
                  rmax_in := in2;
               END_IF;
               IF rmax = r3 THEN
                  rmax_in := rmax_in OR in3;
               END_IF;
               IF rmax < r3 THEN
                  rmax := r3;
                  rmax_in := in3;
               END_IF;
            END_IF;
            IF strictly_in(apc,

 aitp) THEN
               IF rc >= rmxp THEN
                  rmin := rc - rmxp;
                  rmin_in := max_included(ritp);
               ELSE
                  IF rc <= rmnp THEN
                     rmin := rmnp - rc;
                     rmin_in := min_included(ritp);
                  ELSE
                     rmin := 0.00000;
                     rmin_in := TRUE;
                  END_IF;
               END_IF;
            ELSE
               rmin := r0;
               rmin_in := in0;
               a := apc - aitp.min;
               r := rc * COS(a);
               IF (rmnp < r) AND (r < rmxp) THEN
                  rmin := rc * SIN(ABS(a));
                  rmin_in := min_included(aitp);
               END_IF;
               a := apc - aitp.max;
               r := rc * COS(a);
               IF (rmnp < r) AND (r < rmxp) THEN
                  r := rc * SIN(ABS(a));
                  inn := max_included(aitp);
                  IF r = rmin THEN
                     rmin_in := rmin_in OR inn;
                  END_IF;
                  IF r < rmin THEN
                     rmin := r;
                     rmin_in := inn;
                  END_IF;
               END_IF;
               IF r1 = rmin THEN
                  rmin_in := rmin_in OR in1;
               END_IF;
               IF r1 < rmin THEN
                  rmin := r1;
                  rmin_in := in1;
               END_IF;
               IF r2 = rmin THEN
                  rmin_in := rmin_in OR in2;
               END_IF;
               IF r2 < rmin THEN
                  rmin := r2;
                  rmin_in := in2;
               END_IF;
               IF r3 = rmin THEN
                  rmin_in := rmin_in OR in3;
               END_IF;
               IF r3 < rmin THEN
                  rmin := r3;
                  rmin_in := in3;
               END_IF;
            END_IF;
            IF rc >= rmxp THEN
               ab := acp;
               find_aminmax( ab,

 a0,

 a1,

 a2,

 a3,

 in0,

 in1,

 in2,

 in3,

 amin,

 amax,

 amin_in,

 amax_in );
               a := ACOS(rmxp / rc);
               IF strictly_in(apc - a,

 aitp) THEN
                  amin := ab - ASIN(rmxp / rc);
                  amin_in := max_included(ritp);
               END_IF;
               IF strictly_in(apc + a,

 aitp) THEN
                  amax := ab + ASIN(rmxp / rc);
                  amax_in := max_included(ritp);
               END_IF;
               angle_range( amin,

 amax );
            ELSE
               IF rc > rmnp THEN
                  ab := angle(0.500000 * (aitp.min + aitp.max));
                  find_aminmax( ab,

 a0,

 a1,

 a2,

 a3,

 in0,

 in1,

 in2,

 in3,

 amin,

 amax,

 amin_in,

 amax_in );
               ELSE
                  ab := angle(0.500000 * (aitp.min + aitp.max));
                  a0 := angle(a0 - ab);
                  a1 := angle(a1 - ab);
                  a2 := angle(a2 - ab);
                  a3 := angle(a3 - ab);
                  IF a3 > a2 THEN
                     a2 := a2 + 2.00000 * 3.14159;
                  END_IF;
                  IF a0 > a1 THEN
                     a0 := a0 + 2.00000 * 3.14159;
                  END_IF;
                  IF a3 < a0 THEN
                     amin := a3;
                     amin_in := in3;
                  ELSE
                     amin := a0;
                     amin_in := in0;
                  END_IF;
                  IF a2 > a1 THEN
                     amax := a2;
                     amax_in := in2;
                  ELSE
                     amax := a1;
                     amax_in := in1;
                  END_IF;
                  IF (amax - amin > 2.00000 * 3.14159) OR (amax - amin = 2.00000 * 3.14159) AND (amin_in OR amax_in) THEN
                     amin := -3.14159;
                     amin_in := FALSE;
                     amax := 3.14159;
                     amax_in := TRUE;
                  ELSE
                     amin := amin + ab;
                     amax := amax + ab;
                     angle_range( amin,

 amax );
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
         IF rmin_in THEN
            minclo := closed;
         END_IF;
         IF rmax_in THEN
            maxclo := closed;
         END_IF;
         ritv := make_finite_real_interval(rmin,

 minclo,

 rmax,

 maxclo);
      ELSE
         IF (rc > rmnp) AND strictly_in(apc,

 aitp) THEN
            RETURN (?);
         END_IF;
         IF aitp.max - aitp.min = 2.00000 * 3.14159 THEN
            a := angle(aitp.min);
            IF rc > rmnp THEN
               IF max_included(aitp) THEN
                  RETURN (?);
               END_IF;
               rmin := 0.00000;
               rmin_in := FALSE;
               amin := aitp.min;
               amin_in := FALSE;
               amax := aitp.max;
               amax_in := FALSE;
            ELSE
               rmin := rmnp - rc;
               rmin_in := min_included(ritp);
               amin := -3.14159;
               amin_in := FALSE;
               amax := 3.14159;
               amax_in := TRUE;
               IF NOT max_included(aitp) THEN
                  IF apc = a THEN
                     rmin_in := FALSE;
                     amin := aitp.min;
                     amin_in := FALSE;
                     amax := aitp.max;
                     amax_in := FALSE;
                  ELSE
                     IF acp = a THEN
                        amin := aitp.min;
                        amin_in := FALSE;
                        amax := aitp.max;
                        amax_in := FALSE;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         ELSE
            a0 := angle(aitp.min);
            in0 := FALSE;
            a1 := angle(aitp.max);
            in1 := FALSE;
            x := xp + rmnp * COS(aitp.max) - xc;
            y := yp + rmnp * SIN(aitp.max) - yc;
            r2 := SQRT(x ** 2 + y ** 2);
            in2 := min_included(ritp) AND max_included(aitp);
            IF r2 <> 0.00000 THEN
               a2 := atan2(y,

 x);
            ELSE
               a2 := a1;
               in2 := in1;
            END_IF;
            x := xp + rmnp * COS(aitp.min) - xc;
            y := yp + rmnp * SIN(aitp.min) - yc;
            r3 := SQRT(x ** 2 + y ** 2);
            in3 := min_included(ritp) AND min_included(aitp);
            IF r3 <> 0.00000 THEN
               a3 := atan2(y,

 x);
            ELSE
               a3 := a0;
               in3 := in0;
            END_IF;
            IF rmnp = 0.00000 THEN
               in2 := min_included(ritp);
               in3 := in2;
            END_IF;
            IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
               in0 := min_included(aitp);
               in3 := in0;
            ELSE
               IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
                  in1 := max_included(aitp);
                  in2 := in1;
               END_IF;
            END_IF;
            IF strictly_in(apc,

 aitp) THEN
               rmin := rmnp - rc;
               rmin_in := min_included(ritp);
            ELSE
               rmin := r2;
               rmin_in := in2;
               a := apc - aitp.min;
               r := rc * COS(a);
               IF rmnp < r THEN
                  rmin := rc * SIN(ABS(a));
                  rmin_in := min_included(aitp);
               END_IF;
               a := apc - aitp.max;
               r := rc * COS(a);
               IF rmnp < r THEN
                  r := rc * SIN(ABS(a));
                  inn := max_included(aitp);
                  IF r = rmin THEN
                     rmin_in := rmin_in OR inn;
                  END_IF;
                  IF r < rmin THEN
                     rmin := r;
                     rmin_in := inn;
                  END_IF;
               END_IF;
               IF r3 = rmin THEN
                  rmin_in := rmin_in OR in3;
               END_IF;
               IF r3 < rmin THEN
                  rmin := r3;
                  rmin_in := in3;
               END_IF;
            END_IF;
            ab := angle(0.500000 * (aitp.min + aitp.max));
            IF rc > rmnp THEN
               find_aminmax( ab,

 a0,

 a1,

 a2,

 a3,

 in0,

 in1,

 in2,

 in3,

 amin,

 amax,

 amin_in,

 amax_in );
            ELSE
               a0 := angle(a0 - ab);
               a1 := angle(a1 - ab);
               a2 := angle(a2 - ab);
               a3 := angle(a3 - ab);
               IF a3 > a2 THEN
                  a2 := a2 + 2.00000 * 3.14159;
               END_IF;
               IF a0 > a1 THEN
                  a0 := a0 + 2.00000 * 3.14159;
               END_IF;
               IF a3 < a0 THEN
                  amin := a3;
                  amin_in := in3;
               ELSE
                  amin := a0;
                  amin_in := in0;
               END_IF;
               IF a2 > a1 THEN
                  amax := a2;
                  amax_in := in2;
               ELSE
                  amax := a1;
                  amax_in := in1;
               END_IF;
               IF (amax - amin > 2.00000 * 3.14159) OR (amax - amin = 2.00000 * 3.14159) AND (amin_in OR amax_in) THEN
                  amin := -3.14159;
                  amin_in := FALSE;
                  amax := 3.14159;
                  amax_in := TRUE;
                  IF (rmin = 0.00000) AND rmin_in THEN
                     RETURN (?);
                  END_IF;
               ELSE
                  amin := amin + ab;
                  amax := amax + ab;
                  angle_range( amin,

 amax );
               END_IF;
            END_IF;
         END_IF;
         IF rmin_in THEN
            minclo := closed;
         END_IF;
         ritv := make_real_interval_from_min(rmin,

 minclo);
      END_IF;
      minclo := open;
      maxclo := open;
      IF amin_in THEN
         minclo := closed;
      END_IF;
      IF amax_in THEN
         maxclo := closed;
      END_IF;
      aitv := make_finite_real_interval(amin,

 minclo,

 amax,

 maxclo);
      RETURN (make_polar_complex_number_region(centre,

 ritv,

 aitv));
   END_FUNCTION;



   FUNCTION equal_cregion_pregion
      (crgn : cartesian_complex_number_region;
       prgn : polar_complex_number_region ) : LOGICAL;
   LOCAL
      arng : REAL;
      amin : REAL;
      xc : REAL;
      yc : REAL;
      aitv : real_interval;
      xitv : real_interval;
      yitv : real_interval;
      c_in : BOOLEAN;
   END_LOCAL;
      IF NOT EXISTS(crgn) OR NOT EXISTS(prgn) THEN
         RETURN (FALSE);
      END_IF;
      IF max_exists(prgn.distance_constraint) THEN
         RETURN (FALSE);
      END_IF;
      IF real_min(prgn.distance_constraint) <> 0.00000 THEN
         RETURN (FALSE);
      END_IF;
      c_in := min_included(prgn.distance_constraint);
      aitv := prgn.direction_constraint;
      amin := aitv.min;
      arng := aitv.max - amin;
      xc := prgn.centre.real_part;
      yc := prgn.centre.imag_part;
      xitv := crgn.real_constraint;
      yitv := crgn.imag_constraint;
      IF arng = 0.500000 * 3.14159 THEN
         IF amin = 0.00000 THEN
            RETURN ((((((NOT max_exists(xitv) AND NOT max_exists(yitv)) AND min_exists(xitv)) AND min_exists(yitv)) AND (real_min(xitv) = xc)) AND (real_min(yitv) = yc)) AND ((((((c_in AND min_included(aitv)) AND max_included(aitv)) AND min_included(xitv)) AND min_included(yitv) OR (((NOT c_in AND NOT min_included(aitv)) AND max_included(aitv)) AND min_included(xitv)) AND NOT min_included(yitv)) OR (((NOT c_in AND min_included(aitv)) AND NOT max_included(aitv)) AND NOT min_included(xitv)) AND min_included(yitv)) OR (((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT min_included(xitv)) AND NOT min_included(yitv)));
         END_IF;
         IF amin = 0.500000 * 3.14159 THEN
            RETURN ((((((max_exists(xitv) AND NOT max_exists(yitv)) AND NOT min_exists(xitv)) AND min_exists(yitv)) AND (real_max(xitv) = xc)) AND (real_min(yitv) = yc)) AND ((((((c_in AND min_included(aitv)) AND max_included(aitv)) AND max_included(xitv)) AND min_included(yitv) OR (((NOT c_in AND NOT min_included(aitv)) AND max_included(aitv)) AND max_included(xitv)) AND NOT min_included(yitv)) OR (((NOT c_in AND min_included(aitv)) AND NOT max_included(aitv)) AND NOT max_included(xitv)) AND min_included(yitv)) OR (((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT max_included(xitv)) AND NOT min_included(yitv)));
         END_IF;
         IF amin = -3.14159 THEN
            RETURN ((((((max_exists(xitv) AND max_exists(yitv)) AND NOT min_exists(xitv)) AND NOT min_exists(yitv)) AND (real_max(xitv) = xc)) AND (real_max(yitv) = yc)) AND ((((((c_in AND min_included(aitv)) AND max_included(aitv)) AND max_included(xitv)) AND max_included(yitv) OR (((NOT c_in AND NOT min_included(aitv)) AND max_included(aitv)) AND max_included(xitv)) AND NOT max_included(yitv)) OR (((NOT c_in AND min_included(aitv)) AND NOT max_included(aitv)) AND NOT max_included(xitv)) AND max_included(yitv)) OR (((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT max_included(xitv)) AND NOT max_included(yitv)));
         END_IF;
         IF amin = -0.500000 * 3.14159 THEN
            RETURN ((((((NOT max_exists(xitv) AND max_exists(yitv)) AND min_exists(xitv)) AND NOT min_exists(yitv)) AND (real_min(xitv) = xc)) AND (real_max(yitv) = yc)) AND ((((((c_in AND min_included(aitv)) AND max_included(aitv)) AND min_included(xitv)) AND max_included(yitv) OR (((NOT c_in AND NOT min_included(aitv)) AND max_included(aitv)) AND min_included(xitv)) AND NOT max_included(yitv)) OR (((NOT c_in AND min_included(aitv)) AND NOT max_included(aitv)) AND NOT min_included(xitv)) AND max_included(yitv)) OR (((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT min_included(xitv)) AND NOT max_included(yitv)));
         END_IF;
      END_IF;
      IF arng = 3.14159 THEN
         IF amin = 0.00000 THEN
            RETURN (((((NOT max_exists(xitv) AND NOT max_exists(yitv)) AND NOT min_exists(xitv)) AND min_exists(yitv)) AND (real_min(yitv) = yc)) AND (((c_in AND min_included(aitv)) AND max_included(aitv)) AND min_included(yitv) OR ((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT min_included(yitv)));
         END_IF;
         IF amin = 0.500000 * 3.14159 THEN
            RETURN (((((max_exists(xitv) AND NOT max_exists(yitv)) AND NOT min_exists(xitv)) AND NOT min_exists(yitv)) AND (real_max(xitv) = xc)) AND (((c_in AND min_included(aitv)) AND max_included(aitv)) AND max_included(xitv) OR ((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT max_included(xitv)));
         END_IF;
         IF amin = -3.14159 THEN
            RETURN (((((NOT max_exists(xitv) AND max_exists(yitv)) AND NOT min_exists(xitv)) AND NOT min_exists(yitv)) AND (real_max(yitv) = yc)) AND (((c_in AND min_included(aitv)) AND max_included(aitv)) AND max_included(yitv) OR ((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT max_included(yitv)));
         END_IF;
         IF amin = -0.500000 * 3.14159 THEN
            RETURN (((((NOT max_exists(xitv) AND NOT max_exists(yitv)) AND min_exists(xitv)) AND NOT min_exists(yitv)) AND (real_min(xitv) = xc)) AND (((c_in AND min_included(aitv)) AND max_included(aitv)) AND min_included(xitv) OR ((NOT c_in AND NOT min_included(aitv)) AND NOT max_included(aitv)) AND NOT min_included(xitv)));
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION equal_maths_functions
      (fun1 : maths_function;
       fun2 : maths_function ) : LOGICAL;
   LOCAL
      cum : LOGICAL;
   END_LOCAL;
      IF fun1 = fun2 THEN
         RETURN (TRUE);
      END_IF;
      cum := equal_maths_spaces(fun1.domain,

 fun2.domain);
      IF cum = FALSE THEN
         RETURN (FALSE);
      END_IF;
      cum := cum AND equal_maths_spaces(fun1.range,

 fun2.range);
      IF cum = FALSE THEN
         RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
   END_FUNCTION;



   FUNCTION equal_maths_spaces
      (spc1 : maths_space;
       spc2 : maths_space ) : LOGICAL;
   LOCAL
      spc1types : SET OF STRING := stripped_typeof(spc1);
      spc2types : SET OF STRING := stripped_typeof(spc2);
      set1 : SET OF maths_value;
      set2 : SET OF maths_value;
      cum : LOGICAL := TRUE;
      base : maths_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
      factors2 : LIST OF maths_space;
      fs1 : function_space;
      fs2 : function_space;
      cum2 : LOGICAL;
   END_LOCAL;
      IF spc1 = spc2 THEN
         RETURN (TRUE);
      END_IF;
      IF 'FINITE_SPACE' IN spc1types THEN
         set1 := spc1\finite_space.members;
         IF 'FINITE_SPACE' IN spc2types THEN
            set2 := spc2\finite_space.members;
            REPEAT i := 1 TO SIZEOF(set1);
               cum := cum AND member_of(set1[i],

 spc2);
               IF cum = FALSE THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            IF cum = TRUE THEN
               REPEAT i := 1 TO SIZEOF(set2);
                  cum := cum AND member_of(set2[i],

 spc1);
                  IF cum = FALSE THEN
                     RETURN (FALSE);
                  END_IF;
               END_REPEAT;
            END_IF;
            RETURN (cum);
         END_IF;
         IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
            set2 := [];
            REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
               set2 := set2 + [ i ];
            END_REPEAT;
            RETURN (equal_maths_spaces(spc1,

 make_finite_space(set2)));
         END_IF;
      END_IF;
      IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
         set1 := [];
         REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
            set1 := set1 + [ i ];
         END_REPEAT;
         RETURN (equal_maths_spaces(make_finite_space(set1),

 spc2));
      END_IF;
      IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
         RETURN (equal_cregion_pregion(spc1,

 spc2));
      END_IF;
      IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
         RETURN (equal_cregion_pregion(spc2,

 spc1));
      END_IF;
      IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
         base := spc1\uniform_product_space.base;
         expnt := spc1\uniform_product_space.exponent;
         IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
            IF expnt <> spc2\uniform_product_space.exponent THEN
               RETURN (FALSE);
            END_IF;
            RETURN (equal_maths_spaces(base,

 spc2\uniform_product_space.base));
         END_IF;
         IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
            factors := spc2\listed_product_space.factors;
            IF expnt <> SIZEOF(factors) THEN
               RETURN (FALSE);
            END_IF;
            REPEAT i := 1 TO SIZEOF(factors);
               cum := cum AND equal_maths_spaces(base,

 factors[i]);
               IF cum = FALSE THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (cum);
         END_IF;
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
         factors := spc1\listed_product_space.factors;
         IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
            IF spc2\uniform_product_space.exponent <> SIZEOF(factors) THEN
               RETURN (FALSE);
            END_IF;
            base := spc2\uniform_product_space.base;
            REPEAT i := 1 TO SIZEOF(factors);
               cum := cum AND equal_maths_spaces(base,

 factors[i]);
               IF cum = FALSE THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (cum);
         END_IF;
         IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
            factors2 := spc2\listed_product_space.factors;
            IF SIZEOF(factors) <> SIZEOF(factors2) THEN
               RETURN (FALSE);
            END_IF;
            REPEAT i := 1 TO SIZEOF(factors);
               cum := cum AND equal_maths_spaces(factors[i],

 factors2[i]);
               IF cum = FALSE THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (cum);
         END_IF;
      END_IF;
      IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
         RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,

 spc2\extended_tuple_space.extender) AND equal_maths_spaces(spc1\extended_tuple_space.base,

 spc2\extended_tuple_space.base));
      END_IF;
      IF ('FUNCTION_SPACE' IN spc1types) AND ('FUNCTION_SPACE' IN spc2types) THEN
         fs1 := spc1;
         fs2 := spc2;
         IF fs1.domain_constraint <> fs2.domain_constraint THEN
            IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
               RETURN (FALSE);
            END_IF;
            IF fs1.domain_constraint <> sc_subspace THEN
               fs1 := spc2;
               fs2 := spc1;
            END_IF;
            IF (fs1.domain_constraint <> sc_subspace) OR (fs2.domain_constraint <> sc_member) THEN
               RETURN (UNKNOWN);
            END_IF;
            IF any_space_satisfies(fs1.domain_constraint,

 fs1.domain_argument) <> any_space_satisfies(fs2.domain_constraint,

 fs2.domain_argument) THEN
               RETURN (FALSE);
            END_IF;
            IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
               RETURN (FALSE);
            END_IF;
            IF SIZEOF([ 'FINITE_SPACE',

 'FINITE_INTEGER_INTERVAL' ] * stripped_typeof(fs1.domain_argument)) = 0 THEN
               RETURN (FALSE);
            END_IF;
            RETURN (UNKNOWN);
         END_IF;
         cum := equal_maths_spaces(fs1.domain_argument,

 fs2.domain_argument);
         IF cum = FALSE THEN
            RETURN (FALSE);
         END_IF;
         IF fs1.range_constraint <> fs2.range_constraint THEN
            IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
               RETURN (FALSE);
            END_IF;
            IF fs1.range_constraint <> sc_subspace THEN
               fs1 := spc2;
               fs2 := spc1;
            END_IF;
            IF (fs1.range_constraint <> sc_subspace) OR (fs2.range_constraint <> sc_member) THEN
               RETURN (UNKNOWN);
            END_IF;
            IF any_space_satisfies(fs1.range_constraint,

 fs1.range_argument) <> any_space_satisfies(fs2.range_constraint,

 fs2.range_argument) THEN
               RETURN (FALSE);
            END_IF;
            IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
               RETURN (FALSE);
            END_IF;
            IF SIZEOF([ 'FINITE_SPACE',

 'FINITE_INTEGER_INTERVAL' ] * stripped_typeof(fs1.range_argument)) = 0 THEN
               RETURN (FALSE);
            END_IF;
            RETURN (UNKNOWN);
         END_IF;
         cum := cum AND equal_maths_spaces(fs1.range_argument,

 fs2.range_argument);
         RETURN (cum);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION equal_maths_values
      (val1 : maths_value;
       val2 : maths_value ) : LOGICAL;
      FUNCTION mem_of_vs
         (val1 : maths_value;
          val2 : maths_value ) : LOGICAL;
         IF NOT has_values_space(val2) THEN
            RETURN (UNKNOWN);
         END_IF;
         IF NOT member_of(val1,

 values_space_of(val2)) THEN
            RETURN (FALSE);
         END_IF;
         RETURN (UNKNOWN);
      END_FUNCTION;
   LOCAL
      types1 : SET OF STRING;
      types2 : SET OF STRING;
      list1 : LIST OF maths_value;
      list2 : LIST OF maths_value;
      cum : LOGICAL := TRUE;
   END_LOCAL;
      IF NOT EXISTS(val1) OR NOT EXISTS(val2) THEN
         RETURN (FALSE);
      END_IF;
      IF val1 = val2 THEN
         RETURN (TRUE);
      END_IF;
      types1 := stripped_typeof(val1);
      types2 := stripped_typeof(val2);
      IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1) THEN
         IF 'MATHS_ATOM' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'LIST' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'MATHS_SPACE' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'MATHS_FUNCTION' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'GENERIC_EXPRESSION' IN types2 THEN
            RETURN (mem_of_vs(val1,

 val2));
         END_IF;
         RETURN (UNKNOWN);
      END_IF;
      IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2) THEN
         RETURN (equal_maths_values(val2,

 val1));
      END_IF;
      IF 'LIST' IN types1 THEN
         IF 'LIST' IN types2 THEN
            list1 := val1;
            list2 := val2;
            IF SIZEOF(list1) <> SIZEOF(list2) THEN
               RETURN (FALSE);
            END_IF;
            REPEAT i := 1 TO SIZEOF(list1);
               cum := cum AND equal_maths_values(list1[i],

 list2[i]);
               IF cum = FALSE THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (cum);
         END_IF;
         IF 'MATHS_SPACE' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'MATHS_FUNCTION' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'GENERIC_EXPRESSION' IN types2 THEN
            RETURN (mem_of_vs(val1,

 val2));
         END_IF;
         RETURN (UNKNOWN);
      END_IF;
      IF 'LIST' IN types2 THEN
         RETURN (equal_maths_values(val2,

 val1));
      END_IF;
      IF 'MATHS_SPACE' IN types1 THEN
         IF 'MATHS_SPACE' IN types2 THEN
            RETURN (equal_maths_spaces(val1,

 val2));
         END_IF;
         IF 'MATHS_FUNCTION' IN types2 THEN
            RETURN (FALSE);
         END_IF;
         IF 'GENERIC_EXPRESSION' IN types2 THEN
            RETURN (mem_of_vs(val1,

 val2));
         END_IF;
         RETURN (UNKNOWN);
      END_IF;
      IF 'MATHS_SPACE' IN types2 THEN
         RETURN (equal_maths_values(val2,

 val1));
      END_IF;
      IF 'MATHS_FUNCTION' IN types1 THEN
         IF 'MATHS_FUNCTION' IN types2 THEN
            RETURN (equal_maths_functions(val1,

 val2));
         END_IF;
         IF 'GENERIC_EXPRESSION' IN types2 THEN
            RETURN (mem_of_vs(val1,

 val2));
         END_IF;
         RETURN (UNKNOWN);
      END_IF;
      IF 'MATHS_FUNCTION' IN types2 THEN
         RETURN (equal_maths_values(val2,

 val1));
      END_IF;
      IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2) THEN
         IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
            RETURN (UNKNOWN);
         END_IF;
         IF NOT compatible_spaces(values_space_of(val1),

 values_space_of(val2)) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      RETURN (UNKNOWN);
   END_FUNCTION;



   FUNCTION es_subspace_of_es
      (es1 : elementary_space_enumerators;
       es2 : elementary_space_enumerators ) : BOOLEAN;
      IF NOT EXISTS(es1) OR NOT EXISTS(es2) THEN
         RETURN (FALSE);
      END_IF;
      IF es1 = es2 THEN
         RETURN (TRUE);
      END_IF;
      IF es2 = es_generics THEN
         RETURN (TRUE);
      END_IF;
      IF (es1 = es_booleans) AND (es2 = es_logicals) THEN
         RETURN (TRUE);
      END_IF;
      IF (es2 = es_numbers) AND (((es1 = es_complex_numbers) OR (es1 = es_reals)) OR (es1 = es_integers)) THEN
         RETURN (TRUE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION expression_is_constant
      (expr : generic_expression ) : BOOLEAN;
      RETURN (bool(SIZEOF(free_variables_of(expr)) = 0));
   END_FUNCTION;



   FUNCTION extremal_position_check
      (fun : linearized_table_function ) : BOOLEAN;
   LOCAL
      source_domain : maths_space;
      source_interval : finite_integer_interval;
      index : INTEGER := 1;
      base : INTEGER;
      shape : LIST OF positive_integer;
      ndim : positive_integer;
      slo : INTEGER;
      shi : INTEGER;
      sublo : LIST OF INTEGER := [];
      subhi : LIST OF INTEGER := [];
   END_LOCAL;
      IF NOT EXISTS(fun) THEN
         RETURN (FALSE);
      END_IF;
      source_domain := factor1(fun.source.domain);
      IF schema_prefix + 'TUPLE_SPACE' IN TYPEOF(source_domain) THEN
         source_domain := factor1(source_domain);
      END_IF;
      IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(source_domain)) THEN
         RETURN (FALSE);
      END_IF;
      source_interval := source_domain;
      base := fun\explicit_table_function.index_base;
      shape := fun\explicit_table_function.shape;
      IF schema_prefix + 'STANDARD_TABLE_FUNCTION' IN TYPEOF(fun) THEN
         REPEAT j := 1 TO SIZEOF(shape);
            index := index * shape[j];
         END_REPEAT;
         index := fun.first + index - 1;
         RETURN (bool((source_interval.min <= index) AND (index <= source_interval.max)));
      END_IF;
      IF schema_prefix + 'REGULAR_TABLE_FUNCTION' IN TYPEOF(fun) THEN
         ndim := SIZEOF(fun\explicit_table_function.shape);
         REPEAT j := 1 TO ndim;
            slo := base;
            shi := base + shape[j] - 1;
            IF fun\regular_table_function.increments[j] >= 0 THEN
               INSERT( sublo,

 slo,

 j - 1 );
               INSERT( subhi,

 shi,

 j - 1 );
            ELSE
               INSERT( sublo,

 shi,

 j - 1 );
               INSERT( subhi,

 slo,

 j - 1 );
            END_IF;
         END_REPEAT;
         index := regular_indexing(sublo,

 base,

 shape,

 fun\regular_table_function.increments,

 fun.first);
         IF NOT ((source_interval.min <= index) AND (index <= source_interval.max)) THEN
            RETURN (FALSE);
         END_IF;
         index := regular_indexing(subhi,

 base,

 shape,

 fun\regular_table_function.increments,

 fun.first);
         IF NOT ((source_interval.min <= index) AND (index <= source_interval.max)) THEN
            RETURN (FALSE);
         END_IF;
         RETURN (TRUE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION face_bound_reversed
      (a_face_bound : face_bound ) : face_bound;
   LOCAL
      the_reverse : face_bound;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound) THEN
         the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,

 NOT a_face_bound\face_bound.orientation) || face_outer_bound();
      ELSE
         the_reverse := dummy_tri || face_bound(a_face_bound.bound,

 NOT a_face_bound.orientation);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION face_reversed
      (a_face : face ) : oriented_face;
   LOCAL
      the_reverse : oriented_face;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
         the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face\oriented_face.face_element,

 NOT a_face\oriented_face.orientation);
      ELSE
         the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face,

 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION factor1
      (tspace : tuple_space ) : maths_space;
   LOCAL
      typenames : SET OF STRING := TYPEOF(tspace);
   END_LOCAL;
      IF schema_prefix + 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
         RETURN (tspace\uniform_product_space.base);
      END_IF;
      IF schema_prefix + 'LISTED_PRODUCT_SPACE' IN typenames THEN
         RETURN (tspace\listed_product_space.factors[1]);
      END_IF;
      IF schema_prefix + 'EXTENDED_TUPLE_SPACE' IN typenames THEN
         RETURN (factor1(tspace\extended_tuple_space.base));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION factor_space
      (tspace : tuple_space;
       idx : positive_integer ) : maths_space;
   LOCAL
      typenames : SET OF STRING := TYPEOF(tspace);
   END_LOCAL;
      IF schema_prefix + 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
         IF idx <= tspace\uniform_product_space.exponent THEN
            RETURN (tspace\uniform_product_space.base);
         END_IF;
         RETURN (?);
      END_IF;
      IF schema_prefix + 'LISTED_PRODUCT_SPACE' IN typenames THEN
         IF idx <= SIZEOF(tspace\listed_product_space.factors) THEN
            RETURN (tspace\listed_product_space.factors[idx]);
         END_IF;
         RETURN (?);
      END_IF;
      IF schema_prefix + 'EXTENDED_TUPLE_SPACE' IN typenames THEN
         IF idx <= space_dimension(tspace\extended_tuple_space.base) THEN
            RETURN (factor_space(tspace\extended_tuple_space.base,

 idx));
         END_IF;
         RETURN (tspace\extended_tuple_space.extender);
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION first_proj_axis
      (z_axis : direction;
       arg : direction ) : direction;
   LOCAL
      x_axis : direction;
      v : direction;
      z : direction;
      x_vec : vector;
   END_LOCAL;
      IF NOT EXISTS(z_axis) THEN
         RETURN (?);
      ELSE
         z := normalise(z_axis);
         IF NOT EXISTS(arg) THEN
            IF (z.direction_ratios <> [ 1.00000,

 0.00000,

 0.00000 ]) AND (z.direction_ratios <> [ -1.00000,

 0.00000,

 0.00000 ]) THEN
               v := dummy_gri || direction([ 1.00000,

 0.00000,

 0.00000 ]);
            ELSE
               v := dummy_gri || direction([ 0.00000,

 1.00000,

 0.00000 ]);
            END_IF;
         ELSE
            IF arg.dim <> 3 THEN
               RETURN (?);
            END_IF;
            IF cross_product(arg,

 z).magnitude = 0.00000 THEN
               RETURN (?);
            ELSE
               v := normalise(arg);
            END_IF;
         END_IF;
         x_vec := scalar_times_vector(dot_product(v,

 z),

 z);
         x_axis := vector_difference(v,

 x_vec).orientation;
         x_axis := normalise(x_axis);
      END_IF;
      RETURN (x_axis);
   END_FUNCTION;



   FUNCTION free_variables_of
      (expr : generic_expression ) : SET OF generic_variable;
   LOCAL
      typenames : SET OF STRING := stripped_typeof(expr);
      result : SET OF generic_variable := [];
      exprs : LIST OF generic_expression := [];
   END_LOCAL;
      IF 'GENERIC_LITERAL' IN typenames THEN
         RETURN (result);
      END_IF;
      IF 'GENERIC_VARIABLE' IN typenames THEN
         result := result + expr;
         RETURN (result);
      END_IF;
      IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
         exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands| NOT (ge IN expr\quantifier_expression.variables));
         REPEAT i := 1 TO SIZEOF(exprs);
            result := result + free_variables_of(exprs[i]);
         END_REPEAT;
         REPEAT i := 1 TO SIZEOF(expr\quantifier_expression.variables);
            result := result - expr\quantifier_expression.variables[i];
         END_REPEAT;
         RETURN (result);
      END_IF;
      IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
         RETURN (free_variables_of(expr\unary_generic_expression.operand));
      END_IF;
      IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
         result := free_variables_of(expr\binary_generic_expression.operands[1]);
         RETURN (result + free_variables_of(expr\binary_generic_expression.operands[2]));
      END_IF;
      IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
         REPEAT i := 1 TO SIZEOF(expr\multiple_arity_generic_expression.operands);
            result := result + free_variables_of(expr\multiple_arity_generic_expression.operands[i]);
         END_REPEAT;
         RETURN (result);
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION function_applicability
      (func : maths_function_select;
       arguments : LIST [1:?] OF maths_value ) : BOOLEAN;
   LOCAL
      domain : tuple_space := convert_to_maths_function(func).domain;
      domain_types : SET OF STRING := TYPEOF(domain);
      narg : positive_integer := SIZEOF(arguments);
      arg : generic_expression;
   END_LOCAL;
      IF schema_prefix + 'PRODUCT_SPACE' IN domain_types THEN
         IF space_dimension(domain) <> narg THEN
            RETURN (FALSE);
         END_IF;
      ELSE
         IF schema_prefix + 'EXTENDED_TUPLE_SPACE' IN domain_types THEN
            IF space_dimension(domain) > narg THEN
               RETURN (FALSE);
            END_IF;
         ELSE
            RETURN (FALSE);
         END_IF;
      END_IF;
      REPEAT i := 1 TO narg;
         arg := convert_to_operand(arguments[i]);
         IF NOT has_values_space(arg) THEN
            RETURN (FALSE);
         END_IF;
         IF NOT compatible_spaces(factor_space(domain,

 i),

 values_space_of(arg)) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION function_is_1d_array
      (func : maths_function ) : BOOLEAN;
   LOCAL
      temp : maths_space;
   END_LOCAL;
      IF NOT EXISTS(func) THEN
         RETURN (FALSE);
      END_IF;
      IF space_dimension(func.domain) <> 1 THEN
         RETURN (FALSE);
      END_IF;
      temp := factor1(func.domain);
      IF schema_prefix + 'PRODUCT_SPACE' IN TYPEOF(temp) THEN
         IF space_dimension(temp) <> 1 THEN
            RETURN (FALSE);
         END_IF;
         temp := factor1(temp);
      END_IF;
      IF schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp) THEN
         RETURN (TRUE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION function_is_1d_table
      (func : maths_function ) : BOOLEAN;
   LOCAL
      temp : maths_space;
      itvl : finite_integer_interval;
   END_LOCAL;
      IF NOT EXISTS(func) THEN
         RETURN (FALSE);
      END_IF;
      IF space_dimension(func.domain) <> 1 THEN
         RETURN (FALSE);
      END_IF;
      temp := factor1(func.domain);
      IF schema_prefix + 'PRODUCT_SPACE' IN TYPEOF(temp) THEN
         IF space_dimension(temp) <> 1 THEN
            RETURN (FALSE);
         END_IF;
         temp := factor1(temp);
      END_IF;
      IF schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp) THEN
         itvl := temp;
         RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION function_is_2d_table
      (func : maths_function ) : BOOLEAN;
   LOCAL
      temp : maths_space;
      pspace : product_space;
      itvl1 : finite_integer_interval;
      itvl2 : finite_integer_interval;
   END_LOCAL;
      IF NOT EXISTS(func) THEN
         RETURN (FALSE);
      END_IF;
      IF space_dimension(func.domain) <> 1 THEN
         RETURN (FALSE);
      END_IF;
      temp := factor1(func.domain);
      IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN
         RETURN (FALSE);
      END_IF;
      pspace := temp;
      IF space_dimension(pspace) <> 2 THEN
         RETURN (FALSE);
      END_IF;
      temp := factor1(pspace);
      IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
         RETURN (FALSE);
      END_IF;
      itvl1 := temp;
      temp := factor_space(pspace,

 2);
      IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
         RETURN (FALSE);
      END_IF;
      itvl2 := temp;
      RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
   END_FUNCTION;



   FUNCTION function_is_array
      (func : maths_function ) : BOOLEAN;
   LOCAL
      tspace : tuple_space;
      temp : maths_space;
   END_LOCAL;
      IF NOT EXISTS(func) THEN
         RETURN (FALSE);
      END_IF;
      tspace := func.domain;
      IF (space_dimension(tspace) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN TYPEOF(factor1(tspace))) THEN
         tspace := factor1(tspace);
      END_IF;
      IF NOT (schema_prefix + 'PRODUCT_SPACE' IN TYPEOF(tspace)) THEN
         RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO space_dimension(tspace);
         temp := factor_space(tspace,

 i);
         IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp)) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION function_is_table
      (func : maths_function ) : BOOLEAN;
   LOCAL
      tspace : tuple_space;
      temp : maths_space;
      base : INTEGER;
   END_LOCAL;
      IF NOT EXISTS(func) THEN
         RETURN (FALSE);
      END_IF;
      tspace := func.domain;
      IF (space_dimension(tspace) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN TYPEOF(factor1(tspace))) THEN
         tspace := factor1(tspace);
      END_IF;
      IF NOT (schema_prefix + 'PRODUCT_SPACE' IN TYPEOF(tspace)) THEN
         RETURN (FALSE);
      END_IF;
      temp := factor1(tspace);
      IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp)) THEN
         RETURN (FALSE);
      END_IF;
      base := temp\finite_integer_interval.min;
      IF (base <> 0) AND (base <> 1) THEN
         RETURN (FALSE);
      END_IF;
      REPEAT i := 2 TO space_dimension(tspace);
         temp := factor_space(tspace,

 i);
         IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp)) THEN
            RETURN (FALSE);
         END_IF;
         IF temp\finite_integer_interval.min <> base THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION gbsf_check_curve
      (cv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE' ] * TYPEOF(cv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) THEN
            RETURN (TRUE);
         ELSE
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) THEN
               RETURN (SIZEOF(QUERY (seg <* cv\composite_curve.segments| NOT gbsf_check_curve(seg.parent_curve))) = 0);
            ELSE
               IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' ] * TYPEOF(cv)) = 1 THEN
                  RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
               ELSE
                  IF (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' ] * TYPEOF(cv)) = 1) AND (cv\offset_curve_3d.self_intersect = FALSE) THEN
                     RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
                  ELSE
                     IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' ] * TYPEOF(cv)) = 1 THEN
                        RETURN (gbsf_check_curve(cv\pcurve.reference_to_curve.items[1]) AND gbsf_check_surface(cv\pcurve.basis_surface));
                     ELSE
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                           IF (SIZEOF(cv\polyline.points) >= 3) AND (SIZEOF(bag_to_set(USEDIN(cv,

 '')) - bag_to_set(USEDIN(cv,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE.CURVE_3D'))) = 0) THEN
                              RETURN (TRUE);
                           END_IF;
                        ELSE
                           IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' ] * TYPEOF(cv)) = 1 THEN
                              IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                                 REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                                    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                       IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                                          RETURN (FALSE);
                                       END_IF;
                                    ELSE
                                       IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                                             RETURN (FALSE);
                                          END_IF;
                                       END_IF;
                                    END_IF;
                                 END_REPEAT;
                                 RETURN (TRUE);
                              END_IF;
                           ELSE
                              IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' IN TYPEOF(cv) THEN
                                 IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARABOLA',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.HYPERBOLA' ] * TYPEOF(cv\trimmed_curve.basis_curve)) = 1 THEN
                                    RETURN (TRUE);
                                 ELSE
                                    RETURN (gbsf_check_curve(cv\trimmed_curve.basis_curve));
                                 END_IF;
                              END_IF;
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION gbsf_check_point
      (pnt : point ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
            RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
               RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
                  RETURN (gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve.items[1]) AND gbsf_check_surface(pnt\degenerate_pcurve.basis_surface));
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION gbsf_check_surface
      (sf : surface ) : BOOLEAN;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) THEN
         RETURN (TRUE);
      ELSE
         IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPHERICAL_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TOROIDAL_SURFACE' ] * TYPEOF(sf)) = 1 THEN
            RETURN (TRUE);
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN
               IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONICAL_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CYLINDRICAL_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' ] * TYPEOF(sf\curve_bounded_surface.basis_surface)) = 1 THEN
                  RETURN (SIZEOF(QUERY (bcurve <* sf\curve_bounded_surface.boundaries| NOT gbsf_check_curve(bcurve))) = 0);
               ELSE
                  IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface) THEN
                     RETURN (SIZEOF(QUERY (bcurve <* sf\curve_bounded_surface.boundaries| NOT gbsf_check_curve(bcurve))) = 0);
                  END_IF;
               END_IF;
            ELSE
               IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) THEN
                  RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
               ELSE
                  IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
                     REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
                        REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
                           IF NOT gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface) THEN
                              RETURN (FALSE);
                           END_IF;
                        END_REPEAT;
                     END_REPEAT;
                     RETURN (TRUE);
                  ELSE
                     IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(sf) THEN
                        IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONICAL_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CYLINDRICAL_SURFACE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' ] * TYPEOF(sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN
                           RETURN (TRUE);
                        ELSE
                           RETURN (gbsf_check_surface(sf\rectangular_trimmed_surface.basis_surface));
                        END_IF;
                     ELSE
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' IN TYPEOF(sf) THEN
                           RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
                        ELSE
                           IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(sf) THEN
                              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION get_basis_surface
      (c : curve_on_surface ) : SET [0:2] OF surface;
   LOCAL
      surfs : SET [0:2] OF surface;
      n : INTEGER;
   END_LOCAL;
      surfs := [];
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(c) THEN
         surfs := [ c\pcurve.basis_surface ];
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
            n := SIZEOF(c\surface_curve.associated_geometry);
            REPEAT i := 1 TO n;
               surfs := surfs + associated_surface(c\surface_curve.associated_geometry[i]);
            END_REPEAT;
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) THEN
         n := SIZEOF(c\composite_curve.segments);
         surfs := get_basis_surface(c\composite_curve.segments[1].parent_curve);
         IF n > 1 THEN
            REPEAT i := 2 TO n;
               surfs := surfs * get_basis_surface(c\composite_curve.segments[i].parent_curve);
            END_REPEAT;
         END_IF;
      END_IF;
      RETURN (surfs);
   END_FUNCTION;



   FUNCTION get_description_value
      (obj : description_attribute_select ) : text;
   LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
   END_LOCAL;
      IF SIZEOF(description_bag) = 1 THEN
         RETURN (description_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_id_value
      (obj : id_attribute_select ) : identifier;
   LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
   END_LOCAL;
      IF SIZEOF(id_bag) = 1 THEN
         RETURN (id_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_name_value
      (obj : name_attribute_select ) : label;
   LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM');
   END_LOCAL;
      IF SIZEOF(name_bag) = 1 THEN
         RETURN (name_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_role
      (obj : role_select ) : object_role;
   LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE');
   END_LOCAL;
      IF SIZEOF(role_bag) = 1 THEN
         RETURN (role_bag[1].role);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION has_values_space
      (expr : generic_expression ) : BOOLEAN;
   LOCAL
      typenames : SET OF STRING := stripped_typeof(expr);
   END_LOCAL;
      IF 'EXPRESSION' IN typenames THEN
         RETURN (bool((('NUMERIC_EXPRESSION' IN typenames) OR ('STRING_EXPRESSION' IN typenames)) OR ('BOOLEAN_EXPRESSION' IN typenames)));
      END_IF;
      IF 'MATHS_FUNCTION' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'FUNCTION_APPLICATION' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'MATHS_SPACE' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'MATHS_VARIABLE' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
         RETURN (has_values_space(expr\unary_generic_expression.operand));
      END_IF;
      IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'LOGICAL_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'BINARY_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'MATHS_ENUM_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'REAL_TUPLE_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'ATOM_BASED_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION instance_unique
      (the_bag : BAG OF GENERIC : intype ) : BOOLEAN;
   LOCAL
      the_set : SET OF GENERIC : intype := [];
      i : INTEGER;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      IF SIZEOF(the_bag) > 0 THEN
         the_set := bag_to_set(the_bag);
      END_IF;
      IF NOT (SIZEOF(the_set) = SIZEOF(the_bag)) THEN
         pass := FALSE;
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_SQL_mappable
      (arg : expression ) : BOOLEAN;
   LOCAL
      i : INTEGER;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SIMPLE_NUMERIC_EXPRESSION' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SQL_MAPPABLE_DEFINED_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MINUS_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand));
      END_IF;
      IF ((((((((((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ABS_FUNCTION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SIN_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COS_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TAN_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ASIN_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ACOS_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ATAN_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXP_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LOG_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LOG2_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LOG10_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VALUE_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_FUNCTION' IN TYPEOF(arg)) THEN
         RETURN (FALSE);
      END_IF;
      IF ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLUS_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MULT_EXPRESSION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAXIMUM_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MINIMUM_FUNCTION' IN TYPEOF(arg)) THEN
         REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
            IF NOT is_SQL_mappable(arg\multiple_arity_numeric_expression.operands[i]) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
         RETURN (TRUE);
      END_IF;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MINUS_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SLASH_EXPRESSION' IN TYPEOF(arg)) THEN
         RETURN (is_SQL_mappable(arg\binary_numeric_expression.operands[1]) AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
      END_IF;
      IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DIV_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MOD_EXPRESSION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POWER_EXPRESSION' IN TYPEOF(arg)) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SIMPLE_BOOLEAN_EXPRESSION' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NOT_EXPRESSION' IN TYPEOF(arg) THEN
         RETURN (is_SQL_mappable(arg\unary_generic_expression.operand));
      END_IF;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ODD_FUNCTION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.XOR_EXPRESSION' IN TYPEOF(arg)) THEN
         RETURN (FALSE);
      END_IF;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AND_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OR_EXPRESSION' IN TYPEOF(arg)) THEN
         REPEAT i := 1 TO SIZEOF(arg\multiple_arity_Boolean_expression.operands);
            IF NOT is_SQL_mappable(arg\multiple_arity_Boolean_expression.operands[i]) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EQUALS_EXPRESSION' IN TYPEOF(arg) THEN
         RETURN (is_SQL_mappable(arg\binary_generic_expression.operands[1]) AND is_SQL_mappable(arg\binary_generic_expression.operands[2]));
      END_IF;
      IF (((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPARISON_EQUAL' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPARISON_GREATER' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPARISON_GREATER_EQUAL' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPARISON_LESS' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPARISON_LESS_EQUAL' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPARISON_NOT_EQUAL' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LIKE_EXPRESSION' IN TYPEOF(arg)) THEN
         RETURN (is_SQL_mappable(arg\comparison_expression.operands[1]) AND is_SQL_mappable(arg\comparison_expression.operands[2]));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.INTERVAL_EXPRESSION' IN TYPEOF(arg) THEN
         RETURN ((is_SQL_mappable(arg\interval_expression.interval_low) AND is_SQL_mappable(arg\interval_expression.interval_high)) AND is_SQL_mappable(arg\interval_expression.interval_item));
      END_IF;
      IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NUMERIC_DEFINED_FUNCTION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SIMPLE_STRING_EXPRESSION' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.INDEX_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBSTRING_EXPRESSION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONCAT_EXPRESSION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FORMAT_FUNCTION' IN TYPEOF(arg)) THEN
         RETURN (FALSE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION is_acyclic
      (arg : generic_expression ) : BOOLEAN;
      RETURN (acyclic(arg,

 []));
   END_FUNCTION;



   FUNCTION is_assembly_module_design
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'physical design') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_assembly_module_macro_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'macro occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_assembly_module_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'physical occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_assembly_module_usage
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'physical design usage') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_bottom_footprint_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pds : SET OF property_definition := bag_to_set(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION'));
      fo : SET OF shape_aspect := [];
      sar : SET OF shape_aspect_relationship := [];
      dri : SET OF descriptive_representation_item := [];
      pdr : SET OF property_definition_representation := [];
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pds) BY 1;
         fo := fo + bag_to_set(QUERY (sa <* USEDIN(pds[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa))));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fo) BY 1;
         sar := sar + bag_to_set(QUERY (sar <* USEDIN(fo[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND ('usage definition' = sar\shape_aspect_relationship.name)));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         pdr := pdr + bag_to_set(QUERY (pdr <* USEDIN(sar[i].relating_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'product definition context description')));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr) BY 1;
         dri := dri + QUERY (dri <* pdr[i].used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'text')) AND (dri.description = 'bottom'));
      END_REPEAT;
      IF SIZEOF(dri) = 1 THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_bottom_footprint_occurrence_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_bottom_footprint_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_bottom_padstack_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pds : SET OF property_definition := bag_to_set(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION'));
      fo : SET OF shape_aspect := [];
      sar : SET OF shape_aspect_relationship := [];
      dri : SET OF descriptive_representation_item := [];
      pdr : SET OF property_definition_representation := [];
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pds) BY 1;
         fo := fo + bag_to_set(QUERY (sa <* USEDIN(pds[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PADSTACK_OCCURRENCE' IN TYPEOF(sa))));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fo) BY 1;
         sar := sar + bag_to_set(QUERY (sar <* USEDIN(fo[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PADSTACK_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND ('usage definition' = sar\shape_aspect_relationship.name)));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         pdr := pdr + bag_to_set(QUERY (pdr <* USEDIN(sar[i].relating_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'product definition context description')));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr) BY 1;
         dri := dri + QUERY (dri <* pdr[i].used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'text')) AND (dri.description = 'bottom'));
      END_REPEAT;
      IF SIZEOF(dri) = 1 THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_bottom_padstack_occurrence_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_bottom_padstack_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_ee_product_definition
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF (((((((NOT is_laminate_component(pd) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd)) THEN
         RETURN (TRUE);
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_int_expr
      (arg : numeric_expression ) : BOOLEAN;
   LOCAL
      i : INTEGER;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.INT_LITERAL' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REAL_LITERAL' IN TYPEOF(arg) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ABS_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (is_int_expr(arg\unary_numeric_expression.operand));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MINUS_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (is_int_expr(arg\unary_numeric_expression.operand));
      END_IF;
      IF (((((((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SIN_FUNCTION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COS_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TAN_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ASIN_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ACOS_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ATAN_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXP_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LOG_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LOG2_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LOG10_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg)) THEN
         RETURN (FALSE);
      END_IF;
      IF ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLUS_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MULT_EXPRESSION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAXIMUM_FUNCTION' IN TYPEOF(arg))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MINIMUM_FUNCTION' IN TYPEOF(arg)) THEN
         REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
            IF NOT is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
         RETURN (TRUE);
      END_IF;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MINUS_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POWER_EXPRESSION' IN TYPEOF(arg)) THEN
         RETURN (is_int_expr(arg\binary_numeric_expression.operands[1]) AND is_int_expr(arg\binary_numeric_expression.operands[2]));
      END_IF;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DIV_EXPRESSION' IN TYPEOF(arg)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MOD_EXPRESSION' IN TYPEOF(arg)) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SLASH_EXPRESSION' IN TYPEOF(arg) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VALUE_FUNCTION' IN TYPEOF(arg) THEN
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.INT_VALUE_FUNCTION' IN TYPEOF(arg) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.INTEGER_DEFINED_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.STRING_DEFINED_FUNCTION' IN TYPEOF(arg) THEN
         RETURN (FALSE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION is_interconnect_module_component_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_interconnect_module_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_interconnect_module_design
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'physical design') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_interconnect_module_macro_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'macro occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_interconnect_module_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'physical occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_interconnect_module_usage
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'physical design usage') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_laminate_component
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF pd\product_definition.description = 'laminate component' THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_COMPONENT' IN TYPEOF(pd) THEN
            RETURN (TRUE);
         END_IF;
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_laminate_component_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_laminate_component(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_symmetrical_footprint_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pds : SET OF property_definition := bag_to_set(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION'));
      fo : SET OF shape_aspect := [];
      sar : SET OF shape_aspect_relationship := [];
      dri : SET OF descriptive_representation_item := [];
      pdr : SET OF property_definition_representation := [];
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pds) BY 1;
         fo := fo + bag_to_set(QUERY (sa <* USEDIN(pds[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa))));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fo) BY 1;
         sar := sar + bag_to_set(QUERY (sar <* USEDIN(fo[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND ('usage definition' = sar\shape_aspect_relationship.name)));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         pdr := pdr + bag_to_set(QUERY (pdr <* USEDIN(sar[i].relating_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'product definition context description')));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr) BY 1;
         dri := dri + QUERY (dri <* pdr[i].used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'text')) AND (dri.description = 'symmetrical'));
      END_REPEAT;
      IF SIZEOF(dri) = 1 THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_symmetrical_footprint_occurrence_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_symmetrical_footprint_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_symmetrical_padstack_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pds : SET OF property_definition := bag_to_set(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION'));
      fo : SET OF shape_aspect := [];
      sar : SET OF shape_aspect_relationship := [];
      dri : SET OF descriptive_representation_item := [];
      pdr : SET OF property_definition_representation := [];
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pds) BY 1;
         fo := fo + bag_to_set(QUERY (sa <* USEDIN(pds[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PADSTACK_OCCURRENCE' IN TYPEOF(sa))));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fo) BY 1;
         sar := sar + bag_to_set(QUERY (sar <* USEDIN(fo[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PADSTACK_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND ('usage definition' = sar\shape_aspect_relationship.name)));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         pdr := pdr + bag_to_set(QUERY (pdr <* USEDIN(sar[i].relating_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'product definition context description')));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr) BY 1;
         dri := dri + QUERY (dri <* pdr[i].used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'text')) AND (dri.description = 'symmetrical'));
      END_REPEAT;
      IF SIZEOF(dri) = 1 THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_symmetrical_padstack_occurrence_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_symmetrical_padstack_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_top_footprint_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pds : SET OF property_definition := bag_to_set(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION'));
      fo : SET OF shape_aspect := [];
      sar : SET OF shape_aspect_relationship := [];
      dri : SET OF descriptive_representation_item := [];
      pdr : SET OF property_definition_representation := [];
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pds) BY 1;
         fo := fo + bag_to_set(QUERY (sa <* USEDIN(pds[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa))));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fo) BY 1;
         sar := sar + bag_to_set(QUERY (sar <* USEDIN(fo[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND ('usage definition' = sar\shape_aspect_relationship.name)));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         pdr := pdr + bag_to_set(QUERY (pdr <* USEDIN(sar[i].relating_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'product definition context description')));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr) BY 1;
         dri := dri + QUERY (dri <* pdr[i].used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'text')) AND (dri.description = 'top'));
      END_REPEAT;
      IF SIZEOF(dri) = 1 THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_top_footprint_occurrence_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_top_footprint_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_top_padstack_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pds : SET OF property_definition := bag_to_set(USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION'));
      fo : SET OF shape_aspect := [];
      sar : SET OF shape_aspect_relationship := [];
      dri : SET OF descriptive_representation_item := [];
      pdr : SET OF property_definition_representation := [];
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pds) BY 1;
         fo := fo + bag_to_set(QUERY (sa <* USEDIN(pds[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PADSTACK_OCCURRENCE' IN TYPEOF(sa))));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fo) BY 1;
         sar := sar + bag_to_set(QUERY (sar <* USEDIN(fo[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PADSTACK_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND ('usage definition' = sar\shape_aspect_relationship.name)));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         pdr := pdr + bag_to_set(QUERY (pdr <* USEDIN(sar[i].relating_shape_aspect.of_shape.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'product definition context description')));
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr) BY 1;
         dri := dri + QUERY (dri <* pdr[i].used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'text')) AND (dri.description = 'top'));
      END_REPEAT;
      IF SIZEOF(dri) = 1 THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_top_padstack_occurrence_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_top_padstack_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION item_in_context
      (item : representation_item;
       cntxt : representation_context ) : BOOLEAN;
   LOCAL
      y : BAG OF representation_item;
   END_LOCAL;
      IF SIZEOF(USEDIN(item,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS') * cntxt.representations_in_context) > 0 THEN
         RETURN (TRUE);
      ELSE
         y := QUERY (z <* USEDIN(item,

 '')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z));
         IF SIZEOF(y) > 0 THEN
            REPEAT i := 1 TO HIINDEX(y);
               IF item_in_context(y[i],

 cntxt) THEN
                  RETURN (TRUE);
               END_IF;
            END_REPEAT;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION leap_year
      (year : year_number ) : BOOLEAN;
      IF (year MOD 4 = 0) AND (year MOD 100 <> 0) OR (year MOD 400 = 0) THEN
         RETURN (TRUE);
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION list_face_loops
      (f : face ) : LIST [0:?] OF loop;
   LOCAL
      loops : LIST [0:?] OF loop := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(f.bounds);
         loops := loops + f.bounds[i].bound;
      END_REPEAT;
      RETURN (loops);
   END_FUNCTION;



   FUNCTION list_of_topology_reversed
      (a_list : list_of_reversible_topology_item ) : list_of_reversible_topology_item;
   LOCAL
      the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
      the_reverse := [];
      REPEAT i := 1 TO SIZEOF(a_list);
         the_reverse := topology_reversed(a_list[i]) + the_reverse;
      END_REPEAT;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION list_selected_components
      (aggr : AGGREGATE OF LIST OF maths_value;
       k : positive_integer ) : LIST OF maths_value;
   LOCAL
      result : LIST OF maths_value := [];
      j : INTEGER := 0;
   END_LOCAL;
      REPEAT i := LOINDEX(aggr) TO HIINDEX(aggr);
         IF k <= SIZEOF(aggr[i]) THEN
            INSERT( result,

 aggr[i][k],

 j );
            j := j + 1;
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION list_to_array
      (lis : LIST [0:?] OF GENERIC : T;
       low : INTEGER;
       u : INTEGER ) : ARRAY [low:u] OF GENERIC : T;
   LOCAL
      n : INTEGER;
      res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      n := SIZEOF(lis);
      IF n <> u - low + 1 THEN
         RETURN (?);
      ELSE
         res := [ lis[1] ];
         REPEAT i := 2 TO n;
            res[(low + i - 1)] := lis[i];
         END_REPEAT;
         RETURN (res);
      END_IF;
   END_FUNCTION;



   FUNCTION list_to_set
      (l : LIST [0:?] OF GENERIC : T ) : SET OF GENERIC : T;
   LOCAL
      s : SET OF GENERIC : T := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(l);
         s := s + l[i];
      END_REPEAT;
      RETURN (s);
   END_FUNCTION;



   FUNCTION make_array_of_array
      (lis : LIST [1:?] OF LIST [1:?] OF GENERIC : T;
       low1 : INTEGER;
       u1 : INTEGER;
       low2 : INTEGER;
       u2 : INTEGER ) : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;
      IF u1 - low1 + 1 <> SIZEOF(lis) THEN
         RETURN (?);
      END_IF;
      IF u2 - low2 + 1 <> SIZEOF(lis[1]) THEN
         RETURN (?);
      END_IF;
      res := [ list_to_array(lis[1],

 low2,

 u2) ];
      REPEAT i := 2 TO HIINDEX(lis);
         IF u2 - low2 + 1 <> SIZEOF(lis[i]) THEN
            RETURN (?);
         END_IF;
         res[(low1 + i - 1)] := list_to_array(lis[i],

 low2,

 u2);
      END_REPEAT;
      RETURN (res);
   END_FUNCTION;



   FUNCTION make_atom_based_literal
      (lit_value : atom_based_value ) : atom_based_literal;
      RETURN (atom_based_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
   END_FUNCTION;



   FUNCTION make_binary_literal
      (lit_value : BINARY ) : binary_literal;
      RETURN (binary_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
   END_FUNCTION;



   FUNCTION make_boolean_literal
      (lit_value : BOOLEAN ) : boolean_literal;
      RETURN (boolean_literal(lit_value) || simple_boolean_expression() || boolean_expression() || expression() || generic_expression() || simple_generic_expression() || generic_literal());
   END_FUNCTION;



   FUNCTION make_cartesian_complex_number_region
      (real_constraint : real_interval;
       imag_constraint : real_interval ) : cartesian_complex_number_region;
      RETURN (cartesian_complex_number_region(real_constraint,

 imag_constraint) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_complex_number_literal
      (rpart : REAL;
       ipart : REAL ) : complex_number_literal;
      RETURN (complex_number_literal(rpart,

 ipart) || generic_literal() || simple_generic_expression() || generic_expression());
   END_FUNCTION;



   FUNCTION make_elementary_function
      (func_id : elementary_function_enumerators ) : elementary_function;
      RETURN (elementary_function(func_id) || maths_function() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_elementary_space
      (space_id : elementary_space_enumerators ) : elementary_space;
      RETURN (elementary_space(space_id) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_extended_tuple_space
      (base : product_space;
       extender : maths_space ) : extended_tuple_space;
      RETURN (extended_tuple_space(base,

 extender) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_finite_integer_interval
      (min : INTEGER;
       max : INTEGER ) : finite_integer_interval;
      RETURN (finite_integer_interval(min,

 max) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_finite_real_interval
      (min : REAL;
       minclo : open_closed;
       max : REAL;
       maxclo : open_closed ) : finite_real_interval;
      RETURN (finite_real_interval(min,

 minclo,

 max,

 maxclo) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_finite_space
      (members : SET OF maths_value ) : finite_space;
      RETURN (finite_space(members) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_function_application
      (afunction : maths_function_select;
       arguments : LIST [1:?] OF maths_value ) : function_application;
      RETURN (function_application(afunction,

 arguments) || multiple_arity_generic_expression((convert_to_maths_function(afunction) + convert_to_operands(arguments))) || generic_expression());
   END_FUNCTION;



   FUNCTION make_function_space
      (domain_constraint : space_constraint_type;
       domain_argument : maths_space;
       range_constraint : space_constraint_type;
       range_argument : maths_space ) : function_space;
      RETURN (function_space(domain_constraint,

 domain_argument,

 range_constraint,

 range_argument) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_int_literal
      (lit_value : INTEGER ) : int_literal;
      RETURN (int_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() || expression() || generic_expression() || simple_generic_expression() || generic_literal());
   END_FUNCTION;



   FUNCTION make_listed_product_space
      (factors : LIST OF maths_space ) : listed_product_space;
      RETURN (listed_product_space(factors) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_logical_literal
      (lit_value : LOGICAL ) : logical_literal;
      RETURN (logical_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
   END_FUNCTION;



   FUNCTION make_maths_enum_literal
      (lit_value : maths_enum_atom ) : maths_enum_literal;
      RETURN (maths_enum_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
   END_FUNCTION;



   FUNCTION make_maths_tuple_literal
      (lit_value : LIST OF maths_value ) : maths_tuple_literal;
      RETURN (maths_tuple_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
   END_FUNCTION;



   FUNCTION make_parallel_composed_function
      (srcdom : maths_space_or_function;
       prepfuncs : LIST [2:?] OF maths_function;
       finfunc : maths_function_select ) : parallel_composed_function;
      RETURN (parallel_composed_function(srcdom,

 prepfuncs,

 finfunc) || maths_function() || generic_expression() || multiple_arity_generic_expression(convert_to_operands_prcmfn(srcdom,

 prepfuncs,

 finfunc)));
   END_FUNCTION;



   FUNCTION make_polar_complex_number_region
      (centre : complex_number_literal;
       dis_constraint : real_interval;
       dir_constraint : finite_real_interval ) : polar_complex_number_region;
      RETURN (polar_complex_number_region(centre,

 dis_constraint,

 dir_constraint) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_real_interval_from_min
      (min : REAL;
       minclo : open_closed ) : real_interval_from_min;
      RETURN (real_interval_from_min(min,

 minclo) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_real_interval_to_max
      (max : REAL;
       maxclo : open_closed ) : real_interval_to_max;
      RETURN (real_interval_to_max(max,

 maxclo) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION make_real_literal
      (lit_value : REAL ) : real_literal;
      RETURN (real_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() || expression() || generic_expression() || simple_generic_expression() || generic_literal());
   END_FUNCTION;



   FUNCTION make_string_literal
      (lit_value : STRING ) : string_literal;
      RETURN (string_literal(lit_value) || simple_string_expression() || string_expression() || expression() || generic_expression() || simple_generic_expression() || generic_literal());
   END_FUNCTION;



   FUNCTION make_uniform_product_space
      (base : maths_space;
       exponent : positive_integer ) : uniform_product_space;
      RETURN (uniform_product_space(base,

 exponent) || maths_space() || generic_expression() || generic_literal() || simple_generic_expression());
   END_FUNCTION;



   FUNCTION max_exists
      (spc : maths_space ) : BOOLEAN;
   LOCAL
      types : SET OF STRING := TYPEOF(spc);
   END_LOCAL;
      RETURN (bool((((schema_prefix + 'FINITE_INTEGER_INTERVAL' IN types) OR (schema_prefix + 'INTEGER_INTERVAL_TO_MAX' IN types)) OR (schema_prefix + 'FINITE_REAL_INTERVAL' IN types)) OR (schema_prefix + 'REAL_INTERVAL_TO_MAX' IN types)));
   END_FUNCTION;



   FUNCTION max_included
      (spc : maths_space ) : BOOLEAN;
   LOCAL
      types : SET OF STRING := TYPEOF(spc);
   END_LOCAL;
      IF (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN types) OR (schema_prefix + 'INTEGER_INTERVAL_TO_MAX' IN types) THEN
         RETURN (TRUE);
      END_IF;
      IF schema_prefix + 'FINITE_REAL_INTERVAL' IN types THEN
         RETURN (bool(spc\finite_real_interval.max_closure = closed));
      END_IF;
      IF schema_prefix + 'REAL_INTERVAL_TO_MAX' IN types THEN
         RETURN (bool(spc\real_interval_to_max.max_closure = closed));
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION member_of
      (val : GENERIC : G;
       spc : maths_space ) : LOGICAL;
      FUNCTION fedex
         (val : AGGREGATE OF GENERIC : x;
          i : INTEGER ) : GENERIC : x;
         RETURN (val[i]);
      END_FUNCTION;
   LOCAL
      v : maths_value := simplify_maths_value(convert_to_maths_value(val));
      vtypes : SET OF STRING := stripped_typeof(v);
      s : maths_space := simplify_maths_space(spc);
      stypes : SET OF STRING := stripped_typeof(s);
      tmp_int : INTEGER;
      tmp_real : REAL;
      tmp_cmplx : complex_number_literal;
      lgcl : LOGICAL;
      cum : LOGICAL;
      vspc : maths_space;
      sspc : maths_space;
      smem : SET OF maths_value;
      factors : LIST OF maths_space;
   END_LOCAL;
      IF NOT EXISTS(s) THEN
         RETURN (FALSE);
      END_IF;
      IF NOT EXISTS(v) THEN
         RETURN (s = the_generics);
      END_IF;
      IF ((('GENERIC_EXPRESSION' IN vtypes) AND NOT ('MATHS_SPACE' IN vtypes)) AND NOT ('MATHS_FUNCTION' IN vtypes)) AND NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes) THEN
         IF has_values_space(v) THEN
            vspc := values_space_of(v);
            IF subspace_of(vspc,

 s) THEN
               RETURN (TRUE);
            END_IF;
            IF NOT compatible_spaces(vspc,

 s) THEN
               RETURN (FALSE);
            END_IF;
            RETURN (UNKNOWN);
         END_IF;
         RETURN (UNKNOWN);
      END_IF;
      IF 'ELEMENTARY_SPACE' IN stypes THEN
         CASE s\elementary_space.space_id OF
            es_numbers :
                  RETURN (('NUMBER' IN vtypes) OR ('COMPLEX_NUMBER_LITERAL' IN vtypes));
            es_complex_numbers :
                  RETURN ('COMPLEX_NUMBER_LITERAL' IN vtypes);
            es_reals :
                  RETURN (('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
            es_integers :
                  RETURN ('INTEGER' IN vtypes);
            es_logicals :
                  RETURN ('LOGICAL' IN vtypes);
            es_booleans :
                  RETURN ('BOOLEAN' IN vtypes);
            es_strings :
                  RETURN ('STRING' IN vtypes);
            es_binarys :
                  RETURN ('BINARY' IN vtypes);
            es_maths_spaces :
                  RETURN ('MATHS_SPACE' IN vtypes);
            es_maths_functions :
                  RETURN ('MATHS_FUNCTION' IN vtypes);
            es_generics :
                  RETURN (TRUE);
         END_CASE;
      END_IF;
      IF 'FINITE_INTEGER_INTERVAL' IN stypes THEN
         IF 'INTEGER' IN vtypes THEN
            tmp_int := v;
            RETURN ((s\finite_integer_interval.min <= tmp_int) AND (tmp_int <= s\finite_integer_interval.max));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes THEN
         IF 'INTEGER' IN vtypes THEN
            tmp_int := v;
            RETURN (s\integer_interval_from_min.min <= tmp_int);
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'INTEGER_INTERVAL_TO_MAX' IN stypes THEN
         IF 'INTEGER' IN vtypes THEN
            tmp_int := v;
            RETURN (tmp_int <= s\integer_interval_to_max.max);
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'FINITE_REAL_INTERVAL' IN stypes THEN
         IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
            tmp_real := v;
            IF s\finite_real_interval.min_closure = closed THEN
               IF s\finite_real_interval.max_closure = closed THEN
                  RETURN ((s\finite_real_interval.min <= tmp_real) AND (tmp_real <= s\finite_real_interval.max));
               ELSE
                  RETURN ((s\finite_real_interval.min <= tmp_real) AND (tmp_real < s\finite_real_interval.max));
               END_IF;
            ELSE
               IF s\finite_real_interval.max_closure = closed THEN
                  RETURN ((s\finite_real_interval.min < tmp_real) AND (tmp_real <= s\finite_real_interval.max));
               ELSE
                  RETURN ((s\finite_real_interval.min < tmp_real) AND (tmp_real < s\finite_real_interval.max));
               END_IF;
            END_IF;
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'REAL_INTERVAL_FROM_MIN' IN stypes THEN
         IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
            tmp_real := v;
            IF s\real_interval_from_min.min_closure = closed THEN
               RETURN (s\real_interval_from_min.min <= tmp_real);
            ELSE
               RETURN (s\real_interval_from_min.min < tmp_real);
            END_IF;
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'REAL_INTERVAL_TO_MAX' IN stypes THEN
         IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
            tmp_real := v;
            IF s\real_interval_to_max.max_closure = closed THEN
               RETURN (tmp_real <= s\real_interval_to_max.max);
            ELSE
               RETURN (tmp_real < s\real_interval_to_max.max);
            END_IF;
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes THEN
         IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
            RETURN (member_of(v\complex_number_literal.real_part,

 s\cartesian_complex_number_region.real_constraint) AND member_of(v\complex_number_literal.imag_part,

 s\cartesian_complex_number_region.imag_constraint));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes THEN
         IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
            tmp_cmplx := v;
            tmp_cmplx.real_part := tmp_cmplx.real_part - s\polar_complex_number_region.centre.real_part;
            tmp_cmplx.imag_part := tmp_cmplx.imag_part - s\polar_complex_number_region.centre.imag_part;
            tmp_real := SQRT(tmp_cmplx.real_part ** 2 + tmp_cmplx.imag_part ** 2);
            IF NOT member_of(tmp_real,

 s\polar_complex_number_region.distance_constraint) THEN
               RETURN (FALSE);
            END_IF;
            IF tmp_real = 0.00000 THEN
               RETURN (TRUE);
            END_IF;
            tmp_real := atan2(tmp_cmplx.imag_part,

 tmp_cmplx.real_part);
            RETURN (member_of(tmp_real,

 s\polar_complex_number_region.direction_constraint) OR member_of(tmp_real + 2.00000 * 3.14159,

 s\polar_complex_number_region.direction_constraint));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'FINITE_SPACE' IN stypes THEN
         smem := s\finite_space.members;
         cum := FALSE;
         REPEAT i := 1 TO SIZEOF(smem);
            cum := cum OR equal_maths_values(v,

 smem[i]);
            IF cum = TRUE THEN
               RETURN (TRUE);
            END_IF;
         END_REPEAT;
         RETURN (cum);
      END_IF;
      IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
         IF 'LIST' IN vtypes THEN
            IF SIZEOF(v) = s\uniform_product_space.exponent THEN
               sspc := s\uniform_product_space.base;
               cum := TRUE;
               REPEAT i := 1 TO SIZEOF(v);
                  cum := cum AND member_of(v[i],

 sspc);
                  IF cum = FALSE THEN
                     RETURN (FALSE);
                  END_IF;
               END_REPEAT;
               RETURN (cum);
            END_IF;
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
         IF 'LIST' IN vtypes THEN
            factors := s\listed_product_space.factors;
            IF SIZEOF(v) = SIZEOF(factors) THEN
               cum := TRUE;
               REPEAT i := 1 TO SIZEOF(v);
                  cum := cum AND member_of(v[i],

 factors[i]);
                  IF cum = FALSE THEN
                     RETURN (FALSE);
                  END_IF;
               END_REPEAT;
               RETURN (cum);
            END_IF;
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
         IF 'LIST' IN vtypes THEN
            sspc := s\extended_tuple_space.base;
            tmp_int := space_dimension(sspc);
            IF SIZEOF(v) >= tmp_int THEN
               cum := TRUE;
               REPEAT i := 1 TO tmp_int;
                  cum := cum AND member_of(v[i],

 factor_space(sspc,

 i));
                  IF cum = FALSE THEN
                     RETURN (FALSE);
                  END_IF;
               END_REPEAT;
               sspc := s\extended_tuple_space.extender;
               REPEAT i := tmp_int + 1 TO SIZEOF(v);
                  cum := cum AND member_of(v[i],

 sspc);
                  IF cum = FALSE THEN
                     RETURN (FALSE);
                  END_IF;
               END_REPEAT;
               RETURN (cum);
            END_IF;
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'FUNCTION_SPACE' IN stypes THEN
         IF 'MATHS_FUNCTION' IN vtypes THEN
            vspc := v\maths_function.domain;
            sspc := s\function_space.domain_argument;
            CASE s\function_space.domain_constraint OF
               sc_equal :
                     cum := equal_maths_spaces(vspc,

 sspc);
               sc_subspace :
                     cum := subspace_of(vspc,

 sspc);
               sc_member :
                     cum := member_of(vspc,

 sspc);
            END_CASE;
            IF cum = FALSE THEN
               RETURN (FALSE);
            END_IF;
            vspc := v\maths_function.range;
            sspc := s\function_space.range_argument;
            CASE s\function_space.range_constraint OF
               sc_equal :
                     cum := cum AND equal_maths_spaces(vspc,

 sspc);
               sc_subspace :
                     cum := cum AND subspace_of(vspc,

 sspc);
               sc_member :
                     cum := cum AND member_of(vspc,

 sspc);
            END_CASE;
            RETURN (cum);
         END_IF;
         RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
   END_FUNCTION;



   FUNCTION min_exists
      (spc : maths_space ) : BOOLEAN;
   LOCAL
      types : SET OF STRING := TYPEOF(spc);
   END_LOCAL;
      RETURN (bool((((schema_prefix + 'FINITE_INTEGER_INTERVAL' IN types) OR (schema_prefix + 'INTEGER_INTERVAL_FROM_MIN' IN types)) OR (schema_prefix + 'FINITE_REAL_INTERVAL' IN types)) OR (schema_prefix + 'REAL_INTERVAL_FROM_MIN' IN types)));
   END_FUNCTION;



   FUNCTION min_included
      (spc : maths_space ) : BOOLEAN;
   LOCAL
      types : SET OF STRING := TYPEOF(spc);
   END_LOCAL;
      IF (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN types) OR (schema_prefix + 'INTEGER_INTERVAL_FROM_MIN' IN types) THEN
         RETURN (TRUE);
      END_IF;
      IF schema_prefix + 'FINITE_REAL_INTERVAL' IN types THEN
         RETURN (bool(spc\finite_real_interval.min_closure = closed));
      END_IF;
      IF schema_prefix + 'REAL_INTERVAL_FROM_MIN' IN types THEN
         RETURN (bool(spc\real_interval_from_min.min_closure = closed));
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION mixed_loop_type_set
      (l : SET [0:?] OF loop ) : LOGICAL;
   LOCAL
      poly_loop_type : LOGICAL;
   END_LOCAL;
      IF SIZEOF(l) <= 1 THEN
         RETURN (FALSE);
      END_IF;
      poly_loop_type := 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
      REPEAT i := 2 TO SIZEOF(l);
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type THEN
            RETURN (TRUE);
         END_IF;
      END_REPEAT;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION msb_shells
      (brep : manifold_solid_brep;
       schema_name : STRING ) : SET [1:?] OF closed_shell;
      IF schema_name + '.BREP_WITH_VOIDS' IN TYPEOF(brep) THEN
         RETURN (brep\brep_with_voids.voids + brep.outer);
      ELSE
         RETURN ([ brep.outer ]);
      END_IF;
   END_FUNCTION;



   FUNCTION msf_curve_check
      (cv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' ] * TYPEOF(cv)) > 1 THEN
         RETURN (FALSE);
      ELSE
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) THEN
            RETURN (TRUE);
         ELSE
            IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE' ] * TYPEOF(cv)) = 1 THEN
               RETURN (TRUE);
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
                  RETURN (msf_curve_check(cv\curve_replica.parent_curve));
               ELSE
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND (cv\offset_curve_3d.self_intersect = FALSE) THEN
                     RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve));
                  ELSE
                     IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                        RETURN (msf_curve_check(cv\pcurve.reference_to_curve\representation.items[1]) AND msf_surface_check(cv\pcurve.basis_surface));
                     ELSE
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(cv) THEN
                           IF msf_curve_check(cv\surface_curve.curve_3d) THEN
                              REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                                 IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                    IF NOT msf_surface_check(cv\surface_curve.associated_geometry[i]) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                 ELSE
                                    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                       IF NOT msf_curve_check(cv\surface_curve.associated_geometry[i]) THEN
                                          RETURN (FALSE);
                                       END_IF;
                                    END_IF;
                                 END_IF;
                              END_REPEAT;
                              RETURN (TRUE);
                           END_IF;
                        ELSE
                           IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                              IF SIZEOF(cv\polyline.points) >= 3 THEN
                                 RETURN (TRUE);
                              END_IF;
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION msf_surface_check
      (surf : surface ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(surf) THEN
            RETURN (msf_curve_check(surf\swept_surface.swept_curve));
         ELSE
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE' IN TYPEOF(surf)) AND (surf\offset_surface.self_intersect = FALSE) THEN
               RETURN (msf_surface_check(surf\offset_surface.basis_surface));
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' IN TYPEOF(surf) THEN
                  RETURN (msf_surface_check(surf\surface_replica.parent_surface));
               ELSE
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND (surf\b_spline_surface.self_intersect = FALSE) THEN
                     RETURN (TRUE);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION no_cyclic_domain_reference
      (ref : maths_space_or_function;
       used : SET OF maths_function ) : BOOLEAN;
   LOCAL
      typenames : SET OF STRING := TYPEOF(ref);
      func : maths_function;
   END_LOCAL;
      IF NOT EXISTS(ref) OR NOT EXISTS(used) THEN
         RETURN (FALSE);
      END_IF;
      IF schema_prefix + 'MATHS_SPACE' IN typenames THEN
         RETURN (TRUE);
      END_IF;
      func := ref;
      IF func IN used THEN
         RETURN (FALSE);
      END_IF;
      IF schema_prefix + 'CONSTANT_FUNCTION' IN typenames THEN
         RETURN (no_cyclic_domain_reference(func\constant_function.source_of_domain,

 used + [ func ]));
      END_IF;
      IF schema_prefix + 'SELECTOR_FUNCTION' IN typenames THEN
         RETURN (no_cyclic_domain_reference(func\selector_function.source_of_domain,

 used + [ func ]));
      END_IF;
      IF schema_prefix + 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
         RETURN (no_cyclic_domain_reference(func\parallel_composed_function.source_of_domain,

 used + [ func ]));
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION no_cyclic_space_reference
      (spc : maths_space;
       refs : SET OF maths_space ) : BOOLEAN;
   LOCAL
      types : SET OF STRING;
      refs_plus : SET OF maths_space;
   END_LOCAL;
      IF spc IN refs THEN
         RETURN (FALSE);
      END_IF;
      types := TYPEOF(spc);
      refs_plus := refs + spc;
      IF schema_prefix + 'FINITE_SPACE' IN types THEN
         RETURN (bool(SIZEOF(QUERY (sp <* QUERY (mem <* spc\finite_space.members| (schema_prefix + 'MATHS_SPACE' IN TYPEOF(mem)))| NOT no_cyclic_space_reference(sp,

 refs_plus))) = 0));
      END_IF;
      IF schema_prefix + 'UNIFORM_PRODUCT_SPACE' IN types THEN
         RETURN (no_cyclic_space_reference(spc\uniform_product_space.base,

 refs_plus));
      END_IF;
      IF schema_prefix + 'LISTED_PRODUCT_SPACE' IN types THEN
         RETURN (bool(SIZEOF(QUERY (fac <* spc\listed_product_space.factors| NOT no_cyclic_space_reference(fac,

 refs_plus))) = 0));
      END_IF;
      IF schema_prefix + 'EXTENDED_TUPLE_SPACE' IN types THEN
         RETURN (no_cyclic_space_reference(spc\extended_tuple_space.base,

 refs_plus) AND no_cyclic_space_reference(spc\extended_tuple_space.extender,

 refs_plus));
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION nondecreasing
      (lr : LIST OF REAL ) : BOOLEAN;
      IF NOT EXISTS(lr) THEN
         RETURN (FALSE);
      END_IF;
      REPEAT j := 2 TO SIZEOF(lr);
         IF lr[j] < lr[(j - 1)] THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION normalise
      (arg : vector_or_direction ) : vector_or_direction;
   LOCAL
      ndim : INTEGER;
      v : direction;
      result : vector_or_direction;
      vec : vector;
      mag : REAL;
   END_LOCAL;
      IF NOT EXISTS(arg) THEN
         result := ?;
      ELSE
         ndim := arg.dim;
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg) THEN
            BEGIN
               v := dummy_gri || direction(arg.orientation.direction_ratios);
               IF arg.magnitude = 0.00000 THEN
                  RETURN (?);
               ELSE
                  vec := dummy_gri || vector(v,

 1.00000);
               END_IF;
            END;
         ELSE
            v := dummy_gri || direction(arg.direction_ratios);
         END_IF;
         mag := 0.00000;
         REPEAT i := 1 TO ndim;
            mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
         END_REPEAT;
         IF mag > 0.00000 THEN
            mag := sqrt(mag);
            REPEAT i := 1 TO ndim;
               v.direction_ratios[i] := v.direction_ratios[i] / mag;
            END_REPEAT;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg) THEN
               vec.orientation := v;
               result := vec;
            ELSE
               result := v;
            END_IF;
         ELSE
            RETURN (?);
         END_IF;
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION number_superspace_of
      (spc : maths_space ) : elementary_space;
      IF subspace_of_es(spc,

 es_integers) THEN
         RETURN (the_integers);
      END_IF;
      IF subspace_of_es(spc,

 es_reals) THEN
         RETURN (the_reals);
      END_IF;
      IF subspace_of_es(spc,

 es_complex_numbers) THEN
         RETURN (the_complex_numbers);
      END_IF;
      IF subspace_of_es(spc,

 es_numbers) THEN
         RETURN (the_numbers);
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION number_tuple_subspace_check
      (spc : maths_space ) : LOGICAL;
   LOCAL
      types : SET OF STRING := stripped_typeof(spc);
      factors : LIST OF maths_space;
      cum : LOGICAL := TRUE;
   END_LOCAL;
      IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
         RETURN (subspace_of_es(spc\uniform_product_space.base,

 es_numbers));
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN types THEN
         factors := spc\listed_product_space.factors;
         REPEAT i := 1 TO SIZEOF(factors);
            cum := cum AND subspace_of_es(factors[i],

 es_numbers);
         END_REPEAT;
         RETURN (cum);
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN types THEN
         cum := subspace_of_es(spc\extended_tuple_space.extender,

 es_numbers);
         cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
         RETURN (cum);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION one_tuples_of
      (spc : maths_space ) : tuple_space;
      RETURN (make_uniform_product_space(spc,

 1));
   END_FUNCTION;



   FUNCTION open_shell_reversed
      (a_shell : open_shell ) : oriented_open_shell;
   LOCAL
      the_reverse : oriented_open_shell;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) THEN
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() || oriented_open_shell(a_shell\oriented_open_shell.open_shell_element,

 NOT a_shell\oriented_open_shell.orientation);
      ELSE
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() || oriented_open_shell(a_shell,

 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION orthogonal_complement
      (vec : direction ) : direction;
   LOCAL
      result : direction;
   END_LOCAL;
      IF (vec.dim <> 2) OR NOT EXISTS(vec) THEN
         RETURN (?);
      ELSE
         result := dummy_gri || direction([ -vec.direction_ratios[2],

 vec.direction_ratios[1] ]);
         RETURN (result);
      END_IF;
   END_FUNCTION;



   FUNCTION parallel_composed_function_composability_check
      (funcs : LIST OF maths_function;
       final : maths_function_select ) : BOOLEAN;
   LOCAL
      tplsp : tuple_space := the_zero_tuple_space;
      finfun : maths_function := convert_to_maths_function(final);
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(funcs);
         tplsp := assoc_product_space(tplsp,

 funcs[i].range);
      END_REPEAT;
      RETURN (compatible_spaces(tplsp,

 finfun.domain));
   END_FUNCTION;



   FUNCTION parallel_composed_function_domain_check
      (comdom : tuple_space;
       funcs : LIST OF maths_function ) : BOOLEAN;
      REPEAT i := 1 TO SIZEOF(funcs);
         IF NOT compatible_spaces(comdom,

 funcs[i].domain) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION partial_derivative_check
      (domain : tuple_space;
       d_vars : LIST [1:?] OF input_selector ) : BOOLEAN;
   LOCAL
      domn : tuple_space := domain;
      fspc : maths_space;
      dim : INTEGER;
      k : INTEGER;
   END_LOCAL;
      IF (space_dimension(domain) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN TYPEOF(factor1(domain))) THEN
         domn := factor1(domain);
      END_IF;
      dim := space_dimension(domn);
      REPEAT i := 1 TO SIZEOF(d_vars);
         k := d_vars[i];
         IF k > dim THEN
            RETURN (FALSE);
         END_IF;
         fspc := factor_space(domn,

 k);
         IF NOT subspace_of_es(fspc,

 es_reals) AND NOT subspace_of_es(fspc,

 es_complex_numbers) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION path_head_to_tail
      (a_path : path ) : LOGICAL;
   LOCAL
      n : INTEGER;
      p : LOGICAL := TRUE;
   END_LOCAL;
      n := SIZEOF(a_path.edge_list);
      REPEAT i := 2 TO n;
         p := p AND (a_path.edge_list[(i - 1)].edge_end :=: a_path.edge_list[i].edge_start);
      END_REPEAT;
      RETURN (p);
   END_FUNCTION;



   FUNCTION path_reversed
      (a_path : path ) : oriented_path;
   LOCAL
      the_reverse : oriented_path;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
         the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path\oriented_path.path_element,

 NOT a_path\oriented_path.orientation);
      ELSE
         the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path,

 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION real_max
      (spc : maths_space ) : REAL;
   LOCAL
      types : SET OF STRING := TYPEOF(spc);
   END_LOCAL;
      IF schema_prefix + 'FINITE_INTEGER_INTERVAL' IN types THEN
         RETURN (spc\finite_integer_interval.max);
      END_IF;
      IF schema_prefix + 'INTEGER_INTERVAL_TO_MAX' IN types THEN
         RETURN (spc\integer_interval_to_max.max);
      END_IF;
      IF schema_prefix + 'FINITE_REAL_INTERVAL' IN types THEN
         RETURN (spc\finite_real_interval.max);
      END_IF;
      IF schema_prefix + 'REAL_INTERVAL_TO_MAX' IN types THEN
         RETURN (spc\real_interval_to_max.max);
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION real_min
      (spc : maths_space ) : REAL;
   LOCAL
      types : SET OF STRING := TYPEOF(spc);
   END_LOCAL;
      IF schema_prefix + 'FINITE_INTEGER_INTERVAL' IN types THEN
         RETURN (spc\finite_integer_interval.min);
      END_IF;
      IF schema_prefix + 'INTEGER_INTERVAL_FROM_MIN' IN types THEN
         RETURN (spc\integer_interval_from_min.min);
      END_IF;
      IF schema_prefix + 'FINITE_REAL_INTERVAL' IN types THEN
         RETURN (spc\finite_real_interval.min);
      END_IF;
      IF schema_prefix + 'REAL_INTERVAL_FROM_MIN' IN types THEN
         RETURN (spc\real_interval_from_min.min);
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION regular_indexing
      (sub : LIST OF INTEGER;
       base : zero_or_one;
       shape : LIST [1:?] OF positive_integer;
       inc : LIST [1:?] OF INTEGER;
       first : INTEGER ) : INTEGER;
   LOCAL
      k : INTEGER;
      index : INTEGER;
   END_LOCAL;
      IF (((NOT EXISTS(sub) OR NOT EXISTS(base)) OR NOT EXISTS(shape)) OR NOT EXISTS(inc)) OR NOT EXISTS(first) THEN
         RETURN (?);
      END_IF;
      IF (SIZEOF(sub) <> SIZEOF(inc)) OR (SIZEOF(sub) <> SIZEOF(shape)) THEN
         RETURN (?);
      END_IF;
      index := first;
      REPEAT j := 1 TO SIZEOF(sub);
         IF NOT EXISTS(sub[j]) OR NOT EXISTS(inc[j]) THEN
            RETURN (?);
         END_IF;
         k := sub[j] - base;
         IF NOT ((0 <= k) AND (k < shape[j])) THEN
            RETURN (?);
         END_IF;
         index := index + k * inc[j];
      END_REPEAT;
      RETURN (index);
   END_FUNCTION;



   FUNCTION remove_first
      (alist : LIST OF GENERIC : GEN ) : LIST OF GENERIC : GEN;
   LOCAL
      blist : LIST OF GENERIC : GEN := alist;
   END_LOCAL;
      IF SIZEOF(blist) > 0 THEN
         REMOVE( blist,

 1 );
      END_IF;
      RETURN (blist);
   END_FUNCTION;



   FUNCTION repackage
      (tspace : tuple_space;
       repckg : repackage_options ) : tuple_space;
      CASE repckg OF
         ro_nochange :
               RETURN (tspace);
         ro_wrap_as_tuple :
               RETURN (one_tuples_of(tspace));
         ro_unwrap_tuple :
               RETURN (factor1(tspace));
      OTHERWISE :
            RETURN (?);
      END_CASE;
   END_FUNCTION;



   FUNCTION scalar_times_vector
      (scalar : REAL;
       vec : vector_or_direction ) : vector;
   LOCAL
      v : direction;
      mag : REAL;
      result : vector;
   END_LOCAL;
      IF NOT EXISTS(scalar) OR NOT EXISTS(vec) THEN
         RETURN (?);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(vec) THEN
            v := dummy_gri || direction(vec.orientation.direction_ratios);
            mag := scalar * vec.magnitude;
         ELSE
            v := dummy_gri || direction(vec.direction_ratios);
            mag := scalar;
         END_IF;
         IF mag < 0.00000 THEN
            REPEAT i := 1 TO SIZEOF(v.direction_ratios);
               v.direction_ratios[i] := -v.direction_ratios[i];
            END_REPEAT;
            mag := -mag;
         END_IF;
         result := dummy_gri || vector(normalise(v),

 mag);
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION second_proj_axis
      (z_axis : direction;
       x_axis : direction;
       arg : direction ) : direction;
   LOCAL
      y_axis : vector;
      v : direction;
      temp : vector;
   END_LOCAL;
      IF NOT EXISTS(arg) THEN
         v := dummy_gri || direction([ 0.00000,

 1.00000,

 0.00000 ]);
      ELSE
         v := arg;
      END_IF;
      temp := scalar_times_vector(dot_product(v,

 z_axis),

 z_axis);
      y_axis := vector_difference(v,

 temp);
      temp := scalar_times_vector(dot_product(v,

 x_axis),

 x_axis);
      y_axis := vector_difference(y_axis,

 temp);
      y_axis := normalise(y_axis);
      RETURN (y_axis.orientation);
   END_FUNCTION;



   FUNCTION set_of_topology_reversed
      (a_set : set_of_reversible_topology_item ) : set_of_reversible_topology_item;
   LOCAL
      the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
      the_reverse := [];
      REPEAT i := 1 TO SIZEOF(a_set);
         the_reverse := the_reverse + topology_reversed(a_set[i]);
      END_REPEAT;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION shape_of_array
      (func : maths_function ) : LIST OF positive_integer;
   LOCAL
      tspace : tuple_space;
      temp : maths_space;
      result : LIST OF positive_integer := [];
   END_LOCAL;
      IF schema_prefix + 'EXPLICIT_TABLE_FUNCTION' IN TYPEOF(func) THEN
         RETURN (func\explicit_table_function.shape);
      END_IF;
      tspace := func.domain;
      IF (space_dimension(tspace) = 1) AND (schema_prefix + 'TUPLE_SPACE' IN TYPEOF(factor1(tspace))) THEN
         tspace := factor1(tspace);
      END_IF;
      REPEAT i := 1 TO space_dimension(tspace);
         temp := factor_space(tspace,

 i);
         IF NOT (schema_prefix + 'FINITE_INTEGER_INTERVAL' IN TYPEOF(temp)) THEN
            RETURN (?);
         END_IF;
         INSERT( result,

 temp\finite_integer_interval.size,

 i - 1 );
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION shell_reversed
      (a_shell : shell ) : shell;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
         RETURN (open_shell_reversed(a_shell));
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
            RETURN (closed_shell_reversed(a_shell));
         ELSE
            RETURN (?);
         END_IF;
      END_IF;
   END_FUNCTION;



   FUNCTION simplify_function_application
      (expr : function_application ) : maths_value;
      FUNCTION ctmv
         (x : GENERIC : G ) : maths_value;
         RETURN (convert_to_maths_value(x));
      END_FUNCTION;
      PROCEDURE parts
         (c : complex_number_literal;
          VAR x : REAL;
          VAR y : REAL );
         x := c.real_part;
         y := c.imag_part;
      END_PROCEDURE;
      FUNCTION makec
         (x : REAL;
          y : REAL ) : complex_number_literal;
         RETURN (make_complex_number_literal(x,

 y));
      END_FUNCTION;
      FUNCTION good_t
         (v : maths_value;
          tn : STRING ) : BOOLEAN;
      LOCAL
         tpl : LIST OF maths_value;
      END_LOCAL;
         IF 'LIST' IN TYPEOF(v) THEN
            tpl := v;
            REPEAT i := 1 TO SIZEOF(tpl);
               IF NOT (tn IN TYPEOF(tpl[i])) THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (TRUE);
         END_IF;
         RETURN (FALSE);
      END_FUNCTION;
   CONSTANT
      cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
   END_CONSTANT;
   LOCAL
      types : SET OF STRING := stripped_typeof(expr.func);
      ef_val : elementary_function_enumerators;
      is_elementary : BOOLEAN := FALSE;
      v : maths_value;
      v1 : maths_value;
      v2 : maths_value;
      v3 : maths_value;
      vlist : LIST OF maths_value := [];
      gexpr : generic_expression;
      pairs : SET [1:?] OF LIST [2:2] OF maths_value;
      boo : BOOLEAN;
      lgc : LOGICAL;
      cum : LOGICAL;
      j : INTEGER;
      k : INTEGER;
      n : INTEGER;
      p : REAL;
      q : REAL;
      r : REAL;
      s : REAL;
      t : REAL;
      u : REAL;
      str : STRING;
      st2 : STRING;
      bin : BINARY;
      bi2 : BINARY;
      tpl : LIST OF maths_value;
      tp2 : LIST OF maths_value;
      mem : SET OF maths_value := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(expr.arguments);
         v := simplify_maths_value(expr.arguments[i]);
         INSERT( vlist,

 v,

 i - 1 );
      END_REPEAT;
      IF SIZEOF(vlist) >= 1 THEN
         v1 := vlist[1];
      END_IF;
      IF SIZEOF(vlist) >= 2 THEN
         v2 := vlist[2];
      END_IF;
      IF SIZEOF(vlist) >= 3 THEN
         v3 := vlist[3];
      END_IF;
      IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
         ef_val := expr.func;
         is_elementary := TRUE;
      END_IF;
      IF 'ELEMENTARY_FUNCTION' IN types THEN
         ef_val := expr.func\elementary_function.func_id;
         is_elementary := TRUE;
      END_IF;
      IF is_elementary THEN
         CASE ef_val OF
            ef_and :
                  BEGIN
                     cum := TRUE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'LOGICAL' IN TYPEOF(vlist[i]) THEN
                           lgc := vlist[i];
                           cum := cum AND lgc;
                           IF lgc = FALSE THEN
                              RETURN (ctmv(FALSE));
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(cum));
                     END_IF;
                     IF cum <> TRUE THEN
                        INSERT( vlist,

 ctmv(cum),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_or :
                  BEGIN
                     cum := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'LOGICAL' IN TYPEOF(vlist[i]) THEN
                           lgc := vlist[i];
                           cum := cum OR lgc;
                           IF lgc = TRUE THEN
                              RETURN (ctmv(TRUE));
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(cum));
                     END_IF;
                     IF cum <> FALSE THEN
                        INSERT( vlist,

 ctmv(cum),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_not :
                  IF 'LOGICAL' IN TYPEOF(v1) THEN
                     lgc := v1;
                     RETURN (ctmv(NOT lgc));
                  END_IF;
            ef_xor :
                  BEGIN
                     IF 'LOGICAL' IN TYPEOF(v1) THEN
                        lgc := v1;
                        IF 'LOGICAL' IN TYPEOF(v2) THEN
                           cum := v2;
                           RETURN (ctmv(lgc XOR cum));
                        ELSE
                           IF lgc = FALSE THEN
                              RETURN (ctmv(v2));
                           ELSE
                              IF lgc = UNKNOWN THEN
                                 RETURN (ctmv(UNKNOWN));
                              ELSE
                                 RETURN (make_function_application(ef_not,

 [ v2 ]));
                              END_IF;
                           END_IF;
                        END_IF;
                     ELSE
                        IF 'LOGICAL' IN TYPEOF(v2) THEN
                           lgc := v2;
                           IF lgc = FALSE THEN
                              RETURN (ctmv(v1));
                           ELSE
                              IF lgc = UNKNOWN THEN
                                 RETURN (ctmv(UNKNOWN));
                              ELSE
                                 RETURN (make_function_application(ef_not,

 [ v1 ]));
                              END_IF;
                           END_IF;
                        END_IF;
                     END_IF;
                  END;
            ef_negate_i :
                  IF 'INTEGER' IN TYPEOF(v1) THEN
                     j := v1;
                     RETURN (ctmv(-j));
                  END_IF;
            ef_add_i :
                  BEGIN
                     j := 0;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'INTEGER' IN TYPEOF(vlist[i]) THEN
                           k := vlist[i];
                           j := j + k;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(j));
                     END_IF;
                     IF j <> 0 THEN
                        INSERT( vlist,

 ctmv(j),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_subtract_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j - k));
                  END_IF;
            ef_multiply_i :
                  BEGIN
                     j := 1;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'INTEGER' IN TYPEOF(vlist[i]) THEN
                           k := vlist[i];
                           j := j * k;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(j));
                     END_IF;
                     IF j <> 1 THEN
                        INSERT( vlist,

 ctmv(j),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_divide_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j DIV k));
                  END_IF;
            ef_mod_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j MOD k));
                  END_IF;
            ef_exponentiate_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     n := 1;
                     REPEAT i := 1 TO ABS(k);
                        n := n * j;
                     END_REPEAT;
                     IF k < 0 THEN
                        n := 1 DIV n;
                     END_IF;
                     RETURN (ctmv(n));
                  END_IF;
            ef_eq_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j = k));
                  END_IF;
            ef_ne_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j <> k));
                  END_IF;
            ef_gt_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j > k));
                  END_IF;
            ef_lt_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j < k));
                  END_IF;
            ef_ge_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j >= k));
                  END_IF;
            ef_le_i :
                  IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     j := v1;
                     k := v2;
                     RETURN (ctmv(j <= k));
                  END_IF;
            ef_abs_i :
                  IF 'INTEGER' IN TYPEOF(v1) THEN
                     j := v1;
                     RETURN (ctmv(ABS(j)));
                  END_IF;
            ef_max_i :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'INTEGER' IN TYPEOF(vlist[i]) THEN
                           IF boo THEN
                              k := vlist[i];
                              IF k > j THEN
                                 j := k;
                              END_IF;
                           ELSE
                              j := vlist[i];
                              boo := TRUE;
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(j));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(j),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_min_i :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'INTEGER' IN TYPEOF(vlist[i]) THEN
                           IF boo THEN
                              k := vlist[i];
                              IF k < j THEN
                                 j := k;
                              END_IF;
                           ELSE
                              j := vlist[i];
                              boo := TRUE;
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(j));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(j),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_negate_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(-r));
                  END_IF;
            ef_reciprocal_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(1.00000 / r));
                  END_IF;
            ef_add_r :
                  BEGIN
                     r := 0.00000;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'REAL' IN TYPEOF(vlist[i]) THEN
                           s := vlist[i];
                           r := r + s;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(r));
                     END_IF;
                     IF r <> 0.00000 THEN
                        INSERT( vlist,

 ctmv(r),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_subtract_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r - s));
                  END_IF;
            ef_multiply_r :
                  BEGIN
                     r := 1.00000;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'REAL' IN TYPEOF(vlist[i]) THEN
                           s := vlist[i];
                           r := r * s;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(r));
                     END_IF;
                     IF r <> 1.00000 THEN
                        INSERT( vlist,

 ctmv(r),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_divide_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r / s));
                  END_IF;
            ef_mod_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     t := r / s;
                     j := t DIV 1;
                     IF (t < 0.00000) AND (j <> t) THEN
                        j := j - 1;
                     END_IF;
                     RETURN (ctmv(r - j * s));
                  END_IF;
            ef_exponentiate_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r ** s));
                  END_IF;
            ef_exponentiate_ri :
                  IF ('REAL' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     r := v1;
                     k := v2;
                     t := 1.00000;
                     REPEAT i := 1 TO ABS(k);
                        t := t * r;
                     END_REPEAT;
                     IF k < 0 THEN
                        t := 1.00000 / t;
                     END_IF;
                     RETURN (ctmv(t));
                  END_IF;
            ef_eq_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r = s));
                  END_IF;
            ef_ne_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r <> s));
                  END_IF;
            ef_gt_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r > s));
                  END_IF;
            ef_lt_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r < s));
                  END_IF;
            ef_ge_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r >= s));
                  END_IF;
            ef_le_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(r <= s));
                  END_IF;
            ef_abs_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(ABS(r)));
                  END_IF;
            ef_max_r :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'REAL' IN TYPEOF(vlist[i]) THEN
                           IF boo THEN
                              s := vlist[i];
                              IF s > r THEN
                                 r := s;
                              END_IF;
                           ELSE
                              r := vlist[i];
                              boo := TRUE;
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(r));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(r),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_min_r :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'REAL' IN TYPEOF(vlist[i]) THEN
                           IF boo THEN
                              s := vlist[i];
                              IF s < r THEN
                                 r := s;
                              END_IF;
                           ELSE
                              r := vlist[i];
                              boo := TRUE;
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(r));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(r),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_acos_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(ACOS(r)));
                  END_IF;
            ef_asin_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(ASIN(r)));
                  END_IF;
            ef_atan2_r :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (ctmv(atan2(r,

 s)));
                  END_IF;
            ef_cos_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(COS(r)));
                  END_IF;
            ef_exp_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(EXP(r)));
                  END_IF;
            ef_ln_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(LOG(r)));
                  END_IF;
            ef_log2_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(LOG2(r)));
                  END_IF;
            ef_log10_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(LOG10(r)));
                  END_IF;
            ef_sin_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(SIN(r)));
                  END_IF;
            ef_sqrt_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(SQRT(r)));
                  END_IF;
            ef_tan_r :
                  IF 'REAL' IN TYPEOF(v1) THEN
                     r := v1;
                     RETURN (ctmv(TAN(r)));
                  END_IF;
            ef_form_c :
                  IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2)) THEN
                     r := v1;
                     s := v2;
                     RETURN (make_complex_number_literal(r,

 s));
                  END_IF;
            ef_rpart_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     RETURN (ctmv(v1\complex_number_literal.real_part));
                  END_IF;
            ef_ipart_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     RETURN (ctmv(v1\complex_number_literal.imag_part));
                  END_IF;
            ef_negate_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     RETURN (make_complex_number_literal(-p,

 -q));
                  END_IF;
            ef_reciprocal_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     t := p * p + q * q;
                     RETURN (make_complex_number_literal(p / t,

 -q / t));
                  END_IF;
            ef_add_c :
                  BEGIN
                     p := 0.00000;
                     q := 0.00000;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF cnlit IN TYPEOF(vlist[i]) THEN
                           parts( vlist[i],

 r,

 s );
                           p := p + r;
                           q := q + s;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (make_complex_number_literal(p,

 q));
                     END_IF;
                     IF p * p + q * q <> 0.00000 THEN
                        INSERT( vlist,

 make_complex_number_literal(p,

 q),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_subtract_c :
                  IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
                     parts( v1,

 p,

 q );
                     parts( v2,

 r,

 s );
                     RETURN (make_complex_number_literal(p - r,

 q - s));
                  END_IF;
            ef_multiply_c :
                  BEGIN
                     p := 1.00000;
                     q := 0.00000;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF cnlit IN TYPEOF(vlist[i]) THEN
                           parts( vlist[i],

 r,

 s );
                           p := p * r - q * s;
                           q := p * s + q * r;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (make_complex_number_literal(p,

 q));
                     END_IF;
                     IF (p <> 1.00000) OR (q <> 0.00000) THEN
                        INSERT( vlist,

 make_complex_number_literal(p,

 q),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_divide_c :
                  IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
                     parts( v1,

 p,

 q );
                     parts( v2,

 r,

 s );
                     t := r * r + s * s;
                     RETURN (make_complex_number_literal((p * r + q * s) / t,

 (q * r - p * s) / t));
                  END_IF;
            ef_exponentiate_c :
                  IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
                     parts( v1,

 p,

 q );
                     parts( v2,

 r,

 s );
                     t := 0.500000 * LOG((p * p + q * q));
                     u := atan2(q,

 p);
                     p := r * t - s * u;
                     q := r * u + s * t;
                     r := EXP(p);
                     RETURN (make_complex_number_literal(r * COS(q),

 r * SIN(q)));
                  END_IF;
            ef_exponentiate_ci :
                  IF (cnlit IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     parts( v1,

 p,

 q );
                     k := v2;
                     r := 1.00000;
                     s := 0.00000;
                     REPEAT i := 1 TO ABS(k);
                        r := p * r - q * s;
                        s := p * s + q * r;
                     END_REPEAT;
                     IF k < 0 THEN
                        t := r * r + s * s;
                        r := r / t;
                        s := -s / t;
                     END_IF;
                     RETURN (make_complex_number_literal(r,

 s));
                  END_IF;
            ef_eq_c :
                  IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
                     parts( v1,

 p,

 q );
                     parts( v2,

 r,

 s );
                     RETURN (ctmv((p = r) AND (q = s)));
                  END_IF;
            ef_ne_c :
                  IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
                     parts( v1,

 p,

 q );
                     parts( v2,

 r,

 s );
                     RETURN (ctmv((p <> r) OR (q <> s)));
                  END_IF;
            ef_conjugate_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     RETURN (make_complex_number_literal(p,

 -q));
                  END_IF;
            ef_abs_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     RETURN (ctmv(SQRT(p * p + q * q)));
                  END_IF;
            ef_arg_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     RETURN (ctmv(atan2(q,

 p)));
                  END_IF;
            ef_cos_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     t := 0.500000 * EXP(-q);
                     u := 0.500000 * EXP(q);
                     RETURN (make_complex_number_literal((t + u) * COS(p),

 (t - u) * SIN(p)));
                  END_IF;
            ef_exp_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     RETURN (make_complex_number_literal(EXP(p) * COS(q),

 EXP(p) * SIN(q)));
                  END_IF;
            ef_ln_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     RETURN (make_complex_number_literal(0.500000 * LOG((p * p + q * q)),

 atan2(q,

 p)));
                  END_IF;
            ef_sin_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     t := 0.500000 * EXP(-q);
                     u := 0.500000 * EXP(q);
                     RETURN (make_complex_number_literal((t + u) * SIN(p),

 (u - t) * COS(p)));
                  END_IF;
            ef_sqrt_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     t := SQRT(SQRT(p * p + q * q));
                     u := 0.500000 * atan2(q,

 p);
                     RETURN (make_complex_number_literal(t * COS(u),

 t * SIN(u)));
                  END_IF;
            ef_tan_c :
                  IF cnlit IN TYPEOF(v1) THEN
                     parts( v1,

 p,

 q );
                     t := EXP(2.00000 * q) + EXP(-2.00000 * q) + 2.00000 * COS(2.00000 * p);
                     RETURN (make_complex_number_literal(2.00000 * SIN(2.00000 * p) / t,

 (EXP(-2.00000 * q) - EXP(2.00000 * q)) / t));
                  END_IF;
            ef_subscript_s :
                  IF ('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     str := v1;
                     k := v2;
                     RETURN (ctmv(str[k]));
                  END_IF;
            ef_eq_s :
                  IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     str := v1;
                     st2 := v2;
                     RETURN (ctmv(str = st2));
                  END_IF;
            ef_ne_s :
                  IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     str := v1;
                     st2 := v2;
                     RETURN (ctmv(str <> st2));
                  END_IF;
            ef_gt_s :
                  IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     str := v1;
                     st2 := v2;
                     RETURN (ctmv(str > st2));
                  END_IF;
            ef_lt_s :
                  IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     str := v1;
                     st2 := v2;
                     RETURN (ctmv(str < st2));
                  END_IF;
            ef_ge_s :
                  IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     str := v1;
                     st2 := v2;
                     RETURN (ctmv(str >= st2));
                  END_IF;
            ef_le_s :
                  IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     str := v1;
                     st2 := v2;
                     RETURN (ctmv(str <= st2));
                  END_IF;
            ef_subsequence_s :
                  IF (('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))) AND ('INTEGER' IN TYPEOF(v3)) THEN
                     str := v1;
                     j := v2;
                     k := v3;
                     RETURN (ctmv(str[ k : j ]));
                  END_IF;
            ef_concat_s :
                  BEGIN
                     str := '';
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'STRING' IN TYPEOF(vlist[i]) THEN
                           st2 := vlist[i];
                           str := str + st2;
                           REMOVE( vlist,

 i );
                        ELSE
                           IF str <> '' THEN
                              INSERT( vlist,

 ctmv(str),

 i );
                              str := '';
                           END_IF;
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(str));
                     END_IF;
                     IF str <> '' THEN
                        INSERT( vlist,

 ctmv(str),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_size_s :
                  IF 'STRING' IN TYPEOF(v1) THEN
                     str := v1;
                     RETURN (ctmv(LENGTH(str)));
                  END_IF;
            ef_format :
                  IF ('NUMBER' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     RETURN (ctmv(FORMAT(v1,

 v2)));
                  END_IF;
            ef_value :
                  IF 'STRING' IN TYPEOF(v1) THEN
                     str := v1;
                     RETURN (ctmv(VALUE(str)));
                  END_IF;
            ef_like :
                  IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2)) THEN
                     RETURN (ctmv(v1 LIKE v2));
                  END_IF;
            ef_subscript_b :
                  IF ('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     bin := v1;
                     k := v2;
                     RETURN (ctmv(bin[k]));
                  END_IF;
            ef_eq_b :
                  IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2)) THEN
                     bin := v1;
                     bi2 := v2;
                     RETURN (ctmv(bin = bi2));
                  END_IF;
            ef_ne_b :
                  IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2)) THEN
                     bin := v1;
                     bi2 := v2;
                     RETURN (ctmv(bin <> bi2));
                  END_IF;
            ef_gt_b :
                  IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2)) THEN
                     bin := v1;
                     bi2 := v2;
                     RETURN (ctmv(bin > bi2));
                  END_IF;
            ef_lt_b :
                  IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2)) THEN
                     bin := v1;
                     bi2 := v2;
                     RETURN (ctmv(bin < bi2));
                  END_IF;
            ef_ge_b :
                  IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2)) THEN
                     bin := v1;
                     bi2 := v2;
                     RETURN (ctmv(bin >= bi2));
                  END_IF;
            ef_le_b :
                  IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2)) THEN
                     bin := v1;
                     bi2 := v2;
                     RETURN (ctmv(bin <= bi2));
                  END_IF;
            ef_subsequence_b :
                  IF (('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))) AND ('INTEGER' IN TYPEOF(v3)) THEN
                     bin := v1;
                     j := v2;
                     k := v3;
                     RETURN (ctmv(bin[ k : j ]));
                  END_IF;
            ef_concat_b :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'BINARY' IN TYPEOF(vlist[i]) THEN
                           IF boo THEN
                              bi2 := vlist[i];
                              bin := bin + bi2;
                           ELSE
                              bin := vlist[i];
                              boo := TRUE;
                           END_IF;
                           REMOVE( vlist,

 i );
                        ELSE
                           IF boo THEN
                              INSERT( vlist,

 ctmv(bin),

 i );
                              boo := FALSE;
                           END_IF;
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(bin));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(bin),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_size_b :
                  IF 'BINARY' IN TYPEOF(v1) THEN
                     bin := v1;
                     RETURN (ctmv(BLENGTH(bin)));
                  END_IF;
            ef_subscript_t :
                  IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     tpl := v1;
                     k := v2;
                     RETURN (ctmv(tpl[k]));
                  END_IF;
            ef_eq_t :
                  IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2)) THEN
                     lgc := equal_maths_values(v1,

 v2);
                     IF lgc <> UNKNOWN THEN
                        RETURN (ctmv(lgc));
                     END_IF;
                  END_IF;
            ef_ne_t :
                  IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2)) THEN
                     lgc := equal_maths_values(v1,

 v2);
                     IF lgc <> UNKNOWN THEN
                        RETURN (ctmv(NOT lgc));
                     END_IF;
                  END_IF;
            ef_concat_t :
                  BEGIN
                     tpl := [];
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'STRING' IN TYPEOF(vlist[i]) THEN
                           tp2 := vlist[i];
                           tpl := tpl + tp2;
                           REMOVE( vlist,

 i );
                        ELSE
                           IF SIZEOF(tpl) <> 0 THEN
                              INSERT( vlist,

 ctmv(tpl),

 i );
                              tpl := [];
                           END_IF;
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(tpl));
                     END_IF;
                     IF SIZEOF(tpl) <> 0 THEN
                        INSERT( vlist,

 ctmv(tpl),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_size_t :
                  IF 'LIST' IN TYPEOF(v1) THEN
                     tpl := v1;
                     RETURN (ctmv(SIZEOF(tpl)));
                  END_IF;
            ef_entuple :
                  RETURN (ctmv(vlist));
            ef_detuple :
                  IF 'LIST' IN TYPEOF(v1) THEN
                     tpl := v1;
                     RETURN (ctmv(tpl[1]));
                  END_IF;
            ef_insert :
                  IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v3)) THEN
                     tpl := v1;
                     k := v3;
                     INSERT( tpl,

 v2,

 k );
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_remove :
                  IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) THEN
                     tpl := v1;
                     k := v2;
                     REMOVE( tpl,

 k );
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_sum_it :
                  IF good_t(v1,

 'INTEGER') THEN
                     tpl := v1;
                     j := 0;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        j := j + tpl[i];
                     END_REPEAT;
                     RETURN (ctmv(j));
                  END_IF;
            ef_product_it :
                  IF good_t(v1,

 'INTEGER') THEN
                     tpl := v1;
                     j := 1;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        j := j * tpl[i];
                     END_REPEAT;
                     RETURN (ctmv(j));
                  END_IF;
            ef_add_it :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF good_t(vlist[i],

 'INTEGER') THEN
                           IF NOT boo THEN
                              tpl := vlist[i];
                              boo := TRUE;
                           ELSE
                              tp2 := vlist[i];
                              IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                                 RETURN (?);
                              END_IF;
                              REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                              END_REPEAT;
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(tpl));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(tpl),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_subtract_it :
                  IF good_t(v1,

 'INTEGER') AND good_t(v2,

 'INTEGER') THEN
                     tpl := v1;
                     tp2 := v2;
                     IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                        RETURN (?);
                     END_IF;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        tpl[i] := tpl[i] - tp2[i];
                     END_REPEAT;
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_scalar_mult_it :
                  IF ('INTEGER' IN TYPEOF(v1)) AND good_t(v2,

 'INTEGER') THEN
                     j := v1;
                     tpl := v2;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        tpl[i] := j * tpl[i];
                     END_REPEAT;
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_dot_prod_it :
                  IF good_t(v1,

 'INTEGER') AND good_t(v2,

 'INTEGER') THEN
                     tpl := v1;
                     tp2 := v2;
                     j := 0;
                     IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                        RETURN (?);
                     END_IF;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        j := j + tpl[i] * tp2[i];
                     END_REPEAT;
                     RETURN (ctmv(j));
                  END_IF;
            ef_sum_rt :
                  IF good_t(v1,

 'REAL') THEN
                     tpl := v1;
                     r := 0.00000;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        r := r + tpl[i];
                     END_REPEAT;
                     RETURN (ctmv(r));
                  END_IF;
            ef_product_rt :
                  IF good_t(v1,

 'REAL') THEN
                     tpl := v1;
                     r := 1.00000;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        r := r * tpl[i];
                     END_REPEAT;
                     RETURN (ctmv(r));
                  END_IF;
            ef_add_rt :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF good_t(vlist[i],

 'REAL') THEN
                           IF NOT boo THEN
                              tpl := vlist[i];
                              boo := TRUE;
                           ELSE
                              tp2 := vlist[i];
                              IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                                 RETURN (?);
                              END_IF;
                              REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                              END_REPEAT;
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(tpl));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(tpl),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_subtract_rt :
                  IF good_t(v1,

 'REAL') AND good_t(v2,

 'REAL') THEN
                     tpl := v1;
                     tp2 := v2;
                     IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                        RETURN (?);
                     END_IF;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        tpl[i] := tpl[i] - tp2[i];
                     END_REPEAT;
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_scalar_mult_rt :
                  IF ('REAL' IN TYPEOF(v1)) AND good_t(v2,

 'REAL') THEN
                     r := v1;
                     tpl := v2;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        tpl[i] := r * tpl[i];
                     END_REPEAT;
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_dot_prod_rt :
                  IF good_t(v1,

 'REAL') AND good_t(v2,

 'REAL') THEN
                     tpl := v1;
                     tp2 := v2;
                     r := 0;
                     IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                        RETURN (?);
                     END_IF;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        r := r + tpl[i] * tp2[i];
                     END_REPEAT;
                     RETURN (ctmv(r));
                  END_IF;
            ef_norm_rt :
                  IF good_t(v1,

 'REAL') THEN
                     tpl := v1;
                     r := 0.00000;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        r := r + tpl[i] * tpl[i];
                     END_REPEAT;
                     RETURN (ctmv(SQRT(r)));
                  END_IF;
            ef_sum_ct :
                  IF good_t(v1,

 cnlit) THEN
                     tpl := v1;
                     p := 0.00000;
                     q := 0.00000;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        parts( tpl[i],

 r,

 s );
                        p := p + r;
                        q := q + s;
                     END_REPEAT;
                     RETURN (make_complex_number_literal(p,

 q));
                  END_IF;
            ef_product_ct :
                  IF good_t(v1,

 cnlit) THEN
                     tpl := v1;
                     p := 1.00000;
                     q := 0.00000;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        parts( tpl[i],

 r,

 s );
                        p := p * r - q * s;
                        q := p * s + q * r;
                     END_REPEAT;
                     RETURN (make_complex_number_literal(p,

 q));
                  END_IF;
            ef_add_ct :
                  BEGIN
                     boo := FALSE;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF good_t(vlist[i],

 cnlit) THEN
                           IF NOT boo THEN
                              tpl := vlist[i];
                              boo := TRUE;
                           ELSE
                              tp2 := vlist[i];
                              IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                                 RETURN (?);
                              END_IF;
                              REPEAT l := 1 TO SIZEOF(tpl);
                                 parts( tpl[j],

 p,

 q );
                                 parts( tp2[j],

 r,

 s );
                                 tpl[j] := make_complex_number_literal(p + r,

 q + s);
                              END_REPEAT;
                           END_IF;
                           REMOVE( vlist,

 i );
                        END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0 THEN
                        RETURN (ctmv(tpl));
                     END_IF;
                     IF boo THEN
                        INSERT( vlist,

 ctmv(tpl),

 0 );
                     END_IF;
                     IF SIZEOF(vlist) = 1 THEN
                        RETURN (vlist[1]);
                     END_IF;
                  END;
            ef_subtract_ct :
                  IF good_t(v1,

 cnlit) AND good_t(v2,

 cnlit) THEN
                     tpl := v1;
                     tp2 := v2;
                     IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                        RETURN (?);
                     END_IF;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        parts( tpl[i],

 p,

 q );
                        parts( tp2[i],

 r,

 s );
                        tpl[i] := make_complex_number_literal(p - r,

 q - s);
                     END_REPEAT;
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_scalar_mult_ct :
                  IF (cnlit IN TYPEOF(v1)) AND good_t(v2,

 cnlit) THEN
                     parts( v1,

 p,

 q );
                     tpl := v2;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        parts( tpl[i],

 r,

 s );
                        tpl[i] := make_complex_number_literal(p * r - q * s,

 p * s + q * r);
                     END_REPEAT;
                     RETURN (ctmv(tpl));
                  END_IF;
            ef_dot_prod_ct :
                  IF good_t(v1,

 cnlit) AND good_t(v2,

 cnlit) THEN
                     tpl := v1;
                     tp2 := v2;
                     t := 0.00000;
                     u := 0.00000;
                     IF SIZEOF(tpl) <> SIZEOF(tp2) THEN
                        RETURN (?);
                     END_IF;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        parts( tpl[i],

 p,

 q );
                        parts( tp2[i],

 r,

 s );
                        t := t + p * r + q * s;
                        u := u + q * r - p * s;
                     END_REPEAT;
                     RETURN (make_complex_number_literal(t,

 u));
                  END_IF;
            ef_norm_ct :
                  IF good_t(v1,

 cnlit) THEN
                     tpl := v1;
                     r := 0.00000;
                     REPEAT i := 1 TO SIZEOF(tpl);
                        parts( tpl[i],

 p,

 q );
                        r := r + p * p + q * q;
                     END_REPEAT;
                     RETURN (ctmv(SQRT(r)));
                  END_IF;
            ef_if,

 ef_if_i,

 ef_if_r,

 ef_if_c,

 ef_if_s,

 ef_if_b,

 ef_if_t :
                  IF 'LOGICAL' IN TYPEOF(v1) THEN
                     lgc := v1;
                     IF lgc THEN
                        RETURN (v2);
                     ELSE
                        RETURN (v3);
                     END_IF;
                  END_IF;
            ef_ensemble :
                  RETURN (make_finite_space(mem + vlist));
            ef_member_of :
                  IF schema_prefix + 'MATHS_SPACE' IN TYPEOF(v2) THEN
                     lgc := member_of(v1,

 v2);
                     IF lgc <> UNKNOWN THEN
                        RETURN (ctmv(lgc));
                     END_IF;
                  END_IF;
         END_CASE;
         RETURN (make_function_application(expr.func,

 vlist));
      END_IF;
      IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
         gexpr := substitute(expr.func\abstracted_expression_function.expr,

 expr.func\quantifier_expression.variables,

 vlist);
         RETURN (simplify_generic_expression(gexpr));
      END_IF;
      IF 'FINITE_FUNCTION' IN types THEN
         pairs := expr.func\finite_function.pairs;
         REPEAT i := 1 TO SIZEOF(pairs);
            IF equal_maths_values(vlist[1],

 pairs[i][1]) THEN
               RETURN (simplify_maths_value(pairs[i][2]));
            END_IF;
         END_REPEAT;
         RETURN (make_function_application(expr.func,

 vlist));
      END_IF;
      RETURN (expr);
   END_FUNCTION;



   FUNCTION simplify_generic_expression
      (expr : generic_expression ) : maths_value;
      FUNCTION restore_unary
         (expr : unary_generic_expression;
          opnd : generic_expression ) : generic_expression;
         expr.operand := opnd;
         RETURN (expr);
      END_FUNCTION;
      FUNCTION restore_binary
         (expr : binary_generic_expression;
          opd1 : generic_expression;
          opd2 : generic_expression ) : generic_expression;
         expr.operands[1] := opd1;
         expr.operands[2] := opd2;
         RETURN (expr);
      END_FUNCTION;
      FUNCTION restore_mulary
         (expr : multiple_arity_generic_expression;
          ops : LIST OF generic_expression ) : generic_expression;
         expr.operands := ops;
         RETURN (expr);
      END_FUNCTION;
      FUNCTION make_number_literal
         (nmb : NUMBER ) : generic_literal;
         IF 'INTEGER' IN TYPEOF(nmb) THEN
            RETURN (make_int_literal(nmb));
         END_IF;
         RETURN (make_real_literal(nmb));
      END_FUNCTION;
   LOCAL
      types : SET OF STRING := stripped_typeof(expr);
      v1 : maths_value;
      v2 : maths_value;
      vlist : LIST OF maths_value := [];
      op1 : generic_expression;
      op2 : generic_expression;
      oplist : LIST OF generic_expression := [];
      opnds : LIST [2:?] OF generic_expression;
      n : INTEGER;
      m : INTEGER;
      finfun : maths_function_select;
      boo : BOOLEAN;
      str : STRING;
      nmb : NUMBER;
   END_LOCAL;
      IF 'INT_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\int_literal.the_value));
      END_IF;
      IF 'REAL_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\real_literal.the_value));
      END_IF;
      IF 'BOOLEAN_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\boolean_literal.the_value));
      END_IF;
      IF 'STRING_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\string_literal.the_value));
      END_IF;
      IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
         RETURN (expr);
      END_IF;
      IF 'LOGICAL_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\logical_literal.lit_value));
      END_IF;
      IF 'BINARY_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\binary_literal.lit_value));
      END_IF;
      IF 'MATHS_ENUM_LITERAL' IN types THEN
         RETURN (expr\maths_enum_literal.lit_value);
      END_IF;
      IF 'REAL_TUPLE_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\real_tuple_literal.lit_value));
      END_IF;
      IF 'INTEGER_TUPLE_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\integer_tuple_literal.lit_value));
      END_IF;
      IF 'ATOM_BASED_LITERAL' IN types THEN
         RETURN (expr\atom_based_literal.lit_value);
      END_IF;
      IF 'MATHS_TUPLE_LITERAL' IN types THEN
         RETURN (convert_to_maths_value(expr\maths_tuple_literal.lit_value));
      END_IF;
      IF 'MATHS_SPACE' IN types THEN
         RETURN (simplify_maths_space(expr));
      END_IF;
      IF 'FUNCTION_APPLICATION' IN types THEN
         RETURN (simplify_function_application(expr));
      END_IF;
      IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
         v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
         op1 := convert_to_operand(v1);
      END_IF;
      IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
         v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
         op1 := convert_to_operand(v1);
         v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
         op2 := convert_to_operand(v2);
      END_IF;
      IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
         opnds := expr\multiple_arity_generic_expression.operands;
         REPEAT i := 1 TO SIZEOF(opnds);
            v1 := simplify_generic_expression(opnds[i]);
            INSERT( vlist,

 v1,

 i - 1 );
            INSERT( oplist,

 convert_to_operand(v1),

 i - 1 );
         END_REPEAT;
      END_IF;
      IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
         v1 := vlist[1];
         n := SIZEOF(vlist);
         finfun := vlist[n];
         REMOVE( vlist,

 n );
         REMOVE( vlist,

 1 );
         RETURN (make_parallel_composed_function(v1,

 vlist,

 finfun));
      END_IF;
      IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(ABS(v1)));
      END_IF;
      IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(ACOS(v1)));
      END_IF;
      IF 'AND_EXPRESSION' IN types THEN
         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
            IF 'BOOLEAN' IN TYPEOF(vlist[i]) THEN
               boo := vlist[i];
               IF NOT boo THEN
                  RETURN (convert_to_maths_value(FALSE));
               END_IF;
               REMOVE( oplist,

 i );
            END_IF;
         END_REPEAT;
         IF SIZEOF(oplist) = 0 THEN
            RETURN (convert_to_maths_value(TRUE));
         END_IF;
         IF SIZEOF(oplist) = 1 THEN
            RETURN (oplist[1]);
         END_IF;
      END_IF;
      IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(ASIN(v1)));
      END_IF;
      IF (('ATAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))) AND ('NUMBER' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(atan(v1,

 v2)));
      END_IF;
      IF ('COMPARISON_EXPRESSION' IN types) AND ((('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2)) OR ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))) OR ('BOOLEAN' IN TYPEOF(v1)) AND ('BOOLEAN' IN TYPEOF(v2))) THEN
         IF 'COMPARISON_EQUAL' IN types THEN
            boo := bool(v1 = v2);
         ELSE
            IF 'COMPARISON_GREATER' IN types THEN
               boo := bool(v1 > v2);
            ELSE
               IF 'COMPARISON_GREATER_EQUAL' IN types THEN
                  boo := bool(v1 >= v2);
               ELSE
                  IF 'COMPARISON_LESS' IN types THEN
                     boo := bool(v1 < v2);
                  ELSE
                     IF 'COMPARISON_LESS_EQUAL' IN types THEN
                        boo := bool(v1 <= v2);
                     ELSE
                        IF 'COMPARISON_NOT_EQUAL' IN types THEN
                           boo := bool(v1 <> v2);
                        ELSE
                           IF 'LIKE_EXPRESSION' IN types THEN
                              boo := bool(v1 LIKE v2);
                           ELSE
                              RETURN (?);
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
         RETURN (convert_to_maths_value(boo));
      END_IF;
      IF 'CONCAT_EXPRESSION' IN types THEN
         str := '';
         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
            IF 'STRING' IN TYPEOF(vlist[i]) THEN
               str := vlist[i] + str;
               REMOVE( oplist,

 i );
            ELSE
               IF LENGTH(str) > 0 THEN
                  INSERT( oplist,

 make_string_literal(str),

 i );
                  str := '';
               END_IF;
            END_IF;
         END_REPEAT;
         IF SIZEOF(oplist) = 0 THEN
            RETURN (convert_to_maths_value(str));
         END_IF;
         IF LENGTH(str) > 0 THEN
            INSERT( oplist,

 make_string_literal(str),

 0 );
         END_IF;
         IF SIZEOF(oplist) = 1 THEN
            RETURN (oplist[1]);
         END_IF;
      END_IF;
      IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(COS(v1)));
      END_IF;
      IF (('DIV_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))) AND ('NUMBER' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(v1 DIV v2));
      END_IF;
      IF 'EQUALS_EXPRESSION' IN types THEN
         opnds := expr\binary_generic_expression.operands;
         RETURN (convert_to_maths_value(opnds[1] :=: opnds[2]));
      END_IF;
      IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(EXP(v1)));
      END_IF;
      IF (('FORMAT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))) AND ('STRING' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(FORMAT(v1,

 v2)));
      END_IF;
      IF (('INDEX_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))) AND ('NUMBER' IN TYPEOF(v2)) THEN
         str := v1;
         n := v2;
         RETURN (convert_to_maths_value(str[n]));
      END_IF;
      IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(VALUE(v1)));
      END_IF;
      IF 'INTERVAL_EXPRESSION' IN types THEN
         str := '';
         IF 'NUMBER' IN TYPEOF(vlist[1]) THEN
            str := 'NUMBER';
         END_IF;
         IF 'STRING' IN TYPEOF(vlist[1]) THEN
            str := 'STRING';
         END_IF;
         IF 'BOOLEAN' IN TYPEOF(vlist[1]) THEN
            str := 'BOOLEAN';
         END_IF;
         IF ((LENGTH(str) > 0) AND (str IN TYPEOF(vlist[2]))) AND (str IN TYPEOF(vlist[3])) THEN
            RETURN (convert_to_maths_value((vlist[1] <= vlist[2]) AND (vlist[2] <= vlist[3])));
         END_IF;
      END_IF;
      IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(LENGTH(v1)));
      END_IF;
      IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(LOG(v1)));
      END_IF;
      IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(LOG10(v1)));
      END_IF;
      IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(LOG2(v1)));
      END_IF;
      IF 'MAXIMUM_EXPRESSION' IN types THEN
         boo := FALSE;
         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
            IF 'NUMBER' IN TYPEOF(vlist[i]) THEN
               IF boo THEN
                  IF nmb < vlist[i] THEN
                     nmb := vlist[i];
                  END_IF;
               ELSE
                  nmb := vlist[i];
                  boo := TRUE;
               END_IF;
               REMOVE( oplist,

 i );
            END_IF;
         END_REPEAT;
         IF SIZEOF(oplist) = 0 THEN
            RETURN (convert_to_maths_value(nmb));
         END_IF;
         IF boo THEN
            INSERT( oplist,

 make_number_literal(nmb),

 0 );
         END_IF;
      END_IF;
      IF 'MINIMUM_EXPRESSION' IN types THEN
         boo := FALSE;
         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
            IF 'NUMBER' IN TYPEOF(vlist[i]) THEN
               IF boo THEN
                  IF nmb > vlist[i] THEN
                     nmb := vlist[i];
                  END_IF;
               ELSE
                  nmb := vlist[i];
                  boo := TRUE;
               END_IF;
               REMOVE( oplist,

 i );
            END_IF;
         END_REPEAT;
         IF SIZEOF(oplist) = 0 THEN
            RETURN (convert_to_maths_value(nmb));
         END_IF;
         IF boo THEN
            INSERT( oplist,

 make_number_literal(nmb),

 0 );
         END_IF;
      END_IF;
      IF (('MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))) AND ('NUMBER' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(v1 - v2));
      END_IF;
      IF (('MOD_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))) AND ('NUMBER' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(v1 MOD v2));
      END_IF;
      IF 'MULT_EXPRESSION' IN types THEN
         nmb := 1;
         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
            IF 'NUMBER' IN TYPEOF(vlist[i]) THEN
               nmb := nmb * vlist[i];
               REMOVE( oplist,

 i );
            END_IF;
         END_REPEAT;
         IF SIZEOF(oplist) = 0 THEN
            RETURN (convert_to_maths_value(nmb));
         END_IF;
         IF nmb <> 1 THEN
            INSERT( oplist,

 make_number_literal(nmb),

 0 );
         END_IF;
         IF SIZEOF(oplist) = 1 THEN
            RETURN (oplist[1]);
         END_IF;
      END_IF;
      IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1)) THEN
         boo := v1;
         RETURN (convert_to_maths_value(NOT boo));
      END_IF;
      IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(ODD(v1)));
      END_IF;
      IF 'OR_EXPRESSION' IN types THEN
         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
            IF 'BOOLEAN' IN TYPEOF(vlist[i]) THEN
               boo := vlist[i];
               IF boo THEN
                  RETURN (convert_to_maths_value(TRUE));
               END_IF;
               REMOVE( oplist,

 i );
            END_IF;
         END_REPEAT;
         IF SIZEOF(oplist) = 0 THEN
            RETURN (convert_to_maths_value(FALSE));
         END_IF;
         IF SIZEOF(oplist) = 1 THEN
            RETURN (oplist[1]);
         END_IF;
      END_IF;
      IF 'PLUS_EXPRESSION' IN types THEN
         nmb := 0;
         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
            IF 'NUMBER' IN TYPEOF(vlist[i]) THEN
               nmb := nmb + vlist[i];
               REMOVE( oplist,

 i );
            END_IF;
         END_REPEAT;
         IF SIZEOF(oplist) = 0 THEN
            RETURN (convert_to_maths_value(nmb));
         END_IF;
         IF nmb <> 0 THEN
            INSERT( oplist,

 make_number_literal(nmb),

 0 );
         END_IF;
         IF SIZEOF(oplist) = 1 THEN
            RETURN (oplist[1]);
         END_IF;
      END_IF;
      IF (('POWER_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))) AND ('NUMBER' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(v1 ** v2));
      END_IF;
      IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(SIN(v1)));
      END_IF;
      IF (('SLASH_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))) AND ('NUMBER' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(v1 / v2));
      END_IF;
      IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(SQRT(v1)));
      END_IF;
      IF ((('SUBSTRING_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(vlist[1]))) AND ('NUMBER' IN TYPEOF(vlist[2]))) AND ('NUMBER' IN TYPEOF(vlist[3])) THEN
         str := vlist[1];
         n := vlist[2];
         m := vlist[3];
         RETURN (convert_to_maths_value(str[ m : n ]));
      END_IF;
      IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(TAN(v1)));
      END_IF;
      IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) THEN
         nmb := v1;
         RETURN (convert_to_maths_value(-nmb));
      END_IF;
      IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1)) THEN
         RETURN (convert_to_maths_value(VALUE(v1)));
      END_IF;
      IF (('XOR_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1))) AND ('BOOLEAN' IN TYPEOF(v2)) THEN
         RETURN (convert_to_maths_value(v1 XOR v2));
      END_IF;
      IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
         RETURN (restore_unary(expr,

 op1));
      END_IF;
      IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
         RETURN (restore_binary(expr,

 op1,

 op2));
      END_IF;
      IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
         RETURN (restore_mulary(expr,

 oplist));
      END_IF;
      RETURN (expr);
   END_FUNCTION;



   FUNCTION simplify_maths_space
      (spc : maths_space ) : maths_space;
   LOCAL
      stypes : SET OF STRING := stripped_typeof(spc);
      sset : SET OF maths_value;
      zset : SET OF maths_value := [];
      zval : maths_value;
      zspc : maths_space;
      zallint : BOOLEAN := TRUE;
      zint : INTEGER;
      zmin : INTEGER;
      zmax : INTEGER;
      factors : LIST OF maths_space;
      zfactors : LIST OF maths_space := [];
      rspc : maths_space;
   END_LOCAL;
      IF 'FINITE_SPACE' IN stypes THEN
         sset := spc\finite_space.members;
         REPEAT i := 1 TO SIZEOF(sset);
            zval := simplify_maths_value(sset[i]);
            zset := zset + [ zval ];
            IF zallint AND ('INTEGER' IN TYPEOF(zval)) THEN
               zint := zval;
               IF i = 1 THEN
                  zmin := zint;
                  zmax := zint;
               ELSE
                  IF zint < zmin THEN
                     zmin := zint;
                  END_IF;
                  IF zint > zmax THEN
                     zmax := zint;
                  END_IF;
               END_IF;
            ELSE
               zallint := FALSE;
            END_IF;
         END_REPEAT;
         IF zallint AND (SIZEOF(zset) = zmax - zmin + 1) THEN
            RETURN (make_finite_integer_interval(zmin,

 zmax));
         END_IF;
         RETURN (make_finite_space(zset));
      END_IF;
      IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
         zspc := simplify_maths_space(spc\uniform_product_space.base);
         RETURN (make_uniform_product_space(zspc,

 spc\uniform_product_space.exponent));
      END_IF;
      IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
         factors := spc\listed_product_space.factors;
         REPEAT i := 1 TO SIZEOF(factors);
            INSERT( zfactors,

 simplify_maths_space(factors[i]),

 i - 1 );
         END_REPEAT;
         RETURN (make_listed_product_space(zfactors));
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
         zspc := simplify_maths_space(spc\extended_tuple_space.base);
         rspc := simplify_maths_space(spc\extended_tuple_space.extender);
         RETURN (make_extended_tuple_space(zspc,

 rspc));
      END_IF;
      IF 'FUNCTION_SPACE' IN stypes THEN
         zspc := simplify_maths_space(spc\function_space.domain_argument);
         rspc := simplify_maths_space(spc\function_space.range_argument);
         RETURN (make_function_space(spc\function_space.domain_constraint,

 zspc,

 spc\function_space.range_constraint,

 rspc));
      END_IF;
      RETURN (spc);
   END_FUNCTION;



   FUNCTION simplify_maths_value
      (val : maths_value ) : maths_value;
   LOCAL
      vtypes : SET OF STRING := stripped_typeof(val);
      vlist : LIST OF maths_value;
      nlist : LIST OF maths_value := [];
   END_LOCAL;
      IF 'GENERIC_EXPRESSION' IN vtypes THEN
         RETURN (simplify_generic_expression(val));
      END_IF;
      IF 'LIST' IN vtypes THEN
         vlist := val;
         REPEAT i := 1 TO SIZEOF(vlist);
            INSERT( nlist,

 simplify_maths_value(vlist[i]),

 i - 1 );
         END_REPEAT;
         RETURN (convert_to_maths_value(nlist));
      END_IF;
      RETURN (val);
   END_FUNCTION;



   FUNCTION singleton_member_of
      (spc : maths_space ) : maths_value;
   LOCAL
      types : SET OF STRING := stripped_typeof(spc);
   END_LOCAL;
      IF 'FINITE_SPACE' IN types THEN
         IF SIZEOF(spc\finite_space.members) = 1 THEN
            RETURN (spc\finite_space.members[1]);
         END_IF;
         RETURN (?);
      END_IF;
      IF 'FINITE_INTEGER_INTERVAL' IN types THEN
         IF spc\finite_integer_interval.size = 1 THEN
            RETURN (spc\finite_integer_interval.min);
         END_IF;
         RETURN (?);
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION space_dimension
      (tspace : tuple_space ) : nonnegative_integer;
   LOCAL
      types : SET OF STRING := TYPEOF(tspace);
   END_LOCAL;
      IF schema_prefix + 'UNIFORM_PRODUCT_SPACE' IN types THEN
         RETURN (tspace\uniform_product_space.exponent);
      END_IF;
      IF schema_prefix + 'LISTED_PRODUCT_SPACE' IN types THEN
         RETURN (SIZEOF(tspace\listed_product_space.factors));
      END_IF;
      IF schema_prefix + 'EXTENDED_TUPLE_SPACE' IN types THEN
         RETURN (space_dimension(tspace\extended_tuple_space.base));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION space_is_continuum
      (space : maths_space ) : BOOLEAN;
   LOCAL
      typenames : SET OF STRING := TYPEOF(space);
      factors : LIST OF maths_space;
   END_LOCAL;
      IF NOT EXISTS(space) THEN
         RETURN (FALSE);
      END_IF;
      IF subspace_of_es(space,

 es_reals) OR subspace_of_es(space,

 es_complex_numbers) THEN
         RETURN (TRUE);
      END_IF;
      IF schema_prefix + 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
         RETURN (space_is_continuum(space\uniform_product_space.base));
      END_IF;
      IF schema_prefix + 'LISTED_PRODUCT_SPACE' IN typenames THEN
         factors := space\listed_product_space.factors;
         IF SIZEOF(factors) = 0 THEN
            RETURN (FALSE);
         END_IF;
         REPEAT i := 1 TO SIZEOF(factors);
            IF NOT space_is_continuum(factors[i]) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
         RETURN (TRUE);
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION space_is_singleton
      (spc : maths_space ) : BOOLEAN;
   LOCAL
      types : SET OF STRING := stripped_typeof(spc);
   END_LOCAL;
      IF 'FINITE_SPACE' IN types THEN
         RETURN (bool(SIZEOF(spc\finite_space.members) = 1));
      END_IF;
      IF 'FINITE_INTEGER_INTERVAL' IN types THEN
         RETURN (bool(spc\finite_integer_interval.size = 1));
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION stripped_typeof
      (arg : GENERIC : G ) : SET OF STRING;
   LOCAL
      types : SET OF STRING := TYPEOF(arg);
      stypes : SET OF STRING := [];
      n : INTEGER := LENGTH(schema_prefix);
   END_LOCAL;
      RETURN (stypes);
   END_FUNCTION;



   FUNCTION subspace_of
      (space1 : maths_space;
       space2 : maths_space ) : LOGICAL;
   LOCAL
      spc1 : maths_space := simplify_maths_space(space1);
      spc2 : maths_space := simplify_maths_space(space2);
      types1 : SET OF STRING := stripped_typeof(spc1);
      types2 : SET OF STRING := stripped_typeof(spc2);
      lgcl : LOGICAL;
      cum : LOGICAL;
      es_val : elementary_space_enumerators;
      bnd1 : REAL;
      bnd2 : REAL;
      n : INTEGER;
      sp1 : maths_space;
      sp2 : maths_space;
      prgn1 : polar_complex_number_region;
      prgn2 : polar_complex_number_region;
      aitv : finite_real_interval;
   END_LOCAL;
      IF NOT EXISTS(spc1) OR NOT EXISTS(spc2) THEN
         RETURN (FALSE);
      END_IF;
      IF spc2 = the_generics THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELEMENTARY_SPACE' IN types1 THEN
         IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
            RETURN (FALSE);
         END_IF;
         es_val := spc2\elementary_space.space_id;
         IF spc1\elementary_space.space_id = es_val THEN
            RETURN (TRUE);
         END_IF;
         CASE spc1\elementary_space.space_id OF
            es_numbers :
                  RETURN (FALSE);
            es_complex_numbers :
                  RETURN (es_val = es_numbers);
            es_reals :
                  RETURN (es_val = es_numbers);
            es_integers :
                  RETURN (es_val = es_numbers);
            es_logicals :
                  RETURN (FALSE);
            es_booleans :
                  RETURN (es_val = es_logicals);
            es_strings :
                  RETURN (FALSE);
            es_binarys :
                  RETURN (FALSE);
            es_maths_spaces :
                  RETURN (FALSE);
            es_maths_functions :
                  RETURN (FALSE);
            es_generics :
                  RETURN (FALSE);
         END_CASE;
         RETURN (UNKNOWN);
      END_IF;
      IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
         cum := TRUE;
         REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
            cum := cum AND member_of(i,

 spc2);
            IF cum = FALSE THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
         RETURN (cum);
      END_IF;
      IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            es_val := spc2\elementary_space.space_id;
            RETURN ((es_val = es_numbers) OR (es_val = es_integers));
         END_IF;
         IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
            RETURN (spc1\integer_interval_from_min.min >= spc2\integer_interval_from_min.min);
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            es_val := spc2\elementary_space.space_id;
            RETURN ((es_val = es_numbers) OR (es_val = es_integers));
         END_IF;
         IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
            RETURN (spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'FINITE_REAL_INTERVAL' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            es_val := spc2\elementary_space.space_id;
            RETURN ((es_val = es_numbers) OR (es_val = es_reals));
         END_IF;
         IF (('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2)) OR ('REAL_INTERVAL_TO_MAX' IN types2) THEN
            IF min_exists(spc2) THEN
               bnd1 := spc1\finite_real_interval.min;
               bnd2 := real_min(spc2);
               IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included(spc1)) AND NOT min_included(spc2) THEN
                  RETURN (FALSE);
               END_IF;
            END_IF;
            IF max_exists(spc2) THEN
               bnd1 := spc1\finite_real_interval.max;
               bnd2 := real_max(spc2);
               IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included(spc1)) AND NOT max_included(spc2) THEN
                  RETURN (FALSE);
               END_IF;
            END_IF;
            RETURN (TRUE);
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            es_val := spc2\elementary_space.space_id;
            RETURN ((es_val = es_numbers) OR (es_val = es_reals));
         END_IF;
         IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
            bnd1 := spc1\real_interval_from_min.min;
            bnd2 := spc2\real_interval_from_min.min;
            RETURN ((bnd2 < bnd1) OR (bnd2 = bnd1) AND (min_included(spc2) OR NOT min_included(spc1)));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            es_val := spc2\elementary_space.space_id;
            RETURN ((es_val = es_numbers) OR (es_val = es_reals));
         END_IF;
         IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
            bnd1 := spc1\real_interval_to_max.max;
            bnd2 := spc2\real_interval_to_max.max;
            RETURN ((bnd2 > bnd1) OR (bnd2 = bnd1) AND (max_included(spc2) OR NOT max_included(spc1)));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            es_val := spc2\elementary_space.space_id;
            RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
         END_IF;
         IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
            RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,

 spc2\cartesian_complex_number_region.real_constraint) AND subspace_of(spc1\cartesian_complex_number_region.imag_constraint,

 spc2\cartesian_complex_number_region.imag_constraint));
         END_IF;
         IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
            RETURN (subspace_of(enclose_cregion_in_pregion(spc1,

 spc2\polar_complex_number_region.centre),

 spc2));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            es_val := spc2\elementary_space.space_id;
            RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
         END_IF;
         IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
            RETURN (subspace_of(enclose_pregion_in_cregion(spc1),

 spc2));
         END_IF;
         IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
            prgn1 := spc1;
            prgn2 := spc2;
            IF prgn1.centre = prgn2.centre THEN
               IF prgn2.direction_constraint.max > 3.14159 THEN
                  aitv := make_finite_real_interval(-3.14159,

 open,

 prgn2.direction_constraint.max - 2.00000 * 3.14159,

 prgn2.direction_constraint.max_closure);
                  RETURN (subspace_of(prgn1.distance_constraint,

 prgn2.distance_constraint) AND (subspace_of(prgn1.direction_constraint,

 prgn2.direction_constraint) OR subspace_of(prgn1.direction_constraint,

 aitv)));
               ELSE
                  RETURN (subspace_of(prgn1.distance_constraint,

 prgn2.distance_constraint) AND subspace_of(prgn1.direction_constraint,

 prgn2.direction_constraint));
               END_IF;
            END_IF;
            RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,

 prgn2.centre),

 prgn2));
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'FINITE_SPACE' IN types1 THEN
         cum := TRUE;
         REPEAT i := 1 TO SIZEOF(spc1\finite_space.members);
            cum := cum AND member_of(spc1\finite_space.members[i],

 spc2);
            IF cum = FALSE THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
         RETURN (cum);
      END_IF;
      IF 'PRODUCT_SPACE' IN types1 THEN
         IF 'PRODUCT_SPACE' IN types2 THEN
            IF space_dimension(spc1) = space_dimension(spc2) THEN
               cum := TRUE;
               REPEAT i := 1 TO space_dimension(spc1);
                  cum := cum AND subspace_of(factor_space(spc1,

 i),

 factor_space(spc2,

 i));
                  IF cum = FALSE THEN
                     RETURN (FALSE);
                  END_IF;
               END_REPEAT;
               RETURN (cum);
            END_IF;
         END_IF;
         IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
            IF space_dimension(spc1) >= space_dimension(spc2) THEN
               cum := TRUE;
               REPEAT i := 1 TO space_dimension(spc1);
                  cum := cum AND subspace_of(factor_space(spc1,

 i),

 factor_space(spc2,

 i));
                  IF cum = FALSE THEN
                     RETURN (FALSE);
                  END_IF;
               END_REPEAT;
               RETURN (cum);
            END_IF;
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
         IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
            n := space_dimension(spc1);
            IF n < space_dimension(spc2) THEN
               n := space_dimension(spc2);
            END_IF;
            cum := TRUE;
            REPEAT i := 1 TO n + 1;
               cum := cum AND subspace_of(factor_space(spc1,

 i),

 factor_space(spc2,

 i));
               IF cum = FALSE THEN
                  RETURN (FALSE);
               END_IF;
            END_REPEAT;
            RETURN (cum);
         END_IF;
         RETURN (FALSE);
      END_IF;
      IF 'FUNCTION_SPACE' IN types1 THEN
         IF 'ELEMENTARY_SPACE' IN types2 THEN
            RETURN (spc2\elementary_space.space_id = es_maths_functions);
         END_IF;
         IF 'FUNCTION_SPACE' IN types2 THEN
            cum := TRUE;
            sp1 := spc1\function_space.domain_argument;
            sp2 := spc2\function_space.domain_argument;
            CASE spc1\function_space.domain_constraint OF
               sc_equal :
                     BEGIN
                        CASE spc2\function_space.domain_constraint OF
                           sc_equal :
                                 cum := cum AND equal_maths_spaces(sp1,

 sp2);
                           sc_subspace :
                                 cum := cum AND subspace_of(sp1,

 sp2);
                           sc_member :
                                 cum := cum AND member_of(sp1,

 sp2);
                        END_CASE;
                     END;
               sc_subspace :
                     BEGIN
                        CASE spc2\function_space.domain_constraint OF
                           sc_equal :
                                 RETURN (FALSE);
                           sc_subspace :
                                 cum := cum AND subspace_of(sp1,

 sp2);
                           sc_member :
                                 BEGIN
                                    IF NOT member_of(sp1,

 sp2) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                    cum := UNKNOWN;
                                 END;
                        END_CASE;
                     END;
               sc_member :
                     BEGIN
                        CASE spc2\function_space.domain_constraint OF
                           sc_equal :
                                 cum := (cum AND space_is_singleton(sp1)) AND equal_maths_spaces(singleton_member_of(sp1),

 sp2);
                           sc_subspace :
                                 BEGIN
                                    IF NOT member_of(sp2,

 sp1) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                    cum := UNKNOWN;
                                 END;
                           sc_member :
                                 cum := cum AND subspace_of(sp1,

 sp2);
                        END_CASE;
                     END;
            END_CASE;
            IF cum = FALSE THEN
               RETURN (FALSE);
            END_IF;
            sp1 := spc1\function_space.range_argument;
            sp2 := spc2\function_space.range_argument;
            CASE spc1\function_space.range_constraint OF
               sc_equal :
                     BEGIN
                        CASE spc2\function_space.range_constraint OF
                           sc_equal :
                                 cum := cum AND equal_maths_spaces(sp1,

 sp2);
                           sc_subspace :
                                 cum := cum AND subspace_of(sp1,

 sp2);
                           sc_member :
                                 cum := cum AND member_of(sp1,

 sp2);
                        END_CASE;
                     END;
               sc_subspace :
                     BEGIN
                        CASE spc2\function_space.domain_constraint OF
                           sc_equal :
                                 RETURN (FALSE);
                           sc_subspace :
                                 cum := cum AND subspace_of(sp1,

 sp2);
                           sc_member :
                                 BEGIN
                                    IF NOT member_of(sp1,

 sp2) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                    cum := UNKNOWN;
                                 END;
                        END_CASE;
                     END;
               sc_member :
                     BEGIN
                        CASE spc2\function_space.domain_constraint OF
                           sc_equal :
                                 cum := (cum AND space_is_singleton(sp1)) AND equal_maths_spaces(singleton_member_of(sp1),

 sp2);
                           sc_subspace :
                                 BEGIN
                                    IF NOT member_of(sp2,

 sp1) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                    cum := UNKNOWN;
                                 END;
                           sc_member :
                                 cum := cum AND subspace_of(sp1,

 sp2);
                        END_CASE;
                     END;
            END_CASE;
            RETURN (cum);
         END_IF;
         RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
   END_FUNCTION;



   FUNCTION subspace_of_es
      (spc : maths_space;
       es : elementary_space_enumerators ) : LOGICAL;
   LOCAL
      types : SET OF STRING := stripped_typeof(spc);
   END_LOCAL;
      IF NOT EXISTS(spc) OR NOT EXISTS(es) THEN
         RETURN (FALSE);
      END_IF;
      IF 'ELEMENTARY_SPACE' IN types THEN
         RETURN (es_subspace_of_es(spc\elementary_space.space_id,

 es));
      END_IF;
      IF 'FINITE_SPACE' IN types THEN
         RETURN (all_members_of_es(spc\finite_space.members,

 es));
      END_IF;
      CASE es OF
         es_numbers :
               RETURN (((((((('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types)) OR ('INTEGER_INTERVAL_TO_MAX' IN types)) OR ('FINITE_REAL_INTERVAL' IN types)) OR ('REAL_INTERVAL_FROM_MIN' IN types)) OR ('REAL_INTERVAL_TO_MAX' IN types)) OR ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types)) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types));
         es_complex_numbers :
               RETURN (('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types));
         es_reals :
               RETURN ((('FINITE_REAL_INTERVAL' IN types) OR ('REAL_INTERVAL_FROM_MIN' IN types)) OR ('REAL_INTERVAL_TO_MAX' IN types));
         es_integers :
               RETURN ((('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types)) OR ('INTEGER_INTERVAL_TO_MAX' IN types));
         es_logicals :
               RETURN (FALSE);
         es_booleans :
               RETURN (FALSE);
         es_strings :
               RETURN (FALSE);
         es_binarys :
               RETURN (FALSE);
         es_maths_spaces :
               RETURN (FALSE);
         es_maths_functions :
               RETURN ('FUNCTION_SPACE' IN types);
         es_generics :
               RETURN (TRUE);
      END_CASE;
      RETURN (UNKNOWN);
   END_FUNCTION;



   FUNCTION substitute
      (expr : generic_expression;
       vars : LIST [1:?] OF generic_variable;
       vals : LIST [1:?] OF maths_value ) : generic_expression;
   LOCAL
      types : SET OF STRING := stripped_typeof(expr);
      opnds : LIST OF generic_expression;
      op1 : generic_expression;
      op2 : generic_expression;
      qvars : LIST OF generic_variable;
      srcdom : maths_space_or_function;
      prpfun : LIST [1:?] OF maths_function;
      finfun : maths_function_select;
   END_LOCAL;
      IF SIZEOF(vars) <> SIZEOF(vals) THEN
         RETURN (?);
      END_IF;
      IF 'GENERIC_LITERAL' IN types THEN
         RETURN (expr);
      END_IF;
      IF 'GENERIC_VARIABLE' IN types THEN
         REPEAT i := 1 TO SIZEOF(vars);
            IF expr :=: vars[i] THEN
               RETURN (vals[i]);
            END_IF;
         END_REPEAT;
         RETURN (expr);
      END_IF;
      IF 'QUANTIFIER_EXPRESSION' IN types THEN
         qvars := expr\quantifier_expression.variables;
         REPEAT i := SIZEOF(vars) TO 1 BY -1;
            IF vars[i] IN qvars THEN
               REMOVE( vars,

 i );
               REMOVE( vals,

 i );
            END_IF;
         END_REPEAT;
         opnds := expr\multiple_arity_generic_expression.operands;
         REPEAT i := 1 TO SIZEOF(opnds);
            IF NOT (opnds[i] IN qvars) THEN
               expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i],

 vars,

 vals);
            END_IF;
         END_REPEAT;
         RETURN (expr);
      END_IF;
      IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
         op1 := expr\unary_generic_expression.operand;
         expr\unary_generic_expression.operand := substitute(op1,

 vars,

 vals);
      END_IF;
      IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
         op1 := expr\binary_generic_expression.operands[1];
         expr\binary_generic_expression.operands[1] := substitute(op1,

 vars,

 vals);
         op2 := expr\binary_generic_expression.operands[2];
         expr\binary_generic_expression.operands[2] := substitute(op2,

 vars,

 vals);
      END_IF;
      IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
         srcdom := expr\parallel_composed_function.source_of_domain;
         prpfun := expr\parallel_composed_function.prep_functions;
         finfun := expr\parallel_composed_function.final_function;
         srcdom := substitute(srcdom,

 vars,

 vals);
         REPEAT i := 1 TO SIZEOF(prpfun);
            prpfun[i] := substitute(prpfun[i],

 vars,

 vals);
         END_REPEAT;
         IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
            finfun := substitute(finfun,

 vars,

 vals);
         END_IF;
         RETURN (make_parallel_composed_function(srcdom,

 prpfun,

 finfun));
      END_IF;
      IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
         opnds := expr\multiple_arity_generic_expression.operands;
         REPEAT i := 1 TO SIZEOF(opnds);
            expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i],

 vars,

 vals);
         END_REPEAT;
      END_IF;
      RETURN (expr);
   END_FUNCTION;



   FUNCTION surface_weights_positive
      (b : rational_b_spline_surface ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 0 TO b.u_upper;
         REPEAT j := 0 TO b.v_upper;
            IF b.weights[i][j] <= 0.00000 THEN
               result := FALSE;
               RETURN (result);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION topology_reversed
      (an_item : reversible_topology ) : reversible_topology;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE' IN TYPEOF(an_item) THEN
         RETURN (edge_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PATH' IN TYPEOF(an_item) THEN
         RETURN (path_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
         RETURN (face_bound_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE' IN TYPEOF(an_item) THEN
         RETURN (face_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL' IN TYPEOF(an_item) THEN
         RETURN (shell_reversed(an_item));
      END_IF;
      IF 'SET' IN TYPEOF(an_item) THEN
         RETURN (set_of_topology_reversed(an_item));
      END_IF;
      IF 'LIST' IN TYPEOF(an_item) THEN
         RETURN (list_of_topology_reversed(an_item));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION unique_version_change_order
      (c : action;
       schema_name : STRING ) : BOOLEAN;
   LOCAL
      ords : action_directive := c\directed_action.directive;
      assign : SET OF action_request_assignment := [];
      versions : SET OF product_definition_formation := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ords.requests);
         assign := assign + QUERY (ara <* bag_to_set(USEDIN(ords.requests[i],

 schema_name + '.ACTION_REQUEST_ASSIGNMENT.' + 'ASSIGNED_ACTION_REQUEST'))| (schema_name + '.CHANGE_REQUEST' IN TYPEOF(ara)));
      END_REPEAT;
      REPEAT k := 1 TO SIZEOF(assign);
         versions := versions + assign[k]\change_request.items;
      END_REPEAT;
      RETURN (SIZEOF(QUERY (vers <* versions| NOT (SIZEOF(QUERY (other_vers <* versions - vers| (vers.of_product :=: other_vers.of_product))) = 0))) = 0);
   END_FUNCTION;



   FUNCTION using_items
      (item : founded_item_select;
       checked_items : SET OF founded_item_select ) : SET OF founded_item_select;
   LOCAL
      new_check_items : SET OF founded_item_select;
      result_items : SET OF founded_item_select;
      next_items : SET OF founded_item_select;
   END_LOCAL;
      result_items := [];
      new_check_items := checked_items + item;
      next_items := QUERY (z <* bag_to_set(USEDIN(item,

 ''))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FOUNDED_ITEM' IN TYPEOF(z)));
      IF SIZEOF(next_items) > 0 THEN
         REPEAT i := 1 TO HIINDEX(next_items);
            IF NOT (next_items[i] IN new_check_items) THEN
               result_items := result_items + next_items[i] + using_items(next_items[i],

 new_check_items);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (result_items);
   END_FUNCTION;



   FUNCTION using_representations
      (item : founded_item_select ) : SET OF representation;
   LOCAL
      results : SET OF representation;
      result_bag : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
   END_LOCAL;
      results := [];
      result_bag := USEDIN(item,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
         REPEAT i := 1 TO HIINDEX(result_bag);
            results := results + result_bag[i];
         END_REPEAT;
      END_IF;
      intermediate_items := using_items(item,

 []);
      IF SIZEOF(intermediate_items) > 0 THEN
         REPEAT i := 1 TO HIINDEX(intermediate_items);
            result_bag := USEDIN(intermediate_items[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS');
            IF SIZEOF(result_bag) > 0 THEN
               REPEAT j := 1 TO HIINDEX(result_bag);
                  results := results + result_bag[j];
               END_REPEAT;
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (results);
   END_FUNCTION;



   FUNCTION valid_2d_wireframe_edge_curve
      (crv : curve;
       schma : STRING ) : BOOLEAN;
      IF SIZEOF([ (schma + '.LINE'),

 (schma + '.B_SPLINE_CURVE'),

 (schma + '.CIRCLE'),

 (schma + '.HYPERBOLA'),

 (schma + '.ELLIPSE'),

 (schma + '.PARABOLA'),

 (schma + '.POLYLINE') ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF schma + '.CURVE_REPLICA' IN TYPEOF(crv) THEN
            RETURN (valid_2d_wireframe_edge_curve(crv\curve_replica.parent_curve,

 schma));
         ELSE
            IF schma + '.OFFSET_CURVE_2D' IN TYPEOF(crv) THEN
               RETURN (valid_2d_wireframe_edge_curve(crv\offset_curve_2d.basis_curve,

 schma));
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_basis_curve_in_2d_wireframe
      (crv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE' ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' IN TYPEOF(crv) THEN
            IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARABOLA',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.HYPERBOLA' ] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1 THEN
               RETURN (TRUE);
            ELSE
               RETURN (valid_basis_curve_in_2d_wireframe(crv\trimmed_curve.basis_curve));
            END_IF;
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_2D' IN TYPEOF(crv) THEN
               RETURN (valid_basis_curve_in_2d_wireframe(crv\offset_curve_2d.basis_curve));
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
                  RETURN (valid_basis_curve_in_2d_wireframe(crv\curve_replica.parent_curve));
               ELSE
                  IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE' IN TYPEOF(crv) THEN
                     RETURN (SIZEOF(QUERY (ccs <* crv\composite_curve.segments| NOT valid_basis_curve_in_2d_wireframe(ccs.parent_curve))) = 0);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_calendar_date
      (date : calendar_date ) : LOGICAL;
      CASE date.month_component OF
         1 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         2 :
               BEGIN
                  IF leap_year(date.year_component) THEN
                     RETURN ((1 <= date.day_component) AND (date.day_component <= 29));
                  ELSE
                     RETURN ((1 <= date.day_component) AND (date.day_component <= 28));
                  END_IF;
               END;
         3 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         4 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         5 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         6 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         7 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         8 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         9 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         10 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         11 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         12 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
      END_CASE;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_geometrically_bounded_wf_curve
      (crv : curve;
       schma : STRING ) : BOOLEAN;
      IF SIZEOF([ (schma + '.POLYLINE'),

 (schma + '.B_SPLINE_CURVE'),

 (schma + '.ELLIPSE'),

 (schma + '.CIRCLE') ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF schma + '.TRIMMED_CURVE' IN TYPEOF(crv) THEN
            IF SIZEOF([ (schma + '.LINE'),

 (schma + '.PARABOLA'),

 (schma + '.HYPERBOLA') ] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1 THEN
               RETURN (TRUE);
            ELSE
               RETURN (valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve,

 schma));
            END_IF;
         ELSE
            IF schma + '.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
               RETURN (valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve,

 schma));
            ELSE
               IF schma + '.CURVE_REPLICA' IN TYPEOF(crv) THEN
                  RETURN (valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve,

 schma));
               ELSE
                  IF schma + '.COMPOSITE_CURVE' IN TYPEOF(crv) THEN
                     RETURN (SIZEOF(QUERY (ccs <* crv\composite_curve.segments| NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve,

 schma))) = 0);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_geometrically_bounded_wf_point
      (pnt : point;
       schma : STRING ) : BOOLEAN;
      IF schma + '.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
         RETURN (TRUE);
      ELSE
         IF schma + '.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
            RETURN (valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve,

 schma));
         ELSE
            IF schma + '.POINT_REPLICA' IN TYPEOF(pnt) THEN
               RETURN (valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt,

 schma));
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_measure_value
      (m : measure_value ) : BOOLEAN;
      IF 'REAL' IN TYPEOF(m) THEN
         RETURN (m > 0.00000);
      ELSE
         IF 'INTEGER' IN TYPEOF(m) THEN
            RETURN (m > 0);
         ELSE
            RETURN (TRUE);
         END_IF;
      END_IF;
   END_FUNCTION;



   FUNCTION valid_time
      (time : local_time ) : BOOLEAN;
      IF EXISTS(time.second_component) THEN
         RETURN (EXISTS(time.minute_component));
      ELSE
         RETURN (TRUE);
      END_IF;
   END_FUNCTION;



   FUNCTION valid_units
      (m : measure_with_unit ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 1.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(3.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000,

 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION valid_wireframe_edge_curve
      (crv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
            RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
               RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_wireframe_vertex_point
      (pnt : point ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
            RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION values_space_of
      (expr : generic_expression ) : maths_space;
   LOCAL
      e_prefix : STRING := 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.';
      typenames : SET OF STRING := TYPEOF(expr);
   END_LOCAL;
      IF schema_prefix + 'MATHS_VARIABLE' IN typenames THEN
         RETURN (expr\maths_variable.values_space);
      END_IF;
      IF e_prefix + 'EXPRESSION' IN typenames THEN
         IF e_prefix + 'NUMERIC_EXPRESSION' IN typenames THEN
            IF expr\numeric_expression.is_int THEN
               IF e_prefix + 'INT_LITERAL' IN typenames THEN
                  RETURN (make_finite_space([ expr\int_literal.the_value ]));
               ELSE
                  RETURN (the_integers);
               END_IF;
            ELSE
               IF e_prefix + 'REAL_LITERAL' IN typenames THEN
                  RETURN (make_finite_space([ expr\real_literal.the_value ]));
               ELSE
                  RETURN (the_reals);
               END_IF;
            END_IF;
         END_IF;
         IF e_prefix + 'BOOLEAN_EXPRESSION' IN typenames THEN
            IF e_prefix + 'BOOLEAN_LITERAL' IN typenames THEN
               RETURN (make_finite_space([ expr\boolean_literal.the_value ]));
            ELSE
               RETURN (the_booleans);
            END_IF;
         END_IF;
         IF e_prefix + 'STRING_EXPRESSION' IN typenames THEN
            IF e_prefix + 'STRING_LITERAL' IN typenames THEN
               RETURN (make_finite_space([ expr\string_literal.the_value ]));
            ELSE
               RETURN (the_strings);
            END_IF;
         END_IF;
         RETURN (?);
      END_IF;
      IF schema_prefix + 'MATHS_FUNCTION' IN typenames THEN
         IF expression_is_constant(expr) THEN
            RETURN (make_finite_space([ expr ]));
         ELSE
            RETURN (make_function_space(sc_equal,

 expr\maths_function.domain,

 sc_equal,

 expr\maths_function.range));
         END_IF;
      END_IF;
      IF schema_prefix + 'FUNCTION_APPLICATION' IN typenames THEN
         RETURN (expr\function_application.func.range);
      END_IF;
      IF schema_prefix + 'MATHS_SPACE' IN typenames THEN
         IF expression_is_constant(expr) THEN
            RETURN (make_finite_space([ expr ]));
         ELSE
            RETURN (make_elementary_space(es_maths_spaces));
         END_IF;
      END_IF;
      IF schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
         RETURN (values_space_of(expr\unary_generic_expression.operand));
      END_IF;
      IF schema_prefix + 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr ]));
      END_IF;
      IF schema_prefix + 'LOGICAL_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr\logical_literal.lit_value ]));
      END_IF;
      IF schema_prefix + 'BINARY_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr\binary_literal.lit_value ]));
      END_IF;
      IF schema_prefix + 'MATHS_ENUM_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr\maths_enum_literal.lit_value ]));
      END_IF;
      IF schema_prefix + 'REAL_TUPLE_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr\real_tuple_literal.lit_value ]));
      END_IF;
      IF schema_prefix + 'INTEGER_TUPLE_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr\integer_tuple_literal.lit_value ]));
      END_IF;
      IF schema_prefix + 'ATOM_BASED_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr\atom_based_literal.lit_value ]));
      END_IF;
      IF schema_prefix + 'MATHS_TUPLE_LITERAL' IN typenames THEN
         RETURN (make_finite_space([ expr\maths_tuple_literal.lit_value ]));
      END_IF;
      IF schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
         RETURN (drop_numeric_constraints(values_space_of(expr\partial_derivative_expression.derivand)));
      END_IF;
      IF schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
         RETURN (drop_numeric_constraints(values_space_of(expr\definite_integral_expression.integrand)));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION vector_difference
      (arg1 : vector_or_direction;
       arg2 : vector_or_direction ) : vector;
   LOCAL
      result : vector;
      res : direction;
      vec1 : direction;
      vec2 : direction;
      mag : REAL;
      mag1 : REAL;
      mag2 : REAL;
      ndim : INTEGER;
   END_LOCAL;
      IF (NOT EXISTS(arg1) OR NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim) THEN
         RETURN (?);
      ELSE
         BEGIN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
               mag1 := arg1.magnitude;
               vec1 := arg1.orientation;
            ELSE
               mag1 := 1.00000;
               vec1 := arg1;
            END_IF;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
               mag2 := arg2.magnitude;
               vec2 := arg2.orientation;
            ELSE
               mag2 := 1.00000;
               vec2 := arg2;
            END_IF;
            vec1 := normalise(vec1);
            vec2 := normalise(vec2);
            ndim := SIZEOF(vec1.direction_ratios);
            mag := 0.00000;
            res := dummy_gri || direction(vec1.direction_ratios);
            REPEAT i := 1 TO ndim;
               res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] + mag2 * vec2.direction_ratios[i];
               mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
            END_REPEAT;
            IF mag > 0.00000 THEN
               result := dummy_gri || vector(res,

 sqrt(mag));
            ELSE
               result := dummy_gri || vector(vec1,

 0.00000);
            END_IF;
         END;
      END_IF;
      RETURN (result);
   END_FUNCTION;


(* ***********************************
Rules in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   RULE add_design_object_management_relationship_unique_constraint FOR (add_design_object_assignment,

 add_design_object_request_assignment );
   LOCAL
      pdr_bag : BAG OF product_definition_relationship := [];
      pd_bag : BAG OF product_definition := [];
      adoa_bag : BAG OF add_design_object_assignment;
      adora_bag : BAG OF add_design_object_request_assignment;
      pass : BOOLEAN := TRUE;
      mdo_bag : BAG OF managed_design_object;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(add_design_object_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(add_design_object_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(add_design_object_assignment[i].items[j])) AND (add_design_object_assignment[i].items[j].name = 'design object addition') THEN
               IF EXISTS(add_design_object_assignment[i].items[j].related_product_definition) THEN
                  IF NOT (add_design_object_assignment[i].items[j].related_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + add_design_object_assignment[i].items[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(add_design_object_request_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(add_design_object_request_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(add_design_object_request_assignment[i].items[j])) AND (add_design_object_request_assignment[i].items[j].name = 'design object addition') THEN
               IF EXISTS(add_design_object_request_assignment[i].items[j].related_product_definition) THEN
                  IF NOT (add_design_object_request_assignment[i].items[j].related_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + add_design_object_request_assignment[i].items[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         mdo_bag := [];
         pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object addition');
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adoa_bag := QUERY (adoa <* add_design_object_assignment| pdr_bag[j] IN adoa.items);
            REPEAT k := 1 TO SIZEOF(adoa_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(adoa_bag[k].items) BY 1;
                  IF EXISTS(adoa_bag[k].items[l]) THEN
                     IF adoa_bag[k].items[l] IN mdo_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        mdo_bag := mdo_bag + adoa_bag[k].items[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adora_bag := QUERY (adora <* add_design_object_request_assignment| pdr_bag[j] IN adora.items);
            REPEAT k := 1 TO SIZEOF(adora_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(adora_bag[k].items) BY 1;
                  IF adora_bag[k].items[l] IN mdo_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     mdo_bag := mdo_bag + adora_bag[k].items[l];
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE adjacent_stratum_surface_definition_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(sar.related_shape_aspect)) AND (sar.related_shape_aspect\shape_aspect.description IN [ 'secondary surface' ])))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description IN [ 'primary surface' ])))) = 0;
   END_RULE;



   RULE adjacent_stratum_surface_definition_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      assd : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.description = 'adjacent stratum surface definition');
      pass1 : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
      pss_bag : BAG OF stratum_surface := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass2 : BOOLEAN := TRUE;
      sss_bag : BAG OF stratum_surface;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(assd) BY 1;
         IF EXISTS(assd[i]\shape_aspect_relationship.name) THEN
            IF assd[i]\shape_aspect_relationship.name IN name_bag THEN
               pass1 := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + assd[i]\shape_aspect_relationship.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(assd) BY 1;
         IF EXISTS(assd[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(assd[i].relating_shape_aspect) THEN
               IF NOT (assd[i].relating_shape_aspect IN pss_bag) THEN
                  pss_bag := pss_bag + assd[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pss_bag) BY 1;
         IF NOT pass2 THEN
            ESCAPE;
         END_IF;
         sss_bag := [];
         sar_bag := QUERY (sar <* assd| sar.relating_shape_aspect :=: pss_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(assd[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN sss_bag THEN
                     pass2 := FALSE;
                     ESCAPE;
                  ELSE
                     sss_bag := sss_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE aggregate_connectivity_requirement_unique_constraint FOR (product_definition_relationship );
   LOCAL
      acr : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'aggregate connectivity requirement');
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(acr) BY 1;
         IF EXISTS(acr[i].related_product_definition) THEN
            IF acr[i].id = 'design composition path' THEN
               IF acr[i].related_product_definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + acr[i].related_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE analytical_model_port_unique_constraint FOR (analytical_model_port );
   LOCAL
      name_bag : BAG OF STRING := [];
      amp_bag : BAG OF analytical_model_port;
      rr_bag : BAG OF representation_relationship;
      pass : BOOLEAN := TRUE;
      am_bag : BAG OF analytical_model;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(analytical_model_port) BY 1;
         IF EXISTS(analytical_model_port[i]\representation.name) THEN
            IF NOT (analytical_model_port[i]\representation.name IN name_bag) THEN
               name_bag := name_bag + analytical_model_port[i]\representation.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         amp_bag := QUERY (amp <* analytical_model_port| amp\representation.name = name_bag[i]);
         am_bag := [];
         REPEAT j := 1 TO SIZEOF(amp_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rr_bag := QUERY (rr <* USEDIN(amp_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr\representation_relationship.name = 'access mechanism') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1)));
            REPEAT k := 1 TO SIZEOF(rr_bag) BY 1;
               IF EXISTS(rr_bag[k].rep_1) THEN
                  IF rr_bag[k].rep_1 IN am_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     am_bag := am_bag + rr_bag[k].rep_1;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE angular_dimension_with_direction_vector_unique_constraint FOR (angular_dimension_with_orientation );
   LOCAL
      p_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_relationship;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF property_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(angular_dimension_with_orientation) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         p_bag := QUERY (pd <* USEDIN(angular_dimension_with_orientation[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.description = 'dimensional location property');
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(p_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'measurement orientation') AND (pdr.related_property_definition\property_definition.description = 'datum based vector orientation'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].related_property_definition) THEN
                  IF pdr_bag[k].related_property_definition IN pd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pd_bag := pd_bag + pdr_bag[k].related_property_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE application_context_requires_ap_definition FOR (application_context,

 application_protocol_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (ac <* application_context| NOT (SIZEOF(QUERY (apd <* application_protocol_definition| (ac :=: apd\application_protocol_definition.application) AND (apd\application_protocol_definition.application_interpreted_model_schema_name = 'electronic_assembly_interconnect_and_packaging_design'))) = 1))) = 0;
   END_RULE;



   RULE approval_requires_approval_date_time FOR (approval,

 approval_date_time );
   WHERE
      WR1:
         SIZEOF(QUERY (app <* approval| NOT (SIZEOF(QUERY (adt <* approval_date_time| (app :=: adt.dated_approval))) = 1))) = 0;
   END_RULE;



   RULE approval_requires_approval_person_organization FOR (approval,

 approval_person_organization );
   WHERE
      WR1:
         SIZEOF(QUERY (app <* approval| NOT (SIZEOF(QUERY (apo <* approval_person_organization| (app :=: apo.authorized_approval))) >= 1))) = 0;
   END_RULE;



   RULE approval_role_constraint FOR (approval_role );
   WHERE
      WR1:
         SIZEOF(QUERY (apr <* approval_role| NOT (apr\approval_role.role = 'authorizer'))) = 0;
   END_RULE;



   RULE approvals_are_assigned FOR (approval,

 approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (app <* approval| NOT (SIZEOF(QUERY (aa <* approval_assignment| (app :=: aa.assigned_approval))) >= 1))) = 0;
   END_RULE;



   RULE assembly_composition_relationship_unique_constraint FOR (assembly_component_usage );
   LOCAL
      acr : BAG OF assembly_component_usage := QUERY (acu <* assembly_component_usage| acu\product_definition_relationship.name = 'assembly composition');
      pu_bag : BAG OF physical_unit := [];
      acu_bag : BAG OF assembly_component_usage;
      pass : BOOLEAN := TRUE;
      cd_bag : BAG OF component_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(acr) BY 1;
         IF EXISTS(acr[i].relating_product_definition) THEN
            IF (acr[i].relating_product_definition.frame_of_reference.name = 'physical design') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(acr[i].relating_product_definition)) THEN
               IF NOT (acr[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + acr[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         cd_bag := [];
         acu_bag := QUERY (acu <* acr| acu.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(acu_bag) BY 1;
            IF EXISTS(acu_bag[j].related_product_definition) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(acu_bag[j].related_product_definition) THEN
                  IF acu_bag[j].related_product_definition IN cd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     cd_bag := cd_bag + acu_bag[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE bare_die_unique_constraint FOR (bare_die,

 externally_defined_bare_die,

 library_defined_bare_die );
   LOCAL
      bd : BAG OF physical_unit := QUERY (r <* bare_die| r.frame_of_reference.name = 'physical design usage');
      edbd : BAG OF physical_unit := QUERY (r <* externally_defined_bare_die| r.frame_of_reference.name = 'physical design usage');
      ldbd : BAG OF physical_unit := QUERY (r <* library_defined_bare_die| r.frame_of_reference.name = 'physical design usage');
      pu : BAG OF physical_unit;
      pdr_bag : BAG OF product_definition_relationship;
      fu_bag : BAG OF functional_unit := [];
      pu_bag : BAG OF physical_unit;
      ut_bag : BAG OF property_definition;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF property_definition;
   END_LOCAL;
      pu := bd + edbd + ldbd;
      REPEAT i := 1 TO SIZEOF(pu) BY 1;
         pdr_bag := QUERY (pdr <* USEDIN(pu[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ((pdr\product_definition_relationship.name = 'implemented function') AND (pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)));
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j].relating_product_definition) THEN
               IF NOT (pdr_bag[j].relating_product_definition IN fu_bag) THEN
                  fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pu_bag := QUERY (r <* pu| SIZEOF(QUERY (pdr <* USEDIN(fu_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.related_product_definition :=: r))) > 0);
         pd_bag := [];
         REPEAT j := 1 TO SIZEOF(pu_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            ut_bag := QUERY (pd <* USEDIN(pu_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.name = 'unit technology');
            REPEAT k := 1 TO SIZEOF(ut_bag) BY 1;
               IF EXISTS(ut_bag[k]) THEN
                  IF ut_bag[k] IN pd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pd_bag := pd_bag + ut_bag[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE boundary_size_characteristic_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| ((rep\representation.name = 'diametrical boundary size') OR (rep\representation.name = 'opposing boundary set size')) AND NOT (SIZEOF(QUERY (lmwu <* rep.items| (lmwu\representation_item.name = 'tolerance value'))) = 1))) = 0;
   END_RULE;



   RULE bus_structural_definition_unique_constraint FOR (bus_structural_definition,

 product_definition_formation,

 product );
   LOCAL
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(bus_structural_definition) BY 1;
         IF EXISTS(bus_structural_definition[i].formation.of_product.name) THEN
            IF bus_structural_definition[i].formation.of_product.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + bus_structural_definition[i]\product_definition.formation.of_product.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE cartesian_coordinate_system_constraint FOR (global_unit_assigned_context,

 geometric_representation_context,

 global_uncertainty_assigned_context );
   LOCAL
      guac_inst : SET OF global_unit_assigned_context := QUERY (guac <* global_unit_assigned_context| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(guac)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN TYPEOF(guac)));
   END_LOCAL;
   WHERE
      WR1:
         SIZEOF(QUERY (guac <* guac_inst| NOT (SIZEOF(guac.units) <= 3))) = 0;
      WR2:
         SIZEOF(QUERY (guac <* guac_inst| NOT (((SIZEOF(QUERY (u <* guac.units| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT' IN TYPEOF(u)))) = 1) AND (SIZEOF(QUERY (u <* guac.units| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLANE_ANGLE_UNIT' IN TYPEOF(u)))) = 1)) AND (SIZEOF(QUERY (u <* guac.units| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SOLID_ANGLE_UNIT' IN TYPEOF(u)))) <= 1)))) = 0;
      WR3:
         SIZEOF(QUERY (grc <* guac_inst| NOT ((grc.coordinate_space_dimension = 2) OR (grc.coordinate_space_dimension = 3)))) = 0;
      WR4:
         SIZEOF(QUERY (guac <* guac_inst| NOT (SIZEOF(QUERY (u <* guac.uncertainty| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(u)))) = 1))) = 0;
      WR5:
         SIZEOF(QUERY (guac <* guac_inst| NOT (SIZEOF(QUERY (u <* guac.units| NOT (NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLANE_ANGLE_UNIT' IN TYPEOF(u)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONVERSION_BASED_UNIT' IN TYPEOF(u))) AND (u\conversion_based_unit.name = 'degree')) OR (abs(u\conversion_based_unit.conversion_factor\measure_with_unit.value_component - 0.0174533) <= 0.00100000) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(u\conversion_based_unit.conversion_factor))))) = 0))) = 0;
   END_RULE;



   RULE cartesian_transformation_operator_2d_constraint FOR (cartesian_transformation_operator_2d );
   WHERE
      WR1:
         SIZEOF(QUERY (cto2 <* cartesian_transformation_operator_2d| NOT ((EXISTS(cto2.axis1) AND EXISTS(cto2.axis2)) AND (cto2.scale > 0.00000)))) = 0;
   END_RULE;



   RULE certification_requires_date_or_date_and_time FOR (certification,

 applied_date_and_time_assignment,

 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (cert <* certification| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (cert IN adata.items))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (cert IN ada.items))) = 1)))) = 0;
   END_RULE;



   RULE certification_unique_constraint FOR (certification );
   LOCAL
      r : BAG OF certification := QUERY (r <* certification| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\certification.name) THEN
            IF r[i]\certification.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\certification.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE change_design_object_management_relationship_unique_constraint FOR (change_from_design_object_assignment,

 change_from_design_object_request_assignment,

 change_to_design_object_assignment,

 change_to_design_object_request_assignment );
   LOCAL
      pd_bag : BAG OF product_definition := [];
      pdr_bag : BAG OF product_definition_relationship;
      ctdoa_bag : BAG OF change_to_design_object_assignment;
      ctdora_bag : BAG OF change_to_design_object_request_assignment;
      cfdoa_bag : BAG OF change_from_design_object_assignment;
      cfdora_bag : BAG OF change_from_design_object_request_assignment;
      pass1 : BOOLEAN := TRUE;
      pass2 : BOOLEAN := TRUE;
      mdo_bag : BAG OF managed_design_object;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(change_from_design_object_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(change_from_design_object_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(change_from_design_object_assignment[i].items[j])) AND (change_from_design_object_assignment[i].items[j].name = 'design object change') THEN
               IF EXISTS(change_from_design_object_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (change_from_design_object_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + change_from_design_object_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(change_from_design_object_request_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(change_from_design_object_request_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(change_from_design_object_request_assignment[i].items[j])) AND (change_from_design_object_request_assignment[i].items[j].name = 'design object change') THEN
               IF EXISTS(change_from_design_object_request_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (change_from_design_object_request_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + change_from_design_object_request_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
         IF NOT (pass1 AND pass2) THEN
            ESCAPE;
         END_IF;
         IF pass1 THEN
            mdo_bag := [];
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object change');
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass1 THEN
                  ESCAPE;
               END_IF;
               ctdoa_bag := QUERY (ctdoa <* change_to_design_object_assignment| pdr_bag[j] IN ctdoa.items);
               REPEAT k := 1 TO SIZEOF(ctdoa_bag) BY 1;
                  IF NOT pass1 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(ctdoa_bag[k].items) BY 1;
                     IF EXISTS(ctdoa_bag[k].items[l]) THEN
                        IF ctdoa_bag[k].items[l] IN mdo_bag THEN
                           pass1 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + ctdoa_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass1 THEN
                  ESCAPE;
               END_IF;
               ctdora_bag := QUERY (ctdora <* change_to_design_object_request_assignment| pdr_bag[j] IN ctdora.items);
               REPEAT k := 1 TO SIZEOF(ctdora_bag) BY 1;
                  IF NOT pass1 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(ctdora_bag[k].items) BY 1;
                     IF EXISTS(ctdora_bag[k].items[l]) THEN
                        IF ctdora_bag[k].items[l] IN mdo_bag THEN
                           pass1 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + ctdora_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
         END_IF;
         IF pass2 THEN
            mdo_bag := [];
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object change');
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass2 THEN
                  ESCAPE;
               END_IF;
               cfdoa_bag := QUERY (cfdoa <* change_from_design_object_assignment| pdr_bag[j] IN cfdoa.items);
               REPEAT k := 1 TO SIZEOF(cfdoa_bag) BY 1;
                  IF NOT pass2 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(cfdoa_bag[k].items) BY 1;
                     IF EXISTS(cfdoa_bag[k].items[l]) THEN
                        IF cfdoa_bag[k].items[l] IN mdo_bag THEN
                           pass2 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + cfdoa_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass2 THEN
                  ESCAPE;
               END_IF;
               cfdora_bag := QUERY (cfdora <* change_from_design_object_request_assignment| pdr_bag[j] IN cfdora.items);
               REPEAT k := 1 TO SIZEOF(cfdora_bag) BY 1;
                  IF NOT pass2 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(cfdora_bag[k].items) BY 1;
                     IF EXISTS(cfdora_bag[k].items[l]) THEN
                        IF cfdora_bag[k].items[l] IN mdo_bag THEN
                           pass2 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + cfdora_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE change_request_unique_constraint FOR (versioned_action_request );
   LOCAL
      cr : BAG OF versioned_action_request := QUERY (v <* versioned_action_request| SIZEOF(QUERY (ara <* USEDIN(v,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST' IN TYPEOF(ara)))) > 0);
      version_bag : BAG OF STRING := [];
      var_bag : BAG OF versioned_action_request;
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(versioned_action_request) BY 1;
         IF EXISTS(versioned_action_request[i].version) THEN
            IF NOT (versioned_action_request[i].version IN version_bag) THEN
               version_bag := version_bag + versioned_action_request[i].version;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(version_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         var_bag := QUERY (v <* versioned_action_request| v\versioned_action_request.version = version_bag[i]);
         id_bag := [];
         REPEAT j := 1 TO SIZEOF(var_bag) BY 1;
            IF EXISTS(var_bag[j].id) THEN
               IF var_bag[j].id IN id_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  id_bag := id_bag + var_bag[j].id;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE characterized_product_category_unique_constraint FOR (characterized_product_category );
   LOCAL
      adr : BAG OF applied_document_reference := [];
      documents : BAG OF document := [];
      labels : BAG OF label := [];
      pass : BOOLEAN := TRUE;
      size_of : LIST OF INTEGER := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(characterized_product_category);
         adr := adr + USEDIN(characterized_product_category[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
         labels := labels + characterized_product_category[i]\product_category.name;
      END_REPEAT;
      IF SIZEOF(adr) <> SIZEOF(labels) THEN
         pass := FALSE;
      END_IF;
      REPEAT k := 1 TO SIZEOF(adr);
         documents := documents + adr[k]\document_reference.assigned_document;
      END_REPEAT;
      IF SIZEOF(documents) <> SIZEOF(labels) THEN
         pass := FALSE;
      END_IF;
      REPEAT i := 1 TO SIZEOF(labels);
         REPEAT j := 1 TO SIZEOF(documents);
            REPEAT k := 1 TO SIZEOF(adr);
               IF (labels[i] = adr[k].items[1]\product_category.name) AND (documents[j] = adr[k]\document_reference.assigned_document) THEN
                  size_of[i] := size_of[i] + 1;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(labels);
         IF size_of[i] <> 1 THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE compatible_dimension FOR (cartesian_point,

 direction,

 representation_context,

 geometric_representation_context );
   WHERE
      WR1:
         SIZEOF(QUERY (x <* cartesian_point| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x,

 y) AND (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0))) = 0;
      WR2:
         SIZEOF(QUERY (x <* direction| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x,

 y) AND (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension))) > 0))) = 0;
   END_RULE;



   RULE component_external_reference_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'design owner')))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'part number')))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'revision code')))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'product definition id')))) = 1))) = 0;
      WR5:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'reference designation')))) = 1))) = 0;
   END_RULE;



   RULE component_feature_external_reference_unique_constraint FOR (descriptive_representation_item );
   LOCAL
      cfer : BAG OF descriptive_representation_item := QUERY (dri <* descriptive_representation_item| dri\representation_item.name = 'component feature external reference');
      desc_bag : BAG OF STRING := [];
      dri_bag : BAG OF descriptive_representation_item;
      rep_bag : BAG OF representation;
      pass : BOOLEAN := TRUE;
      r_bag : BAG OF representation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cfer) BY 1;
         IF EXISTS(cfer[i]\descriptive_representation_item.description) THEN
            IF NOT (cfer[i]\descriptive_representation_item.description IN desc_bag) THEN
               desc_bag := desc_bag + cfer[i]\descriptive_representation_item.description;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(desc_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         r_bag := [];
         dri_bag := QUERY (dri <* cfer| dri\descriptive_representation_item.description = desc_bag[i]);
         REPEAT j := 1 TO SIZEOF(dri_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rep_bag := QUERY (r <* USEDIN(dri_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| r\representation.name = 'component external reference');
            REPEAT k := 1 TO SIZEOF(rep_bag) BY 1;
               IF EXISTS(rep_bag[k]) THEN
                  IF rep_bag[k] IN r_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     r_bag := r_bag + rep_bag[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_feature_to_layout_feature_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'component feature to layout feature') AND NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(sar.relating_shape_aspect)) > 0))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'component feature to layout feature') AND NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(sar.related_shape_aspect)) > 0))) = 0;
   END_RULE;



   RULE component_feature_unique_constraint FOR (component_terminal,

 component_interface_terminal );
   LOCAL
      ct : BAG OF shape_aspect := QUERY (ct <* component_terminal| ct\shape_aspect.description IN [ 'assembly module component terminal',

 'bare die component terminal',

 'interconnect component join terminal',

 'interconnect module component terminal',

 'interconnect module component stratum based terminal',

 'minimally defined component terminal',

 'packaged component join terminal' ]);
      cit : BAG OF shape_aspect := QUERY (cit <* component_interface_terminal| cit\shape_aspect.description IN [ 'interconnect component interface terminal',

 'packaged connector component interface terminal' ]);
      cf : BAG OF shape_aspect;
      cd_bag : BAG OF component_definition := [];
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      def_bag : BAG OF shape_aspect;
   END_LOCAL;
      cf := ct + cit;
      REPEAT i := 1 TO SIZEOF(cf) BY 1;
         IF EXISTS(cf[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(cf[i].of_shape.definition) THEN
               IF NOT (cf[i].of_shape.definition IN cd_bag) THEN
                  cd_bag := cd_bag + cf[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         def_bag := [];
         sa_bag := QUERY (sa <* cf| sa.of_shape.definition :=: cd_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'instantiated feature');
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN def_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     def_bag := def_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_mounting_clearance_relationship_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'mounting clearance') AND (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum height'))) = 0))) = 0;
   END_RULE;



   RULE component_overlap_relationship_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'overlap clearance') AND (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum clearance'))) = 0))) = 0;
   END_RULE;



   RULE component_part_2d_geometric_representation_relationship_constraint FOR (shape_representation_relationship );
   LOCAL
      rr : SET OF representation_relationship := QUERY (srr <* shape_representation_relationship| srr\representation_relationship.name = 'component part planar shape');
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rr) BY 1;
         IF rr[i].rep_1.context_of_items.coordinate_space_dimension <> rr[i].rep_2.context_of_items.coordinate_space_dimension THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_part_3d_geometric_representation_relationship_constraint FOR (shape_representation_relationship );
   LOCAL
      rr : SET OF representation_relationship := QUERY (srr <* shape_representation_relationship| srr\representation_relationship.name = 'component part 3d shape');
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rr) BY 1;
         IF rr[i].rep_1.context_of_items.coordinate_space_dimension <> rr[i].rep_2.context_of_items.coordinate_space_dimension THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_placement_restriction_assignment_constraint FOR (representation );
   LOCAL
      cpra : SET OF representation := QUERY (cpra <* representation| cpra.name = 'component placement restriction assignment');
      i : INTEGER;
      pass1 : BOOLEAN := TRUE;
      pass2 : BOOLEAN := TRUE;
      mra : BOOLEAN := FALSE;
      mrv : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cpra);
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         IF NOT ((SIZEOF(QUERY (rr <* USEDIN(cpra[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment area') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))) = 1))) <= 1) OR (SIZEOF(QUERY (rr <* USEDIN(cpra[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment volume') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))) = 1))) <= 1)) THEN
            pass1 := FALSE;
         END_IF;
         mra := SIZEOF(QUERY (rr <* USEDIN(cpra[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment area') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))) = 1))) = 1;
         mrv := SIZEOF(QUERY (rr <* USEDIN(cpra[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment volume') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))) = 1))) = 1;
         IF NOT (mra OR mrv) THEN
            pass1 := FALSE;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cpra);
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         IF NOT pass2 THEN
            ESCAPE;
         END_IF;
         IF NOT (SIZEOF(QUERY (pdr <* USEDIN(cpra[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.definition)) AND (pdr.definition\group.name = 'item restricted requirements property'))) = 1) THEN
            pass2 := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      amt_bag : BAG OF assembly_module_interface_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
         IF EXISTS(cttamta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) THEN
               IF cttamta[i].relating_shape_aspect IN amt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      amt_bag : BAG OF assembly_module_join_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
         IF EXISTS(cttamta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_JOIN_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) THEN
               IF cttamta[i].relating_shape_aspect IN amt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttimta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      imt_bag : BAG OF interconnect_module_interface_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttimta) BY 1;
         IF EXISTS(cttimta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttimta[i].relating_shape_aspect) THEN
               IF cttimta[i].relating_shape_aspect IN imt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttimta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      imt_bag : BAG OF interconnect_module_join_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttimta) BY 1;
         IF EXISTS(cttimta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_JOIN_TERMINAL' IN TYPEOF(cttimta[i].relating_shape_aspect) THEN
               IF cttimta[i].relating_shape_aspect IN imt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      amt_bag : BAG OF assembly_module_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
         IF EXISTS(cttamta[i].relating_shape_aspect) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(cttamta[i].relating_shape_aspect)) AND (cttamta[i].relating_shape_aspect\shape_aspect.description = 'pca terminal') THEN
               IF cttamta[i].relating_shape_aspect IN amt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_termination_passage_template_terminal_unique_constraint FOR (shape_aspect );
   LOCAL
      ctptt : BAG OF shape_aspect := QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'component termination passage template interface terminal') OR (sa\shape_aspect.description = 'component termination passage template join terminal'));
      name_bag : BAG OF STRING := [];
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      ptd_bag : BAG OF part_template_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ctptt) BY 1;
         IF EXISTS(ctptt[i]\shape_aspect.name) THEN
            IF NOT (ctptt[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + ctptt[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ptd_bag := [];
         sa_bag := QUERY (sa <* ctptt| sa\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'access mechanism') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))) AND (sar.relating_shape_aspect\shape_aspect.name = 'component termination passage template'));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN ptd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE composite_shape_element_constraint FOR (composite_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (csa <* composite_shape_aspect| (SIZEOF(QUERY (sar <* USEDIN(csa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composing'))) < 2))) = 0;
      WR2:
         SIZEOF(QUERY (csa <* composite_shape_aspect| NOT (((SIZEOF(TYPEOF(csa)) > 2) OR (csa\shape_aspect.description <> '')) OR (csa\shape_aspect.name <> '')))) = 0;
   END_RULE;



   RULE conductive_interconnect_element_terminal_unique_constraint FOR (component_terminal );
   LOCAL
      ciet : BAG OF component_terminal := QUERY (ct <* component_terminal| ct\shape_aspect.description = 'conductive interconnect element terminal');
      name_bag : BAG OF STRING := [];
      ct_bag : BAG OF component_terminal;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      csa_bag : BAG OF component_shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ciet) BY 1;
         IF EXISTS(ciet[i]\shape_aspect.name) THEN
            IF NOT (ciet[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + ciet[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ct_bag := QUERY (ct <* ciet| ct\shape_aspect.name = name_bag[i]);
         csa_bag := [];
         REPEAT j := 1 TO SIZEOF(ct_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(ct_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'associated component') AND (sar.relating_shape_aspect\shape_aspect.description IN [ 'conductive interconnect element with pre defined transitions',

 'conductive interconnect element with user defined single transition' ])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN csa_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     csa_bag := csa_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE configuration_item_requires_person_organization FOR (configuration_item,

 applied_person_and_organization_assignment,

 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ci <* configuration_item| NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (ci IN apaoa.items))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (ci IN aoa.items))) = 1)))) = 0;
   END_RULE;



   RULE connection_zone_constraint FOR (shape_aspect,

 representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'connection zone') AND NOT (SIZEOF(USEDIN(sa,

 '')) >= 1))) = 0;
      WR2:
         SIZEOF(QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'connection zone') AND NOT (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name IN [ 'connection',

 'minimum attachment region size',

 'maximum attachment region size',

 'external connection area',

 'external connection zone',

 'internal connection zone',

 'mounting area',

 'terminal connection zone' ]))) >= 1))) = 0;
   END_RULE;



   RULE contract_unique_constraint FOR (contract );
   LOCAL
      r : BAG OF contract := QUERY (r <* contract| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\contract.name) THEN
            IF r[i]\contract.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\contract.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE curve_style_font_and_scaling_unique_constraint FOR (curve_style_font_and_scaling );
   LOCAL
      r : BAG OF curve_style_font_and_scaling := QUERY (r <* curve_style_font_and_scaling| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\curve_style_font_and_scaling.name) THEN
            IF r[i]\curve_style_font_and_scaling.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\curve_style_font_and_scaling.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE curve_style_requires_length_measure_with_unit FOR (curve_style );
   WHERE
      WR1:
         SIZEOF(QUERY (cs <* curve_style| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(cs)))) = 0;
   END_RULE;



   RULE curve_style_unique_constraint FOR (representation );
   LOCAL
      cs : BAG OF representation := QUERY (r <* representation| (r\representation.name = 'curve style parameters') AND (r.context_of_items\representation_context.context_type = 'curve style parametric context'));
      pass : BOOLEAN := TRUE;
      desc_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cs) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         REPEAT j := 1 TO SIZEOF(cs[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(cs[i].items[j])) AND (cs[i].items[j]\representation_item.name = 'curve style name') THEN
               IF EXISTS(cs[i].items[j]\descriptive_representation_item.description) THEN
                  IF cs[i].items[j]\descriptive_representation_item.description IN desc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     desc_bag := desc_bag + cs[i].items[j]\descriptive_representation_item.description;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE date_and_time_require_minute_and_second FOR (date_and_time );
   WHERE
      WR1:
         SIZEOF(QUERY (dat <* date_and_time| NOT EXISTS(dat.time_component.minute_component))) = 0;
      WR2:
         SIZEOF(QUERY (dat <* date_and_time| NOT EXISTS(dat.time_component.second_component))) = 0;
   END_RULE;



   RULE date_constraint FOR (date );
   WHERE
      WR1:
         SIZEOF(QUERY (d <* date| (d.year_component < 1856))) = 0;
   END_RULE;



   RULE datum_feature_usage_in_datum_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      dfuidr : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'datum feature usage in common datum') OR (sar\shape_aspect_relationship.name = 'datum feature usage in single datum'));
      pudf_bag : BAG OF physical_unit_datum_feature := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pud_bag : BAG OF physical_unit_datum;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuidr) BY 1;
         IF EXISTS(dfuidr[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(dfuidr[i].relating_shape_aspect) THEN
               IF NOT (dfuidr[i].relating_shape_aspect IN pud_bag) THEN
                  pud_bag := pud_bag + dfuidr[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pud_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pudf_bag := [];
         sar_bag := QUERY (sar <* dfuidr| (sar.relating_shape_aspect :=: pud_bag[i]) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_FEATURE' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN pudf_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pudf_bag := pudf_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE datum_precedence_assignment_unique_constraint FOR (property_definition );
   LOCAL
      dpa : BAG OF property_definition := QUERY (pd <* property_definition| pd\property_definition.description = 'datum precedence assignment');
      name_bag : BAG OF STRING := [];
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_relationship;
      pass : BOOLEAN := TRUE;
      pds : BAG OF property_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dpa) BY 1;
         IF EXISTS(dpa[i]\property_definition.name) THEN
            IF NOT (dpa[i]\property_definition.name IN name_bag) THEN
               name_bag := name_bag + dpa[i]\property_definition.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pds := [];
         pd_bag := QUERY (pd <* dpa| pd\property_definition.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'assigned datum precedence') AND (pdr.relating_property_definition\property_definition.description IN [ 'datum system property with material conditions',

 'datum system property without material conditions' ]));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_property_definition) THEN
                  IF pdr_bag[k].relating_property_definition IN pds THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pds := pds + pdr_bag[k].relating_property_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE datum_target_usage_in_datum_target_set_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      dtuidts : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'datum target usage');
      pudts_bag : BAG OF physical_unit_datum_target_set := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass1 : BOOLEAN := TRUE;
      pudt_bag : BAG OF physical_unit_datum_target;
      pass2 : BOOLEAN := TRUE;
      num_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dtuidts) BY 1;
         IF EXISTS(dtuidts[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET_SET' IN TYPEOF(dtuidts[i].relating_shape_aspect) THEN
               IF NOT (dtuidts[i].relating_shape_aspect IN pudts_bag) THEN
                  pudts_bag := pudts_bag + dtuidts[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pudts_bag) BY 1;
         IF NOT (pass1 AND pass2) THEN
            ESCAPE;
         END_IF;
         num_bag := [];
         pudt_bag := [];
         sar_bag := QUERY (sar <* dtuidts| sar.relating_shape_aspect :=: pudts_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT (pass1 AND pass2) THEN
               ESCAPE;
            END_IF;
            IF pass1 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET' IN TYPEOF(sar_bag[j].related_shape_aspect)) THEN
               IF EXISTS(sar_bag[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN pudt_bag THEN
                     pass1 := FALSE;
                  ELSE
                     pudt_bag := pudt_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
            IF pass2 THEN
               IF EXISTS(sar_bag[j]\shape_aspect_relationship.description) THEN
                  IF sar_bag[j]\shape_aspect_relationship.description IN num_bag THEN
                     pass2 := FALSE;
                  ELSE
                     num_bag := num_bag + sar_bag[j]\shape_aspect_relationship.description;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE datum_usage_in_datum_system_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      duidsr : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'datum usage in datum system');
      ds_bag : BAG OF datum_system := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pud_bag : BAG OF physical_unit_datum;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(duidsr) BY 1;
         IF EXISTS(duidsr[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(duidsr[i].relating_shape_aspect) THEN
               IF NOT (duidsr[i].relating_shape_aspect IN ds_bag) THEN
                  ds_bag := ds_bag + duidsr[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ds_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pud_bag := [];
         sar_bag := QUERY (sar <* duidsr| sar.relating_shape_aspect :=: ds_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(sar_bag[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN pud_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pud_bag := pud_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE default_assembly_bond_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'default assembly bond shape') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(sr,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)))) = 1))) = 0;
   END_RULE;



   RULE default_passage_based_land_physical_template_unique_constraint FOR (land_physical_template );
   LOCAL
      dpblpt : BAG OF land_physical_template := QUERY (lpt <* land_physical_template| lpt\shape_aspect.description IN [ 'default via based',

 'default attachment size and via based',

 'default unsupported passage based',

 'default component termination passage based',

 'default attachment size and component termination passage based' ]);
      sar_bag : BAG OF shape_aspect_relationship;
      pt_bag : BAG OF passage_technology := [];
      pdr_bag : BAG OF property_definition_relationship;
      pass : BOOLEAN := TRUE;
      st_bag : BAG OF stratum_technology;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dpblpt) BY 1;
         sar_bag := QUERY (sar <* USEDIN(dpblpt[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF NOT (sar_bag[j].related_shape_aspect IN pt_bag) THEN
                  pt_bag := pt_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pt_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         st_bag := [];
         sar_bag := QUERY (sar <* USEDIN(pt_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage') AND (sar.relating_shape_aspect IN dpblpt));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(sar_bag[j].relating_shape_aspect\shape_aspect.of_shape,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(pdr.relating_property_definition.definition)));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_property_definition.definition) THEN
                  IF pdr_bag[k].relating_property_definition.definition IN st_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     st_bag := st_bag + pdr_bag[k].relating_property_definition.definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE delete_design_object_management_relationship_unique_constraint FOR (delete_design_object_assignment,

 delete_design_object_request_assignment );
   LOCAL
      pdr_bag : BAG OF product_definition_relationship := [];
      pd_bag : BAG OF product_definition := [];
      ddoa_bag : BAG OF delete_design_object_assignment;
      ddora_bag : BAG OF delete_design_object_request_assignment;
      pass : BOOLEAN := TRUE;
      mdo_bag : BAG OF managed_design_object;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(delete_design_object_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(delete_design_object_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(delete_design_object_assignment[i].items[j])) AND (delete_design_object_assignment[i].items[j].name = 'design object deletion') THEN
               IF EXISTS(delete_design_object_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (delete_design_object_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + delete_design_object_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(delete_design_object_request_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(delete_design_object_request_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(delete_design_object_request_assignment[i].items[j])) AND (delete_design_object_request_assignment[i].items[j].name = 'design object deletion') THEN
               IF EXISTS(delete_design_object_request_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (delete_design_object_request_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + delete_design_object_request_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         mdo_bag := [];
         pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object deletion');
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            ddoa_bag := QUERY (ddoa <* delete_design_object_assignment| pdr_bag[j] IN ddoa.items);
            REPEAT k := 1 TO SIZEOF(ddoa_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(ddoa_bag[k].items) BY 1;
                  IF EXISTS(ddoa_bag[k].items[l]) THEN
                     IF ddoa_bag[k].items[l] IN mdo_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        mdo_bag := mdo_bag + ddoa_bag[k].items[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            ddora_bag := QUERY (ddora <* delete_design_object_request_assignment| pdr_bag[j] IN ddora.items);
            REPEAT k := 1 TO SIZEOF(ddora_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(ddora_bag[k].items) BY 1;
                  IF EXISTS(ddora_bag[k].items[l]) THEN
                     IF ddora_bag[k].items[l] IN mdo_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        mdo_bag := mdo_bag + ddora_bag[k].items[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE dependent_instantiable_action_directive FOR (action_directive );
   WHERE
      WR1:
         SIZEOF(QUERY (ad <* action_directive| NOT (SIZEOF(USEDIN(ad,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_approval_status FOR (approval_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ast <* approval_status| NOT (SIZEOF(USEDIN(ast,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_certification_type FOR (certification_type );
   WHERE
      WR1:
         SIZEOF(QUERY (ct <* certification_type| NOT (SIZEOF(USEDIN(ct,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_contract_type FOR (contract_type );
   WHERE
      WR1:
         SIZEOF(QUERY (ct <* contract_type| NOT (SIZEOF(USEDIN(ct,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_date FOR (date );
   WHERE
      WR1:
         SIZEOF(QUERY (dt <* date| NOT (SIZEOF(USEDIN(dt,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_date_role FOR (date_role );
   WHERE
      WR1:
         SIZEOF(QUERY (dr <* date_role| NOT (SIZEOF(USEDIN(dr,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_date_time_role FOR (date_time_role );
   WHERE
      WR1:
         SIZEOF(QUERY (dtr <* date_time_role| NOT (SIZEOF(USEDIN(dtr,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_document_type FOR (document_type );
   WHERE
      WR1:
         SIZEOF(QUERY (dt <* document_type| NOT (SIZEOF(USEDIN(dt,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_named_unit FOR (named_unit );
   WHERE
      WR1:
         SIZEOF(QUERY (nu <* named_unit| NOT (SIZEOF(USEDIN(nu,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_organization_role FOR (organization_role );
   WHERE
      WR1:
         SIZEOF(QUERY (org <* organization_role| NOT (SIZEOF(USEDIN(org,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_parametric_representation_context FOR (parametric_representation_context );
   WHERE
      WR1:
         SIZEOF(QUERY (prc <* parametric_representation_context| NOT (SIZEOF(USEDIN(prc,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_person_and_organization_role FOR (person_and_organization_role );
   WHERE
      WR1:
         SIZEOF(QUERY (poar <* person_and_organization_role| NOT (SIZEOF(USEDIN(poar,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_representation_item FOR (representation_item );
   WHERE
      WR1:
         SIZEOF(QUERY (ri <* representation_item| NOT (SIZEOF(USEDIN(ri,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_security_classification_level FOR (security_classification_level );
   WHERE
      WR1:
         SIZEOF(QUERY (scl <* security_classification_level| NOT (SIZEOF(USEDIN(scl,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_shape_representation FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (SIZEOF(USEDIN(sr,

 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_tolerance_value FOR (tolerance_value );
   WHERE
      WR1:
         SIZEOF(QUERY (tv <* tolerance_value| NOT (SIZEOF(USEDIN(tv,

 '')) >= 1))) = 0;
   END_RULE;



   RULE design_functional_unit_allocation_to_assembly_component_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') AND NOT ((pdr.relating_product_definition\product_definition.description = 'design definition path') AND (pdr.relating_product_definition.id = 'design composition path')))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.related_product_definition)))) = 0;
   END_RULE;



   RULE design_functional_unit_allocation_to_assembly_component_unique_constraint FOR (product_definition_relationship );
   LOCAL
      dfuatac : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component');
      cd_bag : BAG OF component_definition := [];
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuatac) BY 1;
         IF EXISTS(dfuatac[i].related_product_definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(dfuatac[i].related_product_definition) THEN
               IF NOT (dfuatac[i].related_product_definition IN cd_bag) THEN
                  cd_bag := cd_bag + dfuatac[i].related_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdr_bag := QUERY (pdr <* dfuatac| pdr.related_product_definition :=: cd_bag[i]);
         id_bag := [];
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j].id) THEN
               IF pdr_bag[j].id IN id_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  id_bag := id_bag + pdr_bag[j].id;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR (product_definition_relationship );
   LOCAL
      dfuataj : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'design functional unit allocation to assembly joint');
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuataj) BY 1;
         IF EXISTS(dfuataj[i].relating_product_definition) THEN
            IF dfuataj[i].relating_product_definition.id = 'design composition path' THEN
               IF dfuataj[i].relating_product_definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + dfuataj[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE design_functional_unit_allocation_to_fabrication_joint_unique_constraint FOR (product_definition_relationship );
   LOCAL
      dfuatfj : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'design functional unit allocation to fabrication joint');
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuatfj) BY 1;
         IF EXISTS(dfuatfj[i].relating_product_definition) THEN
            IF dfuatfj[i].relating_product_definition.id = 'design composition path' THEN
               IF dfuatfj[i].relating_product_definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + dfuatfj[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE design_intent_modification_3d_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'positioned design intent modification 3d shape') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE design_intent_modification_planar_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'design intent modification planar position') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
      WR2:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'design intent modification planar position') AND (SIZEOF(QUERY (rep <* USEDIN(mi,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (SIZEOF(USEDIN(rep,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) = 0))) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'design intent modification planar position') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_source.mapped_representation)))) = 0;
   END_RULE;



   RULE design_intent_modification_sequence_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'shape modification sequence') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'shape modification sequence') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar.related_shape_aspect)))) = 0;
   END_RULE;



   RULE design_intent_modification_sequence_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      dims : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'shape modification sequence');
      pm_bag : BAG OF shape_modification := [];
      sar_bag : BAG OF shape_aspect_relationship;
      sm_bag : BAG OF shape_modification;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dims) BY 1;
         IF EXISTS(dims[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(dims[i].relating_shape_aspect) THEN
               IF NOT (dims[i].relating_shape_aspect IN pm_bag) THEN
                  pm_bag := pm_bag + dims[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pm_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* dims| sar.relating_shape_aspect :=: pm_bag[i]);
         sm_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar_bag[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN sm_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     sm_bag := sm_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE device_terminal_map_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'device terminal map relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'device terminal map relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP' IN TYPEOF(sar.related_shape_aspect)))) = 0;
   END_RULE;



   RULE dimension_along_curve_unique_constraint FOR (dimensional_location_with_path );
   LOCAL
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dimensional_location_with_path) BY 1;
         IF EXISTS(dimensional_location_with_path[i].path) THEN
            IF dimensional_location_with_path[i].path IN sa_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               sa_bag := sa_bag + dimensional_location_with_path[i].path;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE dimension_location_with_direction_vector_unique_constraint FOR (dimensional_location_with_direction );
   LOCAL
      p_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_relationship;
      pdrep_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF property_definition := [];
      place_bag : BAG OF placement := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dimensional_location_with_direction) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         p_bag := QUERY (pd <* USEDIN(dimensional_location_with_direction[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.description = 'dimensional location property');
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(p_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'measurement orientation') AND (pdr.related_property_definition\property_definition.description = 'datum based vector orientation'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].related_property_definition) THEN
                  IF pdr_bag[k].related_property_definition IN pd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pd_bag := pd_bag + pdr_bag[k].related_property_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdrep_bag := USEDIN(p_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pdrep_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(pdrep_bag[k].used_representation.items) BY 1;
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLACEMENT' IN TYPEOF(pdrep_bag[k].used_representation.items[l])) AND (pdrep_bag[k].used_representation.items[l]\representation_item.name = 'orientation') THEN
                     IF EXISTS(pdrep_bag[k].used_representation.items[l]) THEN
                        IF pdrep_bag[k].used_representation.items[l] IN place_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           place_bag := place_bag + pdrep_bag[k].used_representation.items[l];
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE directed_action_requires_approval FOR (directed_action,

 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (da <* directed_action| NOT (SIZEOF(QUERY (aaa <* applied_approval_assignment| (da IN aaa.items))) = 1))) = 0;
   END_RULE;



   RULE directed_action_requires_date_or_date_and_time FOR (directed_action,

 applied_date_and_time_assignment,

 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (da <* directed_action| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (da IN adata.items) AND (adata.role\date_time_role.name = 'start date'))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (da IN ada.items) AND (ada.role\date_role.name = 'start date'))) = 1)))) = 0;
   END_RULE;



   RULE directed_axis_constraint FOR (derived_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (dsa <* derived_shape_aspect| (dsa\shape_aspect.description = 'directed axis') AND NOT (SIZEOF(QUERY (sar <* USEDIN(dsa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'derived axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))) AND (sar\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'axis'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (dsa <* derived_shape_aspect| (dsa\shape_aspect.description = 'directed axis') AND NOT (SIZEOF(QUERY (sar <* USEDIN(dsa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'end shape aspect') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect)))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (dsa <* derived_shape_aspect| (dsa\shape_aspect.description = 'directed axis') AND NOT (SIZEOF(QUERY (sar <* USEDIN(dsa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'start shape aspect') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect)))) = 1))) = 0;
   END_RULE;



   RULE directed_axis_unique_constraint FOR (derived_shape_aspect );
   LOCAL
      da : BAG OF derived_shape_aspect := QUERY (r <* derived_shape_aspect| r\shape_aspect.description = 'directed axis');
      sar_bag : BAG OF shape_aspect_relationship;
      cos_bag : BAG OF centre_of_symmetry := [];
      sar2_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(da) BY 1;
         sar_bag := QUERY (sar <* USEDIN(da[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'derived axis') AND (sar.related_shape_aspect\shape_aspect.description = 'axis')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF NOT (sar_bag[j].related_shape_aspect IN cos_bag) THEN
                  cos_bag := cos_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cos_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sa_bag := [];
         sar_bag := QUERY (sar <* USEDIN(cos_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'derived axis') AND (sar.relating_shape_aspect IN da));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar2_bag := QUERY (sar <* USEDIN(sar_bag[j].relating_shape_aspect,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'start shape aspect');
            REPEAT k := 1 TO SIZEOF(sar2_bag) BY 1;
               IF EXISTS(sar2_bag[k].related_shape_aspect) THEN
                  IF sar2_bag[k].related_shape_aspect IN sa_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     sa_bag := sa_bag + sar2_bag[k].related_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE direction_element_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'direction element') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'element direction vector') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))) AND (pdr.related_property_definition\property_definition.description = 'datum direction_property'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'direction element') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'half datum plane direction vector') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))) AND (pdr.related_property_definition\property_definition.description = 'datum direction_property'))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'direction element') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'direction component') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))) AND (pdr.related_property_definition\property_definition.description = 'datum based vector orientation'))) = 1))) = 0;
   END_RULE;



   RULE edge_segment_vertex_constraint FOR (shape_aspect_relationship,

 edge_segment_vertex );
   LOCAL
      sar : BAG OF shape_aspect_relationship := [];
      esv : BAG OF edge_segment_vertex := edge_segment_vertex;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(esv) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar := QUERY (sar <* shape_aspect_relationship| esv[i] = sar\shape_aspect_relationship.related_shape_aspect);
         pass := SIZEOF(sar) = 2;
         REPEAT j := 2 TO SIZEOF(sar) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pass := sar[j] :<>: sar[(j - 1)];
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pass := TYPEOF(sar[j]) = TYPEOF(sar[(j - 1)]);
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pass := sar[j].relating_shape_aspect :=: sar[(j - 1)].relating_shape_aspect;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE edge_segment_vertex_unique_constraint FOR (edge_segment_vertex );
   LOCAL
      esv : BAG OF edge_segment_vertex := QUERY (r <* edge_segment_vertex| r\shape_aspect.name = 'single datum');
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      desc_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(esv) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pd_bag := QUERY (pd <* USEDIN(esv[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.description = 'shape element characterization');
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := USEDIN(pd_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               IF (pdr_bag[k].used_representation\representation.name = 'shape element characterization') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(pdr_bag[k].used_representation.items[1])) THEN
                  IF EXISTS(pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description) THEN
                     IF pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description IN desc_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        desc_bag := desc_bag + pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description;
                     END_IF;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_colour_unique_constraint FOR (colour_rgb,

 colour_specification );
   LOCAL
      r : BAG OF colour_rgb := QUERY (r <* colour_rgb| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\colour_specification.name) THEN
            IF r[i]\colour_specification.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\colour_specification.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_document_constraint FOR (document );
   WHERE
      WR1:
         SIZEOF(QUERY (doc <* document| (SIZEOF(QUERY (adata <* USEDIN(doc,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adata.role\date_time_role.name = 'creation date'))) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (doc <* document| NOT ((SIZEOF(QUERY (aoa <* USEDIN(doc,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'publisher'))) = 1) OR (SIZEOF(QUERY (apaoa <* USEDIN(doc,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apaoa.role\person_and_organization_role.name = 'publisher'))) = 1)))) = 0;
      WR3:
         SIZEOF(QUERY (doc <* document| NOT (SIZEOF(USEDIN(doc,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS')) = 1))) = 0;
   END_RULE;



   RULE ee_document_unique_constraint FOR (document,

 document_identifier_assignment );
   LOCAL
      pass : BOOLEAN := TRUE;
      rev_exists_bag : BAG OF document := [];
      dia_bag : BAG OF document_identifier_assignment := [];
      desc_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(document) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF NOT EXISTS(document[i].description) THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(document_identifier_assignment) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         desc_bag := [];
         REPEAT j := 1 TO SIZEOF(document_identifier_assignment[i].items) BY 1;
            desc_bag := desc_bag + document_identifier_assignment[i].items[j]\document.description;
         END_REPEAT;
         IF NOT value_unique(desc_bag) THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_material_unique_constraint FOR (material_designation );
   LOCAL
      name_bag : BAG OF STRING := [];
      md_bag : BAG OF material_designation;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      doc_bag : BAG OF ee_specification;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(material_designation) BY 1;
         IF EXISTS(material_designation[i].name) THEN
            IF NOT (material_designation[i].name IN name_bag) THEN
               name_bag := name_bag + material_designation[i].name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         md_bag := QUERY (md <* material_designation| md\material_designation.name = name_bag[i]);
         doc_bag := [];
         REPEAT j := 1 TO SIZEOF(md_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := QUERY (adr <* USEDIN(md_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT' IN TYPEOF(adr.assigned_document));
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN doc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     doc_bag := doc_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_configuration_unique_constraint FOR (configuration_item );
   LOCAL
      id_bag : BAG OF STRING := [];
      ci_bag : BAG OF configuration_item;
      cd_bag : BAG OF configuration_design;
      pass : BOOLEAN := TRUE;
      pdf_bag : BAG OF product_definition_formation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(configuration_item) BY 1;
         IF EXISTS(configuration_item[i].id) THEN
            IF NOT (configuration_item[i].id IN id_bag) THEN
               id_bag := id_bag + configuration_item[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdf_bag := [];
         ci_bag := QUERY (ci <* configuration_item| ci.id = id_bag[i]);
         REPEAT j := 1 TO SIZEOF(ci_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            cd_bag := USEDIN(ci_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONFIGURATION_DESIGN.CONFIGURATION');
            REPEAT k := 1 TO SIZEOF(cd_bag) BY 1;
               IF EXISTS(cd_bag[k].design) THEN
                  IF cd_bag[k].design IN pdf_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pdf_bag := pdf_bag + cd_bag[k].design;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_constraint FOR (product );
   WHERE
      WR1:
         SIZEOF(QUERY (prod <* product| NOT ((SIZEOF(QUERY (aoa <* USEDIN(prod,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'design owner'))) = 1) OR (SIZEOF(QUERY (apaoa <* USEDIN(prod,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apaoa.role\person_and_organization_role.name = 'design owner'))) = 1)))) = 0;
      WR2:
         SIZEOF(QUERY (p <* product| (SIZEOF(USEDIN(p,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT')) = 0))) = 0;
   END_RULE;



   RULE ee_product_definition_constraint FOR (product_definition_with_associated_documents );
   WHERE
      WR1:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT (SIZEOF(QUERY (adata <* USEDIN(pdwad,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adata.role\date_time_role.name = 'creation date'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT ((SIZEOF(QUERY (aoa <* USEDIN(pdwad,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'creator'))) = 1) OR (SIZEOF(QUERY (apaoa <* USEDIN(pdwad,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apaoa.role\person_and_organization_role.name = 'creator'))) = 1)))) = 0;
      WR3:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT (SIZEOF(USEDIN(pdwad,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT (SIZEOF(USEDIN(pdwad,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1))) = 0;
   END_RULE;



   RULE ee_product_definition_unique_constraint FOR (product_definition_with_associated_documents,

 physical_unit,

 functional_unit );
   LOCAL
      pdwad : BAG OF product_definition := QUERY (r <* product_definition_with_associated_documents| TRUE);
      pu : BAG OF product_definition := QUERY (r <* physical_unit| TRUE);
      fu : BAG OF product_definition := QUERY (r <* functional_unit| TRUE);
      epd : BAG OF product_definition;
      pdf_bag : BAG OF product_definition_formation;
      pd_bag : BAG OF product_definition;
      pass1 : BOOLEAN := TRUE;
      lcs_bag : BAG OF STRING;
      pass2 : BOOLEAN := TRUE;
      id_bag : BAG OF STRING;
   END_LOCAL;
      epd := pdwad + pu + fu;
      REPEAT i := 1 TO SIZEOF(epd) BY 1;
         IF EXISTS(epd[i].formation) THEN
            IF NOT (epd[i].formation IN pdf_bag) THEN
               pdf_bag := pdf_bag + epd[i].formation;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdf_bag) BY 1;
         IF NOT (pass1 OR pass2) THEN
            ESCAPE;
         END_IF;
         lcs_bag := [];
         id_bag := [];
         pd_bag := QUERY (pd <* epd| pd.formation :=: pdf_bag[i]);
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT (pass1 OR pass2) THEN
               ESCAPE;
            END_IF;
            IF pass2 THEN
               IF EXISTS(pd_bag[j].id) THEN
                  IF pd_bag[j].id IN id_bag THEN
                     pass2 := FALSE;
                     ESCAPE;
                  ELSE
                     id_bag := id_bag + pd_bag[j].id;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass2;
   END_RULE;



   RULE ee_product_model_unique_constraint FOR (product_concept );
   LOCAL
      r : BAG OF product_concept := QUERY (r <* product_concept| TRUE);
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].id) THEN
            IF r[i]\product_concept.id IN id_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               id_bag := id_bag + r[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_unique_constraint FOR (product );
   LOCAL
      id_bag : BAG OF STRING := [];
      p_bag : BAG OF product;
      aoa_bag : BAG OF applied_organization_assignment;
      apaoa_bag : BAG OF applied_person_and_organization_assignment;
      pass : BOOLEAN := TRUE;
      o_bag : BAG OF organization;
      pao_bag : BAG OF person_and_organization;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(product) BY 1;
         IF EXISTS(product[i].id) THEN
            IF NOT (product[i].id IN id_bag) THEN
               id_bag := id_bag + product[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         o_bag := [];
         pao_bag := [];
         p_bag := QUERY (p <* product| p.id = id_bag[i]);
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            aoa_bag := QUERY (aoa <* USEDIN(p_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ORGANIZATION' IN TYPEOF(aoa.assigned_organization)) AND (aoa.role\organization_role.name = 'design owner'));
            REPEAT k := 1 TO SIZEOF(aoa_bag) BY 1;
               IF EXISTS(aoa_bag[k].assigned_organization) THEN
                  IF aoa_bag[k].assigned_organization IN o_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     o_bag := o_bag + aoa_bag[k].assigned_organization;
                  END_IF;
               END_IF;
            END_REPEAT;
            apaoa_bag := QUERY (apaoa <* USEDIN(p_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERSON_AND_ORGANIZATION' IN TYPEOF(apaoa.assigned_person_and_organization)) AND (apaoa.role\person_and_organization_role.name = 'design owner'));
            REPEAT k := 1 TO SIZEOF(apaoa_bag) BY 1;
               IF EXISTS(apaoa_bag[k].assigned_person_and_organization) THEN
                  IF apaoa_bag[k].assigned_person_and_organization IN pao_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pao_bag := pao_bag + apaoa_bag[k].assigned_person_and_organization;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_version_supersedence_constraint FOR (product_definition_formation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdfr <* product_definition_formation_relationship| (pdfr\product_definition_formation_relationship.name = 'product version supersedence') AND NOT (pdfr.relating_product_definition_formation.of_product :=: pdfr.related_product_definition_formation.of_product))) = 0;
   END_RULE;



   RULE explicitly_located_layer_connection_point_unique_constraint FOR (layer_connection_point );
   LOCAL
      ellcp : BAG OF layer_connection_point := QUERY (lcp <* layer_connection_point| lcp\shape_aspect.description = 'explicitly located');
      s_bag : BAG OF stratum := [];
      lcp_bag : BAG OF layer_connection_point;
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      cp_bag : BAG OF cartesian_point;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ellcp) BY 1;
         IF EXISTS(ellcp[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(ellcp[i].of_shape.definition) THEN
               IF NOT (ellcp[i].of_shape.definition IN s_bag) THEN
                  s_bag := s_bag + ellcp[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         cp_bag := [];
         lcp_bag := QUERY (lcp <* ellcp| lcp.of_shape.definition :=: s_bag[i]);
         REPEAT j := 1 TO SIZEOF(lcp_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pd_bag := USEDIN(lcp_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               pdr_bag := QUERY (pdr <* USEDIN(pd_bag[k],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'connection point location') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(pdr.used_representation.items[1])));
               REPEAT l := 1 TO SIZEOF(pdr_bag) BY 1;
                  IF EXISTS(pdr_bag[l].used_representation.items[1]) THEN
                     IF pdr_bag[l].used_representation.items[1] IN cp_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        cp_bag := cp_bag + pdr_bag[l].used_representation.items[1];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE feature_group_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'feature group relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
   END_RULE;



   RULE feature_shape_definition_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| ((sr\representation.name = 'zone shape') AND (sr.context_of_items.coordinate_space_dimension = 3)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(sr)))) = 0;
   END_RULE;



   RULE fill_area_occurrence_constraint FOR (annotation_fill_area_occurrence );
   WHERE
      WR1:
         SIZEOF(QUERY (afao <* annotation_fill_area_occurrence| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_FILL_AREA' IN TYPEOF(afao.item)))) = 0;
      WR2:
         SIZEOF(QUERY (afao <* annotation_fill_area_occurrence| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(afao.fill_style_target)))) = 0;
      WR3:
         SIZEOF(QUERY (afao <* annotation_fill_area_occurrence| (SIZEOF(QUERY (psa <* afao.styles| (SIZEOF(QUERY (cs <* psa.styles| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CURVE_STYLE' IN TYPEOF(cs)))) = 0))) = 0))) = 0;
   END_RULE;



   RULE fill_area_style_constraint FOR (fill_area_style );
   WHERE
      WR1:
         SIZEOF(QUERY (fas <* fill_area_style| NOT (SIZEOF(fas.fill_styles) = 1))) = 0;
   END_RULE;



   RULE fill_area_style_unique_constraint FOR (fill_area_style );
   LOCAL
      r : BAG OF fill_area_style := QUERY (r <* fill_area_style| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\fill_area_style.name) THEN
            IF r[i]\fill_area_style.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\fill_area_style.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_unit_network_node_definition_unique_constraint FOR (network_node_definition );
   LOCAL
      funnd : BAG OF network_node_definition := QUERY (nnd <* network_node_definition| nnd.frame_of_reference.name = 'functional network design');
      name_bag : BAG OF STRING := [];
      nnd_bag : BAG OF network_node_definition;
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      fu_bag : BAG OF functional_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(funnd) BY 1;
         IF EXISTS(funnd[i]\product_definition.name) THEN
            IF NOT (funnd[i]\product_definition.name IN name_bag) THEN
               name_bag := name_bag + funnd[i]\product_definition.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         fu_bag := [];
         nnd_bag := QUERY (nnd <* funnd| nnd\product_definition.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(nnd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(nnd_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND (pdr\product_definition_relationship.name = 'functional unit network node'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_product_definition) THEN
                  IF pdr_bag[k].relating_product_definition IN fu_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_unit_network_terminal_definition_bus_assignment_constraint FOR (property_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition)))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pdr.related_property_definition.definition)) AND (SIZEOF(QUERY (futd <* USEDIN(pdr.related_property_definition.definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION.OF_SHAPE' IN TYPEOF(futd)))) > 0)))) = 0;
   END_RULE;



   RULE functional_unit_terminal_bus_assignment_constraint FOR (property_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'functional unit terminal bus assignment') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition)))) = 0;
   END_RULE;



   RULE functional_unit_unique_constraint FOR (component_functional_unit );
   LOCAL
      fu : BAG OF component_functional_unit := QUERY (cfu <* component_functional_unit| cfu.frame_of_reference.name = 'functional occurrence');
      id_bag : BAG OF STRING := [];
      cfu_bag : BAG OF component_functional_unit;
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      fu_bag : BAG OF functional_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(fu) BY 1;
         IF EXISTS(fu[i].id) THEN
            IF NOT (fu[i].id IN id_bag) THEN
               id_bag := id_bag + fu[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         fu_bag := [];
         cfu_bag := QUERY (cfu <* fu| cfu.id = id_bag[i]);
         REPEAT j := 1 TO SIZEOF(cfu_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(cfu_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ((pdr\product_definition_relationship.name = 'network composition') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition))) AND (pdr.relating_product_definition.frame_of_reference.name = 'functional network design'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_product_definition) THEN
                  IF pdr_bag[k].relating_product_definition IN fu_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR (functional_unit_terminal_definition );
   LOCAL
      name_bag : BAG OF STRING := [];
      futd_bag : BAG OF functional_unit_terminal_definition;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      fu_bag : BAG OF functional_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(functional_unit_terminal_definition) BY 1;
         IF EXISTS(functional_unit_terminal_definition[i]\shape_aspect.name) THEN
            IF NOT (functional_unit_terminal_definition[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + functional_unit_terminal_definition[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         fu_bag := [];
         futd_bag := QUERY (futd <* functional_unit_terminal_definition| ((futd\shape_aspect.name = name_bag[i]) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(futd.of_shape.definition))) AND (futd.of_shape.definition.frame_of_reference.name = 'functional design usage'));
         REPEAT j := 1 TO SIZEOF(futd_bag) BY 1;
            IF EXISTS(futd_bag[j].of_shape.definition) THEN
               IF futd_bag[j].of_shape.definition IN fu_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  fu_bag := fu_bag + futd_bag[j].of_shape.definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_usage_view_to_part_terminal_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal')))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.related_shape_aspect))))) = 0;
   END_RULE;



   RULE functional_usage_view_to_part_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      fuvtpta : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'functional terminal allocation');
      futd_bag : BAG OF functional_unit_terminal_definition := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(fuvtpta) BY 1;
         IF EXISTS(fuvtpta[i].relating_shape_aspect) THEN
            IF fuvtpta[i].relating_shape_aspect\shape_aspect.description = 'scalar terminal' THEN
               IF NOT (fuvtpta[i].relating_shape_aspect IN futd_bag) THEN
                  futd_bag := futd_bag + fuvtpta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(futd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* fuvtpta| (sar.relating_shape_aspect :=: futd_bag[i]) AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL') ] * TYPEOF(sar.related_shape_aspect)) > 0));
         sa_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_usage_view_to_printed_part_template_terminal_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal')))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)) AND ((sar.related_shape_aspect\shape_aspect.description = 'interface terminal') OR (sar.related_shape_aspect\shape_aspect.description = 'join terminal'))))) = 0;
   END_RULE;



   RULE functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      fuvtpptta : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'functional terminal allocation');
      futd_bag : BAG OF functional_unit_terminal_definition := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pptt_bag : BAG OF printed_part_template_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(fuvtpptta) BY 1;
         IF EXISTS(fuvtpptta[i].relating_shape_aspect) THEN
            IF fuvtpptta[i].relating_shape_aspect\shape_aspect.description = 'scalar terminal' THEN
               IF NOT (fuvtpptta[i].relating_shape_aspect IN futd_bag) THEN
                  futd_bag := futd_bag + fuvtpptta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(futd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pptt_bag := [];
         sar_bag := QUERY (sar <* fuvtpptta| ((sar.relating_shape_aspect :=: futd_bag[i]) AND (sar.related_shape_aspect\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN pptt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pptt_bag := pptt_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE geometric_tolerance_qualifier_constraint FOR (measure_qualification );
   WHERE
      WR1:
         SIZEOF(QUERY (mq <* measure_qualification| ((mq\measure_qualification.name = 'predefined geometric tolerance qualifier') OR (mq\measure_qualification.name = 'user defined geometric tolerance qualifier')) AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(mq.qualified_measure)) AND (SIZEOF(QUERY (pugt <* USEDIN(mq.qualified_measure,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE.MAGNITUDE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt)))) = 0)))) = 0;
   END_RULE;



   RULE inter_stratum_extent_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'inter stratum extent') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.related_product_definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.relating_product_definition))))) = 0;
   END_RULE;



   RULE interconnect_component_interface_terminal_unique_constraint FOR (component_interface_terminal );
   LOCAL
      icit : BAG OF component_interface_terminal := QUERY (cit <* component_interface_terminal| cit\shape_aspect.description = 'interconnect component interface terminal');
      icd_bag : BAG OF interface_component_definition := [];
      cit_bag : BAG OF component_interface_terminal;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(icit) BY 1;
         IF EXISTS(icit[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(icit[i].of_shape.definition) THEN
               IF NOT (icit[i].of_shape.definition IN icd_bag) THEN
                  icd_bag := icd_bag + icit[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(icd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         cit_bag := QUERY (cit <* icit| cit.of_shape.definition :=: icd_bag[i]);
         REPEAT j := 1 TO SIZEOF(cit_bag) BY 1;
            IF EXISTS(cit_bag[j]\shape_aspect.name) THEN
               IF cit_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + cit_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE interconnect_component_join_terminal_unique_constraint FOR (component_terminal );
   LOCAL
      icjt : BAG OF component_terminal := QUERY (ct <* component_terminal| ct\shape_aspect.description = 'interconnect component join terminal');
      cd_bag : BAG OF component_definition := [];
      ct_bag : BAG OF component_terminal;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(icjt) BY 1;
         IF EXISTS(icjt[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(icjt[i].of_shape.definition) THEN
               IF NOT (icjt[i].of_shape.definition IN cd_bag) THEN
                  cd_bag := cd_bag + icjt[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         ct_bag := QUERY (ct <* icjt| ct.of_shape.definition :=: cd_bag[i]);
         REPEAT j := 1 TO SIZEOF(ct_bag) BY 1;
            IF EXISTS(ct_bag[j]\shape_aspect.name) THEN
               IF ct_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + ct_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE interconnect_module_constraint_region_constraint FOR (group_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (gsa <* group_shape_aspect| NOT (gsa\shape_aspect.description = 'interconnect module constraint region') OR NOT (SIZEOF(QUERY (pd <* USEDIN(gsa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) OR (pdr.used_representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 3)))) = 1))) = 0))) = 0;
   END_RULE;



   RULE interconnect_module_stratum_assembly_relationship_constraint FOR (assembly_component_usage );
   WHERE
      WR1:
         SIZEOF(QUERY (acu <* assembly_component_usage| (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(acu.relating_product_definition)))) = 0;
      WR2:
         SIZEOF(QUERY (acu <* assembly_component_usage| (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(acu.related_product_definition)))) = 0;
   END_RULE;



   RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR (assembly_component_usage );
   LOCAL
      imsar : BAG OF assembly_component_usage := QUERY (acu <* assembly_component_usage| acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship');
      pu_bag : BAG OF physical_unit := [];
      acu_bag : BAG OF assembly_component_usage;
      pass : BOOLEAN := TRUE;
      refdes_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(imsar) BY 1;
         IF EXISTS(imsar[i].relating_product_definition) THEN
            IF (imsar[i].relating_product_definition.frame_of_reference.name = 'physical design') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(imsar[i].relating_product_definition)) THEN
               IF NOT (imsar[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + imsar[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         refdes_bag := [];
         acu_bag := QUERY (acu <* imsar| acu.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(acu_bag) BY 1;
            IF EXISTS(acu_bag[j].reference_designator) THEN
               IF acu_bag[j].reference_designator IN refdes_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  refdes_bag := refdes_bag + acu_bag[j].reference_designator;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE interconnect_module_surface_feature_constraint FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| (((((((sa\shape_aspect.description = 'interconnect module edge segment surface') OR (sa\shape_aspect.description = 'interconnect module cavity surface')) OR (sa\shape_aspect.description = 'interconnect module cutout surface')) OR (sa\shape_aspect.description = 'interconnect module edge surface')) OR (sa\shape_aspect.description = 'interconnect module primary surface')) OR (sa\shape_aspect.description = 'interconnect module secondary surface')) OR (sa\shape_aspect.description = 'interconnect module surface feature')) AND NOT (((sa.of_shape.definition\product_definition.name = 'interconnect module') AND (sa.of_shape.definition.frame_of_reference.name = 'physical design usage')) AND ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition)))))) = 0;
   END_RULE;



   RULE interface_component_allocation_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'interface component allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_product_definition)) AND (pdr.relating_product_definition\product_definition.description = 'mating connector')))) = 0;
   END_RULE;



   RULE internal_stratum_access_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      isa : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'internal stratum access');
      paa_bag : BAG OF probe_access_area := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pp_bag : BAG OF plated_passage;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(isa) BY 1;
         IF EXISTS(isa[i].relating_shape_aspect) THEN
            IF (isa[i].relating_shape_aspect\shape_aspect.description = 'internal probe access area') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA' IN TYPEOF(isa[i].relating_shape_aspect)) THEN
               IF NOT (isa[i].relating_shape_aspect IN paa_bag) THEN
                  paa_bag := paa_bag + isa[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(paa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pp_bag := [];
         sar_bag := QUERY (sar <* isa| ((sar.relating_shape_aspect :=: paa_bag[i]) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(sar.related_shape_aspect))) AND (sar.related_shape_aspect\shape_aspect.description IN [ 'bonded conductive base blind via',

 'buried via',

 'interfacial connection',

 'non conductive base blind via',

 'plated conductive base blind via' ]));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN pp_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pp_bag := pp_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE junction_vertex_allocation_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'junction vertex allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sar.related_shape_aspect)) AND (sar.related_shape_aspect\shape_aspect.description = 'explicitly located') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect)) AND (sar.related_shape_aspect\shape_aspect.name = 'inter stratum join')))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'junction vertex allocation') AND NOT (sar.relating_shape_aspect\shape_aspect.description = 'topological junction'))) = 0;
   END_RULE;



   RULE junction_vertex_allocation_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      jva : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'junction vertex allocation');
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(jva) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF EXISTS(jva[i].relating_shape_aspect) THEN
            IF jva[i].relating_shape_aspect\shape_aspect.description = 'topological junction' THEN
               IF jva[i].relating_shape_aspect IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + jva[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE land_physical_template_unique_constraint FOR (land_physical_template );
   LOCAL
      adr_bag : BAG OF applied_document_reference;
      duc : BAG OF document_usage_constraint;
      pass : BOOLEAN := TRUE;
      duc_bag : BAG OF document_usage_constraint := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(land_physical_template) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         adr_bag := USEDIN(land_physical_template[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
         REPEAT j := 1 TO SIZEOF(adr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            duc := QUERY (r <* USEDIN(adr_bag[j].assigned_document,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| r\document_usage_constraint.subject_element = 'predefined classification code');
            REPEAT k := 1 TO SIZEOF(duc) BY 1;
               IF EXISTS(duc[k]) THEN
                  IF duc[k] IN duc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     duc_bag := duc_bag + duc[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE land_template_terminal_unique_constraint FOR (land_template_terminal );
   LOCAL
      ltt : BAG OF land_template_terminal := QUERY (sa <* land_template_terminal| sa\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ]);
      name_bag : BAG OF STRING := [];
      ltt_bag : BAG OF land_template_terminal;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      lpt_bag : BAG OF land_physical_template;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ltt) BY 1;
         IF EXISTS(ltt[i]\shape_aspect.name) THEN
            IF NOT (ltt[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + ltt[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         lpt_bag := [];
         ltt_bag := QUERY (sa <* ltt| sa\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(ltt_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(ltt_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN lpt_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     lpt_bag := lpt_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE layout_spacing_requirement_non_conforming_design_object_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'layout spacing requirement violation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(sar.related_shape_aspect)) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'layout spacing requirement violation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(sar.relating_shape_aspect)) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'layout spacing requirement violation') AND NOT (SIZEOF(QUERY (grp <* USEDIN(sar,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP' IN TYPEOF(grp)) AND (grp\group.name = 'layout spacing requirements property'))) = 1))) = 0;
   END_RULE;



   RULE layout_spacing_requirement_occurrence_unique_constraint FOR (grouped_requirements_property,

 characterized_object );
   LOCAL
      lsro : BAG OF grouped_requirements_property := QUERY (grp <* grouped_requirements_property| grp\group.name = 'layout spacing requirements property');
      ddo : BAG OF characterized_object := QUERY (co <* characterized_object| co\characterized_object.description = 'dependent design object category');
      ga_bag : BAG OF group_assignment := [];
      ddname_bag : BAG OF STRING := [];
      co_bag : BAG OF characterized_object := [];
      pdb : LIST OF property_definition := [];
      pd_bag : BAG OF property_definition := [];
      grp_bag : BAG OF grouped_requirements_property := [];
      rga_bag : BAG OF group_assignment := [];
      pass : BOOLEAN := TRUE;
      rdname_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(lsro) BY 1;
         ga_bag := QUERY (aga <* USEDIN(lsro[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga));
         REPEAT j := 1 TO SIZEOF(ga_bag) BY 1;
            REPEAT k := 1 TO SIZEOF(ga_bag[j].items) BY 1;
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(ga_bag[j].items[k]) THEN
                  pdb[i] := ga_bag[j].items[k];
               ELSE
                  pdb := [];
               END_IF;
               IF ((pdb :<>: []) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(pdb[1]\property_definition.definition))) AND (pdb[1]\property_definition.definition\characterized_object.description = 'dependent design object category') THEN
                  IF EXISTS(pdb[1]\property_definition.definition\characterized_object.name) THEN
                     IF NOT (pdb[1]\property_definition.definition\characterized_object.name IN ddname_bag) THEN
                        ddname_bag := ddname_bag + pdb[1]\property_definition.definition\characterized_object.name;
                     END_IF;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ddname_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         rdname_bag := [];
         co_bag := QUERY (co <* ddo| co\characterized_object.name = ddname_bag[i]);
         REPEAT j := 1 TO SIZEOF(co_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pd_bag := USEDIN(co_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               ga_bag := QUERY (ga <* USEDIN(pd_bag[k],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(ga.assigned_group));
               REPEAT l := 1 TO SIZEOF(ga_bag) BY 1;
                  IF NOT pass THEN
                     ESCAPE;
                  END_IF;
                  IF NOT (ga_bag[l].assigned_group IN grp_bag) THEN
                     grp_bag := grp_bag + ga_bag[l].assigned_group;
                  END_IF;
               END_REPEAT;
               REPEAT l := 1 TO SIZEOF(grp_bag) BY 1;
                  IF NOT pass THEN
                     ESCAPE;
                  END_IF;
                  rga_bag := USEDIN(grp_bag[l],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP');
                  REPEAT m := 1 TO SIZEOF(rga_bag) BY 1;
                     IF NOT pass THEN
                        ESCAPE;
                     END_IF;
                     REPEAT n := 1 TO SIZEOF(rga_bag[m].items) BY 1;
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(rga_bag[n].items[m]) THEN
                           pdb[1] := rga_bag[n].items[m];
                        ELSE
                           pdb := [];
                        END_IF;
                        IF ((pdb :<>: []) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(pdb[1]\property_definition.definition))) AND (pdb[1]\property_definition.definition\characterized_object.description = 'reference design object category') THEN
                           IF EXISTS(pdb[1]\property_definition.definition\characterized_object.name) THEN
                              IF pdb[1]\property_definition.definition\characterized_object.name IN rdname_bag THEN
                                 pass := FALSE;
                                 ESCAPE;
                              ELSE
                                 rdname_bag := rdname_bag + pdb[1]\property_definition.definition\characterized_object.name;
                              END_IF;
                           END_IF;
                        END_IF;
                     END_REPEAT;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE located_interconnect_module_thickness_requirement_unique_constraint FOR (property_definition_representation );
   LOCAL
      limrt : BAG OF property_definition_representation := QUERY (pdr <* property_definition_representation| (pdr.definition\property_definition.name = 'located interconnect module thickness') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)));
      pu_bag : BAG OF physical_unit := [];
      pdr_bag : BAG OF property_definition_representation;
      rr_bag : BAG OF representation_relationship;
      pass : BOOLEAN := TRUE;
      ri_bag : BAG OF representation_item;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(limrt) BY 1;
         IF EXISTS(limrt[i].definition.definition.of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(limrt[i].definition.definition.of_shape.definition) THEN
               IF NOT (limrt[i].definition.definition.of_shape.definition IN pu_bag) THEN
                  pu_bag := pu_bag + limrt[i].definition.definition.of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ri_bag := [];
         pdr_bag := QUERY (pdr <* limrt| pdr.definition.definition.of_shape.definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rr_bag := QUERY (rr <* USEDIN(pdr_bag[j].used_representation,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| rr\representation_relationship.name = 'reference location');
            REPEAT k := 1 TO SIZEOF(rr_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(rr_bag[k].rep_1.items) BY 1;
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(rr_bag[k].rep_1.items[l])) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(rr_bag[k].rep_1.items[l])) THEN
                     IF EXISTS(rr_bag[k].rep_1.items[l]) THEN
                        IF rr_bag[k].rep_1.items[l] IN ri_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           ri_bag := ri_bag + rr_bag[k].rep_1.items[l];
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE marking_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| ((rep\representation.name = 'marking') AND (SIZEOF(QUERY (pdr <* USEDIN(rep,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition)))) > 0)) AND NOT (SIZEOF(QUERY (place <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLACEMENT' IN TYPEOF(place)) AND (place\representation_item.name = 'marking location'))) = 1))) = 0;
   END_RULE;



   RULE mating_connector_placement_relationship_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'mating connector placement') AND (SIZEOF(QUERY (p <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLACEMENT' IN TYPEOF(p)) AND (p\representation_item.name = 'connector placement'))) = 0))) = 0;
   END_RULE;



   RULE mating_connector_termination_constraint FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'mating connector termination') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(sa.of_shape.definition)) AND (sa.of_shape.definition\product_definition.description = 'mating connector')))) = 0;
   END_RULE;



   RULE mating_connector_termination_unique_constraint FOR (shape_aspect );
   LOCAL
      mct : BAG OF shape_aspect := QUERY (sa <* shape_aspect| sa\shape_aspect.description = 'mating connector termination');
      cd_bag : BAG OF component_definition := [];
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      ppt_bag : BAG OF packaged_part_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(mct) BY 1;
         IF EXISTS(mct[i].of_shape.definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(mct[i].of_shape.definition)) AND (mct[i].of_shape.definition\product_definition.description = 'mating connector') THEN
               IF NOT (mct[i].of_shape.definition IN cd_bag) THEN
                  cd_bag := cd_bag + mct[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ppt_bag := [];
         sa_bag := QUERY (sa <* mct| sa.of_shape.definition :=: cd_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated terminal') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN ppt_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     ppt_bag := ppt_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE model_parameter_unique_constraint FOR (model_parameter );
   LOCAL
      name_bag : BAG OF STRING := [];
      mp_bag : BAG OF model_parameter;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      d_bag : BAG OF document;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(model_parameter) BY 1;
         IF EXISTS(model_parameter[i]\representation_item.name) THEN
            IF NOT (model_parameter[i]\representation_item.name IN name_bag) THEN
               name_bag := name_bag + model_parameter[i]\representation_item.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         mp_bag := QUERY (mp <* model_parameter| mp\representation_item.name = name_bag[i]);
         d_bag := [];
         REPEAT j := 1 TO SIZEOF(mp_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := USEDIN(mp_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN d_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     d_bag := d_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE next_higher_assembly_interface_requirement_constraint FOR (specified_higher_usage_occurrence );
   WHERE
      WR1:
         SIZEOF(QUERY (shuo <* specified_higher_usage_occurrence| NOT (SIZEOF(QUERY (pd <* USEDIN(shuo,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = '3d bound volume shape'))) = 0))) = 0))) = 0;
   END_RULE;



   RULE next_higher_assembly_relationship_unique_constraint FOR (next_assembly_usage_occurrence );
   LOCAL
      pu_bag : BAG OF physical_unit := [];
      nauo_bag : BAG OF next_assembly_usage_occurrence;
      pass : BOOLEAN := TRUE;
      refdes_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(next_assembly_usage_occurrence) BY 1;
         IF EXISTS(next_assembly_usage_occurrence[i].relating_product_definition) THEN
            IF (next_assembly_usage_occurrence[i].relating_product_definition.frame_of_reference.name = 'physical design') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(next_assembly_usage_occurrence[i].relating_product_definition)) THEN
               IF NOT (next_assembly_usage_occurrence[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + next_assembly_usage_occurrence[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         refdes_bag := [];
         nauo_bag := QUERY (nauo <* next_assembly_usage_occurrence| nauo.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(nauo_bag) BY 1;
            IF EXISTS(nauo_bag[j].reference_designator) THEN
               IF nauo_bag[j].reference_designator IN refdes_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  refdes_bag := refdes_bag + nauo_bag[j].reference_designator;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE no_shape_for_make_from FOR (make_from_usage_option );
   WHERE
      WR1:
         SIZEOF(QUERY (mfuo <* make_from_usage_option| NOT (SIZEOF(QUERY (pd <* USEDIN(mfuo,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)))) = 0))) = 0;
   END_RULE;



   RULE operational_requirement_occurrence_relationship_constraint FOR (property_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_relationship| ((pdr\property_definition_relationship.name = 'and operation') OR (pdr\property_definition_relationship.name = 'or operation')) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* property_definition_relationship| ((pdr\property_definition_relationship.name = 'and operation') OR (pdr\property_definition_relationship.name = 'or operation')) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition)))) = 0;
   END_RULE;



   RULE organization_unique_constraint FOR (organization );
   LOCAL
      r : BAG OF organization := QUERY (r <* organization| TRUE);
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].id) THEN
            IF r[i]\organization.id IN id_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               id_bag := id_bag + r[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE origin_constraint FOR (placement );
   LOCAL
      origin_2d : SET OF axis2_placement_2d := QUERY (pl <* placement| (pl\representation_item.name = 'origin') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D' IN TYPEOF(pl)));
      origin_3d : SET OF axis2_placement_3d := QUERY (pl <* placement| (pl\representation_item.name = 'origin') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(pl)));
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(origin_2d) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF NOT (((origin_2d[i].location.coordinates[1] = 0.00000) AND (origin_2d[i].location.coordinates[2] = 0.00000)) AND NOT EXISTS(origin_2d[i].ref_direction)) THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(origin_3d) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF NOT (((((origin_3d[i].location.coordinates[1] = 0.00000) AND (origin_3d[i].location.coordinates[2] = 0.00000)) AND (origin_3d[i].location.coordinates[3] = 0.00000)) AND NOT EXISTS(origin_3d[i].ref_direction)) AND NOT EXISTS(origin_3d[i].axis)) THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE package_external_reference_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'design owner')))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'part number')))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'revision code')))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'product definition id')))) = 1))) = 0;
   END_RULE;



   RULE package_terminal_external_reference_constraint FOR (descriptive_representation_item );
   WHERE
      WR1:
         SIZEOF(QUERY (dri <* descriptive_representation_item| (dri\representation_item.name = 'package terminal external reference') AND (SIZEOF(QUERY (rep <* USEDIN(dri,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (rep\representation.name = 'package external reference'))) = 0))) = 0;
   END_RULE;



   RULE package_terminal_external_reference_unique_constraint FOR (descriptive_representation_item );
   LOCAL
      pter : BAG OF descriptive_representation_item := QUERY (dri <* descriptive_representation_item| dri\representation_item.name = 'package terminal external reference');
      desc_bag : BAG OF STRING := [];
      dri_bag : BAG OF descriptive_representation_item;
      rep_bag : BAG OF representation;
      pass : BOOLEAN := TRUE;
      r_bag : BAG OF representation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pter) BY 1;
         IF EXISTS(pter[i]\descriptive_representation_item.description) THEN
            IF NOT (pter[i]\descriptive_representation_item.description IN desc_bag) THEN
               desc_bag := desc_bag + pter[i]\descriptive_representation_item.description;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(desc_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         r_bag := [];
         dri_bag := QUERY (dri <* pter| dri\descriptive_representation_item.description = desc_bag[i]);
         REPEAT j := 1 TO SIZEOF(dri_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rep_bag := QUERY (r <* USEDIN(dri_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| r\representation.name = 'package external reference');
            REPEAT k := 1 TO SIZEOF(rep_bag) BY 1;
               IF EXISTS(rep_bag[k]) THEN
                  IF rep_bag[k] IN r_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     r_bag := r_bag + rep_bag[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE package_unique_constraint FOR (package,

 externally_defined_package,

 library_defined_package );
   LOCAL
      p : BAG OF physical_unit := QUERY (r <* package| r.frame_of_reference.name = 'physical design usage');
      edp : BAG OF physical_unit := QUERY (r <* externally_defined_package| r.frame_of_reference.name = 'physical design usage');
      ldp : BAG OF physical_unit := QUERY (r <* library_defined_package| r.frame_of_reference.name = 'physical design usage');
      pu : BAG OF physical_unit;
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      r_bag : BAG OF representation := [];
   END_LOCAL;
      pu := p + edp + ldp;
      REPEAT i := 1 TO SIZEOF(pu) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pd_bag := USEDIN(pu[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION');
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation\representation.name = 'registered case style');
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].used_representation) THEN
                  IF pdr_bag[k].used_representation IN r_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     r_bag := r_bag + pdr_bag[k].used_representation;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE packaged_connector_terminal_relationship_unique_constraint FOR (packaged_connector_terminal_relationship );
   LOCAL
      pu_bag : BAG OF physical_unit := [];
      pctr_bag : BAG OF packaged_connector_terminal_relationship;
      it_bag : BAG OF packaged_part_terminal;
      jt_bag : BAG OF packaged_part_terminal;
      pass1 : BOOLEAN := TRUE;
      pass2 : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(packaged_connector_terminal_relationship) BY 1;
         IF EXISTS(packaged_connector_terminal_relationship[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(packaged_connector_terminal_relationship[i].of_shape.definition) THEN
               IF NOT (packaged_connector_terminal_relationship[i].of_shape.definition IN pu_bag) THEN
                  pu_bag := pu_bag + packaged_connector_terminal_relationship[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT (pass1 OR pass2) THEN
            ESCAPE;
         END_IF;
         it_bag := [];
         jt_bag := [];
         pctr_bag := QUERY (r <* packaged_connector_terminal_relationship| r.of_shape.definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(pctr_bag) BY 1;
            IF NOT (pass1 OR pass2) THEN
               ESCAPE;
            END_IF;
            IF (pass1 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].relating_shape_aspect))) AND (pctr_bag[j].relating_shape_aspect\shape_aspect.description = 'join terminal') THEN
               IF EXISTS(pctr_bag[j].relating_shape_aspect) THEN
                  IF pctr_bag[j].relating_shape_aspect IN jt_bag THEN
                     pass1 := FALSE;
                     ESCAPE;
                  ELSE
                     jt_bag := jt_bag + pctr_bag[j].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
            IF (pass2 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].related_shape_aspect))) AND (pctr_bag[j].related_shape_aspect\shape_aspect.description = 'interface terminal') THEN
               IF EXISTS(pctr_bag[j].related_shape_aspect) THEN
                  IF pctr_bag[j].related_shape_aspect IN it_bag THEN
                     pass2 := FALSE;
                     ESCAPE;
                  ELSE
                     it_bag := it_bag + pctr_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE packaged_part_unique_constraint FOR (packaged_part,

 externally_defined_packaged_part,

 library_defined_packaged_part );
   LOCAL
      pp : SET OF physical_unit := packaged_part + externally_defined_packaged_part + library_defined_packaged_part;
      pdr_bag : BAG OF product_definition_relationship;
      pdf_bag : BAG OF product_definition_formation := [];
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pp) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdf_bag := [];
         pdr_bag := QUERY (pdr <* USEDIN(pp[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package') AND ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE' IN TYPEOF(pdr.relating_product_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition))));
         pdf_bag := pdf_bag + pdr_bag[1].relating_product_definition.formation;
         REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF EXISTS(pdr_bag[k].relating_product_definition.formation) THEN
               IF NOT (pdr_bag[k].relating_product_definition.formation IN pdf_bag) THEN
                  pass := FALSE;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_device_terminal_model_port_assignment_unique_constraint FOR (property_definition_representation );
   LOCAL
      amp_bag : BAG OF analytical_model_port := [];
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(property_definition_representation) BY 1;
         IF EXISTS(property_definition_representation[i].used_representation) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(property_definition_representation[i].used_representation) THEN
               IF NOT (property_definition_representation[i].used_representation IN amp_bag) THEN
                  amp_bag := amp_bag + property_definition_representation[i].used_representation;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(amp_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sa_bag := [];
         pdr_bag := QUERY (pdr <* property_definition_representation| pdr.used_representation :=: amp_bag[i]);
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j].definition.definition) THEN
               IF pdr_bag[j].definition.definition IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + pdr_bag[j].definition.definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_device_terminal_unique_constraint FOR (shape_aspect );
   LOCAL
      pdr_bag : BAG OF product_definition_relationship := [];
      sa_bag : BAG OF shape_aspect;
      pd_bag : BAG OF property_definition;
      sa : BAG OF bare_die_terminal;
      pass : BOOLEAN := TRUE;
      bdt_bag : BAG OF bare_die_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(shape_aspect) BY 1;
         IF EXISTS(shape_aspect[i].of_shape.definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(shape_aspect[i].of_shape.definition)) AND (shape_aspect[i].of_shape.definition.description = 'part device') THEN
               IF NOT (shape_aspect[i].of_shape.definition IN pdr_bag) THEN
                  pdr_bag := pdr_bag + shape_aspect[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         bdt_bag := [];
         sa_bag := QUERY (sa <* shape_aspect| sa.of_shape.definition :=: pdr_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pd_bag := QUERY (pd <* USEDIN(sa_bag[j].of_shape.definition.related_product_definition,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ] * TYPEOF(pd.definition)) > 0);
            REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               sa := QUERY (bdt <* USEDIN(pd_bag[k],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(bdt));
               REPEAT l := 1 TO SIZEOF(sa) BY 1;
                  IF EXISTS(sa[l]) THEN
                     IF sa[l] IN bdt_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        bdt_bag := bdt_bag + sa[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_device_unique_constraint FOR (product_definition_relationship );
   LOCAL
      pd : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.description = 'part device');
      pu_bag : BAG OF physical_unit := [];
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pd) BY 1;
         IF EXISTS(pd[i].relating_product_definition) THEN
            IF (pd[i].relating_product_definition.frame_of_reference.name = 'physical design usage') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(pd[i].relating_product_definition)) > 0) THEN
               IF NOT (pd[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + pd[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         pdr_bag := QUERY (pdr <* pd| pdr.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j]\product_definition_relationship.name) THEN
               IF pdr_bag[j]\product_definition_relationship.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + pdr_bag[j]\product_definition_relationship.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_feature_constraint FOR (shape_aspect,

 product_definition,

 shape_aspect_relationship );
   LOCAL
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
      sa : BAG OF shape_aspect := [];
      pd : BAG OF product_definition := QUERY (pd <* product_definition| pd.frame_of_reference\application_context_element.name = 'physical design usage');
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pd) BY 1;
         name_bag := [];
         sa := QUERY (sa <* shape_aspect| ((sa.of_shape\property_definition.definition = pd[i]) AND sa.product_definitional) AND NOT (sa\shape_aspect.description = 'connection zone'));
         REPEAT j := 1 TO SIZEOF(sa) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF sa[j]\shape_aspect.name IN name_bag THEN
               pass := FALSE;
            ELSE
               name_bag := name_bag + sa[j]\shape_aspect.name;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'precedent feature') AND (sar.related_shape_aspect = sar.relating_shape_aspect))) = 0;
      WR3:
         SIZEOF(QUERY (sa <* shape_aspect| (((sa\shape_aspect.description = 'part group feature') OR (sa\shape_aspect.description = 'part generic feature')) OR (sa\shape_aspect.description = 'polarity indication feature')) AND (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feature'))) > 1))) = 0;
      WR4:
         SIZEOF(QUERY (sa <* shape_aspect| (((((((sa\shape_aspect.description = 'interconnect module edge segment surface') OR (sa\shape_aspect.description = 'interconnect module cavity surface')) OR (sa\shape_aspect.description = 'interconnect module cutout surface')) OR (sa\shape_aspect.description = 'interconnect module edge surface')) OR (sa\shape_aspect.description = 'interconnect module primary surface')) OR (sa\shape_aspect.description = 'interconnect module secondary surface')) OR (sa\shape_aspect.description = 'interconnect module surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feature'))) > 0))) = 0;
   END_RULE;



   RULE part_feature_unique_constraint FOR (composite_shape_aspect,

 shape_aspect,

 primary_orientation_feature,

 tertiary_orientation_feature,

 secondary_orientation_feature,

 package_body,

 part_tooling_feature,

 thermal_feature,

 part_mounting_feature,

 package_terminal,

 assembly_module_terminal,

 bare_die_terminal,

 interconnect_module_terminal,

 minimally_defined_bare_die_terminal,

 packaged_part_terminal,

 package_body_surface );
   LOCAL
      csa : BAG OF shape_aspect := QUERY (r <* composite_shape_aspect| r\shape_aspect.description = 'part group feature');
      sa : BAG OF shape_aspect := QUERY (r <* shape_aspect| r\shape_aspect.description IN [ 'part generic feature',

 'polarity indication feature',

 'interconnect module edge segment surface',

 'interconnect module cavity surface',

 'interconnect module cutout surface',

 'interconnect module edge surface',

 'interconnect module primary surface',

 'interconnect module secondary surface',

 'interconnect module surface feature' ]);
      pof : BAG OF shape_aspect := QUERY (r <* primary_orientation_feature| TRUE);
      sof : BAG OF shape_aspect := QUERY (r <* secondary_orientation_feature| TRUE);
      tof : BAG OF shape_aspect := QUERY (r <* tertiary_orientation_feature| TRUE);
      pb : BAG OF shape_aspect := QUERY (r <* package_body| TRUE);
      ptf : BAG OF shape_aspect := QUERY (r <* part_tooling_feature| TRUE);
      tf : BAG OF shape_aspect := QUERY (r <* thermal_feature| TRUE);
      pmf : BAG OF shape_aspect := QUERY (r <* part_mounting_feature| TRUE);
      pt : BAG OF shape_aspect := QUERY (r <* package_terminal| TRUE);
      amt : BAG OF shape_aspect := QUERY (r <* assembly_module_terminal| TRUE);
      bdt : BAG OF shape_aspect := QUERY (r <* bare_die_terminal| TRUE);
      imt : BAG OF shape_aspect := QUERY (r <* interconnect_module_terminal| TRUE);
      mdbdt : BAG OF shape_aspect := QUERY (r <* minimally_defined_bare_die_terminal| TRUE);
      ppt : BAG OF shape_aspect := QUERY (r <* packaged_part_terminal| TRUE);
      pbs : BAG OF shape_aspect := QUERY (r <* package_body_surface| TRUE);
      pf : BAG OF shape_aspect := [];
      pu_bag : BAG OF physical_unit := [];
      sa_bag : BAG OF shape_aspect;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      sa := csa + sa + pof + sof + tof + pb + ptf + tf + pmf + pt + amt + bdt + imt + mdbdt + ppt + pbs;
      REPEAT i := 1 TO SIZEOF(sa) BY 1;
         IF EXISTS(sa[i]) THEN
            IF NOT (sa[i] IN pf) THEN
               pf := pf + sa[i];
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pf) BY 1;
         IF EXISTS(pf[i].of_shape.definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(pf[i].of_shape.definition)) AND (pf[i].of_shape.definition.frame_of_reference.name = 'physical design usage') THEN
               IF NOT (pf[i].of_shape.definition IN pu_bag) THEN
                  pu_bag := pu_bag + pf[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         sa_bag := QUERY (sa <* pf| sa.of_shape.definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF EXISTS(sa_bag[j]\shape_aspect.name) THEN
               IF sa_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sa_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_template_non_planar_2d_shape_constraint FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name = 'part template non planar 2d shape') AND NOT (SIZEOF(QUERY (a2p3d <* mssr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(a2p3d)))) = 1))) = 0;
   END_RULE;



   RULE part_terminal_external_reference_unique_constraint FOR (representation );
   LOCAL
      pter : BAG OF representation := QUERY (r <* representation| r\representation.name = 'part terminal external reference');
      fn_bag : BAG OF STRING := [];
      ft_bag : BAG OF STRING := [];
      r_bag : BAG OF representation;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      ptd_bag : BAG OF part_template_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pter) BY 1;
         REPEAT j := 1 TO SIZEOF(pter[i].items) BY 1;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(pter[i].items[j]) THEN
               IF (pter[i].items[j]\representation_item.name = 'feature name') AND NOT (pter[i].items[j]\descriptive_representation_item.description IN fn_bag) THEN
                  fn_bag := fn_bag + pter[i].items[j]\descriptive_representation_item.description;
               END_IF;
               IF (pter[i].items[j]\representation_item.name = 'feature type') AND NOT (pter[i].items[j]\descriptive_representation_item.description IN ft_bag) THEN
                  ft_bag := ft_bag + pter[i].items[j]\descriptive_representation_item.description;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fn_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         REPEAT j := 1 TO SIZEOF(ft_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            r_bag := QUERY (r <* pter| (SIZEOF(QUERY (ri <* r.items| (ri\descriptive_representation_item.description = ft_bag[j]) AND (ri\representation_item.name = 'feature type'))) > 0) AND (SIZEOF(QUERY (ri <* r.items| (ri\descriptive_representation_item.description = fn_bag[i]) AND (ri\representation_item.name = 'feature name'))) > 0));
            ptd_bag := [];
            REPEAT k := 1 TO SIZEOF(r_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               pdr_bag := USEDIN(r_bag[k],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
               REPEAT l := 1 TO SIZEOF(pdr_bag) BY 1;
                  IF EXISTS(pdr_bag[l].definition.definition) THEN
                     IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(pdr_bag[l].definition.definition) THEN
                        IF pdr_bag[l].definition.definition IN ptd_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           ptd_bag := ptd_bag + pdr_bag[l].definition.definition;
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE physical_connectivity_abstraction_map_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      pcam : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'physical to topological abstraction map');
      pce_bag : BAG OF physical_connectivity_element := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      csa_bag : BAG OF component_shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pcam) BY 1;
         IF EXISTS(pcam[i].related_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT' IN TYPEOF(pcam[i].related_shape_aspect) THEN
               IF NOT (pcam[i].related_shape_aspect IN pce_bag) THEN
                  pce_bag := pce_bag + pcam[i].related_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pce_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         csa_bag := [];
         sar_bag := QUERY (sar <* pcam| sar.related_shape_aspect :=: pce_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar_bag[j].relating_shape_aspect)) AND (sar_bag[j].relating_shape_aspect\shape_aspect.description IN [ 'conductive interconnect element with pre defined transitions',

 'conductive interconnect element with user defined single transition' ]) THEN
               IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
                  IF sar_bag[j].relating_shape_aspect IN csa_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     csa_bag := csa_bag + sar_bag[j].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE physical_connectivity_definition_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'physical connectivity definition change') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'physical connectivity definition change') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
      WR3:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'physical connectivity definition change') AND (SIZEOF(QUERY (rpd <* USEDIN(sar,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rpd)))) = 0))) = 0;
   END_RULE;



   RULE physical_connectivity_element_unique_constraint FOR (physical_connectivity_element );
   LOCAL
      name_bag : BAG OF STRING := [];
      pce_bag : BAG OF physical_connectivity_element;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pcd_bag : BAG OF physical_connectivity_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(physical_connectivity_element) BY 1;
         IF EXISTS(physical_connectivity_element[i]\shape_aspect.name) THEN
            IF NOT (physical_connectivity_element[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + physical_connectivity_element[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pcd_bag := [];
         pce_bag := QUERY (pce <* physical_connectivity_element| pce\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(pce_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(pce_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'structure element') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
                  IF sar_bag[j].relating_shape_aspect IN pcd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pcd_bag := pcd_bag + sar_bag[j].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE placement_group_area_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) OR ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name = 'design requirement')))) = 0;
   END_RULE;



   RULE placement_group_volume_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) OR ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name = 'design requirement')))) = 0;
   END_RULE;



   RULE planar_curve_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (NOT (sr\representation.name IN [ 'planar projected shape',

 'bevel edge feature shape',

 'step edge feature shape',

 'radius edge feature shape' ]) OR (sr\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)))) = 0;
   END_RULE;



   RULE planned_effectivity_constraint FOR (configuration_effectivity );
   WHERE
      WR1:
         SIZEOF(QUERY (ce <* configuration_effectivity| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage)) AND (ce.usage\product_definition_relationship.name = 'assembly composition')))) = 0;
      WR2:
         SIZEOF(QUERY (ce <* configuration_effectivity| (SIZEOF(USEDIN(ce,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0))) = 0;
   END_RULE;



   RULE planned_effectivity_unique_constraint FOR (configuration_effectivity );
   LOCAL
      ce_bag : BAG OF configuration_effectivity;
      ci_bag : BAG OF configuration_item := [];
      pass : BOOLEAN := TRUE;
      acu_bag : BAG OF assembly_component_usage;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(configuration_effectivity) BY 1;
         IF EXISTS(configuration_effectivity[i].configuration.configuration) THEN
            IF NOT (configuration_effectivity[i].configuration.configuration IN ci_bag) THEN
               ci_bag := ci_bag + configuration_effectivity[i].configuration.configuration;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ci_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ce_bag := QUERY (r <* configuration_effectivity| ((r.configuration.configuration :=: ci_bag[i]) AND (r.usage\product_definition_relationship.name = 'assembly composition')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(r.usage)));
         acu_bag := [];
         REPEAT j := 1 TO SIZEOF(ce_bag) BY 1;
            IF EXISTS(ce_bag[j].usage) THEN
               IF ce_bag[j].usage IN acu_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  acu_bag := acu_bag + ce_bag[j].usage;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE plus_minus_tolerance_range_representation_constraint FOR (shape_dimension_representation,

 plus_minus_tolerance );
   WHERE
      WR1:
         SIZEOF(QUERY (pmt <* plus_minus_tolerance| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_VALUE' IN TYPEOF(pmt.range)))) = 0;
   END_RULE;



   RULE polarity_indication_feature_constraint FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (NOT (sa\shape_aspect.description = 'polarity indication feature') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1)))) = 0;
      WR2:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (NOT (sa\shape_aspect.description = 'polarity indication feature') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1)))) = 0;
      WR3:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (NOT (sa\shape_aspect.description = 'polarity indication feature') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(sa,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(it.relating_shape_aspect)))) = 1)))) = 0;
   END_RULE;



   RULE positional_boundary_member_definition_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary member property') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition)))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary member property') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'boundary member associated dimension'))) = 1))) = 0;
   END_RULE;



   RULE positional_boundary_offset_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary offset') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(pd.definition)) AND (pd.definition\shape_aspect_relationship.name = 'positional boundary and profile boundary member')))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary offset') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'boundary offset') AND (pdr.relating_property_definition\property_definition.name = 'profile related positional boundary property'))) = 1))) = 0;
   END_RULE;



   RULE printed_connector_template_terminal_relationship_unique_constraint FOR (printed_connector_template_terminal_relationship );
   LOCAL
      ptd_bag : BAG OF part_template_definition := [];
      pcttr_bag : BAG OF printed_connector_template_terminal_relationship;
      sar_bag : BAG OF shape_aspect_relationship;
      pass1 : BOOLEAN := TRUE;
      jt_bag : BAG OF printed_part_template_terminal;
      pass2 : BOOLEAN := TRUE;
      it_bag : BAG OF printed_part_template_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(printed_connector_template_terminal_relationship) BY 1;
         sar_bag := QUERY (sar <* USEDIN(printed_connector_template_terminal_relationship[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'connector') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))) AND (sar.relating_shape_aspect\shape_aspect.description = 'printed connector template'));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
               IF NOT (sar_bag[j].relating_shape_aspect IN ptd_bag) THEN
                  ptd_bag := ptd_bag + sar_bag[j].relating_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ptd_bag) BY 1;
         IF NOT (pass1 OR pass2) THEN
            ESCAPE;
         END_IF;
         it_bag := [];
         jt_bag := [];
         sar_bag := QUERY (sar <* USEDIN(ptd_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'connector');
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT (pass1 OR pass2) THEN
               ESCAPE;
            END_IF;
            pcttr_bag := QUERY (pcttr <* printed_connector_template_terminal_relationship| pcttr :=: sar_bag[j].related_shape_aspect);
            REPEAT k := 1 TO SIZEOF(pcttr_bag) BY 1;
               IF NOT (pass1 OR pass2) THEN
                  ESCAPE;
               END_IF;
               IF (pass1 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(pcttr_bag[k].relating_shape_aspect))) AND (pcttr_bag[k].relating_shape_aspect\shape_aspect.description = 'join terminal') THEN
                  IF EXISTS(pcttr_bag[k].relating_shape_aspect) THEN
                     IF pcttr_bag[k].relating_shape_aspect IN jt_bag THEN
                        pass1 := FALSE;
                        ESCAPE;
                     ELSE
                        jt_bag := jt_bag + pcttr_bag[k].relating_shape_aspect;
                     END_IF;
                  END_IF;
               END_IF;
               IF (pass2 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(pcttr_bag[k].related_shape_aspect))) AND (pcttr_bag[k].related_shape_aspect\shape_aspect.description = 'interface terminal') THEN
                  IF EXISTS(pcttr_bag[k].related_shape_aspect) THEN
                     IF pcttr_bag[k].related_shape_aspect IN it_bag THEN
                        pass2 := FALSE;
                        ESCAPE;
                     ELSE
                        it_bag := it_bag + pcttr_bag[k].related_shape_aspect;
                     END_IF;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE printed_part_template_terminal_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'printed part template terminal relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'printed part template terminal relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
   END_RULE;



   RULE printed_part_template_terminal_unique_constraint FOR (printed_part_template_terminal );
   LOCAL
      pptt : BAG OF printed_part_template_terminal := QUERY (r <* printed_part_template_terminal| r\shape_aspect.description IN [ 'interface terminal',

 'join terminal' ]);
      name_bag : BAG OF STRING := [];
      sar_bag : BAG OF shape_aspect_relationship;
      sa_bag : BAG OF shape_aspect;
      pass : BOOLEAN := TRUE;
      ptd_bag : BAG OF part_template_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pptt) BY 1;
         IF EXISTS(pptt[i]\shape_aspect.name) THEN
            IF NOT (pptt[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + pptt[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ptd_bag := [];
         sa_bag := QUERY (sa <* pptt| sa\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition') AND (sar.relating_shape_aspect\shape_aspect.description = 'printed part template'));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN ptd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE product_association_constraint FOR (product_definition_formation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdfr <* product_definition_formation_relationship| (pdfr\product_definition_formation_relationship.name = 'product association') AND (SIZEOF(QUERY (adr <* USEDIN(pdfr,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document)))) = 0))) = 0;
   END_RULE;



   RULE product_association_unique_constraint FOR (product_definition_formation_relationship );
   LOCAL
      pdfr : BAG OF product_definition_formation_relationship := QUERY (r <* product_definition_formation_relationship| r\product_definition_formation_relationship.name = 'product association');
      pdf_bag : BAG OF product_definition_formation := [];
      pdfr_bag : BAG OF product_definition_formation_relationship;
      pass : BOOLEAN := TRUE;
      adr_bag : BAG OF applied_document_reference;
      es_bag : BAG OF ee_specification;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pdfr) BY 1;
         IF EXISTS(pdfr[i].relating_product_definition_formation) THEN
            IF NOT (pdfr[i].relating_product_definition_formation IN pdf_bag) THEN
               pdf_bag := pdf_bag + pdfr[i].relating_product_definition_formation;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdf_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdfr_bag := QUERY (r <* pdfr| r.relating_product_definition_formation :=: pdf_bag[i]);
         es_bag := [];
         REPEAT j := 1 TO SIZEOF(pdfr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := QUERY (adr <* USEDIN(pdfr_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document));
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN es_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     es_bag := es_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE product_concept_requires_configuration_item FOR (product_concept,

 configuration_item );
   WHERE
      WR1:
         SIZEOF(QUERY (pc <* product_concept| NOT (SIZEOF(QUERY (ci <* configuration_item| (pc :=: ci.item_concept))) >= 1))) = 0;
   END_RULE;



   RULE product_definition_formation_requires_approval FOR (product_definition,

 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd)) AND NOT (SIZEOF(QUERY (aaa <* applied_approval_assignment| (pd.formation IN aaa.items))) = 1))) = 0;
   END_RULE;



   RULE product_definition_formation_requires_person_organization FOR (product_definition,

 applied_person_and_organization_assignment,

 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd)) AND NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (pd.formation IN apaoa.items) AND (apaoa.role\person_and_organization_role.name = 'creator'))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (pd.formation IN aoa.items) AND (aoa.role\organization_role.name = 'creator'))) = 1)))) = 0;
   END_RULE;



   RULE product_definition_requires_date_or_date_and_time FOR (product_definition,

 applied_date_and_time_assignment,

 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT (NOT is_ee_product_definition(pd) OR ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (pd IN adata.items))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (pd IN ada.items))) = 1))))) = 0;
   END_RULE;



   RULE product_definition_requires_person_organization FOR (product_definition,

 applied_person_and_organization_assignment,

 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT (NOT is_ee_product_definition(pd) OR ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (pd IN apaoa.items))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (pd IN aoa.items))) = 1))))) = 0;
   END_RULE;



   RULE product_requires_person_organization FOR (product,

 applied_person_and_organization_assignment,

 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (prod <* product| NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (prod IN apaoa.items))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (prod IN aoa.items))) = 1)))) = 0;
   END_RULE;



   RULE product_requires_product_definition_formation FOR (product,

 product_definition_formation );
   WHERE
      WR1:
         SIZEOF(QUERY (prod <* product| NOT (SIZEOF(QUERY (pdf <* product_definition_formation| (prod :=: pdf.of_product))) >= 1))) = 0;
   END_RULE;



   RULE profile_boundary_definition_with_offsets_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| ((pd\property_definition.description = 'boundary zone definition with specified size') AND (pd\property_definition.name = 'profile boundary with offsets')) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(pd.definition)))) = 0;
   END_RULE;



   RULE profile_related_positional_boundary_definition_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'profile related positional boundary property') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition)) AND (pd.definition\shape_aspect.description = 'profile related positional boundary')))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'profile related positional boundary property') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr.related_property_definition\property_definition.description = 'positional boundary offset') AND (pdr\property_definition_relationship.name = 'boundary offset'))) = 1))) = 0;
   END_RULE;



   RULE projected_zone_and_base_relationship_constraint FOR (projected_zone_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pzd <* projected_zone_definition| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end)) OR (pzd.projection_end.product_definitional = TRUE)))) = 0;
   END_RULE;



   RULE projected_zone_height_characteristic_constraint FOR (projected_zone_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pzd <* projected_zone_definition| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length)))) = 0;
   END_RULE;



   RULE promissory_usage_relationship_constraint FOR (promissory_usage_occurrence );
   WHERE
      WR1:
         SIZEOF(QUERY (puo <* promissory_usage_occurrence| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(puo.relating_product_definition)) AND (puo.relating_product_definition.frame_of_reference.name = 'physical design'))) = 0;
      WR2:
         SIZEOF(QUERY (puo <* promissory_usage_occurrence| (SIZEOF(USEDIN(puo,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 0))) = 0;
   END_RULE;



   RULE promissory_usage_relationship_unique_constraint FOR (promissory_usage_occurrence );
   LOCAL
      pu_bag : BAG OF physical_unit := [];
      puo_bag : BAG OF promissory_usage_occurrence;
      pass : BOOLEAN := TRUE;
      comp_bag : BAG OF physical_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(promissory_usage_occurrence) BY 1;
         IF EXISTS(promissory_usage_occurrence[i].relating_product_definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(promissory_usage_occurrence[i].relating_product_definition)) AND (promissory_usage_occurrence[i].relating_product_definition.frame_of_reference.name = 'physical design') THEN
               IF NOT (promissory_usage_occurrence[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + promissory_usage_occurrence[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         puo_bag := QUERY (puo <* promissory_usage_occurrence| puo.relating_product_definition :=: pu_bag[i]);
         comp_bag := [];
         REPEAT j := 1 TO SIZEOF(puo_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(puo_bag[j].related_product_definition)) AND (puo_bag[j].related_product_definition.frame_of_reference.name IN [ 'physical design',

 'physical design usage' ]) THEN
               IF EXISTS(puo_bag[j].related_product_definition) THEN
                  IF puo_bag[j].related_product_definition IN comp_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     comp_bag := comp_bag + puo_bag[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE radius_edge_feature_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'radius edge feature shape') AND (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum radius length'))) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'radius edge feature shape') AND (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum radius length'))) = 0))) = 0;
   END_RULE;



   RULE reference_composition_path_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference composition path') AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND (pdr.relating_product_definition\product_definition.description = 'reference definition path')) AND (pdr.relating_product_definition.frame_of_reference.name = 'functional occurrence')))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference composition path') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.related_product_definition)) AND (pdr.related_product_definition.frame_of_reference.name = 'functional occurrence')))) = 0;
   END_RULE;



   RULE reference_functional_unit_assignment_to_part_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference functional unit assignment to part') AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.related_product_definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLICATION_CONTEXT_ELEMENT' IN TYPEOF(pdr.related_product_definition.frame_of_reference))) AND ((pdr.relating_product_definition.frame_of_reference.name = 'physical design') OR (pdr.relating_product_definition.frame_of_reference.name = 'physical design usage'))))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference functional unit assignment to part') AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition)) AND (pdr.relating_product_definition\product_definition.description = 'design definition path')) AND (pdr.relating_product_definition.id = 'reference composition path')))) = 0;
   END_RULE;



   RULE reference_functional_unit_assignment_to_part_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      sar : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'reference functional unit assignment to part');
      d_bag : BAG OF STRING := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         IF EXISTS(sar[i]\shape_aspect_relationship.description) THEN
            IF NOT (sar[i]\shape_aspect_relationship.description IN d_bag) THEN
               d_bag := d_bag + sar[i]\shape_aspect_relationship.description;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(d_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (r <* sar| r\shape_aspect_relationship.description = d_bag[i]);
         pd_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect.of_shape.definition) THEN
               IF sar_bag[j].related_shape_aspect.of_shape.definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + sar_bag[j].related_shape_aspect.of_shape.definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE registered_font_constraint FOR (externally_defined_text_font );
   WHERE
      WR1:
         SIZEOF(QUERY (edtf <* externally_defined_text_font| (SIZEOF(QUERY (adr <* USEDIN(edtf,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.kind\document_type.product_data_type = 'font registration document'))) = 0))) = 0;
   END_RULE;



   RULE registered_font_unique_constraint FOR (externally_defined_text_font );
   LOCAL
      ii_bag : BAG OF STRING := [];
      edtf_bag : BAG OF externally_defined_text_font;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      es_bag : BAG OF ee_specification;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(externally_defined_text_font) BY 1;
         IF EXISTS(externally_defined_text_font[i].item_id) THEN
            IF NOT (externally_defined_text_font[i].item_id IN ii_bag) THEN
               ii_bag := ii_bag + externally_defined_text_font[i].item_id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ii_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         edtf_bag := QUERY (edtf <* externally_defined_text_font| edtf.item_id = ii_bag[i]);
         REPEAT j := 1 TO SIZEOF(edtf_bag) BY 1;
            adr_bag := QUERY (adr <* USEDIN(edtf_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| adr.assigned_document.kind\document_type.product_data_type = 'font registration document');
            es_bag := [];
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN es_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     es_bag := es_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE requirements_property_constraint FOR (product_definition,

 descriptive_representation_item,

 requirements_property );
   LOCAL
      ri : BAG OF descriptive_representation_item := QUERY (dri <* descriptive_representation_item| dri\representation_item.name = 'requirements name');
      pd : BAG OF product_definition := QUERY (tpd <* product_definition| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLICATION_CONTEXT_ELEMENT' IN TYPEOF(tpd.frame_of_reference)) AND (tpd.frame_of_reference.name IN [ 'requirement',

 'design requirement',

 'assembly requirement' ])) AND (tpd.name = 'requirements model'));
      r : BAG OF representation := [];
      pdr : BAG OF property_definition_representation := [];
      pass1 : BOOLEAN := TRUE;
      rp : BAG OF property_definition := [];
      pass2 : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ri) BY 1;
         r := [];
         pdr := [];
         r := USEDIN(ri[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS');
         pass1 := SIZEOF(r) = 1;
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         pdr := USEDIN(r[1],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
         pass1 := SIZEOF(pdr) = 1;
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         pass1 := 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr[1].definition);
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd) BY 1;
         rp := [];
         IF NOT pass2 THEN
            ESCAPE;
         END_IF;
         rp := QUERY (rp <* USEDIN(pd[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
         pass2 := SIZEOF(rp) = 1;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE requirements_property_unique_constraint FOR (descriptive_representation_item,

 requirements_property );
   LOCAL
      desc_bag : BAG OF STRING := [];
      pass1 : BOOLEAN := TRUE;
      pdr : BAG OF property_definition_representation := [];
      rep : BAG OF representation := [];
      pd : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(requirements_property) BY 1;
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(requirements_property[i].definition) THEN
            pd := pd + requirements_property[i].definition;
         END_IF;
      END_REPEAT;
      IF instance_unique(pd) = FALSE THEN
         pass1 := FALSE;
      END_IF;
   WHERE
      WR1:
         pass1;
   END_RULE;



   RULE restraint_condition_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| ((pd\property_definition.description = 'restraint') OR (pd\property_definition.description = 'tolerance specific restraint')) AND (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'restraint description'))) = 0))) = 0;
   END_RULE;



   RULE restrict_action_request_status FOR (action_request_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ars <* action_request_status| NOT (ars\action_request_status.status IN [ 'proposed',

 'in work',

 'issued',

 'hold' ]))) = 0;
   END_RULE;



   RULE restrict_approval_status FOR (approval_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ast <* approval_status| NOT (ast\approval_status.name IN [ 'approved',

 'not yet approved',

 'disapproved',

 'withdrawn' ]))) = 0;
   END_RULE;



   RULE restrict_date_role FOR (date_role );
   WHERE
      WR1:
         SIZEOF(QUERY (dr <* date_role| NOT (dr\date_role.name IN [ 'creation date',

 'request date',

 'release date',

 'start date',

 'contract date',

 'certification date',

 'sign off date',

 'classification date',

 'declassification date' ]))) = 0;
   END_RULE;



   RULE restrict_manifold_surface_shape_representation FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name IN [ 'stratum feature non planar 2d shape',

 'open shell based surface',

 'design intent modification non planar 2d shape',

 'part template non planar 2d shape' ]) AND NOT (SIZEOF(QUERY (sbsm <* mssr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_SURFACE_MODEL' IN TYPEOF(sbsm)) AND (SIZEOF(QUERY (os <* sbsm\shell_based_surface_model.sbsm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'OPEN_SHELL' IN TYPEOF(os)))) = 1))) = 1))) = 0;
   END_RULE;



   RULE rule_action_unique_constraint FOR (rule_action );
   LOCAL
      adta : BAG OF applied_date_and_time_assignment;
      adta_bag : BAG OF applied_date_and_time_assignment := [];
      ra_bag : BAG OF rule_action;
      aaa_bag : BAG OF applied_action_assignment;
      pass : BOOLEAN := TRUE;
      rd_bag : BAG OF product_definition_formation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rule_action) BY 1;
         adta := USEDIN(rule_action[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS');
         REPEAT j := 1 TO SIZEOF(adta) BY 1;
            IF EXISTS(adta[j]) THEN
               IF NOT (adta[j] IN adta_bag) THEN
                  adta_bag := adta_bag + adta[j];
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(adta_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ra_bag := QUERY (r <* rule_action| r IN adta_bag[i].items);
         rd_bag := [];
         REPEAT j := 1 TO SIZEOF(ra_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            aaa_bag := QUERY (aa <* USEDIN(ra_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ACTION_ASSIGNMENT' IN TYPEOF(aa));
            REPEAT k := 1 TO SIZEOF(aaa_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(aaa_bag[k].items) BY 1;
                  IF EXISTS(aaa_bag[k].items[l]) THEN
                     IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(aaa_bag[k].items[l])) AND (aaa_bag[k].items[l]\product_definition_formation.description = 'rule version') THEN
                        IF aaa_bag[k].items[l] IN rd_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           rd_bag := rd_bag + aaa_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE rule_conclusion_definition_unique_constraint FOR (rule_conclusion_definition,

 representation,

 representation_relationship );
   LOCAL
      r : BAG OF representation := QUERY (r <* representation| r\representation.name = 'rule definition');
      rr : BAG OF representation_relationship := [];
      pass : BOOLEAN := TRUE;
      count : INTEGER := 0;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         count := 0;
         name_bag := [];
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         rr := USEDIN(r[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1');
         REPEAT j := 1 TO SIZEOF(rr) BY 1;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_CONCLUSION_DEFINITION' IN TYPEOF(rr[j].rep_2) THEN
               IF EXISTS(rr[j].rep_2\representation.name) THEN
                  IF rr[j].rep_2\representation.name IN name_bag THEN
                     pass := FALSE;
                  ELSE
                     name_bag := name_bag + rr[j].rep_2\representation.name;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE rule_function_unique_constraint FOR (rule_function_definition );
   LOCAL
      name_bag : BAG OF STRING := [];
      rfd_bag : BAG OF rule_function_definition;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      doc_bag : BAG OF document;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rule_function_definition) BY 1;
         IF EXISTS(rule_function_definition[i]\representation.name) THEN
            IF NOT (rule_function_definition[i]\representation.name IN name_bag) THEN
               name_bag := name_bag + rule_function_definition[i]\representation.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         doc_bag := [];
         rfd_bag := QUERY (am <* rule_function_definition| am\representation.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(rfd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := QUERY (adr <* USEDIN(rfd_bag[j],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| adr.assigned_document.kind\document_type.product_data_type = 'reference document');
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN doc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     doc_bag := doc_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE rule_premise_definition_unique_constraint FOR (rule_premise_definition,

 representation,

 representation_relationship );
   LOCAL
      rr : BAG OF representation_relationship := [];
      rpd : BAG OF rule_premise_definition := [];
      pass : BOOLEAN := TRUE;
      count : INTEGER := 0;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rule_premise_definition) BY 1;
         count := 0;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         rr := USEDIN(rule_premise_definition[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2');
         REPEAT j := 1 TO SIZEOF(rr) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF rr[j]\representation_relationship.rep_1\representation.description IN [ 'rule definition' ] THEN
               count := count + 1;
            END_IF;
            IF count = 2 THEN
               pass := FALSE;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE security_classification_constraint FOR (security_classification,

 applied_date_and_time_assignment,

 applied_date_assignment,

 applied_person_and_organization_assignment,

 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (sc <* security_classification| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (sc IN adata.items) AND ('classification date' = adata.role\date_time_role.name))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (sc IN ada.items) AND ('classification date' = ada.role\date_role.name))) = 1)))) = 0;
      WR2:
         SIZEOF(QUERY (sc <* security_classification| (SIZEOF(QUERY (apa <* applied_person_and_organization_assignment| (sc IN apa.items) AND (apa.role\person_and_organization_role.name = 'classification officer'))) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (sc <* security_classification| (SIZEOF(QUERY (aaa <* applied_approval_assignment| (sc IN aaa.items))) = 0))) = 0;
   END_RULE;



   RULE shape_dimension_representation_constraint FOR (shape_dimension_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| NOT (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| (mq\measure_qualification.name = 'dimension value qualifier'))) <= 1))) >= 1))) = 0;
      WR2:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| (mq\measure_qualification.name = 'dimension value qualifier') AND (SIZEOF(QUERY (q <* mq.qualifiers| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TYPE_QUALIFIER' IN TYPEOF(q)))) <> 1))) > 0))) > 0))) = 0;
      WR3:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| (mq\measure_qualification.name = 'dimension value qualifier') AND (SIZEOF(QUERY (q <* mq.qualifiers| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TYPE_QUALIFIER' IN TYPEOF(q)) AND NOT (q\type_qualifier.name IN [ 'theoretically exact',

 'maximum dimension',

 'minumum dimersion',

 'lower value',

 'upper value',

 'basic value' ]))) > 0))) > 0))) > 0))) = 0;
      WR4:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| NOT (mq\measure_qualification.name IN [ 'dimension value qualifier',

 'predefined dimension qualifier',

 'user defined dimension qualifier' ]))) > 0))) > 0))) = 0;
      WR5:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| NOT (SIZEOF(USEDIN(sdr,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.' + 'REPRESENTATION')) >= 1))) = 0;
   END_RULE;



   RULE shape_element_composing_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'composing') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
   END_RULE;



   RULE shape_element_constituent_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      sar : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name IN [ 'constituent',

 'composing',

 'bare die terminal surface constituent relationship',

 'interconnect module terminal surface constituent relationship',

 'package terminal surface constituent relationship' ]);
      sa_bag : BAG OF shape_aspect := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         IF EXISTS(sar[i].relating_shape_aspect) THEN
            IF NOT (sar[i].relating_shape_aspect IN sa_bag) THEN
               sa_bag := sa_bag + sar[i].relating_shape_aspect;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (r <* sar| r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]);
         rsa_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN rsa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_element_deriving_relationship_unique_constraint FOR (shape_aspect_deriving_relationship );
   LOCAL
      sa_bag : BAG OF shape_aspect := [];
      sadr_bag : BAG OF shape_aspect_deriving_relationship;
      pass : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(shape_aspect_deriving_relationship) BY 1;
         IF EXISTS(shape_aspect_deriving_relationship[i].relating_shape_aspect) THEN
            IF NOT (shape_aspect_deriving_relationship[i].relating_shape_aspect IN sa_bag) THEN
               sa_bag := sa_bag + shape_aspect_deriving_relationship[i].relating_shape_aspect;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sadr_bag := QUERY (r <* shape_aspect_deriving_relationship| r.relating_shape_aspect :=: sa_bag[i]);
         rsa_bag := [];
         REPEAT j := 1 TO SIZEOF(sadr_bag) BY 1;
            IF EXISTS(sadr_bag[j].related_shape_aspect) THEN
               IF sadr_bag[j].related_shape_aspect IN rsa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  rsa_bag := rsa_bag + sadr_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_element_locating_relationship_unique_constraint FOR (dimensional_location );
   LOCAL
      sa_bag : BAG OF shape_aspect := [];
      dl_bag : BAG OF dimensional_location;
      pass : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dimensional_location) BY 1;
         IF EXISTS(dimensional_location[i].relating_shape_aspect) THEN
            IF NOT (dimensional_location[i].relating_shape_aspect IN sa_bag) THEN
               sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         dl_bag := QUERY (r <* dimensional_location| r.relating_shape_aspect :=: sa_bag[i]);
         rsa_bag := [];
         REPEAT j := 1 TO SIZEOF(dl_bag) BY 1;
            IF EXISTS(dl_bag[j].related_shape_aspect) THEN
               IF dl_bag[j].related_shape_aspect IN rsa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_element_unique_constraint FOR (representation,

 representation_item,

 property_definition_representation );
   LOCAL
      r : BAG OF representation := QUERY (r <* representation| r\representation.name = 'shape element name');
      ri : BAG OF representation_item := [];
      pass : BOOLEAN := TRUE;
      description_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pass := SIZEOF(QUERY (pdr <* USEDIN(r[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (pdr.definition\property_definition.description = 'shape element characterization'))) = 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ri := QUERY (ri <* representation_item| ri IN r[i].items);
         pass := SIZEOF(ri) = 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(ri)) THEN
            pass := FALSE;
            ESCAPE;
         END_IF;
         REPEAT j := 1 TO SIZEOF(ri) BY 1;
            IF EXISTS(ri[j]\descriptive_representation_item.description) THEN
               IF ri[j]\descriptive_representation_item.description IN description_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  description_bag := description_bag + ri[j]\descriptive_representation_item.description;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_representation_requires_origin FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (((SIZEOF(QUERY (it <* sr\representation.items| ((it\representation_item.name = 'origin') OR (it\representation_item.name = 'orientation')) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(it)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(it))))) = 1) OR (SIZEOF(QUERY (it <* sr\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STYLED_ITEM' IN TYPEOF(it)))) >= 1)) OR (SIZEOF(QUERY (it <* sr\representation.items| ((it\representation_item.name = 'origin') OR (it\representation_item.name = 'orientation')) AND ((sr\representation.name = 'zone shape') OR (sr.context_of_items\representation_context.context_type = 'connection zone colour')))) = 0)))) = 0;
   END_RULE;



   RULE step_edge_feature_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum step depth'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum step width'))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum step depth'))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum step width'))) = 1))) = 0;
   END_RULE;



   RULE stratum_average_surface_shape_constraint FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name = 'stratum average surface shape') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(mssr,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition\shape_aspect.description = 'average surface'))) = 1))) = 0;
   END_RULE;



   RULE stratum_feature_non_planar_2d_shape_constraint FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name = 'stratum feature non planar 2d shape') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(mssr,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(pdr.definition.definition)))) = 1))) = 0;
   END_RULE;



   RULE stratum_feature_shape_stratum_average_surface_shape_relationship_constraint FOR (representation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum average surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2)) AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')))) = 0;
      WR2:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum average surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1)) AND (rr.rep_1\representation.name = 'stratum average surface shape')))) = 0;
   END_RULE;



   RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR (representation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2)) AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')))) = 0;
      WR2:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1)) AND (rr.rep_1\representation.name = 'stratum surface shape')))) = 0;
   END_RULE;



   RULE stratum_feature_unique_constraint FOR (stratum_feature );
   LOCAL
      sf_bag : BAG OF stratum_feature;
      s_bag : BAG OF stratum := [];
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(stratum_feature) BY 1;
         IF EXISTS(stratum_feature[i].of_shape.definition) THEN
            IF NOT (stratum_feature[i].of_shape.definition IN s_bag) THEN
               s_bag := s_bag + stratum_feature[i].of_shape.definition;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sf_bag := QUERY (r <* stratum_feature| r.of_shape.definition :=: s_bag[i]);
         name_bag := [];
         REPEAT j := 1 TO SIZEOF(sf_bag) BY 1;
            IF EXISTS(sf_bag[j]\shape_aspect.name) THEN
               IF sf_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sf_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = '3d positioned stratum shape in interconnect module') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE stratum_interconnect_module_planar_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'planar positioned stratum shape in interconnect module') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE stratum_make_from_relationship_constraint FOR (make_from_usage_option );
   WHERE
      WR1:
         SIZEOF(QUERY (mfuo <* make_from_usage_option| (mfuo\product_definition_relationship.name = 'stratum make from') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(mfuo.related_product_definition)))) = 0;
      WR2:
         SIZEOF(QUERY (mfuo <* make_from_usage_option| (mfuo\product_definition_relationship.name = 'stratum make from') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(mfuo.relating_product_definition)))) = 0;
   END_RULE;



   RULE stratum_planar_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (NOT ((sr\representation.name = 'planar projected shape') AND (SIZEOF(QUERY (pdr <* USEDIN(sr,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.definition.definition)))) = 1)) OR (SIZEOF(QUERY (a2p2d <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(a2p2d)))) >= 0)))) = 0;
   END_RULE;



   RULE stratum_surface_in_stratum_3d_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'stratum surface in stratum 3d position') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE stratum_surface_unique_constraint FOR (stratum_surface );
   LOCAL
      ss_bag : BAG OF stratum_surface;
      s_bag : BAG OF stratum := [];
      pass : BOOLEAN := TRUE;
      desc_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(stratum_surface) BY 1;
         IF EXISTS(stratum_surface[i].of_shape.definition) THEN
            IF NOT (stratum_surface[i].of_shape.definition IN s_bag) THEN
               s_bag := s_bag + stratum_surface[i].of_shape.definition;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ss_bag := QUERY (r <* stratum_surface| r.of_shape.definition :=: s_bag[i]);
         desc_bag := [];
         REPEAT j := 1 TO SIZEOF(ss_bag) BY 1;
            IF EXISTS(ss_bag[j]\shape_aspect.description) THEN
               IF ss_bag[j]\shape_aspect.description IN desc_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  desc_bag := desc_bag + ss_bag[j]\shape_aspect.description;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE stratum_technology_line_width_tolerance_assignment_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'stratum technology line width tolerance assignment') AND NOT (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum positive deviation'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'stratum technology line width tolerance assignment') AND NOT (SIZEOF(QUERY (si <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STYLED_ITEM' IN TYPEOF(si)))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'stratum technology line width tolerance assignment') AND NOT (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum negative deviation'))) = 1))) = 0;
   END_RULE;



   RULE substitute_product_constraint FOR (product,

 assembly_component_usage_substitute );
   WHERE
      WR1:
         SIZEOF(QUERY (acus <* assembly_component_usage_substitute| EXISTS(acus.substitute.reference_designator))) = 0;
   END_RULE;



   RULE subtype_combination_shape_aspect FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MINIMALLY_DEFINED_BARE_DIE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DERIVED_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_BOUNDARY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE') ] * TYPEOF(sa)) <= 1))) = 0;
      WR2:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MINIMALLY_DEFINED_BARE_DIE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_BOUNDARY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE') ] * TYPEOF(sa)) <= 1))) = 0;
      WR3:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DERIVED_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_BOUNDARY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE') ] * TYPEOF(sa)) <= 1))) = 0;
      WR4:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_FEATURE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM') ] * TYPEOF(sa)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_action_request_assignment FOR (action_request_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ara <* action_request_assignment| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_REQUEST') ] * TYPEOF(ara)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_dimensional_location FOR (dimensional_location );
   WHERE
      WR1:
         SIZEOF(QUERY (dl <* dimensional_location| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANGULAR_DIMENSION_WITH_ORIENTATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_LOCATION_WITH_DIRECTION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_LOCATION_WITH_PATH') ] * TYPEOF(dl)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_dimensional_size FOR (dimensional_size );
   WHERE
      WR1:
         SIZEOF(QUERY (ds <* dimensional_size| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CURVE_DIMENSION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANGULAR_SIZE') ] * TYPEOF(ds)) <= 1) OR NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CURVE_DIMENSION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE') ] * TYPEOF(ds)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_mapped_item FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_TEXT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_SYMBOL') ] * TYPEOF(mi)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_measure_with_unit FOR (measure_with_unit );
   WHERE
      WR1:
         SIZEOF(QUERY (mwu <* measure_with_unit| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ABSORBED_DOSE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTIVITY_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AREA_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CAPACITANCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONDUCTANCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOSE_EQUIVALENT_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ELECTRIC_CHARGE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ELECTRIC_CURRENT_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ELECTROMOTIVE_FORCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ENERGY_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FORCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FREQUENCY_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ILLUMINANCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INDUCTANCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LUMINOUS_FLUX_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LUMINOUS_INTENSITY_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAGNETIC_FLUX_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MASS_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLANE_ANGLE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POWER_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRESSURE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RATIO_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RESISTANCE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SOLID_ANGLE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TIME_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'UNCERTAINTY_MEASURE_WITH_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VOLUME_MEASURE_WITH_UNIT') ] * TYPEOF(mwu)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_product_definition FOR (product_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM') ] * TYPEOF(pd)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_product_definition_relationship FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_USAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SUPPLIED_PART_RELATIONSHIP') ] * TYPEOF(pdr)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_property_definition FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE_PROPERTY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_GROUP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_PROPERTY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SIGNAL') ] * TYPEOF(pd)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_property_definition_representation FOR (property_definition_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_representation| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_DEFINITION_REPRESENTATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_PROPERTY_REPRESENTATION') ] * TYPEOF(pdr)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_representation FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_FUNCTION_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_STRING_REPRESENTATION') ] * TYPEOF(rep)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_representation_context FOR (representation_context );
   LOCAL
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(representation_context) BY 1;
         pass := ((NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i])) OR (SIZEOF(TYPEOF(representation_context[i])) <= 2)) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i])) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETRIC_REPRESENTATION_CONTEXT') ] * TYPEOF(representation_context[i])) <= 2))) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i])) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETRIC_REPRESENTATION_CONTEXT') ] * TYPEOF(representation_context[i])) <= 2));
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE subtype_exclusive_shape_aspect_relationship FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_LOCATION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_CONNECTIVITY_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_FEATURE_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_DERIVING_RELATIONSHIP'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP') ] * TYPEOF(sar)) <= 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_action FOR (action );
   WHERE
      WR1:
         SIZEOF(QUERY (act <* action| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIRECTED_ACTION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXECUTED_ACTION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION') ] * TYPEOF(act)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_address FOR (address );
   WHERE
      WR1:
         SIZEOF(QUERY (add <* address| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERSONAL_ADDRESS'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ORGANIZATIONAL_ADDRESS') ] * TYPEOF(add)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_colour FOR (colour );
   WHERE
      WR1:
         SIZEOF(QUERY (c <* colour| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COLOUR_RGB' IN TYPEOF(c)))) = 0;
   END_RULE;



   RULE subtype_mandatory_composite_shape_aspect FOR (composite_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (csa <* composite_shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_GROUP_SHAPE_ASPECT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_UNIT_SHAPE_ASPECT') ] * TYPEOF(csa)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_compound_representation_item FOR (compound_representation_item );
   WHERE
      WR1:
         SIZEOF(QUERY (tl <* compound_representation_item| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATA_SET_REPRESENTATION_ITEM' IN TYPEOF(tl)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TABLE_REPRESENTATION_ITEM' IN TYPEOF(tl))))) = 0;
   END_RULE;



   RULE subtype_mandatory_date FOR (date );
   WHERE
      WR1:
         SIZEOF(QUERY (d <* date| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CALENDAR_DATE' IN TYPEOF(d)))) = 0;
   END_RULE;



   RULE subtype_mandatory_externally_defined_item FOR (externally_defined_item );
   WHERE
      WR1:
         SIZEOF(QUERY (edi <* externally_defined_item| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BOND_CATEGORY'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_CURVE_FONT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_FUNCTIONAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_HATCH_STYLE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_REPRESENTATION_ITEM'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_SYMBOL'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_TEXT_FONT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_TILE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_TILE_STYLE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SIGNAL_CATEGORY') ] * TYPEOF(edi)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_geometric_tolerance FOR (geometric_tolerance );
   WHERE
      WR1:
         SIZEOF(QUERY (gt <* geometric_tolerance| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE') ] * TYPEOF(gt)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item );
   WHERE
      WR1:
         SIZEOF(QUERY (pdi <* pre_defined_item| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_TEXT_FONT'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_CURVE_FONT') ] * TYPEOF(pdi)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_product_definition_usage FOR (product_definition_usage );
   WHERE
      WR1:
         SIZEOF(QUERY (pdu <* product_definition_usage| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE'),

 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_USAGE_OPTION') ] * TYPEOF(pdu)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_runout_zone_orientation FOR (runout_zone_orientation );
   WHERE
      WR1:
         SIZEOF(QUERY (rzo <* runout_zone_orientation| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION') ] * TYPEOF(rzo)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_text_literal FOR (text_literal );
   WHERE
      WR1:
         SIZEOF(QUERY (tl <* text_literal| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_LITERAL_WITH_EXTENT' IN TYPEOF(tl)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN TYPEOF(tl))))) = 0;
   END_RULE;



   RULE supplied_product_version_unique_constraint FOR (product_definition_formation_with_specified_source );
   LOCAL
      spv : BAG OF product_definition_formation_with_specified_source := QUERY (r <* product_definition_formation_with_specified_source| SIZEOF(QUERY (pd <* USEDIN(r,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION.FORMATION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SUPPLIED_PART_RELATIONSHIP' IN TYPEOF(pdr)))) > 0))) > 0);
      aoa_bag : BAG OF applied_organization_assignment;
      o_bag : BAG OF organization := [];
      pdf_bag : BAG OF product_definition_formation_with_specified_source;
      spn_bag : BAG OF STRING;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(spv) BY 1;
         aoa_bag := QUERY (aoa <* USEDIN(spv[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| aoa.role\organization_role.name = 'supplier');
         REPEAT j := 1 TO SIZEOF(aoa_bag) BY 1;
            IF EXISTS(aoa_bag[j].assigned_organization) THEN
               IF NOT (aoa_bag[j].assigned_organization IN o_bag) THEN
                  o_bag := o_bag + aoa_bag[j].assigned_organization;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(o_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdf_bag := QUERY (pdf <* spv| SIZEOF(QUERY (aoa <* USEDIN(pdf,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'supplier') AND (aoa.assigned_organization :=: o_bag[i]))) > 0);
         spn_bag := [];
         REPEAT j := 1 TO SIZEOF(pdf_bag) BY 1;
            IF EXISTS(pdf_bag[j].of_product.id) THEN
               IF pdf_bag[j].of_product.id IN spn_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  spn_bag := spn_bag + pdf_bag[j].of_product.id;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE topological_junction_unique_constraint FOR (shape_aspect );
   LOCAL
      tj : BAG OF shape_aspect := QUERY (r <* shape_aspect| r\shape_aspect.description = 'topological junction');
      sar_bag : BAG OF shape_aspect_relationship;
      s_bag : BAG OF shape_aspect := [];
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(tj) BY 1;
         sar_bag := QUERY (sar <* USEDIN(tj[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'topological junction scope') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
               IF NOT (sar_bag[j].relating_shape_aspect IN s_bag) THEN
                  s_bag := s_bag + sar_bag[j].relating_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* USEDIN(s_bag[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'topological junction scope');
         name_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect\shape_aspect.name) THEN
               IF sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE transmission_line_functional_unit_terminal_allocation_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      tlfuta : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'transmission line functional terminal allocation');
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      ut_bag : BAG OF shape_aspect := [];
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(tlfuta) BY 1;
         IF EXISTS(tlfuta[i].relating_shape_aspect) THEN
            IF tlfuta[i].relating_shape_aspect\shape_aspect.description = 'unit terminal' THEN
               IF NOT (tlfuta[i].relating_shape_aspect IN ut_bag) THEN
                  ut_bag := ut_bag + tlfuta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ut_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* tlfuta| (sar.related_shape_aspect\shape_aspect.description = 'printed component join terminal') AND (sar.relating_shape_aspect :=: ut_bag[i]));
         sa_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE versioned_action_request_requires_approval FOR (versioned_action_request,

 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (varq <* versioned_action_request| NOT (SIZEOF(QUERY (aaa <* applied_approval_assignment| (varq IN aaa.items))) = 1))) = 0;
   END_RULE;



   RULE versioned_action_request_requires_date_or_date_and_time FOR (versioned_action_request,

 applied_date_and_time_assignment,

 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (varq <* versioned_action_request| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (varq IN adata.items))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (varq IN ada.items))) = 1)))) = 0;
   END_RULE;



   RULE versioned_action_request_requires_person_organization FOR (versioned_action_request,

 applied_person_and_organization_assignment,

 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (varq <* versioned_action_request| NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (varq IN apaoa.items))) >= 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (varq IN aoa.items))) >= 1)))) = 0;
   END_RULE;



   RULE versioned_action_request_requires_status FOR (versioned_action_request,

 action_request_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ar <* versioned_action_request| NOT (SIZEOF(QUERY (ars <* action_request_status| (ar :=: ars.assigned_request))) = 1))) = 0;
   END_RULE;



   RULE via_template_terminal_unique_constraint FOR (shape_aspect );
   LOCAL
      vt : BAG OF shape_aspect := QUERY (r <* shape_aspect| r\shape_aspect.description = 'via template');
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(vt) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* USEDIN(vt[i],

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access mechanism') AND (sar.related_shape_aspect\shape_aspect.description = 'via template terminal'));
         name_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect\shape_aspect.name) THEN
               IF sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE work_order_unique_constraint FOR (directed_action );
   LOCAL
      r : BAG OF directed_action := QUERY (r <* directed_action| SIZEOF(QUERY (aa <* USEDIN(r,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE' IN TYPEOF(aa)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_WORK' IN TYPEOF(aa)))) > 0);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].directive\action_directive.name) THEN
            IF r[i].directive\action_directive.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i].directive\action_directive.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE work_request_unique_constraint FOR (versioned_action_request );
   LOCAL
      r : BAG OF versioned_action_request := QUERY (r <* versioned_action_request| SIZEOF(QUERY (ara <* USEDIN(r,

 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST' IN TYPEOF(ara)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_REQUEST' IN TYPEOF(ara)))) > 0);
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].id) THEN
            IF r[i].id IN id_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               id_bag := id_bag + r[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;


(* *********************************** *)


END_SCHEMA;


(* ************************************************************************** *)
