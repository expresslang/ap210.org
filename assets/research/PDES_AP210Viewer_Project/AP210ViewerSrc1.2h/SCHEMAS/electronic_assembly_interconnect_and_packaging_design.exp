(*
 Updated Wed Jan 23 14:34:20 EST 2001
 added part 42 tc3, (did not include cylindrical, polar, spherical point subtypes,
  as these would require changes to SHORT NAMES, AND EXPRESS G.)

 Updated Fri Dec 8
 located_interconnect_module_thickness_requirement_unique_constraint

Updated Sat Dec 3
shape_element_constraint

Updated: Fri Dec 1
 land wr4 back to IS version; mapping table is inconsistent and needs to be corrected to agree with rule
 component_terminal wr15  use 'description' instead of 'name'
 layer_connection_point_link wr4 changed back to 3
  EPM and Expresso differ on interpretation of part 11.

Updated: Tue Nov 21
  subtype_mandatory_shape_representation
   coded incorrectly
  shape_element_constraint
   coded incorrectly
 
Updated: Sat Nov 18
  stratum_technology
   corrected inconsistency between WHERE rule subclauses.

Updated: Wed Nov 8
  characteristic_unique_constraint
    corrected representation_item.name problem

Updated: Sun Nov 5 13:00 CST 2000
  polarity_indication_feature_constraint
corrected shape_representation.name problem in default_assembly_bond_constraint
and in mating_connector_placement_relationship_constraint.
workaround for 
assembly_definition,
ee_product_constraint,
planar_curve_constraint,
feature_shape_occurrence_constraint,
component_terminal,
component_shape_aspect,
explicitly_located_layer_connection_point_unique_constraint,
inter_stratum_feature,
interconnect_definition,
land_physical_template,
layer_connection_point_link,
stratum_technology,
applied_date_correlation,
applied_date_time_correlation
*)

SCHEMA electronic_assembly_interconnect_and_packaging_design;

  CONSTANT
  dummy_gri : geometric_representation_item := representation_item('') || 
                 geometric_representation_item();
  dummy_tri : topological_representation_item := representation_item('') 
                 || topological_representation_item();
  END_CONSTANT;

  TYPE action_assigned_item = SELECT
    (product_definition_formation,
     rule_definition);
  END_TYPE; -- action_assigned_item

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE amount_of_substance_measure = REAL;
  END_TYPE; -- amount_of_substance_measure

  TYPE angle_relator = ENUMERATION OF
    (equal,
     large,
     small);
  END_TYPE; -- angle_relator

  TYPE approval_assigned_item = SELECT
    (action,
     action_directive,
     alternate_product_relationship,
     applied_date_and_time_assignment,
     applied_document_reference,
     certification,
     change_request,
     characterized_object,
     colour,
     component_definition,
     component_shape_aspect,
     composite_curve_segment,
     configuration_effectivity,
     configuration_item,
     contract,
     curve_style,
     curve_style_font,
     curve_style_font_and_scaling,
     date,
     dimension_related_tolerance_zone_element,
     dimensional_characteristic_representation,
     dimensional_size,
     directed_action,
     document,
     document_usage_constraint,
     externally_defined_item,
     fill_area_style,
     fill_area_style_colour,
     geometric_tolerance,
     geometric_tolerance_relationship,
     group,
     inter_stratum_feature,
     material_designation,
     measure_with_unit,
     plus_minus_tolerance,
     pre_defined_item,
     product,
     product_concept,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_formation_with_specified_source,
     product_definition_relationship,
     property_definition,
     property_definition_relationship,
     property_definition_representation,
     representation,
     representation_context,
     representation_item,
     representation_relationship,
     runout_zone_orientation,
     security_classification,
     shape_aspect,
     shape_aspect_relationship,
     start_request,
     stratum_feature,
     tolerance_value,
     tolerance_zone_form,
     versioned_action_request);
  END_TYPE; -- approval_assigned_item

  TYPE area_measure = REAL;
  END_TYPE; -- area_measure

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model,
     half_space_solid,
     csg_primitive,
     boolean_result);
  END_TYPE; -- boolean_operand

  TYPE boolean_operator = ENUMERATION OF
    (union,
     intersection,
     difference);
  END_TYPE; -- boolean_operator

  TYPE box_characteristic_select = SELECT
    (box_height,
     box_width,
     box_slant_angle,
     box_rotate_angle);
  END_TYPE; -- box_characteristic_select

  TYPE box_height = positive_ratio_measure;
  END_TYPE; -- box_height

  TYPE box_rotate_angle = plane_angle_measure;
  END_TYPE; -- box_rotate_angle

  TYPE box_slant_angle = plane_angle_measure;
  END_TYPE; -- box_slant_angle

  TYPE box_width = positive_ratio_measure;
  END_TYPE; -- box_width

  TYPE certification_assigned_item = SELECT
    (supplied_part_relationship,
     make_from_usage_option,
     product_definition_formation_with_specified_source);
  END_TYPE; -- certification_assigned_item

  TYPE change_request_item = SELECT
    (product_definition_formation,
     representation_relationship);
  END_TYPE; -- change_request_item

  TYPE character_spacing_select = SELECT
    (length_measure,
     ratio_measure,
     measure_with_unit,
     descriptive_measure);
  END_TYPE; -- character_spacing_select

  TYPE character_style_select = SELECT
    (character_glyph_style_stroke,
     character_glyph_style_outline,
     text_style_for_defined_font);
  END_TYPE; -- character_style_select

  TYPE characterized_definition = SELECT
    (characterized_object,
     characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_material_property = SELECT
    (material_property_representation,
     product_material_composition_relationship);
  END_TYPE; -- characterized_material_property

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE classification_assigned_item = SELECT
    (requirements_property,
     signal,
     stratum);
  END_TYPE; -- classification_assigned_item

  TYPE context_dependent_measure = REAL;
  END_TYPE; -- context_dependent_measure

  TYPE contract_assigned_item = SELECT
    (alternate_product_relationship,
     directed_action,
     product,
     product_definition_formation);
  END_TYPE; -- contract_assigned_item

  TYPE count_measure = NUMBER;
  END_TYPE; -- count_measure

  TYPE csg_primitive = SELECT
    (sphere,
     block,
     right_angular_wedge,
     torus,
     right_circular_cone,
     right_circular_cylinder);
  END_TYPE; -- csg_primitive

  TYPE csg_select = SELECT
    (boolean_result,
     csg_primitive);
  END_TYPE; -- csg_select

  TYPE curve_font_or_scaled_curve_font_select = SELECT
    (curve_style_font_select,
     curve_style_font_and_scaling);
  END_TYPE; -- curve_font_or_scaled_curve_font_select

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE curve_or_annotation_curve_occurrence = SELECT
    (curve,
     annotation_curve_occurrence);
  END_TYPE; -- curve_or_annotation_curve_occurrence

  TYPE curve_or_render = SELECT
    (curve_style);
  END_TYPE; -- curve_or_render

  TYPE curve_style_font_select = SELECT
    (curve_style_font,
     pre_defined_curve_font,
     externally_defined_curve_font);
  END_TYPE; -- curve_style_font_select

  TYPE date_and_time_assigned_item = SELECT
    (approval_person_organization,
     certification,
     change,
     contract,
     directed_action,
     document,
     product_definition,
     rule_action,
     security_classification,
     versioned_action_request);
  END_TYPE; -- date_and_time_assigned_item

  TYPE date_assigned_item = SELECT
    (product_definition,
     versioned_action_request,
     directed_action,
     approval_person_organization,
     contract,
     security_classification,
     certification);
  END_TYPE; -- date_assigned_item

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  END_TYPE; -- day_in_month_number

  TYPE defined_symbol_select = SELECT
    (externally_defined_symbol);
  END_TYPE; -- defined_symbol_select

  TYPE descriptive_measure = STRING;
  END_TYPE; -- descriptive_measure

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- dimension_count

  TYPE dimensional_characteristic = SELECT
    (dimensional_location,
     dimensional_size);
  END_TYPE; -- dimensional_characteristic

  TYPE document_assigned_item = SELECT
    (action_method,
     assembly_component_usage,
     bond_category,
     characterized_object,
     component_definition,
     component_interface_terminal,
     component_shape_aspect,
     component_terminal,
     configuration_item,
     descriptive_representation_item,
     externally_defined_item,
     functional_unit_terminal_definition,
     layer,
     material_designation,
     measure_representation_item,
     package_terminal,
     part_template_definition,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     property_definition,
     representation,
     representation_item,
     requirements_property,
     rule_definition,
     shape_aspect,
     signal,
     stratum);
  END_TYPE; -- document_assigned_item

  TYPE electric_current_measure = REAL;
  END_TYPE; -- electric_current_measure

  TYPE fill_area_style_tile_shape_select = SELECT
    (fill_area_style_tile_curve_with_style,
     fill_area_style_tile_coloured_region,
     fill_area_style_tile_symbol_with_style,
     externally_defined_tile);
  END_TYPE; -- fill_area_style_tile_shape_select

  TYPE fill_style_select = SELECT
    (fill_area_style_colour,
     externally_defined_tile_style,
     fill_area_style_tiles,
     externally_defined_hatch_style,
     fill_area_style_hatching);
  END_TYPE; -- fill_style_select

  TYPE font_select = SELECT
    (externally_defined_text_font);
  END_TYPE; -- font_select

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE; -- founded_item_select

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE group_assigned_item = SELECT
    (component_definition,
     component_interface_terminal,
     component_shape_aspect,
     component_terminal,
     configuration_item,
     inter_stratum_feature,
     printed_part_template_terminal,
     product,
     product_definition_formation,
     representation,
     representation_item,
     requirements_property,
     rule_definition,
     shape_aspect,
     stratum,
     stratum_feature,
     stratum_surface);
  END_TYPE; -- group_assigned_item

  TYPE hiding_or_blanking_select = SELECT
    (annotation_fill_area,
     character_glyph_symbol_outline);
  END_TYPE; -- hiding_or_blanking_select

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE; -- hour_in_day

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE invisibility_context = SELECT
    (presentation_representation);
  END_TYPE; -- invisibility_context

  TYPE invisible_item = SELECT
    (styled_item,
     representation);
  END_TYPE; -- invisible_item

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     unspecified,
     quasi_uniform_knots,
     piecewise_bezier_knots);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE layered_item = SELECT
    (presentation_representation,
     representation_item);
  END_TYPE; -- layered_item

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE limit_condition = ENUMERATION OF
    (maximum_material_condition,
     least_material_condition,
     regardless_of_feature_size);
  END_TYPE; -- limit_condition

  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE luminous_intensity_measure = REAL;
  END_TYPE; -- luminous_intensity_measure

  TYPE managed_design_object = SELECT
    (action,
     alternate_product_relationship,
     applied_approval_assignment,
     applied_date_and_time_assignment,
     applied_document_reference,
     approval,
     approval_status,
     certification,
     characterized_object,
     colour,
     composite_curve_segment,
     configuration_effectivity,
     configuration_item,
     contract,
     curve_style,
     curve_style_font,
     curve_style_font_and_scaling,
     date,
     dimension_related_tolerance_zone_element,
     dimensional_characteristic_representation,
     dimensional_size,
     document,
     document_usage_constraint,
     externally_defined_item,
     fill_area_style,
     fill_area_style_colour,
     geometric_tolerance,
     geometric_tolerance_relationship,
     group,
     layer_connection_point,
     layer_connection_point_link,
     material_designation,
     measure_with_unit,
     organization,
     person,
     person_and_organization,
     plus_minus_tolerance,
     pre_defined_item,
     product,
     product_concept,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     property_definition,
     property_definition_relationship,
     property_definition_representation,
     representation,
     representation_context,
     representation_item,
     representation_relationship,
     runout_zone_orientation,
     security_classification,
     shape_aspect,
     shape_aspect_relationship,
     tolerance_value,
     tolerance_zone_form,
     versioned_action_request);
  END_TYPE; -- managed_design_object

  TYPE mass_measure = REAL;
  END_TYPE; -- mass_measure

  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     time_measure,
     electric_current_measure,
     thermodynamic_temperature_measure,
     amount_of_substance_measure,
     luminous_intensity_measure,
     plane_angle_measure,
     solid_angle_measure,
     area_measure,
     volume_measure,
     ratio_measure,
     parameter_value,
     numeric_measure,
     context_dependent_measure,
     descriptive_measure,
     positive_length_measure,
     positive_plane_angle_measure,
     positive_ratio_measure,
     count_measure);
  END_TYPE; -- measure_value

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE numeric_measure = NUMBER;
  END_TYPE; -- numeric_measure

  TYPE organization_assigned_item = SELECT
    (configuration_item,
     contract,
     directed_action,
     document,
     versioned_action_request,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_with_specified_source,
     representation,
     security_classification);
  END_TYPE; -- organization_assigned_item

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_and_organization_assigned_item = SELECT
    (configuration_item,
     contract,
     document,
     product,
     product_definition_formation,
     product_definition,
     rule_action,
     security_classification,
     versioned_action_request);
  END_TYPE; -- person_and_organization_assigned_item

  TYPE person_assigned_item = SELECT
    (change,
     document,
     security_classification);
  END_TYPE; -- person_assigned_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_length_measure

  TYPE positive_plane_angle_measure = plane_angle_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_plane_angle_measure

  TYPE positive_ratio_measure = ratio_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_ratio_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE presentable_text = STRING;
  END_TYPE; -- presentable_text

  TYPE presentation_representation_select = SELECT
    (presentation_representation);
  END_TYPE; -- presentation_representation_select

  TYPE presentation_style_select = SELECT
    (curve_style,
     fill_area_style,
     text_style);
  END_TYPE; -- presentation_style_select

  TYPE ratio_measure = REAL;
  END_TYPE; -- ratio_measure

  TYPE replacement_from_item = SELECT
    (rule_definition);
  END_TYPE; -- replacement_from_item

  TYPE replacement_to_item = SELECT
    (rule_definition);
  END_TYPE; -- replacement_to_item

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 60));
  END_TYPE; -- second_in_minute

  TYPE security_classification_assigned_item = SELECT
    (assembly_component_usage,
     document,
     make_from_usage_option,
     product_definition_formation,
     product_definition);
  END_TYPE; -- security_classification_assigned_item

  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE shell = SELECT
    (vertex_shell,
     wire_shell,
     open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE size_select = SELECT
    (positive_length_measure,
     measure_with_unit,
     descriptive_measure);
  END_TYPE; -- size_select

  TYPE solid_angle_measure = REAL;
  END_TYPE; -- solid_angle_measure

  TYPE source = ENUMERATION OF
    (made,
     bought,
     not_known);
  END_TYPE; -- source

  TYPE source_item = SELECT
    (identifier);
  END_TYPE; -- source_item

  TYPE squared_or_rounded = ENUMERATION OF
    (squared,
     rounded);
  END_TYPE; -- squared_or_rounded

  TYPE start_request_item = SELECT
    (product_definition_formation,
     representation_relationship);
  END_TYPE; -- start_request_item

  TYPE style_context_select = SELECT
    (group,
     representation,
     representation_item);
  END_TYPE; -- style_context_select

  TYPE supported_item = SELECT
    (action_directive,
     action,
     action_method);
  END_TYPE; -- supported_item

  TYPE surface_model = SELECT
    (shell_based_surface_model);
  END_TYPE; -- surface_model

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE text_alignment = label;
  END_TYPE; -- text_alignment

  TYPE text_or_character = SELECT
    (annotation_text,
     annotation_text_character,
     text_literal);
  END_TYPE; -- text_or_character

  TYPE text_path = ENUMERATION OF
    (left,
     right,
     up,
     down);
  END_TYPE; -- text_path

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE; -- thermodynamic_temperature_measure

  TYPE time_measure = REAL;
  END_TYPE; -- time_measure

  TYPE tolerance_method_definition = SELECT
    (tolerance_value);
  END_TYPE; -- tolerance_method_definition

  TYPE tolerance_select = SELECT
    (geometric_tolerance,
     plus_minus_tolerance);
  END_TYPE; -- tolerance_select

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE; -- trimming_preference

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE; -- unit

  TYPE value_qualifier = SELECT
    (precision_qualifier,
     type_qualifier,
     uncertainty_qualifier);
  END_TYPE; -- value_qualifier

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE volume_measure = REAL;
  END_TYPE; -- volume_measure

  TYPE wireframe_model = SELECT
    (shell_based_wireframe_model,
     edge_based_wireframe_model);
  END_TYPE; -- wireframe_model

  TYPE work_item = SELECT
    (product_definition_formation);
  END_TYPE; -- work_item

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY action;
      name          : label;
      description   : text;
      chosen_method : action_method;
  END_ENTITY; -- action

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
      assigned_action : action;
  END_ENTITY; -- action_assignment

  ENTITY action_directive;
      name        : label;
      description : text;
      analysis    : text;
      comment     : text;
      requests    : SET [1:?] OF versioned_action_request;
  END_ENTITY; -- action_directive

  ENTITY action_method;
      name        : label;
      description : text;
      consequence : text;
      purpose     : text;
  END_ENTITY; -- action_method

  ENTITY action_method_relationship;
      name            : label;
      description     : text;
      relating_method : action_method;
      related_method  : action_method;
  END_ENTITY; -- action_method_relationship

  ENTITY action_relationship;
      name            : label;
      description     : text;
      relating_action : action;
      related_action  : action;
  END_ENTITY; -- action_relationship

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
  END_ENTITY; -- action_request_assignment

  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
  END_ENTITY; -- action_request_solution

  ENTITY action_request_status;
      status           : label;
      assigned_request : versioned_action_request;
  END_ENTITY; -- action_request_status

  ENTITY action_status;
      status          : label;
      assigned_action : executed_action;
  END_ENTITY; -- action_status

  ENTITY add_design_object_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(it)) AND (it.
               name = 'design object addition')) )) = 1);
  END_ENTITY; -- add_design_object_assignment

  ENTITY add_design_object_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(it)) AND (it.
               name = 'design object addition')) )) = 1);
  END_ENTITY; -- add_design_object_request_assignment

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY advanced_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D'] 
               * TYPEOF(it)) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM'] 
               * TYPEOF(it)) = 1) )) > 0);
      wr3: (SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh <* msb_shells(
               msb,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN') | (NOT (SIZEOF(QUERY ( fcs <* csh\
               connected_face_set.cfs_faces | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
               IN TYPEOF(fcs))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' 
               IN TYPEOF(it)) ) | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' 
               IN TYPEOF(msb\manifold_solid_brep.outer)) )) = 0);
      wr5: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BREP_WITH_VOIDS' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh <* brv\
               brep_with_voids.voids | csh\oriented_closed_shell.
               orientation )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
               IN TYPEOF(it)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
  END_ENTITY; -- advanced_brep_shape_representation

  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1 : (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE'] 
                * TYPEOF(face_geometry)) = 1);
      wr2 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds.bound\path.edge_list | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' 
                IN TYPEOF(oe.edge_element))) )) = 0)) )) = 0);
      wr3 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds.bound\path.edge_list | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE'] 
                * TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1)) )) 
                = 0)) )) = 0);
      wr4 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds.bound\path.edge_list | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(oe.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' 
                IN TYPEOF(oe.edge_start\vertex_point.vertex_geometry)) AND 
                ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(oe.edge_end)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' 
                IN TYPEOF(oe.edge_end\vertex_point.vertex_geometry)))) )) =
                 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' 
                IN TYPEOF(elp_fbnds.bound)) )) = 0);
      wr6 : ((NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' 
                IN TYPEOF(face_geometry))) OR (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE'] 
                * TYPEOF(face_geometry\swept_surface.swept_curve)) = 1));
      wr7 : (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* SELF.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                loop_vertex)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' 
                IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                loop_vertex\vertex_point.vertex_geometry)))) )) = 0);
      wr8 : (SIZEOF(QUERY ( bnd <* SELF.bounds | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP'] 
                * TYPEOF(bnd.bound)) = 1)) )) = 0);
      wr9 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds.bound\path.edge_list | (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' 
                IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND (
                NOT (SIZEOF(QUERY ( sc_ag <* oe.edge_element\edge_curve.
                edge_geometry\surface_curve.associated_geometry | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
                IN TYPEOF(sc_ag))) )) = 0))) )) = 0)) )) = 0);
      wr10: (((NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' 
                IN TYPEOF(face_geometry))) OR (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
                IN TYPEOF(face_geometry\swept_surface.swept_curve))) OR (
                SIZEOF(face_geometry\swept_surface.swept_curve\polyline.
                points) < 3)) AND (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* SELF.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds.bound\path.edge_list | (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
                IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND (
                NOT (SIZEOF(oe.edge_element\edge_curve.edge_geometry\
                polyline.points) < 3))) )) = 0)) )) = 0));
  END_ENTITY; -- advanced_face

  ENTITY alternate_product_relationship;
      name       : label;
      definition : text;
      alternate  : product;
      base       : product;
      basis      : text;
    UNIQUE
      ur1 : alternate, base;
    WHERE
      wr1: (alternate :<>: base);
  END_ENTITY; -- alternate_product_relationship

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AMOUNT_OF_SUBSTANCE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- amount_of_substance_measure_with_unit

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 1) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- amount_of_substance_unit

  ENTITY analytical_model
    SUBTYPE OF (representation);
    UNIQUE
      ur1 : SELF\representation.name;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 2);
      wr2: (SIZEOF(QUERY ( dr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (dr.assigned_document.
               kind.product_data_type = 'language reference manual') )) = 1);
      wr3: (SIZEOF(QUERY ( it <* SELF.items | (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODEL_PARAMETER') IN TYPEOF(it))) )) = 0);
      wr4: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_1') | ((rr.name = 
               'access mechanism') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ANALYTICAL_MODEL_PORT') IN TYPEOF(rr.rep_2))) )) >= 1);
  END_ENTITY; -- analytical_model

  ENTITY analytical_model_port
    SUBTYPE OF (representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'distributed property') AND (it\
               descriptive_representation_item.description IN ['true',
               'false'])) )) = 1);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'nominal signal flow direction') AND (it\
               descriptive_representation_item.description IN [
               'input direction','output direction','bidirectional',
               'unknown direction','not applicable'])) )) <= 1);
      wr3: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'port type') AND (it\descriptive_representation_item.
               description IN ['string property type',
               'logical property type','physical property type',
               'boolean property type'])) )) = 1);
      wr4: (SIZEOF(QUERY ( am <* QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | (rr.name = 
               'access mechanism') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ANALYTICAL_MODEL') IN TYPEOF(am.rep_1)) )) = 1);
      wr5: (SIZEOF(QUERY ( aga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT.ITEMS') | (aga.assigned_group\group.name 
               IN ['scalar port','digital scalar port','vector port',
               'digital vector port','digital analytical model port']) )) 
               <= 1);
      wr6: ((NOT (SIZEOF(QUERY ( aga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT.ITEMS') | (aga.assigned_group\group.name 
               IN ['vector port','digital vector port']) )) = 1)) OR (
               SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name =
                'size') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COUNT_MEASURE') IN TYPEOF(it\measure_with_unit.
               value_component)) AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CONTEXT_DEPENDENT_UNIT') IN TYPEOF(it\measure_with_unit.
               unit_component))) )) = 1));
      wr7: ((NOT (SIZEOF(QUERY ( aga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT.ITEMS') | (aga.assigned_group\group.name 
               IN ['digital scalar port','digital vector port',
               'digital analytical model port']) )) = 1)) OR (SIZEOF(
               QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'nominal signal flow direction') AND (it\
               descriptive_representation_item.description IN [
               'input direction','output direction','bidirectional',
               'unknown direction'])) )) = 1));
  END_ENTITY; -- analytical_model_port

  ENTITY analytical_representation
    SUBTYPE OF (representation);
    UNIQUE
      ur1 : SELF\representation.name;
    WHERE
      wr1: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_1') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PARAMETER_ASSIGNMENT_REPRESENTATION') IN TYPEOF(rr.rep_2)) )) 
               >= 1);
      wr2: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ANALYTICAL_MODEL') IN TYPEOF(rr.rep_1)) )) = 1);
  END_ENTITY; -- analytical_representation

  ENTITY angular_dimension_with_orientation
    SUBTYPE OF (dimensional_location);
    WHERE
      wr1: (SELF\shape_aspect_relationship.description = 'angular');
  END_ENTITY; -- angular_dimension_with_orientation

  ENTITY angular_location
    SUBTYPE OF (dimensional_location);
      angle_selection : angle_relator;
  END_ENTITY; -- angular_location

  ENTITY angular_size
    SUBTYPE OF (dimensional_size);
      angle_selection : angle_relator;
  END_ENTITY; -- angular_size

  ENTITY angularity_tolerance
    SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
    WHERE
      wr1: (SELF\geometric_tolerance.name = 'angularity');
  END_ENTITY; -- angularity_tolerance

  ENTITY annotation_curve_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' 
               IN TYPEOF(SELF\styled_item.item));
  END_ENTITY; -- annotation_curve_occurrence

  ENTITY annotation_fill_area
    SUBTYPE OF (geometric_representation_item);
      boundaries : SET [1:?] OF curve;
  END_ENTITY; -- annotation_fill_area

  ENTITY annotation_fill_area_occurrence
    SUBTYPE OF (annotation_occurrence);
      fill_style_target : point;
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_FILL_AREA' 
               IN TYPEOF(SELF.item));
  END_ENTITY; -- annotation_fill_area_occurrence

  ENTITY annotation_occurrence
    SUPERTYPE OF (ONEOF (annotation_curve_occurrence,
        annotation_fill_area_occurrence,annotation_text_occurrence,
        annotation_symbol_occurrence))
    SUBTYPE OF (styled_item);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' 
               IN TYPEOF(SELF));
  END_ENTITY; -- annotation_occurrence

  ENTITY annotation_symbol
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_REPRESENTATION_MAP' 
               IN TYPEOF(SELF\mapped_item.mapping_source));
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_TARGET' 
               IN TYPEOF(SELF\mapped_item.mapping_target));
      wr3: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' 
               IN TYPEOF(SELF));
  END_ENTITY; -- annotation_symbol

  ENTITY annotation_symbol_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_SYMBOL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_SYMBOL'] 
               * TYPEOF(SELF\styled_item.item)) > 0);
  END_ENTITY; -- annotation_symbol_occurrence

  ENTITY annotation_text
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' 
               IN TYPEOF(SELF\mapped_item.mapping_target));
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_STRING_REPRESENTATION' 
               IN TYPEOF(SELF\mapped_item.mapping_source.
               mapped_representation));
      wr3: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' 
               IN TYPEOF(SELF));
  END_ENTITY; -- annotation_text

  ENTITY annotation_text_character
    SUBTYPE OF (mapped_item);
      alignment : text_alignment;
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTER_GLYPH_SYMBOL' 
               IN TYPEOF(SELF\mapped_item.mapping_source.
               mapped_representation));
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' 
               IN TYPEOF(SELF\mapped_item.mapping_target));
      wr3: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' 
               IN TYPEOF(SELF));
  END_ENTITY; -- annotation_text_character

  ENTITY annotation_text_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT'] 
               * TYPEOF(SELF\styled_item.item)) > 0);
  END_ENTITY; -- annotation_text_occurrence

  ENTITY apex
    SUBTYPE OF (derived_shape_aspect);
  END_ENTITY; -- apex

  ENTITY application_context;
      application : text;
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context,
        product_concept_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY applied_action_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_assigned_item;
  END_ENTITY; -- applied_action_assignment

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_assigned_item;
  END_ENTITY; -- applied_approval_assignment

  ENTITY applied_certification_assignment
    SUBTYPE OF (certification_assignment);
      items : SET [1:?] OF certification_assigned_item;
  END_ENTITY; -- applied_certification_assignment

  ENTITY applied_classification_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF classification_assigned_item;
  END_ENTITY; -- applied_classification_assignment

  ENTITY applied_contract_assignment
    SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contract_assigned_item;
  END_ENTITY; -- applied_contract_assignment

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_assigned_item;
    WHERE
      wr1: applied_date_time_correlation(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
      wr2: ((NOT (SELF.role.name = 'participant date and time')) OR (
               SIZEOF(QUERY ( ra <* QUERY ( it <* SELF.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_ACTION') IN TYPEOF(it)) ) | (NOT (SIZEOF(USEDIN(ra,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')) = 1)) )) 
               = 0));
  END_ENTITY; -- applied_date_and_time_assignment

  ENTITY applied_date_assignment
    SUBTYPE OF (date_assignment);
      items : SET [1:?] OF date_assigned_item;
    WHERE
      wr1: applied_date_correlation(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
  END_ENTITY; -- applied_date_assignment

  ENTITY applied_document_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_assigned_item;
  END_ENTITY; -- applied_document_reference

  ENTITY applied_group_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF group_assigned_item;
  END_ENTITY; -- applied_group_assignment

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_assigned_item;
  END_ENTITY; -- applied_organization_assignment

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_assigned_item;
  END_ENTITY; -- applied_person_and_organization_assignment

  ENTITY applied_person_assignment
    SUBTYPE OF (person_assignment);
      items : SET [1:?] OF person_assigned_item;
  END_ENTITY; -- applied_person_assignment

  ENTITY applied_security_classification_assignment
    SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF security_classification_assigned_item;
  END_ENTITY; -- applied_security_classification_assignment

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_relationship;
      name              : label;
      description       : text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY; -- approval_relationship

  ENTITY approval_role;
      role : label;
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AREA_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- area_measure_with_unit

  ENTITY area_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- area_unit

  ENTITY array_placement_group_component_definition
    SUBTYPE OF (assembly_group_component_definition);
  END_ENTITY; -- array_placement_group_component_definition

  ENTITY array_placement_group_component_shape_aspect
    SUBTYPE OF (assembly_group_component_shape_aspect);
  END_ENTITY; -- array_placement_group_component_shape_aspect

  ENTITY assembly_bond_definition
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      wr2: (SIZEOF(QUERY ( aga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT.ITEMS') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BOND_CATEGORY') IN TYPEOF(aga.assigned_group)) )) = 1);
      wr3: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'bonded feature 1') )) = 1);
      wr4: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'bonded feature 2') )) = 1);
  END_ENTITY; -- assembly_bond_definition

  ENTITY assembly_component_usage
    SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
        specified_higher_usage_occurrence,promissory_usage_occurrence))
    SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY; -- assembly_component_usage

  ENTITY assembly_component_usage_substitute;
      name       : label;
      definition : text;
      base       : assembly_component_usage;
      substitute : assembly_component_usage;
    UNIQUE
      ur1 : base, substitute;
    WHERE
      wr1: (base.relating_product_definition :=: substitute.
               relating_product_definition);
      wr2: (base :<>: substitute);
  END_ENTITY; -- assembly_component_usage_substitute

  ENTITY assembly_definition
    SUBTYPE OF (physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'assembly module') )) >= 1);
--tt polarity of pdr changed.
      wr2: ((NOT (SELF.frame_of_reference.name = 'physical design')) OR (
               SIZEOF(QUERY ( du <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 'design usage') )
                | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_DEFINITION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
--tt corrected type problem
               'LIBRARY_DEFINED_ASSEMBLY_DEFINITION'] * TYPEOF(du.relating_product_definition)) = 1) 
--tt changed polarity of pdr
               AND (du.relating_product_definition.frame_of_reference.name =
                'physical design usage') AND (SIZEOF(QUERY ( prpc <* 
--tt changed polarity of pdr
               USEDIN(du.relating_product_definition.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
               product_category.name = 'assembly module') )) >= 1)) )) = 1));
      wr3: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.
               description = 'pca terminal')) )) >= 2)) )) = 0));
  END_ENTITY; -- assembly_definition

  ENTITY assembly_group_component_definition
    SUBTYPE OF (component_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( gc <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'group component') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_DEFINITION') IN TYPEOF(gc.
               related_product_definition)) )) >= 1);
  END_ENTITY; -- assembly_group_component_definition

  ENTITY assembly_group_component_shape_aspect
    SUBTYPE OF (component_shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( gc <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'group component') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(gc.related_shape_aspect)) )) 
               >= 1);
  END_ENTITY; -- assembly_group_component_shape_aspect

  ENTITY assembly_joint
    SUBTYPE OF (shape_aspect_relationship, shape_aspect);
    WHERE
      wr1: (((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(SELF.relating_shape_aspect)) 
               AND (SELF.relating_shape_aspect\shape_aspect.description IN [
               'assembly module component terminal',
               'bare die component terminal',
               'interconnect component join terminal',
               'interconnect module component terminal',
               'package terminal occurrence',
               'packaged component join terminal'])) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_INTERFACE_TERMINAL') IN TYPEOF(SELF.
               relating_shape_aspect)));
      wr2: (((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(SELF.related_shape_aspect)) 
               AND (SELF.related_shape_aspect\shape_aspect.description IN [
               'assembly module component terminal',
               'bare die component terminal',
               'interconnect component join terminal',
               'interconnect module component terminal',
               'package terminal occurrence',
               'packaged component join terminal'])) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_INTERFACE_TERMINAL') IN TYPEOF(SELF.
               related_shape_aspect)));
      wr3: ((NOT (SELF\shape_aspect_relationship.name = 
               'assembled with bonding')) OR (SIZEOF(QUERY ( pdr <* USEDIN(
               SELF.of_shape.definition,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(pdr)) )) >= 1));
      wr4: ((NOT (SELF\shape_aspect_relationship.name = 
               'assembled with bonding')) OR (SIZEOF(QUERY ( ddu <* 
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'default definition usage') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_BOND_DEFINITION') IN TYPEOF(ddu.
               relating_shape_aspect)) )) = 1));
      wr5: ((NOT (SELF\shape_aspect_relationship.name = 
               'assembled with bonding')) OR (SIZEOF(QUERY ( pd <* USEDIN(
               SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
               used_representation\representation.name = 'bond assembly position') AND (
               SIZEOF(QUERY ( it <* pdr.used_representation.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MAPPED_ITEM') IN TYPEOF(it)) AND (it\representation_item.name = 
               'assembly position')) )) = 1)) )) = 1) )) <= 1));
      wr6: ((NOT (SELF\shape_aspect_relationship.name = 
               'assembled with fasteners')) OR (SIZEOF(QUERY ( pdr <* 
               USEDIN(SELF.of_shape.definition,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(pdr)) )) >= 1));
  END_ENTITY; -- assembly_joint

  ENTITY assembly_module_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition\
               product_definition.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'assembly module') )) >= 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )) 
               >= 1)) )) = 0);
      wr3: (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'member connected terminal') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_CONNECTED_TERMINALS_DEFINITION') IN TYPEOF(mct.
               relating_shape_aspect)) )) <= 1);
      wr4: ((NOT (SELF\shape_aspect.description = 'pca terminal')) OR ((
               SIZEOF(TYPEOF(SELF.of_shape.definition) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_DEFINITION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_ASSEMBLY_DEFINITION']) >= 1) AND (SELF.
               of_shape.definition\product_definition.frame_of_reference.
               name = 'physical design usage')));
      wr5: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar.
               related_shape_aspect\shape_aspect.description = 'connection zone') )) = 1);
      wr6: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar.
               related_shape_aspect\shape_aspect.description = 'interface terminal') )) 
               <= 1);
  END_ENTITY; -- assembly_module_terminal

  ENTITY assembly_module_usage_view_connector_relationship
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'AXIS2_PLACEMENT_3D') IN TYPEOF(SELF\mapped_item.
               mapping_target));
      wr2: (SELF\mapped_item.mapping_source.mapped_representation.name = 
               '3d bound volume shape');
      wr3: (SIZEOF(QUERY ( pdr <* USEDIN(SELF\mapped_item.mapping_source.
               mapped_representation,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
               (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_CONNECTOR',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_CONNECTOR',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_CONNECTOR'] * TYPEOF(pdr.
               definition.definition)) = 1) )) = 1);
      wr4: (SIZEOF(QUERY ( r <* USEDIN(SELF\representation_item,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (SIZEOF(QUERY ( pdr <* USEDIN(r,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
               ((pdr.definition.definition.frame_of_reference\
               application_context_element.name = 'physical design usage') 
               AND (SIZEOF(QUERY ( pc <* USEDIN(pdr.definition.definition.
               of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (pc\
               product_category.name = 'assembly module') )) = 1)) )) = 1) )) 
               = 1);
      wr5: (SIZEOF(QUERY ( sr <* USEDIN(SELF\representation_item,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (sr\representation.
               context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3) )) = SIZEOF(QUERY ( sr <* 
               USEDIN(SELF\representation_item,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (sr <> []) )));
  END_ENTITY; -- assembly_module_usage_view_connector_relationship

  ENTITY auxiliary_characteristic_dimension_representation
    SUBTYPE OF (dimensional_characteristic_representation);
  END_ENTITY; -- auxiliary_characteristic_dimension_representation

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY; -- axis2_placement_3d

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.UNIFORM_CURVE' 
               IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.QUASI_UNIFORM_CURVE' 
               IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BEZIER_CURVE' 
               IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' 
               IN TYPEOF(SELF)));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: (SIZEOF(knot_multiplicities) = upper_index_on_knots);
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR 
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.UNIFORM_SURFACE' 
               IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.QUASI_UNIFORM_SURFACE' 
               IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BEZIER_SURFACE' 
               IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' 
               IN TYPEOF(SELF)));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr4: (SIZEOF(v_multiplicities) = knot_v_upper);
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY bare_die
    SUBTYPE OF (physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( ifdu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 
               'implemented function') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(ifdu.
               relating_product_definition)) AND (ifdu.
               relating_product_definition.frame_of_reference.name = 
               'functional design usage')) )) = 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( dut <* 
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'device unit technology') ) | (dut.
               relating_property_definition\property_definition.name = 'unit technology') )) = 
               1) )) = 1);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BARE_DIE_TERMINAL') IN TYPEOF(sa)) )) >= 2)) )) = 0);
  END_ENTITY; -- bare_die

  ENTITY bare_die_terminal
    SUBTYPE OF (minimally_defined_bare_die_terminal);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BARE_DIE') IN TYPEOF(SELF.of_shape.definition));
      wr2: (SIZEOF(QUERY ( eca <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'external connection area') ) | (eca.
               related_shape_aspect\shape_aspect.description = 'connection zone') )) = 1);
      wr3: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
  END_ENTITY; -- bare_die_terminal

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY block
    SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
  END_ENTITY; -- block

  ENTITY bond_category
    SUBTYPE OF (group, externally_defined_item);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1);
  END_ENTITY; -- bond_category

  ENTITY boolean_result
    SUBTYPE OF (geometric_representation_item);
      operator       : boolean_operator;
      first_operand  : boolean_operand;
      second_operand : boolean_operand;
  END_ENTITY; -- boolean_result

  ENTITY boundary_curve
    SUBTYPE OF (composite_curve_on_surface);
    WHERE
      wr1: SELF\composite_curve.closed_curve;
  END_ENTITY; -- boundary_curve

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,trimmed_curve,
        bounded_pcurve,bounded_surface_curve,composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_pcurve
    SUBTYPE OF (pcurve, bounded_curve);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' 
               IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
  END_ENTITY; -- bounded_pcurve

  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (b_spline_surface,rectangular_trimmed_surface,
        curve_bounded_surface,rectangular_composite_surface))
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY bounded_surface_curve
    SUBTYPE OF (surface_curve, bounded_curve);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' 
               IN TYPEOF(SELF\surface_curve.curve_3d));
  END_ENTITY; -- bounded_surface_curve

  ENTITY box_domain;
      corner  : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      zlength : positive_length_measure;
    WHERE
      wr1: (SIZEOF(QUERY ( item <* USEDIN(SELF,'') | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOXED_HALF_SPACE' 
               IN TYPEOF(item))) )) = 0);
  END_ENTITY; -- box_domain

  ENTITY boxed_half_space
    SUBTYPE OF (half_space_solid);
      enclosure : box_domain;
  END_ENTITY; -- boxed_half_space

  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY; -- brep_with_voids

  ENTITY bus_structural_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( bce <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'bus composition element') ) | ((((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'NETWORK_NODE_DEFINITION') IN TYPEOF(bce.
               related_product_definition)) AND (bce.
               related_product_definition.frame_of_reference.name = 
               'functional network design')) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(bce.
               related_product_definition))) )) >= 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment') )) 
               <= 1) )) <= 1);
  END_ENTITY; -- bus_structural_definition

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
        cartesian_transformation_operator_3d))
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_2d
    SUBTYPE OF (cartesian_transformation_operator);
    DERIVE
      u : LIST [2:2] OF direction := base_axis(2,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,?);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- cartesian_transformation_operator_2d

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY centre_of_symmetry
    SUBTYPE OF (derived_shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( sadr <* deriving_relationships | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMMETRIC_SHAPE_ASPECT' 
               IN TYPEOF(sadr.related_shape_aspect))) )) = 0);
  END_ENTITY; -- centre_of_symmetry

  ENTITY certification;
      name    : label;
      purpose : text;
      kind    : certification_type;
  END_ENTITY; -- certification

  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
      assigned_certification : certification;
  END_ENTITY; -- certification_assignment

  ENTITY certification_type;
      description : label;
  END_ENTITY; -- certification_type

  ENTITY change
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DIRECTED_ACTION') IN TYPEOF(SELF.assigned_action));
      wr2: unique_version_change_order(SELF.assigned_action,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
  END_ENTITY; -- change

  ENTITY change_from_design_object_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( aa <* USEDIN(SELF\action_assignment.
               assigned_action,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CHANGE_TO_DESIGN_OBJECT_ASSIGNMENT') IN TYPEOF(aa)) )) >= 1);
  END_ENTITY; -- change_from_design_object_assignment

  ENTITY change_from_design_object_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( aa <* USEDIN(SELF\action_request_assignment.
               assigned_action_request,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CHANGE_TO_DESIGN_OBJECT_REQUEST_ASSIGNMENT') IN TYPEOF(aa)) )) 
               >= 1);
  END_ENTITY; -- change_from_design_object_request_assignment

  ENTITY change_request
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF change_request_item;
  END_ENTITY; -- change_request

  ENTITY change_to_design_object_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( aa <* USEDIN(SELF\action_assignment.
               assigned_action,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CHANGE_FROM_DESIGN_OBJECT_ASSIGNMENT') IN TYPEOF(aa)) )) >=
                1);
      wr2: (SIZEOF(QUERY ( pdr <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.
               name = 'design object change')) )) = 1);
  END_ENTITY; -- change_to_design_object_assignment

  ENTITY change_to_design_object_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( aa <* USEDIN(SELF\action_request_assignment.
               assigned_action_request,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CHANGE_FROM_DESIGN_OBJECT_REQUEST_ASSIGNMENT') IN TYPEOF(aa)) )) 
               >= 1);
      wr2: (SIZEOF(QUERY ( pdr <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.
               name = 'design object change')) )) = 1);
  END_ENTITY; -- change_to_design_object_request_assignment

  ENTITY character_glyph_font_usage;
      character : character_glyph_symbol;
      font      : text_font;
  END_ENTITY; -- character_glyph_font_usage

  ENTITY character_glyph_style_outline;
      outline_style : curve_style;
  END_ENTITY; -- character_glyph_style_outline

  ENTITY character_glyph_style_stroke;
      stroke_style : curve_style;
  END_ENTITY; -- character_glyph_style_stroke

  ENTITY character_glyph_symbol
    SUBTYPE OF (symbol_representation);
      character_box  : planar_extent;
      baseline_ratio : ratio_measure;
    DERIVE
      box_height : length_measure := character_box.size_in_y;
    WHERE
      wr1: ((0 <= baseline_ratio) AND (baseline_ratio <= 1));
      wr2: item_in_context(SELF.character_box,SELF\representation.
               context_of_items);
      wr3: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_LENGTH_MEASURE' 
               IN TYPEOF(SELF.box_height));
  END_ENTITY; -- character_glyph_symbol

  ENTITY character_glyph_symbol_outline
    SUBTYPE OF (character_glyph_symbol);
      outlines : SET [1:?] OF annotation_fill_area;
    WHERE
      wr1: (SELF.outlines <= SELF\representation.items);
  END_ENTITY; -- character_glyph_symbol_outline

  ENTITY characterized_object;
      name        : label;
      description : text;
  END_ENTITY; -- characterized_object

  ENTITY characterized_product_category
    SUBTYPE OF (characterized_object, product_category);
    UNIQUE
      ur1 : SELF\product_category.name;
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.description = 
               'product category values') AND (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PARAMETER_ASSIGNMENT_REPRESENTATION') IN TYPEOF(pdr.
               used_representation)) )) >= 1)) )) = 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.description = 
               'product category parameters') AND (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( ri <* pdr.used_representation.items | (NOT (SIZEOF(
               TYPEOF(ri) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODEL_PARAMETER']) = 1)) )) = 0) )) >= 1)) )) = 1);
      wr3: (SELF\characterized_object.name = SELF\product_category.name);
  END_ENTITY; -- characterized_product_category

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY circular_runout_tolerance
    SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
    WHERE
      wr1: (SELF\geometric_tolerance.name = 'circular runout');
      wr2: (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF)));
      wr3: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | ((pdr\property_definition_relationship.name = 'referenced datum system definition') AND (
               pdr.related_property_definition\property_definition.description = 
               'datum system property without material conditions')) )) = 1);
  END_ENTITY; -- circular_runout_tolerance

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY colour;
  END_ENTITY; -- colour

  ENTITY colour_rgb
    SUBTYPE OF (colour_specification);
      red   : REAL;
      green : REAL;
      blue  : REAL;
    WHERE
      wr1: ((0 <= red) AND (red <= 1));
      wr2: ((0 <= green) AND (green <= 1));
      wr3: ((0 <= blue) AND (blue <= 1));
  END_ENTITY; -- colour_rgb

  ENTITY colour_specification
    SUBTYPE OF (colour);
      name : label;
  END_ENTITY; -- colour_specification

  ENTITY component_definition
    SUPERTYPE OF (ONEOF (printed_component,packaged_component) ANDOR 
        thermal_component)
    SUBTYPE OF (product_definition);
    WHERE
      wr1 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )
                 | (sr_pdr.used_representation\representation.name = 
                'planar projected shape') )) <= 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )
                 | (sr_pdr.used_representation\representation.name = 
                '3d bound volume shape') )) <= 1)) )) = 0);
      wr3 : ((NOT (SELF\product_definition.description = 
                'bare die component')) OR (SIZEOF(QUERY ( ip <* 
                QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | (pdr\product_definition_relationship.name = 'instantiated part') ) | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'BARE_DIE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EXTERNALLY_DEFINED_BARE_DIE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LIBRARY_DEFINED_BARE_DIE'] * TYPEOF(ip.
                relating_product_definition)) = 1) AND (ip.
                relating_product_definition.frame_of_reference.name = 
                'physical design usage')) )) = 1));
      wr4 : ((NOT ((SELF.frame_of_reference.name = 'physical occurrence') 
                AND (SIZEOF(QUERY ( pc1 <* USEDIN(SELF.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (pc1\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( ip <* QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | (pdr\product_definition_relationship.name = 'instantiated part') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PHYSICAL_UNIT') IN TYPEOF(ip.relating_product_definition)) 
                AND (ip.relating_product_definition.frame_of_reference.name 
                = 'physical design usage') AND (SIZEOF(QUERY ( pc2 <* 
                USEDIN(ip.relating_product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (pc2\
                product_category.name = 'assembly module') )) >= 1)) )) = 1));
      wr5 : ((NOT ((SELF.frame_of_reference.name = 'physical occurrence') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.description = 
                'assembly module component terminal')) )) >= 2) )) >= 1));
      wr6 : ((NOT ((SELF.frame_of_reference.name = 'physical occurrence') 
                AND (SIZEOF(QUERY ( pc1 <* USEDIN(SELF.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (pc1\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( ip <* QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | (pdr\product_definition_relationship.name = 'instantiated part') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PHYSICAL_UNIT') IN TYPEOF(ip.relating_product_definition)) 
                AND (ip.relating_product_definition.frame_of_reference.name 
                = 'physical design usage') AND (SIZEOF(QUERY ( pc2 <* 
                USEDIN(ip.relating_product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (pc2\
                product_category.name = 'interconnect module') )) >= 1)) )) 
                = 1));
      wr7 : ((NOT ((SELF.frame_of_reference.name = 'physical occurrence') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.description = 
                'interconnect module component terminal')) )) >= 2) )) >= 1));
      wr8 : ((NOT (SELF\product_definition.description = 
                'mating connector')) OR (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS') IN TYPEOF(
                SELF)) AND (SIZEOF(QUERY ( doc <* SELF\
                product_definition_with_associated_documents.
                documentation_ids | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EE_SPECIFICATION') IN TYPEOF(doc)) )) = 1)) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pt_occ <* QUERY ( sa <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | (sa\shape_aspect.description = 
                'part template occurrence') ) | (SIZEOF(QUERY ( it <* 
                QUERY ( sar <* USEDIN(pt_occ,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
                description = 'printed connector template')) )) = 1) )) = 1)) )) 
                = 0) OR (SIZEOF(QUERY ( ip <* QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | (pdr\product_definition_relationship.name = 'instantiated part') ) | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGED_PART',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EXTERNALLY_DEFINED_PACKAGED_PART',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(ip.
                relating_product_definition)) = 1) AND (ip.
                relating_product_definition\product_definition.description = 
                'packaged connector')) )) = 1));
      wr9 : ((NOT (SELF\product_definition.description = 
                'mating connector')) OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 'mating connector placement') )) 
                = 1) )) = 1));
      wr10: ((NOT (SELF\product_definition.description = 
                'mating connector')) OR ((SIZEOF(QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                 | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) = 0) 
                AND (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) = 0)));
      wr11: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | ((pdr\product_definition_relationship.name = 'instantiated part') AND (NOT (SELF.
                formation :=: pdr.relating_product_definition.formation))) )) 
                = 0);
      wr12: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )
                 | ((sr_pdr.used_representation\representation.name = 
                'part template non planar 2d shape') OR (sr_pdr.
                used_representation\representation.name = 'non planar 2d shape') OR (
                sr_pdr.used_representation\representation.name = 
                'open shell based surface')) )) <= 1)) )) = 0);
  END_ENTITY; -- component_definition

  ENTITY component_functional_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_FUNCTIONAL_UNIT') IN TYPEOF(SELF.of_shape.
               definition));
      wr2: (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'instantiated terminal') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') IN TYPEOF(it.
               relating_shape_aspect)) )) = 1);
      wr3: (SIZEOF(QUERY ( futba <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'functional unit terminal bus assignment') )
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(futba.
               relating_property_definition.definition)) )) <= 1);
      wr4: (SIZEOF(QUERY ( futna <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'functional unit terminal node assignment') )
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'NETWORK_NODE_DEFINITION') IN TYPEOF(futna.
               relating_property_definition.definition)) )) <= 1);
  END_ENTITY; -- component_functional_terminal

  ENTITY component_functional_unit
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SELF.frame_of_reference.name = 'functional occurrence');
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_FUNCTIONAL_TERMINAL') IN TYPEOF(sa)) )) >= 1) )) 
               >= 1);
      wr3: (SIZEOF(QUERY ( ifu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'instantiated functional unit') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(ifu.relating_product_definition)) )) 
               = 1);
      wr4: (SIZEOF(QUERY ( nc <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'network composition') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(nc.relating_product_definition)) 
               AND (nc.relating_product_definition.frame_of_reference.name 
               = 'functional network design')) )) = 1);
  END_ENTITY; -- component_functional_unit

  ENTITY component_interface_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1 : (SELF\shape_aspect.description IN [
                'interconnect component interface terminal',
                'packaged connector component interface terminal']);
      wr2 : (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition));
      wr3 : (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') )) <= 1);
      wr4 : (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'design usage') )) <= 1);
      wr5 : ((NOT (SELF\shape_aspect.description = 
                'packaged connector component interface terminal')) OR ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTERFACE_COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.
                definition)));
      wr6 : ((NOT (SELF\shape_aspect.description = 
                'packaged connector component interface terminal')) OR (
                SELF.of_shape.definition\product_definition.
                frame_of_reference.name = 'physical occurrence'));
      wr7 : ((NOT (SELF\shape_aspect.description = 
                'interconnect component interface terminal')) OR ((SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar.
                related_shape_aspect\shape_aspect.description = 'connection zone') )) = 
                1) AND (NOT (SELF.of_shape.definition\product_definition.
                description IN ['assembly module component',
                'bare die component','interconnect module component',
                'laminate component','packaged component']))));
      wr8 : ((NOT (SELF\shape_aspect.description = 
                'packaged connector component interface terminal')) OR SELF
                .product_definitional);
      wr9 : ((NOT (SELF\shape_aspect.description = 
                'packaged connector component interface terminal')) OR (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGED_COMPONENT') IN TYPEOF(SELF.of_shape.definition)) 
                AND (SELF.of_shape.definition\product_definition.
                description = 'packaged connector component') AND (SELF.
                of_shape.definition\product_definition.frame_of_reference.
                name = 'physical occurrence')));
      wr10: ((NOT (SELF\shape_aspect.description = 
                'packaged connector component interface terminal')) OR (
                SIZEOF(QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGED_PART_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.
                description = 'interface terminal')) )) = 1));
  END_ENTITY; -- component_interface_terminal

  ENTITY component_location
    SUBTYPE OF (representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'placement fixed') AND ((it\
               descriptive_representation_item.description = 'true') OR (it
               \descriptive_representation_item.description = 'false'))) )) 
               = 1);
      wr2: (SIZEOF(QUERY ( ms <* QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'mounting style')) ) | (NOT (ms\
               descriptive_representation_item.description IN ['normal',
               'reversed'])) )) = 0);
      wr3: ((NOT (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 2)) OR (SIZEOF(QUERY ( it <* 
               SELF.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CARTESIAN_TRANSFORMATION_OPERATOR_2D') IN TYPEOF(it)) )) = 
               1));
      wr4: ((NOT (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3)) OR (SIZEOF(QUERY ( it <* 
               SELF.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'AXIS2_PLACEMENT_3D') IN TYPEOF(it)) )) = 1));
  END_ENTITY; -- component_location

  ENTITY component_shape_aspect
    SUPERTYPE OF (ONEOF (land,inter_stratum_feature) ANDOR 
        thermal_component_shape_aspect)
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1 : (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition));
      wr2 : ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROBE_ACCESS_AREA',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND'] * TYPEOF(SELF)) = 1) OR (SELF\shape_aspect.
                description IN ['component feature',
                'component termination passage interface terminal',
                'land interface terminal',
                'non functional land interface terminal',
                'printed connector component interface terminal',
                'laminate component','laminate text component',
                'laminate text string component','conductive interconnect element with pre defined transitions','conductive interconnect element with user defined single transition',
                'routed interconnect component',
                'special symbol laminate component',
                'primary stratum indicator symbol',
                'stratum feature template component',
                'interconnect module component surface feature']));
      wr3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )
                 | (sr_pdr.used_representation\representation.name = 
                'planar projected shape') )) <= 1)) )) = 0);
      wr4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )
                 | (sr_pdr.used_representation\representation.name = 
                '3d bound volume shape') )) <= 1)) )) = 0);
      wr5 : ((NOT (SELF\shape_aspect.description IN ['component feature',
                'component termination passage interface terminal',
                'land interface terminal',
                'non functional land interface terminal',
                'printed connector component interface terminal'])) OR (
                SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'design usage') )) <= 1));
      wr6 : ((NOT (SELF\shape_aspect.description IN [
                'laminate text component','laminate text string component',
                'special symbol laminate component',
                'primary stratum indicator symbol',
                'stratum feature template component'])) OR (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition)) 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition
                \product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1)));
      wr7 : (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') )) <= 1);
      wr8 : ((NOT (SELF\shape_aspect.description = 
                'component termination passage interface terminal')) OR (
                SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PLATED_PASSAGE') IN TYPEOF(ac.relating_shape_aspect)) AND 
                (ac.relating_shape_aspect\shape_aspect.description = 
                'component termination passage')) )) = 1));
      wr9 : ((NOT (SELF\shape_aspect.description = 
                'component termination passage interface terminal')) OR (
                SIZEOF(QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (i_f.
                relating_shape_aspect\shape_aspect.description = 'component termination passage template interface terminal') )) 
                = 1));
      wr10: ((NOT (SELF\shape_aspect.description = 
                'laminate text component')) OR (SIZEOF(QUERY ( it <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_TEXT_TEMPLATE_DEFINITION') IN TYPEOF(it.
                relating_shape_aspect)) )) = 1));
      wr11: ((NOT (SELF\shape_aspect.description IN [
                'stratum feature template component'])) OR (SIZEOF(
                QUERY ( sfi <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'stratum feature implementation') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STRATUM_FEATURE') IN TYPEOF(sfi.relating_shape_aspect)) )) 
                = 1));
      wr12: ((NOT (SELF\shape_aspect.description IN [
                'land interface terminal',
                'non functional land interface terminal'])) OR (SIZEOF(
                QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_TEMPLATE_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) AND 
--tt commented out and replaced with TRUE.
--(i_f.related_shape_aspect\shape_aspect.description = 'interface terminal')
                (TRUE)) )) = 1));
      wr13: ((NOT (SELF\shape_aspect.description = 
                'land interface terminal')) OR (SIZEOF(QUERY ( ac <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND') IN TYPEOF(ac.relating_shape_aspect)) AND 
--tt commented out and replaced with TRUE.
(*
(ac.related_shape_aspect\shape_aspect.description IN ['functional land',
                'via dependent land','via and contact size dependent land',
                'component termination passage dependent land',
                'contact size dependent land','component termination passage and contact size dependent land'])
*)
                 (TRUE)) )) 
                = 1));
      wr14: ((NOT (SELF\shape_aspect.description = 
                'non functional land interface terminal')) OR (SIZEOF(
                QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND') IN TYPEOF(ac.relating_shape_aspect)) AND 
                (TRUE)
--tt removed redundant and incorrect segment
(*
(ac.related_shape_aspect\shape_aspect.description IN ['non functional land',
                'via dependent non functional land',
                'via and contact size dependent non functional land','component termination passage dependent non functional land',
                'contact size dependent non functional land',
                'component termination passage and contact size ' + 
                'dependent non functional land',
                'unsupported passage dependent non functional land'])
*)
                 ) )) =
                 1));
      wr15: ((NOT (SELF\shape_aspect.description IN ['conductive interconnect element with pre defined transitions',
                'conductive interconnect element with ' + 
                'user defined single transition'])) OR (SIZEOF(
                QUERY ( cc <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'composed conductor') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STRATUM_FEATURE') IN TYPEOF(cc.related_shape_aspect)) )) =
                 1));
      wr16: ((NOT (SELF\shape_aspect.description IN ['conductive interconnect element with pre defined transitions',
                'conductive interconnect element with user ' + 
                'defined single transition'])) OR (SIZEOF(QUERY ( ac <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_TERMINAL') IN TYPEOF(ac.related_shape_aspect)) 
                AND (ac.related_shape_aspect\shape_aspect.description = 
                'conductive interconnect element terminal')) )) = 2));
      wr17: ((NOT (SELF\shape_aspect.description = 
                'printed connector component interface terminal')) OR SELF.
                product_definitional);
      wr18: ((NOT (SELF\shape_aspect.description = 
                'printed connector component interface terminal')) OR (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRINTED_COMPONENT') IN TYPEOF(SELF.of_shape.definition)) 
                AND (SELF.of_shape.definition\product_definition.
                description = 'printed connector component')));
      wr19: ((NOT (SELF\shape_aspect.description = 
                'printed connector component interface terminal')) OR (
                SIZEOF(QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.
                description = 'interface terminal')) )) = 1));
      wr20: ((NOT (SELF\shape_aspect.description = 
                'routed interconnect component')) OR (SIZEOF(QUERY ( pd <* 
                USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) >= 1) )) 
                = 1));
      wr21: ((NOT (SELF\shape_aspect.description IN [
                'special symbol laminate component',
                'primary stratum indicator symbol'])) OR (SIZEOF(
                QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.
                description = 'special symbol part template')) )) = 1));
      wr22: ((NOT (SELF\shape_aspect.description = 
                'stratum feature template component')) OR (SIZEOF(
                QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | ((((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
                description = 'stratum feature template')) OR ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(it.
                relating_shape_aspect))) )) = 1));
      wr23: ((NOT (SELF\shape_aspect.description IN [
                'laminate text component'])) OR (SIZEOF(QUERY ( sfi <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'stratum feature implementation') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STRATUM_FEATURE') IN TYPEOF(sfi.relating_shape_aspect)) )) 
                >= 1));
      wr24: ((NOT (SELF\shape_aspect.description = 
                'interconnect module component surface feature')) OR (
                SIZEOF(QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (i_f.
                relating_shape_aspect\shape_aspect.description IN [
                'interconnect module secondary surface',
                'interconnect module primary surface',
                'interconnect module edge surface',
                'interconnect module edge segment surface']) )) = 1));
  END_ENTITY; -- component_shape_aspect

  ENTITY component_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1 : (SELF\shape_aspect.description IN [
                'assembly module component terminal',
                'bare die component terminal',
                'component termination passage join terminal',
                'conductive interconnect element terminal',
                'interconnect component join terminal',
                'interconnect module component terminal',
                'land join terminal','minimally defined component terminal',
                'non functional land join terminal',
                'packaged component join terminal',
                'printed component join terminal',
                'package terminal occurrence','via terminal']);
      wr2 : (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition));
      wr3 : (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') )) <= 1);
      wr4 : (SIZEOF(QUERY ( at <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated terminals') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(at.
                relating_shape_aspect)) )) <= 1);
      wr5 : (SIZEOF(QUERY ( cr <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'connectivity requirement') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PHYSICAL_NETWORK') IN TYPEOF(cr.relating_shape_aspect)) )) 
                <= 1);
      wr6 : (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'design usage') )) <= 1);
      wr7 : ((NOT (SELF\shape_aspect.description IN [
                'assembly module component terminal',
                'bare die component terminal','package terminal occurrence',
                'packaged component join terminal',
                'printed component join terminal'])) OR SELF.
                product_definitional);
      wr8 : ((NOT (SELF\shape_aspect.description = 
                'assembly module component terminal')) OR ((SELF.of_shape.
                definition.frame_of_reference.name = 'physical occurrence') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition
                \product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1)));
      wr9 : ((NOT (SELF\shape_aspect.description = 
                'assembly module component terminal')) OR (SIZEOF(
                QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) )) = 1));
      wr10: ((NOT (SELF\shape_aspect.description = 
                'bare die component terminal')) OR (SELF.of_shape.
                definition\product_definition.description = 
                'bare die component'));
      wr11: ((NOT (SELF\shape_aspect.description = 
                'bare die component terminal')) OR (SIZEOF(QUERY ( i_f <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'BARE_DIE_TERMINAL') IN TYPEOF(i_f.relating_shape_aspect)) )) 
                = 1));
      wr12: ((NOT (SELF\shape_aspect.description = 
                'component termination passage join terminal')) OR (SIZEOF(
                QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PLATED_PASSAGE') IN TYPEOF(ac.relating_shape_aspect)) AND 
                (ac.relating_shape_aspect\shape_aspect.description = 
                'component termination passage')) )) = 1));
      wr13: ((NOT (SELF\shape_aspect.description = 
                'component termination passage join terminal')) OR (SIZEOF(
                QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (i_f.
                relating_shape_aspect\shape_aspect.description = 
                'component termination passage template join terminal') )) 
                = 1));
      wr14: ((NOT (SELF\shape_aspect.description = 
                'conductive interconnect element terminal')) OR (SIZEOF(
                QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_SHAPE_ASPECT') IN TYPEOF(ac.
                relating_shape_aspect)) AND ((ac.relating_shape_aspect\shape_aspect.
                description = 'conductive interconnect element with pre defined transitions') 
                OR (ac.relating_shape_aspect\shape_aspect.description = 'conductive interconnect element with user defined single transition'))) )) 
                = 1));
      wr15: ((NOT (SELF\shape_aspect.description IN [
                'conductive interconnect element terminal',
                'interconnect component join terminal',
                'printed component join terminal'])) OR (SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar.
--tt should be 'description' not name
                related_shape_aspect.description = 'connection zone') )) = 1));
      wr16: ((NOT (SELF\shape_aspect.description = 
                'interconnect module component terminal')) OR ((SELF.
                of_shape.definition\product_definition.frame_of_reference.
                name = 'physical occurrence') AND (SIZEOF(QUERY ( prpc <* 
                USEDIN(SELF.of_shape.definition\product_definition.
                formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1)));
      wr17: ((NOT (SELF\shape_aspect.description = 
                'interconnect module component terminal')) OR (SIZEOF(
                QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTERCONNECT_MODULE_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) AND (SIZEOF(QUERY ( pc <* USEDIN(
                i_f.relating_shape_aspect.of_shape.definition\
                product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (pc\
                product_category.name = 'interconnect module') )) > 0)) )) 
                = 1));
      wr18: ((NOT (SELF\shape_aspect.description IN ['land join terminal',
                'non functional land join terminal'])) OR (SIZEOF(
                QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_TEMPLATE_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) AND 
-- tt comment out next section, maintain structure with 'TRUE'
--(i_f.related_shape_aspect\shape_aspect.description = 'join terminal')
                (TRUE)) )) = 1));
      wr19: ((NOT (SELF\shape_aspect.description = 'land join terminal')) 
                OR (SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND') IN TYPEOF(ac.relating_shape_aspect)) AND 
--tt comment out next section, maintain structure with 'TRUE'
(*
(ac.related_shape_aspect\shape_aspect.description IN ['functional land',
                'via dependent land','via and contact size dependent land',
                'component termination passage dependent land',
                'contact size dependent land','component termination passage and contact size dependent land'])
*)
                 (TRUE)) )) 
                = 1));
      wr20: ((NOT (SELF\shape_aspect.description = 
                'minimally defined terminal')) OR (SIZEOF(QUERY ( pdr <* 
                USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'part terminal external reference') )) = 1));
      wr21: ((NOT (SELF\shape_aspect.description = 
                'non functional land join terminal')) OR (SIZEOF(
                QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND') IN TYPEOF(ac.relating_shape_aspect)) AND 
--tt corrected sar polarity
                (ac.relating_shape_aspect\shape_aspect.description IN ['non functional land',
                'via dependent non functional land',
                'via and contact size dependent non functional land','component termination passage dependent non functional land',
                'contact size dependent non functional land',
                'component termination passage and contact size ' + 
                'dependent non functional land',
                'unsupported passage dependent non functional land'])) )) =
                 1));
      wr22: ((NOT (SELF\shape_aspect.description = 
                'package terminal occurrence')) OR (SIZEOF(QUERY ( ud <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'usage definition') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGE_TERMINAL') IN TYPEOF(ud.relating_shape_aspect)) )) 
                = 1));
      wr23: ((NOT (SELF\shape_aspect.description IN [
                'package terminal occurrence',
                'packaged component join terminal'])) OR (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGED_COMPONENT') IN TYPEOF(SELF.of_shape.definition)) 
                AND (SELF.of_shape.definition\product_definition.
                frame_of_reference.name = 'physical occurrence')));
      wr24: ((NOT (SELF\shape_aspect.description = 
                'packaged component join terminal')) OR (SIZEOF(
                QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGED_PART_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.
                description = 'join terminal')) )) = 1));
      wr25: ((NOT (SELF\shape_aspect.description = 
                'packaged component join terminal')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) )) <= 2) )) 
                <= 1) )) <= 1));
      wr26: ((NOT (SELF\shape_aspect.description = 
                'packaged component join terminal')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( lmwu <* QUERY ( it <* pdr.used_representation.items
                 | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) ) | (lmwu.
                name = 'maximum wire length') )) <= 1) )) <= 1) )) <= 1));
      wr27: ((NOT (SELF\shape_aspect.description = 
                'packaged component join terminal')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( lmwu <* QUERY ( it <* pdr.used_representation.items
                 | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) ) | (lmwu.
                name = 'minimum wire length') )) <= 1) )) <= 1) )) <= 1));
      wr28: ((NOT (SELF\shape_aspect.description = 
                'printed component join terminal')) OR ((SELF.of_shape.
                definition\product_definition.frame_of_reference.name = 
                'physical occurrence') AND (SIZEOF(QUERY ( prpc <* USEDIN(
                SELF.of_shape.definition\product_definition.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1)));
      wr29: ((NOT (SELF\shape_aspect.description = 
                'printed component join terminal')) OR (SIZEOF(
                QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(i_f.
                relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.
                description = 'join terminal')) )) = 1));
      wr30: ((NOT (SELF\shape_aspect.description = 
                'printed component join terminal')) OR (SIZEOF(
                QUERY ( i <* QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (pdr\shape_aspect_relationship.
                name = 'implementation') ) | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STRATUM_FEATURE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_SHAPE_ASPECT'] * TYPEOF(i.relating_shape_aspect)) 
                >= 1) OR (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_DEFINITION') IN TYPEOF(i.relating_shape_aspect\shape_aspect.
                of_shape.definition)) AND (i.relating_shape_aspect.of_shape
                .definition\product_definition.frame_of_reference.name = 
                'physical occurrence') AND (SIZEOF(QUERY ( pc <* USEDIN(i.
                relating_shape_aspect.of_shape.definition\
                product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (pc\
                product_category.name = 'interconnect module') )) >= 1))) )) 
                = 1));
      wr31: ((NOT (SELF\shape_aspect.description = 'via terminal')) OR (
                SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PLATED_PASSAGE') IN TYPEOF(ac.relating_shape_aspect)) AND 
                (ac.relating_shape_aspect\shape_aspect.description IN ['buried via',
                'interfacial connection','bonded conductive base blind via',
                'non conductive base blind via',
                'plated conductive base blind via'])) )) = 1));
      wr32: ((NOT (SELF\shape_aspect.description = 'via terminal')) OR (
                SIZEOF(QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated feature') ) | (i_f.
                relating_shape_aspect\shape_aspect.description = 'via template terminal') )) 
                = 1));
      wr33: ((NOT (SELF\shape_aspect.description = 
                'interconnect component join terminal')) OR ((SELF.of_shape
                .definition\product_definition.frame_of_reference.name = 
                'physical occurrence') AND (NOT (SELF.of_shape.definition\
                product_definition.description IN [
                'assembly module component','bare die component',
                'interconnect module component','laminate component',
                'packaged component']))));
      wr34: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( dri <* pdr.used_representation.items | ((dri\representation_item.name =
                 'global swappable') AND (dri.description IN ['true',
                'false'])) )) = 1) )) = 1) )) <= 1);
      wr35: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( dri <* pdr.used_representation.items | ((dri\representation_item.name =
                 'local swappable') AND (dri.description IN ['true','false'])) )) 
                = 1) )) = 1) )) <= 1);
      wr36: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( dri <* pdr.used_representation.items | (dri\representation_item.name = 
                'swap code') )) = 1) )) = 1) )) <= 1);
  END_ENTITY; -- component_terminal

  ENTITY composite_array_shape_aspect
    SUBTYPE OF (composite_shape_aspect);
  END_ENTITY; -- composite_array_shape_aspect

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: (((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0)));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUPERTYPE OF (boundary_curve)
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (SIZEOF(basis_surface) > 0);
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment
    SUBTYPE OF (founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' 
               IN TYPEOF(parent_curve));
  END_ENTITY; -- composite_curve_segment

  ENTITY composite_group_shape_aspect
    SUBTYPE OF (composite_shape_aspect);
  END_ENTITY; -- composite_group_shape_aspect

  ENTITY composite_shape_aspect
    SUBTYPE OF (shape_aspect);
    INVERSE
      component_relationships : SET [2:?] OF shape_aspect_relationship FOR 
                                   relating_shape_aspect;
  END_ENTITY; -- composite_shape_aspect

  ENTITY composite_unit_shape_aspect
    SUBTYPE OF (composite_shape_aspect);
  END_ENTITY; -- composite_unit_shape_aspect

  ENTITY concentricity_tolerance
    SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
    WHERE
      wr1: (SELF\geometric_tolerance.name = 'concentricity');
  END_ENTITY; -- concentricity_tolerance

  ENTITY configuration_design;
      configuration : configuration_item;
      design        : product_definition_formation;
    UNIQUE
      ur1 : configuration, design;
  END_ENTITY; -- configuration_design

  ENTITY configuration_effectivity
    SUBTYPE OF (product_definition_effectivity);
      configuration : configuration_design;
    UNIQUE
      ur1 : configuration, SELF\product_definition_effectivity.usage, 
            SELF\effectivity.id;
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_USAGE' 
               IN TYPEOF(SELF\product_definition_effectivity.usage));
  END_ENTITY; -- configuration_effectivity

  ENTITY configuration_item;
      id           : identifier;
      name         : label;
      description  : OPTIONAL text;
      item_concept : product_concept;
      purpose      : OPTIONAL label;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- configuration_item

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- conical_surface

  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY; -- connected_edge_set

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY connection_zone_based_assembly_joint
    SUBTYPE OF (assembly_joint);
    WHERE
      wr1: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'zone_1') )) = 1);
      wr2: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'zone_2') )) = 1);
      wr3: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar.
               relating_shape_aspect\shape_aspect.description = 'connection zone') )) = 
               2);
  END_ENTITY; -- connection_zone_based_assembly_joint

  ENTITY connection_zone_interface_plane_relationship
    SUBTYPE OF (shape_aspect_relationship);
    UNIQUE
      ur1 : SELF\shape_aspect_relationship.name;
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF)) = 2);
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SEATING_PLANE') IN TYPEOF(SELF\shape_aspect_relationship.
               related_shape_aspect));
      wr3: (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.
               description = 'plane');
      wr4: (SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.
               description = 'connection zone');
  END_ENTITY; -- connection_zone_interface_plane_relationship

  ENTITY connectivity_sub_structure
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(sar.related_shape_aspect)) 
               OR (sar.related_shape_aspect\shape_aspect.description = 
               'topological junction')) )) > 1);
  END_ENTITY; -- connectivity_sub_structure

  ENTITY context_dependent_shape_representation;
      representation_relation      : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' 
               IN TYPEOF(SELF.represented_product_relation.definition));
  END_ENTITY; -- context_dependent_shape_representation

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY; -- context_dependent_unit

  ENTITY contract;
      name    : label;
      purpose : text;
      kind    : contract_type;
  END_ENTITY; -- contract

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
      assigned_contract : contract;
  END_ENTITY; -- contract_assignment

  ENTITY contract_type;
      description : label;
  END_ENTITY; -- contract_type

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY coordinated_representation_item
    SUBTYPE OF (representation, representation_item);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
               (SIZEOF(USEDIN(pdr,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DATA_ENVIRONMENT.ELEMENTS')) <= 1) )) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1);
      wr3: ((NOT (SELF\representation_item.name = 'tolerance')) OR (
               SIZEOF(QUERY ( it <* SELF.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) )) >= 1));
      wr4: ((NOT (SELF\representation_item.name = 'plus minus tolerance')) 
               OR (SIZEOF(QUERY ( it <* SELF.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) )) = 3));
      wr5: ((NOT (SELF\representation_item.name = 'symmetrical tolerance')) 
               OR (SIZEOF(QUERY ( it <* SELF.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) )) = 2));
      wr6: ((NOT (SELF\representation_item.name = 'plus minus tolerance')) 
               OR ((SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name =
                'basic value')) )) = 1) AND (SIZEOF(QUERY ( it <* SELF.
               items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name =
                'plus value')) )) = 1) AND (SIZEOF(QUERY ( it <* SELF.items
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name =
                'minus value')) )) = 1)));
      wr7: ((NOT (SELF\representation_item.name = 'symmetrical tolerance')) 
               OR ((SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name =
                'basic value')) )) = 1) AND (SIZEOF(QUERY ( it <* SELF.
               items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name =
                'deviation value')) )) = 1)));
  END_ENTITY; -- coordinated_representation_item

  ENTITY coordinated_universal_time_offset;
      hour_offset   : hour_in_day;
      minute_offset : OPTIONAL minute_in_hour;
      sense         : ahead_or_behind;
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY csg_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REVOLVED_FACE_SOLID','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXTRUDED_FACE_SOLID'] 
               * TYPEOF(it)) <> 1) )) = 0);
      wr3: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
               IN TYPEOF(it)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
      wr4: (SIZEOF(QUERY ( sr <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA' 
               IN TYPEOF(it)) ) | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REVOLVED_FACE_SOLID','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXTRUDED_FACE_SOLID'] 
               * TYPEOF(sr\solid_replica.parent_solid)) = 0) )) = 0);
      wr5: (SIZEOF(QUERY ( it <* SELF.items | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' 
               IN TYPEOF(it))) )) > 0);
  END_ENTITY; -- csg_shape_representation

  ENTITY csg_solid
    SUBTYPE OF (solid_model);
      tree_root_expression : csg_select;
  END_ENTITY; -- csg_solid

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_2d,
        offset_curve_3d,curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
    WHERE
      wr1: ((NOT implicit_outer) OR (SIZEOF(QUERY ( temp <* boundaries | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OUTER_BOUNDARY_CURVE' 
               IN TYPEOF(temp)) )) = 0));
      wr2: ((NOT implicit_outer) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_SURFACE' 
               IN TYPEOF(basis_surface)));
      wr3: (SIZEOF(QUERY ( temp <* boundaries | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OUTER_BOUNDARY_CURVE' 
               IN TYPEOF(temp)) )) <= 1);
      wr4: (SIZEOF(QUERY ( temp <* boundaries | (temp\
               composite_curve_on_surface.basis_surface[1] <> SELF.
               basis_surface) )) = 0);
  END_ENTITY; -- curve_bounded_surface

  ENTITY curve_dimension
    SUBTYPE OF (dimensional_size);
    WHERE
      wr1: (SELF\dimensional_size.name <> 'angular');
  END_ENTITY; -- curve_dimension

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_curve.dim);
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY curve_style;
      name         : label;
      curve_font   : curve_font_or_scaled_curve_font_select;
      curve_width  : size_select;
      curve_colour : colour;
  END_ENTITY; -- curve_style

  ENTITY curve_style_font;
      name         : label;
      pattern_list : LIST [1:?] OF curve_style_font_pattern;
  END_ENTITY; -- curve_style_font

  ENTITY curve_style_font_and_scaling;
      name               : label;
      curve_font         : curve_style_font_select;
      curve_font_scaling : REAL;
  END_ENTITY; -- curve_style_font_and_scaling

  ENTITY curve_style_font_pattern;
      visible_segment_length   : positive_length_measure;
      invisible_segment_length : positive_length_measure;
  END_ENTITY; -- curve_style_font_pattern

  ENTITY curve_style_with_ends_and_corners
    SUBTYPE OF (curve_style);
      curve_ends    : squared_or_rounded;
      curve_corners : squared_or_rounded;
  END_ENTITY; -- curve_style_with_ends_and_corners

  ENTITY curve_style_with_extension
    SUBTYPE OF (curve_style);
      curve_extensions : length_measure;
  END_ENTITY; -- curve_style_with_extension

  ENTITY cutout_edge_segment
    SUPERTYPE OF (plated_cutout_edge_segment)
    SUBTYPE OF (inter_stratum_feature, shape_aspect_relationship);
    WHERE
      wr1: (SELF.description IN ['plated cutout edge segment',
               'cutout edge segment']);
      wr2: (SIZEOF(QUERY ( cc <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'composed cutout') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTER_STRATUM_FEATURE') IN TYPEOF(cc.relating_shape_aspect)) 
               AND (cc.relating_shape_aspect\shape_aspect.description IN ['cutout',
               'physical connectivity interrupting cutout','plated cutout'])) )) 
               = 1);
      wr3: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.relating_shape_aspect));
      wr4: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect));
      wr5: (SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\
               shape_aspect_relationship.relating_shape_aspect);
  END_ENTITY; -- cutout_edge_segment

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY data_environment;
      name        : label;
      description : text;
      elements    : SET [1:?] OF property_definition_representation;
  END_ENTITY; -- data_environment

  ENTITY date
    SUPERTYPE OF (calendar_date);
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
      assigned_date : date;
      role          : date_role;
  END_ENTITY; -- date_assignment

  ENTITY date_role;
      name : label;
  END_ENTITY; -- date_role

  ENTITY date_time_role;
      name : label;
  END_ENTITY; -- date_time_role

  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_date : date_and_time;
      effectivity_end_date   : OPTIONAL date_and_time;
  END_ENTITY; -- dated_effectivity

  ENTITY datum_difference
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    WHERE
      wr1: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(SELF\
               shape_aspect_relationship.relating_shape_aspect)) AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect)));
      wr2: (SELF\shape_aspect.name = SELF\shape_aspect_relationship.name);
      wr3: (SELF\shape_aspect.description = SELF\shape_aspect_relationship
               .description);
      wr4: (SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF
               \shape_aspect_relationship.related_shape_aspect);
      wr5: (SIZEOF(TYPEOF(SELF)) = 3);
  END_ENTITY; -- datum_difference

  ENTITY datum_difference_analytical_model_port_assignment
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ANALYTICAL_MODEL_PORT') IN TYPEOF(SELF\
               property_definition_representation.used_representation)) AND
                (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'DATUM_DIFFERENCE') IN TYPEOF(SELF\
               property_definition_representation.definition)));
      wr5: (SIZEOF(TYPEOF(SELF)) = 2);
  END_ENTITY; -- datum_difference_analytical_model_port_assignment

  ENTITY datum_difference_based_characteristic
    SUBTYPE OF (representation_item);
    WHERE
      wr1: (SIZEOF(QUERY ( r <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (SIZEOF(QUERY ( prd <* USEDIN(r,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
               ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'PROPERTY_DEFINITION_REPRESENTATION') IN TYPEOF(prd)) AND 
               (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'DATUM_DIFFERENCE') IN TYPEOF(prd\
               property_definition_representation.definition))) )) = 1) )) 
               = 1);
  END_ENTITY; -- datum_difference_based_characteristic

  ENTITY datum_difference_based_model_parameter
    SUBTYPE OF (model_parameter);
    WHERE
      wr1: (SIZEOF(QUERY ( r <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (NOT (SIZEOF(QUERY ( pdr <* 
               USEDIN(r,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DATUM_DIFFERENCE') IN TYPEOF(pdr\
               property_definition_representation.definition))) )) = 0)) )) 
               = 1);
  END_ENTITY; -- datum_difference_based_model_parameter

  ENTITY datum_difference_functional_unit_usage_view_terminal_assignment
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF)) = 2);
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect));
      wr3: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DATUM_DIFFERENCE') IN TYPEOF(SELF\shape_aspect_relationship
               .relating_shape_aspect));
  END_ENTITY; -- datum_difference_functional_unit_usage_view_terminal_assignment

  ENTITY datum_reference_frame
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF)) = 2);
      wr2: (SELF\shape_aspect.product_definitional = FALSE);
      wr3: (SIZEOF(QUERY ( pud <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'reference axis') ) | ((pud.related_shape_aspect\shape_aspect.
               description = 'axis') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(pud))) )) <= 3);
      wr4: (SIZEOF(QUERY ( pud <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'reference plane') ) | ((pud.related_shape_aspect\shape_aspect.
               description = 'plane') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(pud))) )) <= 3);
      wr5: (SIZEOF(QUERY ( pud <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'reference origin') ) | ((pud.related_shape_aspect\shape_aspect.
               description = 'point') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(pud))) )) <= 1);
      wr6: (SIZEOF(QUERY ( ds <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'established datum reference frame') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DATUM_SYSTEM') IN TYPEOF(ds)) )) <= 1);
      wr7: ((SIZEOF(QUERY ( pud <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'reference axis') ) | ((pud.related_shape_aspect\shape_aspect.
               description = 'axis') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(pud))) )) + SIZEOF(
               QUERY ( pud <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'reference plane') ) | ((pud.related_shape_aspect\shape_aspect.
               description = 'plane') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(pud))) )) + SIZEOF(
               QUERY ( pud <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'reference origin') ) | ((pud.related_shape_aspect\shape_aspect.
               description = 'point') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM') IN TYPEOF(pud))) ))) >= 1);
  END_ENTITY; -- datum_reference_frame

  ENTITY datum_system
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF\shape_aspect.product_definitional = FALSE);
      wr2: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'established datum reference frame') )) = 1);
      wr3: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'datum usage in datum system') )) >= 1);
      wr4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.description = 
               'datum system property with material conditions') OR (pd.
               description = 
               'datum system property without material conditions')) )) = 1);
  END_ENTITY; -- datum_system

  ENTITY datum_system_based_dimensional_location
    SUBTYPE OF (dimensional_location);
  END_ENTITY; -- datum_system_based_dimensional_location

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' 
               IN TYPEOF(reference_to_curve\representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- degenerate_pcurve

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: (major_radius < minor_radius);
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY delete_design_object_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(it)) AND (it.
               name = 'design object deletion')) )) = 1);
  END_ENTITY; -- delete_design_object_assignment

  ENTITY delete_design_object_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(it)) AND (it.
               name = 'design object deletion')) )) = 1);
  END_ENTITY; -- delete_design_object_request_assignment

  ENTITY derived_shape_aspect
    SUPERTYPE OF (ONEOF (apex,centre_of_symmetry,geometric_alignment,
        geometric_intersection,extension,tangent))
    SUBTYPE OF (shape_aspect);
    INVERSE
      deriving_relationships : SET [1:?] OF shape_aspect_relationship FOR 
                                  relating_shape_aspect;
  END_ENTITY; -- derived_shape_aspect

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    WHERE
      wr1: ((SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (
               elements[1].exponent <> 1)));
  END_ENTITY; -- derived_unit

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY; -- derived_unit_element

  ENTITY descriptive_representation_item
    SUBTYPE OF (representation_item);
      description : text;
  END_ENTITY; -- descriptive_representation_item

  ENTITY design_make_from_relationship
    SUBTYPE OF (product_definition_relationship);
    WHERE
      wr1: (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT'] * TYPEOF(SELF.relating_product_definition)) 
               = 1);
      wr2: (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT'] * TYPEOF(SELF.related_product_definition)) 
               = 1);
      wr3: (SIZEOF(QUERY ( pds <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_SHAPE.DEFINITION') IN TYPEOF(pds)) )) = 
               0);
  END_ENTITY; -- design_make_from_relationship

  ENTITY design_object
    SUBTYPE OF (characterized_object);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1);
  END_ENTITY; -- design_object

  ENTITY device_terminal_map
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    UNIQUE
      ur1 : SELF\shape_aspect_relationship.related_shape_aspect,
            SELF\shape_aspect_relationship.relating_shape_aspect;
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART_TERMINAL') IN TYPEOF(SELF.
               relating_shape_aspect));
  END_ENTITY; -- device_terminal_map

  ENTITY dimension_related_tolerance_zone_element;
      related_dimension : dimensional_location;
      related_element   : tolerance_zone_definition;
  END_ENTITY; -- dimension_related_tolerance_zone_element

  ENTITY dimensional_characteristic_representation;
      dimension      : dimensional_characteristic;
      representation : shape_dimension_representation;
  END_ENTITY; -- dimensional_characteristic_representation

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY dimensional_location
    SUPERTYPE OF (ONEOF (angular_location,dimensional_location_with_path))
    SUBTYPE OF (shape_aspect_relationship);
  END_ENTITY; -- dimensional_location

  ENTITY dimensional_location_with_direction
    SUBTYPE OF (dimensional_location);
    WHERE
      wr1: (SELF\shape_aspect_relationship.description = 'linear');
  END_ENTITY; -- dimensional_location_with_direction

  ENTITY dimensional_location_with_path
    SUBTYPE OF (dimensional_location);
      path : shape_aspect;
  END_ENTITY; -- dimensional_location_with_path

  ENTITY dimensional_size
    SUPERTYPE OF (angular_size);
      applies_to : shape_aspect;
      name       : label;
    WHERE
      wr1: (applies_to.product_definitional = TRUE);
  END_ENTITY; -- dimensional_size

  ENTITY dimensional_size_property
    SUBTYPE OF (dimensional_size, property_definition);
  END_ENTITY; -- dimensional_size_property

  ENTITY directed_action
    SUBTYPE OF (executed_action);
      directive : action_directive;
  END_ENTITY; -- directed_action

  ENTITY directed_dimensional_location
    SUBTYPE OF (dimensional_location);
  END_ENTITY; -- directed_dimensional_location

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY; -- direction

  ENTITY discrete_shield
    SUBTYPE OF (component_definition);
    WHERE
      wr1: (SELF.frame_of_reference.name = 'physical occurrence');
      wr2: (SIZEOF(QUERY ( si <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'shielded item') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_DEFINITION') IN TYPEOF(si.
               relating_product_definition)) )) >= 1);
  END_ENTITY; -- discrete_shield

  ENTITY document;
      id          : identifier;
      name        : label;
      description : text;
      kind        : document_type;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- document

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
  END_ENTITY; -- document_reference

  ENTITY document_relationship;
      name              : label;
      description       : text;
      relating_document : document;
      related_document  : document;
  END_ENTITY; -- document_relationship

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY; -- document_usage_constraint

  ENTITY document_with_class
    SUBTYPE OF (document);
      class : identifier;
  END_ENTITY; -- document_with_class

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_based_2d_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MAPPED_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'AXIS2_PLACEMENT_2D'] * TYPEOF(it)) = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >= 1);
      wr3 : (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( eb <* ebwm\edge_based_wireframe_model.
                ebwm_boundary | (NOT (SIZEOF(QUERY ( edges <* eb.ces_edges
                 | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_CURVE') IN TYPEOF(edges))) )) = 0)) )) = 0)) )) = 0);
      wr4 : (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( eb <* ebwm\edge_based_wireframe_model.
                ebwm_boundary | (NOT (SIZEOF(QUERY ( pline_edges <* 
                QUERY ( edges <* eb.ces_edges | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'POLYLINE') IN TYPEOF(edges\edge_curve.edge_geometry)) ) | 
                (NOT (SIZEOF(pline_edges\edge_curve.edge_geometry\polyline.
                points) > 2)) )) = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( eb <* ebwm\edge_based_wireframe_model.
                ebwm_boundary | (NOT (SIZEOF(QUERY ( edges <* eb.ces_edges
                 | (NOT (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_POINT') IN TYPEOF(edges.edge_start)) AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_POINT') IN TYPEOF(edges.edge_end)))) )) = 0)) )) = 
                0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( eb <* ebwm\edge_based_wireframe_model.
                ebwm_boundary | (NOT (SIZEOF(QUERY ( edges <* eb.ces_edges
                 | (NOT valid_2d_wireframe_edge_curve(edges\edge_curve.
                edge_geometry,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')) )) 
                = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( eb <* ebwm\edge_based_wireframe_model.
                ebwm_boundary | (NOT (SIZEOF(QUERY ( edges <* eb.ces_edges
                 | (NOT (valid_wireframe_vertex_point(edges.edge_start\
                vertex_point.vertex_geometry) AND 
                valid_wireframe_vertex_point(edges.edge_end\vertex_point.
                vertex_geometry))) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( eb <* ebwm\edge_based_wireframe_model.
                ebwm_boundary | (NOT (SIZEOF(QUERY ( con_edges <* 
                QUERY ( edges <* eb.ces_edges | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'CONIC') IN TYPEOF(edges\edge_curve.edge_geometry)) ) | (
                NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'AXIS2_PLACEMENT_2D') IN TYPEOF(con_edges\edge_curve.
                edge_geometry\conic.position))) )) = 0)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF\representation.items
                 | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MAPPED_ITEM') IN TYPEOF(it)) ) | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(
                mi\mapped_item.mapping_source.mapped_representation))) )) =
                 0);
      wr10: (SELF\representation.context_of_items\
                geometric_representation_context.coordinate_space_dimension 
                = 2);
  END_ENTITY; -- edge_based_2d_wireframe_shape_representation

  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY; -- edge_based_wireframe_model

  ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D'] 
               * TYPEOF(it)) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM'] 
               * TYPEOF(it)) = 1) )) >= 1);
      wr3: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' 
               IN TYPEOF(edges))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
               IN TYPEOF(edges\edge_curve.edge_geometry)) ) | (NOT (SIZEOF(
               pline_edges\edge_curve.edge_geometry\polyline.points) > 2)) )) 
               = 0)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
               IN TYPEOF(edges.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
               IN TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT 
               valid_wireframe_edge_curve(edges\edge_curve.edge_geometry)) )) 
               = 0)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               valid_wireframe_vertex_point(edges.edge_start\vertex_point.
               vertex_geometry) AND valid_wireframe_vertex_point(edges.
               edge_end\vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) 
               = 0);
      wr8: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
               IN TYPEOF(it)) ) | (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0);
      wr9: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3);
  END_ENTITY; -- edge_based_wireframe_shape_representation

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end);
  END_ENTITY; -- edge_loop

  ENTITY edge_segment_vertex
    SUBTYPE OF (physical_unit_datum);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF)) = 3);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
               'shape element characterization') )) = 1);
      wr3: (SELF\shape_aspect.of_shape\property_definition.definition.
               frame_of_reference\application_context_element.name IN [
               'physical design occurrence','physical design usage']);
      wr4: (SELF\shape_aspect.name = 'single datum');
  END_ENTITY; -- edge_segment_vertex

  ENTITY ee_specification
    SUBTYPE OF (document);
    WHERE
      wr1: ((SIZEOF(QUERY ( apoa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | (apoa.
               role.name = 'document source') )) + SIZEOF(QUERY ( apoa <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (apoa.role.name =
                'document source') ))) >= 1);
      wr2: (SELF\document.kind.product_data_type IN [
               'assembly technology specification','design specification',
               'fabrication technology specification',
               'interface specification','language reference manual',
               'lead form specification','material specification',
               'process specification','surface finish specification',
               'test specification']);
  END_ENTITY; -- ee_specification

  ENTITY effectivity
    SUPERTYPE OF (ONEOF (serial_numbered_effectivity,dated_effectivity,
        lot_effectivity));
      id : identifier;
  END_ENTITY; -- effectivity

  ENTITY electric_current_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELECTRIC_CURRENT_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- electric_current_measure_with_unit

  ENTITY electric_current_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 1) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- electric_current_unit

  ENTITY electrical_network
    SUBTYPE OF (functional_unit);
  END_ENTITY; -- electrical_network

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY; -- evaluated_degenerate_pcurve

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY; -- executed_action

  ENTITY expanded_uncertainty
    SUBTYPE OF (standard_uncertainty);
      coverage_factor : REAL;
  END_ENTITY; -- expanded_uncertainty

  ENTITY extension
    SUBTYPE OF (derived_shape_aspect);
    WHERE
      wr1: (SIZEOF(SELF\derived_shape_aspect.deriving_relationships) = 1);
  END_ENTITY; -- extension

  ENTITY external_definition
    SUBTYPE OF (characterized_object, externally_defined_item);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1);
  END_ENTITY; -- external_definition

  ENTITY external_source;
      source_id : source_item;
  END_ENTITY; -- external_source

  ENTITY external_source_relationship;
      name            : label;
      description     : text;
      relating_source : external_source;
      related_source  : external_source;
  END_ENTITY; -- external_source_relationship

  ENTITY externally_defined_assembly_definition
    SUBTYPE OF (externally_defined_physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'assembly module') )) >= 1);
      wr2: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.
               description = 'pca terminal')) )) >= 2)) )) = 0));
  END_ENTITY; -- externally_defined_assembly_definition

  ENTITY externally_defined_bare_die
    SUBTYPE OF (externally_defined_physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( ifdu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 
               'implemented function') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(ifdu.
               relating_product_definition)) AND (ifdu.
               relating_product_definition.frame_of_reference.name = 
               'functional design usage')) )) = 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( dut <* 
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'device unit technology') ) | (dut.
               relating_property_definition\property_definition.name = 'unit technology') )) = 
               1) )) = 1);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BARE_DIE_TERMINAL') IN TYPEOF(sa)) )) >= 2)) )) = 0);
  END_ENTITY; -- externally_defined_bare_die

  ENTITY externally_defined_curve_font
    SUBTYPE OF (externally_defined_item);
  END_ENTITY; -- externally_defined_curve_font

  ENTITY externally_defined_functional_unit
    SUBTYPE OF (functional_unit, externally_defined_item);
  END_ENTITY; -- externally_defined_functional_unit

  ENTITY externally_defined_hatch_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY; -- externally_defined_hatch_style

  ENTITY externally_defined_interconnect_definition
    SUBTYPE OF (externally_defined_physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1);
  END_ENTITY; -- externally_defined_interconnect_definition

  ENTITY externally_defined_item;
      item_id : source_item;
      source  : external_source;
  END_ENTITY; -- externally_defined_item

  ENTITY externally_defined_package
    SUBTYPE OF (externally_defined_physical_unit);
    WHERE
      wr1: (SELF.frame_of_reference.name = 'physical design usage');
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
               used_representation\representation.name = 'registered case style') )) >= 1)) )) 
               = 0);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr)) ) | (sr_pdr.
               used_representation\representation.name = 'seating plane') )) = 1)) )) = 0);
      wr4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_BODY') IN TYPEOF(sa)) )) <= 1)) )) = 0);
      wr5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_TERMINAL') IN TYPEOF(sa)) )) >= 1)) )) = 0);
      wr6: ((NOT (SELF\product_definition.description = 'altered package')) 
               OR (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ((pdr\product_definition_relationship.name = 'package preparation') AND (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGE'] * TYPEOF(pdr.
               relating_product_definition)) = 1)) )) = 1));
  END_ENTITY; -- externally_defined_package

  ENTITY externally_defined_packaged_connector
    SUBTYPE OF (externally_defined_packaged_part);
  END_ENTITY; -- externally_defined_packaged_connector

  ENTITY externally_defined_packaged_part
    SUPERTYPE OF (externally_defined_packaged_connector)
    SUBTYPE OF (externally_defined_physical_unit);
    WHERE
      wr1: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART_TERMINAL') IN TYPEOF(sa)) )) >= 2)) )) = 0));
      wr2: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_DESIGNATION.DEFINITIONS')) = 1));
      wr3: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( ifu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'implemented function') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(ifu.relating_product_definition)) 
               AND (ifu.relating_product_definition.frame_of_reference.name 
               = 'functional design usage')) )) = 1));
      wr4: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( upkg <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'used package') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE') IN TYPEOF(upkg.related_product_definition)) )) = 
               1));
      wr5: ((NOT (SELF\product_definition.description = 
               'altered packaged part')) OR (SIZEOF(QUERY ( bpp <* 
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'base packaged part') ) | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(bpp.
               relating_product_definition)) = 1) AND (bpp.
               relating_product_definition.frame_of_reference.name = 
               'physical design usage')) )) >= 1));
      wr6: ((NOT (SELF\product_definition.description = 
               'altered packaged part')) OR (SIZEOF(QUERY ( upkg <* 
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'used package') ) | (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(upkg.
               relating_product_definition)) = 1) )) >= 1));
  END_ENTITY; -- externally_defined_packaged_part

  ENTITY externally_defined_physical_unit
    SUPERTYPE OF (library_defined_physical_unit ANDOR ONEOF (
        externally_defined_package,externally_defined_packaged_part,
        externally_defined_bare_die,externally_defined_assembly_definition,
        externally_defined_interconnect_definition))
    SUBTYPE OF (physical_unit, externally_defined_item);
  END_ENTITY; -- externally_defined_physical_unit

  ENTITY externally_defined_representation_item
    SUBTYPE OF (externally_defined_item, representation_item);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1);
  END_ENTITY; -- externally_defined_representation_item

  ENTITY externally_defined_symbol
    SUBTYPE OF (externally_defined_item);
  END_ENTITY; -- externally_defined_symbol

  ENTITY externally_defined_text_font
    SUBTYPE OF (externally_defined_item);
  END_ENTITY; -- externally_defined_text_font

  ENTITY externally_defined_tile
    SUBTYPE OF (externally_defined_item);
  END_ENTITY; -- externally_defined_tile

  ENTITY externally_defined_tile_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY; -- externally_defined_tile_style

  ENTITY extruded_area_solid
    SUBTYPE OF (swept_area_solid);
      extruded_direction : direction;
      depth              : positive_length_measure;
    WHERE
      wr1: (dot_product(SELF\swept_area_solid.swept_area.basis_surface\
               elementary_surface.position.p[3],extruded_direction) <> 0);
  END_ENTITY; -- extruded_area_solid

  ENTITY extruded_face_solid
    SUBTYPE OF (swept_face_solid);
      extruded_direction : direction;
      depth              : positive_length_measure;
    WHERE
      wr1: (dot_product(SELF\swept_face_solid.swept_face.face_geometry\
               elementary_surface.position.p[3],extruded_direction) <> 0);
  END_ENTITY; -- extruded_face_solid

  ENTITY fabrication_joint
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( ff <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'fabrication features') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(ff.related_shape_aspect)) 
               AND (ff.related_shape_aspect\shape_aspect.description IN ['via terminal',
               'printed component join terminal',
               'non functional land join terminal','land join terminal',
               'conductive interconnect element terminal',
               'component termination passage join terminal'])) )) = 2);
      wr2: (SIZEOF(QUERY ( ajm <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'auxiliary joint material') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LAND') IN TYPEOF(ajm.related_shape_aspect)) OR (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(ajm.related_shape_aspect)) 
               AND (ajm.related_shape_aspect\shape_aspect.description = 
               'stratum feature template component'))) )) <= 1);
  END_ENTITY; -- fabrication_joint

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      wr2: (SIZEOF(QUERY ( temp <* bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' 
               IN TYPEOF(temp)) )) <= 1);
  END_ENTITY; -- face

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY faceted_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D'] 
               * TYPEOF(it)) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM'] 
               * TYPEOF(it)) = 1) )) > 0);
      wr3: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh <* msb_shells(
               fbrep,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN') | (NOT (SIZEOF(QUERY ( fcs <* csh.
               cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE' 
               IN TYPEOF(fcs)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' 
               IN TYPEOF(fcs\face_surface.face_geometry)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' 
               IN TYPEOF(fcs\face_surface.face_geometry\elementary_surface.
               position.location)))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh <* msb_shells(
               fbrep,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN') | (NOT (SIZEOF(QUERY ( fcs <* csh.
               cfs_faces | (NOT (SIZEOF(QUERY ( bnds <* fcs.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' 
               IN TYPEOF(bnds)) )) = 1)) )) = 0)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' 
               IN TYPEOF(it)) ) | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' 
               IN TYPEOF(msb\manifold_solid_brep.outer)) )) = 0);
      wr6: (SIZEOF(QUERY ( brv <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BREP_WITH_VOIDS' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh <* brv\
               brep_with_voids.voids | csh\oriented_closed_shell.
               orientation )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
               IN TYPEOF(it)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
  END_ENTITY; -- faceted_brep_shape_representation

  ENTITY fiducial
    SUBTYPE OF (component_shape_aspect);
    WHERE
      wr1: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition)) 
               AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition.
               formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1));
  END_ENTITY; -- fiducial

  ENTITY fiducial_part_feature
    SUBTYPE OF (part_tooling_feature);
  END_ENTITY; -- fiducial_part_feature

  ENTITY fiducial_stratum_feature
    SUBTYPE OF (stratum_feature);
  END_ENTITY; -- fiducial_stratum_feature

  ENTITY fill_area_style;
      name        : label;
      fill_styles : SET [1:?] OF fill_style_select;
    WHERE
      wr1: (SIZEOF(QUERY ( fill_style <* SELF.fill_styles | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FILL_AREA_STYLE_COLOUR') IN TYPEOF(fill_style)) )) <= 1);
  END_ENTITY; -- fill_area_style

  ENTITY fill_area_style_colour;
      name        : label;
      fill_colour : colour;
  END_ENTITY; -- fill_area_style_colour

  ENTITY fill_area_style_hatching
    SUBTYPE OF (geometric_representation_item);
      hatch_line_appearance         : curve_style;
      start_of_next_hatch_line      : one_direction_repeat_factor;
      point_of_reference_hatch_line : cartesian_point;
      pattern_start                 : cartesian_point;
      hatch_line_angle              : plane_angle_measure;
  END_ENTITY; -- fill_area_style_hatching

  ENTITY fill_area_style_tile_coloured_region
    SUBTYPE OF (geometric_representation_item);
      closed_curve  : curve_or_annotation_curve_occurrence;
      region_colour : colour;
  END_ENTITY; -- fill_area_style_tile_coloured_region

  ENTITY fill_area_style_tile_curve_with_style
    SUBTYPE OF (geometric_representation_item);
      styled_curve : annotation_curve_occurrence;
  END_ENTITY; -- fill_area_style_tile_curve_with_style

  ENTITY fill_area_style_tile_symbol_with_style
    SUBTYPE OF (geometric_representation_item);
      symbol : annotation_symbol_occurrence;
  END_ENTITY; -- fill_area_style_tile_symbol_with_style

  ENTITY fill_area_style_tiles
    SUBTYPE OF (geometric_representation_item);
      tiling_pattern : two_direction_repeat_factor;
      tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
      tiling_scale   : positive_ratio_measure;
  END_ENTITY; -- fill_area_style_tiles

  ENTITY founded_item;
  END_ENTITY; -- founded_item

  ENTITY functional_terminal_group
    SUBTYPE OF (group);
    UNIQUE
      ur1 : SELF\group.name;
    WHERE
      wr1: (SIZEOF(QUERY ( aga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT') IN TYPEOF(aga)) AND (SIZEOF(
               QUERY ( dri <* aga.items | (dri.name = 
               'functional group type') )) = 1)) )) = 1);
  END_ENTITY; -- functional_terminal_group

  ENTITY functional_unit
    SUPERTYPE OF (externally_defined_functional_unit ANDOR 
        electrical_network ANDOR thermal_network)
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SELF.frame_of_reference.name IN ['functional design usage',
               'functional network design']);
      wr2: ((NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS') IN TYPEOF(
               SELF))) OR (SIZEOF(QUERY ( docs <* SELF\
               product_definition_with_associated_documents.
               documentation_ids | (docs.kind.product_data_type = 
               'CAD filename') )) <= 1));
      wr3: ((SIZEOF(QUERY ( adta <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adta.role.name 
               = 'creation date') )) + SIZEOF(QUERY ( ada <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DATE_ASSIGNMENT.ITEMS') | (ada.role.name = 
               'creation date') ))) = 1);
      wr4: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1);
      wr5: ((SIZEOF(QUERY ( apoa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | (apoa.
               role.name = 'creator') )) + SIZEOF(QUERY ( apoa <* USEDIN(
               SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (apoa.role.name =
                'creator') ))) >= 1);
      wr6: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1);
      wr7: ((NOT (SELF.frame_of_reference.name = 
               'functional network design')) OR (SIZEOF(QUERY ( du <* 
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 'design usage') )
                | (du.relating_product_definition.frame_of_reference.name =
                'functional design usage') )) = 1));
      wr8: ((NOT (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'THERMAL_NETWORK',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ELECTRICAL_NETWORK'] * TYPEOF(SELF)) = 1)) OR (SELF.
               frame_of_reference.name = 'functional network design'));
  END_ENTITY; -- functional_unit

  ENTITY functional_unit_terminal_definition
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(SELF.of_shape.definition)) AND 
               (SELF.of_shape.definition\product_definition.
               frame_of_reference.name = 'functional design usage'));
      wr2: (SIZEOF(QUERY ( pd2 <* QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION') IN TYPEOF(pd)) ) | (SIZEOF(
               QUERY ( funtdba <* QUERY ( pdr <* USEDIN(pd2,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment') )
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(funtdba.
               relating_property_definition.definition)) )) <= 1) )) <= 1);
      wr3: (SIZEOF(QUERY ( pd2 <* QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION') IN TYPEOF(pd)) ) | (SIZEOF(
               QUERY ( funtdna <* QUERY ( pdr <* USEDIN(pd2,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'functional unit network terminal definition node assignment') )
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'NETWORK_NODE_DEFINITION') IN TYPEOF(funtdna.
               relating_property_definition.definition)) )) <= 1) )) <= 1);
  END_ENTITY; -- functional_unit_terminal_definition

  ENTITY functionally_defined_transformation;
      name        : label;
      description : text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY geometric_alignment
    SUBTYPE OF (derived_shape_aspect);
    WHERE
      wr1: (SIZEOF(SELF\derived_shape_aspect.deriving_relationships) > 1);
  END_ENTITY; -- geometric_alignment

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' 
               IN TYPEOF(temp)) )) = 0);
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_intersection
    SUBTYPE OF (derived_shape_aspect);
    WHERE
      wr1: (SIZEOF(SELF\derived_shape_aspect.deriving_relationships) > 1);
  END_ENTITY; -- geometric_intersection

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,edge_curve,
        face_surface,poly_loop,vertex_point,solid_model,boolean_result,
        sphere,right_circular_cone,right_circular_cylinder,torus,block,
        right_angular_wedge,half_space_solid,shell_based_surface_model,
        shell_based_wireframe_model,edge_based_wireframe_model,
        geometric_set))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (geometric_curve_set)
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY geometric_tolerance;
      name                    : label;
      description             : text;
      magnitude               : measure_with_unit;
      toleranced_shape_aspect : shape_aspect;
    WHERE
      wr1: (magnitude.value_component >= 0);
  END_ENTITY; -- geometric_tolerance

  ENTITY geometric_tolerance_group
    SUBTYPE OF (property_definition);
    WHERE
      wr1: (SELF\property_definition.description IN [
               'separate requirement','simultaneous requirement']);
      wr2: ((NOT (SELF\property_definition.description = 
               'separate requirement')) OR (SIZEOF(QUERY ( pdr <* USEDIN(
               SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM') IN 
               TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 
               'group geometric tolerance')) )) >= 1));
      wr3: ((NOT (SELF\property_definition.description = 
               'simultaneous requirement')) OR (SIZEOF(QUERY ( pdr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr\property_definition_relationship.name = 
               'group geometric tolerance')) )) >= 2));
      wr4: ((NOT (SELF\property_definition.description = 
               'separate requirement')) OR (SIZEOF(QUERY ( pdr <* USEDIN(
               SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr.
               related_property_definition\property_definition.name = 
               'linear profile refinement') AND (pdr\property_definition_relationship.name = 
               'group geometric tolerance')) )) = 0));
      wr5: ((NOT (SELF\property_definition.description = 
               'separate requirement')) OR (SIZEOF(QUERY ( pdr <* USEDIN(
               SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr.
               related_property_definition\property_definition.name = 
               'surface profile refinement') AND (pdr\property_definition_relationship.name = 
               'group geometric tolerance')) )) = 0));
      wr6: ((NOT (SELF\property_definition.description = 
               'separate requirement')) OR (SIZEOF(QUERY ( pdr <* USEDIN(
               SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITION_TOLERANCE') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr.
               related_property_definition\property_definition.name = 
               'feature relating position') AND (pdr\property_definition_relationship.name = 
               'group geometric tolerance')) )) = 0));
      wr7: ((NOT (SELF\property_definition.description = 
               'separate requirement')) OR (SIZEOF(QUERY ( pdr <* USEDIN(
               SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | ((pdr\property_definition_relationship.name = 'group geometric tolerance') AND (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITION_TOLERANCE'] * TYPEOF(pdr.
               related_property_definition)) > 0)) )) = 0));
  END_ENTITY; -- geometric_tolerance_group

  ENTITY geometric_tolerance_relationship;
      name                         : label;
      description                  : text;
      relating_geometric_tolerance : geometric_tolerance;
      related_geometric_tolerance  : geometric_tolerance;
  END_ENTITY; -- geometric_tolerance_relationship

  ENTITY geometric_tolerance_with_specified_datum_system
    SUBTYPE OF (physical_unit_geometric_tolerance);
    WHERE
      wr1: (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ANGULARITY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITION_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CIRCULAR_RUNOUT_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CONCENTRICITY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PARALLELISM_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PERPENDICULARITY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SYMMETRY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOTAL_RUNOUT_TOLERANCE'] * TYPEOF(SELF)) = 1);
      wr2: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((pdr.related_property_definition\property_definition.description = 
               'datum system property with material conditions') OR (pdr.
               related_property_definition\property_definition.description = 
               'datum system property without material conditions')) AND (
               pdr\property_definition_relationship.name = 'referenced datum system definition')) )) = 1);
      wr3: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRIC_TOLERANCE_GROUP') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr.
               related_property_definition\property_definition.description = 
               'separate requirement') AND (pdr\property_definition_relationship.name = 
               'group geometric tolerance')) )) <= 1);
  END_ENTITY; -- geometric_tolerance_with_specified_datum_system

  ENTITY geometrically_bounded_2d_wireframe_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 2);
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (NOT (SIZEOF(TYPEOF(item) 
               * ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM']) 
               = 1)) )) = 0);
      wr3: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF(TYPEOF(item) * ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM']) 
               = 1) )) >= 1);
      wr4: (SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
               IN TYPEOF(item)) ) | (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
      wr5: (SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(item)) ) | (NOT (SIZEOF(QUERY ( elem <* gcs\
               geometric_set.elements | (NOT (SIZEOF(TYPEOF(elem) * ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_2D','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE']) 
               = 1)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(item)) ) | (NOT (SIZEOF(QUERY ( crv <* 
               QUERY ( elem <* gcs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' 
               IN TYPEOF(elem)) ) | (NOT valid_basis_curve_in_2d_wireframe(
               crv)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(item)) ) | (NOT (SIZEOF(QUERY ( pnt <* 
               QUERY ( elem <* gcs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' 
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(TYPEOF(pnt) * ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE']) 
               = 1)) )) = 0)) )) = 0);
      wr8: (SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(item)) ) | (NOT (SIZEOF(QUERY ( pl <* 
               QUERY ( elem <* gcs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pl\polyline.points) > 2)) )) 
               = 0)) )) = 0);
  END_ENTITY; -- geometrically_bounded_2d_wireframe_representation

  ENTITY geometrically_bounded_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D'] 
               * TYPEOF(it)) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM'] 
               * TYPEOF(it)) = 1) )) > 0);
      wr3: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
               IN TYPEOF(it)) ) | (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
      wr4: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( pnt <* 
               QUERY ( gsel <* gs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' 
               IN TYPEOF(gsel)) ) | (NOT gbsf_check_point(pnt)) )) = 0)) )) 
               = 0);
      wr5: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cv <* 
               QUERY ( gsel <* gs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' 
               IN TYPEOF(gsel)) ) | (NOT gbsf_check_curve(cv)) )) = 0)) )) 
               = 0);
      wr6: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( sf <* 
               QUERY ( gsel <* gs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' 
               IN TYPEOF(gsel)) ) | (NOT gbsf_check_surface(sf)) )) = 0)) )) 
               = 0);
  END_ENTITY; -- geometrically_bounded_surface_shape_representation

  ENTITY geometrically_bounded_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(TYPEOF(it) * ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM']) 
               = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(TYPEOF(it) * ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM']) 
               = 1) )) >= 1);
      wr3: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( crv <* 
               QUERY ( elem <* gcs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' 
               IN TYPEOF(elem)) ) | (NOT 
               valid_geometrically_bounded_wf_curve(crv,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( pnts <* 
               QUERY ( elem <* gcs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' 
               IN TYPEOF(elem)) ) | (NOT 
               valid_geometrically_bounded_wf_point(pnts,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cnc <* 
               QUERY ( elem <* gcs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC' 
               IN TYPEOF(elem)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' 
               IN TYPEOF(cnc\conic.position))) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' 
               IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( pline <* 
               QUERY ( elem <* gcs\geometric_set.elements | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pline\polyline.points) > 2)) )) 
               = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
               IN TYPEOF(it)) ) | (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
      wr8: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3);
  END_ENTITY; -- geometrically_bounded_wireframe_shape_representation

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY group;
      name        : label;
      description : text;
  END_ENTITY; -- group

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
      assigned_group : group;
  END_ENTITY; -- group_assignment

  ENTITY group_product_definition
    SUBTYPE OF (component_definition);
    WHERE
      wr1: (SELF.frame_of_reference.name = 'design requirement');
      wr2: ((NOT (SELF.description = 'placement group')) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) )) >= 1));
  END_ENTITY; -- group_product_definition

  ENTITY group_relationship;
      name           : label;
      description    : text;
      relating_group : group;
      related_group  : group;
  END_ENTITY; -- group_relationship

  ENTITY group_shape_aspect
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_PRODUCT_DEFINITION') IN TYPEOF(SELF\shape_aspect.
               of_shape.definition));
      wr2: ((NOT (SELF\shape_aspect.description = 
               'interconnect module constraint region')) OR (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_PRODUCT_DEFINITION') IN TYPEOF(SELF\shape_aspect.
               of_shape.definition)) AND (SIZEOF(QUERY ( gm <* 
               QUERY ( pdr <* USEDIN(SELF\shape_aspect.of_shape.definition,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'group member') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT') IN TYPEOF(gm.related_product_definition)) 
               AND (gm.related_product_definition.frame_of_reference.name =
                'physical design') AND (SIZEOF(QUERY ( prpc <* USEDIN(gm.
               related_product_definition.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1)) )) 
               = 1)));
      wr3: ((NOT (SELF\shape_aspect.description = 
               'interconnect module constraint region')) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | ((pdr\property_definition_relationship.name = 'constrained object') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY') IN TYPEOF(pdr.
               related_property_definition.definition))) )) = 1) )) = 1));
      wr4: ((NOT (SELF\shape_aspect.description = 
               'interconnect module constraint region')) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( it <* pdr.used_representation.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'design specific purpose')) )) = 1) )) = 1)) )) = 0));
      wr5: ((NOT (SELF\shape_aspect.description = 
               'interconnect module constraint region')) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( it <* pdr.used_representation.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'keepout') AND (it.description IN ['true','false'])) )) 
               = 1) )) = 1)) )) = 0));
      wr6: ((NOT (SELF\shape_aspect.description = 
               'interconnect module constraint region')) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )) 
               = 1) )) = 1));
      wr7: ((NOT (SELF\shape_aspect.description IN [
               'interconnect module constraint region',
               'termination constraint','placement group'])) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) )) = 1));
      wr8: ((NOT (SELF\shape_aspect.description = 'termination constraint')) 
               OR (SIZEOF(QUERY ( ctm <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'constrained termination member') ) | (ctm.
               related_shape_aspect\shape_aspect.description = 
               'mating connector termination') )) >= 2));
  END_ENTITY; -- group_shape_aspect

  ENTITY grouped_requirements_property
    SUBTYPE OF (group, requirements_property);
    WHERE
      wr1: ((NOT (SELF\group.name = 
               'item restricted requirements property')) OR (SIZEOF(
               QUERY ( aga <* QUERY ( ga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT') IN TYPEOF(ga)) ) | (SIZEOF(aga.
               items) = 1) )) = 1));
      wr2: ((NOT (SELF\group.name = 'layout spacing requirements property')) 
               OR (SIZEOF(QUERY ( aga <* QUERY ( ga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT') IN TYPEOF(ga)) ) | ((SIZEOF(aga.
               items) = 2) AND (SIZEOF(QUERY ( rp <* QUERY ( it <* aga.
               items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(it)) ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESIGN_OBJECT') IN TYPEOF(rp.definition)) AND (rp.
               definition.name IN ['component feature category',
               'assembly component category','cutout category',
               'fill area category','inter stratum feature category',
               'stratum feature category','via category',
               'altered package category'])) )) = 1)) )) = 1));
      wr3: ((NOT (SELF\group.name = 'layout spacing requirements property')) 
               OR (SIZEOF(QUERY ( aga <* QUERY ( ga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT') IN TYPEOF(ga)) ) | ((SIZEOF(aga.
               items) = 2) AND (SIZEOF(QUERY ( rp <* QUERY ( it <* aga.
               items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(it)) ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESIGN_OBJECT') IN TYPEOF(rp.definition)) AND (rp.
               definition.description = 'dependent design object category')) )) 
               = 1)) )) = 1));
      wr4: ((NOT (SELF\group.name = 'layout spacing requirements property')) 
               OR (SIZEOF(QUERY ( aga <* QUERY ( ga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT') IN TYPEOF(ga)) ) | ((SIZEOF(aga.
               items) = 2) AND (SIZEOF(QUERY ( rp <* QUERY ( it <* aga.
               items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(it)) ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESIGN_OBJECT') IN TYPEOF(rp.definition)) AND (rp.
               definition.description = 'reference design object category')) )) 
               = 1)) )) = 1));
  END_ENTITY; -- grouped_requirements_property

  ENTITY half_space_solid
    SUBTYPE OF (geometric_representation_item);
      base_surface   : surface;
      agreement_flag : BOOLEAN;
  END_ENTITY; -- half_space_solid

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY integral_shield
    SUBTYPE OF (component_shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | ((((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_DEFINITION') IN TYPEOF(pdr.
               relating_property_definition)) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(pdr.
               relating_property_definition))) AND (pdr\property_definition_relationship.name = 
               'shielded item')) )) >= 1);
  END_ENTITY; -- integral_shield

  ENTITY inter_stratum_feature
    SUBTYPE OF (component_shape_aspect);
    WHERE
      wr1 : (SELF.description IN ['bonded conductive base blind via',
                'buried via','component termination passage',
                'interfacial connection','non conductive base blind via',
                'plated conductive base blind via','plated cutout',
                'partially plated cutout','plated cutout edge segment',
                'partially plated interconnect module edge',
                'plated interconnect module edge segment',
                'plated interconnect module edge','unsupported passage',
                'cutout','physical connectivity interrupting cutout',
                'dielectric material passage','cutout edge segment',
                'interconnect module edge segment',
                'interconnect module edge']);
      wr2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
                name = 'feature of size') AND (it.description IN ['true',
                'false'])) )) = 1) )) = 1) )) = 1);
      wr3 : (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
                description IN ['inter stratum feature template',
                'via template','component termination passage template',
                'unsupported passage template'])) )) = 1);
      wr4 : ((NOT (SELF.description = 'cutout edge segment')) OR (SIZEOF(
                QUERY ( cc <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'composed cutout') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE') IN TYPEOF(cc.relating_shape_aspect)) 
                AND ((cc.relating_shape_aspect\shape_aspect.description = 'cutout') OR (
                cc.relating_shape_aspect\shape_aspect.description = 
                'physical connectivity interrupting cutout') OR (cc.
                relating_shape_aspect\shape_aspect.description = 
                'partially plated cutout'))) )) = 1));
      wr5 : ((NOT (SELF.description = 'interconnect module edge segment')) 
                OR (SIZEOF(QUERY ( ce <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'composed edge') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE') IN TYPEOF(ce.relating_shape_aspect)) 
                AND ((ce.relating_shape_aspect\shape_aspect.description = 
                'interconnect module edge') OR (ce.relating_shape_aspect\shape_aspect.
                description = 'interconnect module edge'))) )) = 1));
      wr6 : ((NOT (SELF.description = 'dielectric material passage')) OR (
                SIZEOF(QUERY ( pp <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'precedent passage') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE') IN TYPEOF(pp.relating_shape_aspect)) 
                AND ((pp.relating_shape_aspect\shape_aspect.description = 'cutout') OR (
                pp.relating_shape_aspect\shape_aspect.description = 
                'physical connectivity interrupting cutout') OR (pp.
                relating_shape_aspect\shape_aspect.description = 
                'partially plated cutout'))) )) = 1));
      wr7 : ((NOT (SELF.description = 'dielectric material passage')) OR (
                SIZEOF(QUERY ( rp <* QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) ) | (rp.name = 
                'feature material') )) <= 1) OR (SIZEOF(USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1));
      wr8 : ((NOT (SELF.description = 
                'physical connectivity interrupting cutout')) OR (SIZEOF(
                QUERY ( ice <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'interrupted connectivity elements') ) | (ice.
                relating_shape_aspect.name = 
                'conductive interconnect element') )) >= 1));
      wr9 : ((NOT (SELF.description = 'unsupported passage')) OR (SIZEOF(
                QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
                description = 'unsupported passage template')) )) = 1));
      wr10: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition)) 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition
                .formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
--tt correct category name
                product_category.name = 'template model') )) >= 1));
      wr11: ((NOT (SELF\shape_aspect.description = 'cutout edge segment')) 
                OR (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE') IN TYPEOF(it
                .relating_shape_aspect)) )) = 1));
      wr12: ((NOT (SELF\shape_aspect.description = 
                'plated cutout edge segment')) OR (SIZEOF(QUERY ( it <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE') IN TYPEOF(it
                .relating_shape_aspect)) )) = 1));
      wr13: ((NOT (SELF\shape_aspect.description = 
                'interconnect module edge segment')) OR (SIZEOF(
                QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE') IN TYPEOF(it
                .relating_shape_aspect)) )) = 1));
      wr14: ((NOT (SELF\shape_aspect.description = 
                'plated interconnect module edge segment')) OR (SIZEOF(
                QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE') IN TYPEOF(it
                .relating_shape_aspect)) )) = 1));
  END_ENTITY; -- inter_stratum_feature

  ENTITY inter_stratum_feature_edge_segment_template
    SUBTYPE OF (part_template_definition, shape_aspect_relationship);
    WHERE
      wr1: (SIZEOF(QUERY ( ce <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar <> 
               []) ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTER_STRATUM_FEATURE_EDGE_TEMPLATE') IN TYPEOF(ce.
               relating_shape_aspect)) )) = 1);
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect));
      wr3: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.relating_shape_aspect));
      wr4: (SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF
               \shape_aspect_relationship.related_shape_aspect);
      wr5: (SIZEOF(TYPEOF(SELF)) = 4);
  END_ENTITY; -- inter_stratum_feature_edge_segment_template

  ENTITY inter_stratum_feature_edge_template
    SUBTYPE OF (part_template_definition);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF)) = 4);
      wr2: (SELF\shape_aspect.description = 
               'inter stratum feature edge template');
  END_ENTITY; -- inter_stratum_feature_edge_template

  ENTITY interconnect_definition
    SUBTYPE OF (physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1);
--tt polarity of pdr changed.
      wr2: ((NOT (SELF.frame_of_reference.name = 'physical design')) OR (
               SIZEOF(QUERY ( du <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
--tt changed polarity of pdr
               'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 'design usage') )
                | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTERCONNECT_DEFINITION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
--tt corrected type problem
               'LIBRARY_DEFINED_INTERCONNECT_DEFINITION'] * TYPEOF(du.relating_product_definition)) = 1) 
--tt changed polarity of pdr
               AND (du.relating_product_definition.frame_of_reference.name =
                'physical design usage') AND (SIZEOF(QUERY ( prpc <* 
--tt changed polarity of pdr
               USEDIN(du.relating_product_definition.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1)) )) 
               = 1));
  END_ENTITY; -- interconnect_definition

  ENTITY interconnect_module_design_object_category
    SUBTYPE OF (characterized_object);
    WHERE
      wr1: (SELF\characterized_object.description IN ['cutout category',
               'fill area category','inter stratum feature category',
               'stratum feature category','via category']);
  END_ENTITY; -- interconnect_module_design_object_category

  ENTITY interconnect_module_edge_segment
    SUBTYPE OF (inter_stratum_feature, shape_aspect_relationship);
    WHERE
      wr1: (SELF.description IN ['plated interconnect module edge segment',
               'interconnect module edge segment']);
      wr2: (SIZEOF(QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(ji.relating_shape_aspect)) 
               AND (ji.relating_shape_aspect.name = 'inter stratum join')) )) 
               <= 1);
      wr3: ((NOT (SELF.description = 
               'plated interconnect module edge segment')) OR (SIZEOF(
               QUERY ( ce <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'composed edge') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PLATED_INTER_STRATUM_FEATURE') IN TYPEOF(ce.
               relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.
               description = 'plated interconnect module edge')) )) = 1));
      wr4: ((NOT (SELF.description = 'interconnect module edge segment')) 
               OR (SIZEOF(QUERY ( ce <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'composed edge') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTER_STRATUM_FEATURE') IN TYPEOF(ce.relating_shape_aspect)) 
               AND (ce.relating_shape_aspect\shape_aspect.description = 
               'interconnect module edge')) )) = 1));
      wr5: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect));
      wr6: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.relating_shape_aspect));
      wr7: (SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF
               \shape_aspect_relationship.related_shape_aspect);
  END_ENTITY; -- interconnect_module_edge_segment

  ENTITY interconnect_module_edge_segment_surface
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect));
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EDGE_SEGMENT_VERTEX') IN TYPEOF(SELF\
               shape_aspect_relationship.relating_shape_aspect));
      wr3: (SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF
               \shape_aspect_relationship.related_shape_aspect);
      wr4: (SIZEOF(QUERY ( ce <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'composed surface') ) | (
               'interconnect module edge surface' = ce.
               relating_shape_aspect\shape_aspect.description) )) = 1);
      wr5: (SIZEOF(TYPEOF(SELF)) = 3);
  END_ENTITY; -- interconnect_module_edge_segment_surface

  ENTITY interconnect_module_stratum_based_terminal
    SUBTYPE OF (interconnect_module_terminal);
  END_ENTITY; -- interconnect_module_stratum_based_terminal

  ENTITY interconnect_module_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT') IN TYPEOF(SELF.of_shape.definition)) AND (
               SELF.of_shape.definition\product_definition.
               frame_of_reference.name = 'physical design usage') AND (
               SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition.
               formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1));
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )) 
               >= 1) )) >= 1);
      wr3: (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'member connected terminal') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_CONNECTED_TERMINALS_DEFINITION') IN TYPEOF(mct.
               relating_shape_aspect)) )) <= 1);
      wr4: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar.
               related_shape_aspect\shape_aspect.description = 'connection zone') )) = 1);
  END_ENTITY; -- interconnect_module_terminal

  ENTITY interface_component_definition
    SUBTYPE OF (component_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_INTERFACE_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.
               description IN ['interconnect component interface terminal',
               'packaged connector component interface terminal'])) )) >= 1) )) 
               >= 1);
  END_ENTITY; -- interface_component_definition

  ENTITY interface_mounted_join
    SUBTYPE OF (shape_aspect_relationship, shape_aspect);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_INTERFACE_TERMINAL') IN TYPEOF(SELF.
               related_shape_aspect));
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(SELF.relating_shape_aspect));
  END_ENTITY; -- interface_mounted_join

  ENTITY interfaced_group_component_definition
    SUBTYPE OF (assembly_group_component_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( gc <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'group component') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTERFACE_COMPONENT_DEFINITION') IN TYPEOF(gc.
               related_product_definition)) )) >= 1);
  END_ENTITY; -- interfaced_group_component_definition

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]));
  END_ENTITY; -- intersection_curve

  ENTITY item_defined_transformation;
      name             : label;
      description      : text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY; -- item_defined_transformation

  ENTITY join_shape_aspect
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( cp <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'connected point') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LAYER_CONNECTION_POINT') IN TYPEOF(cp.related_shape_aspect)) )) 
               >= 2);
      wr2: (SIZEOF(QUERY ( nt <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'network topology') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_NETWORK') IN TYPEOF(nt.relating_shape_aspect)) )) 
               = 1);
      wr3: ((NOT (SELF.name = 'intra stratum join')) OR (SIZEOF(
               QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(ji.related_shape_aspect)) AND (
               ji.related_shape_aspect\shape_aspect.description = 'conductor')) )) <= 1));
      wr4: ((NOT (SELF.name = 'intra stratum join')) OR (SIZEOF(
               QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(ji.related_shape_aspect)) AND (
               ji.related_shape_aspect\shape_aspect.description = 
               'connected filled area')) )) <= 1));
      wr5: ((NOT (SELF.name = 'inter stratum join')) OR (SIZEOF(
               QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | ((((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_CONCEPT_RELATIONSHIP') IN TYPEOF(ji.
               related_shape_aspect)) AND (ji.related_shape_aspect\
               shape_aspect.description = 'physical network supporting stratum feature conductive join')) 
               OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PLATED_INTER_STRATUM_FEATURE') IN TYPEOF(ji.
               related_shape_aspect))) )) <= 1));
  END_ENTITY; -- join_shape_aspect

  ENTITY land
    SUBTYPE OF (component_shape_aspect);
    WHERE
      wr1 : ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition)) 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition
                .formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
-- tt changed to 'template model'  mapping table change required.
-- addendum?
                product_category.name = 'template model') )) >= 1));
      wr2 : (SIZEOF(QUERY ( i_f <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(i_f.
                relating_shape_aspect)) )) = 1);
      wr3 : (SIZEOF(QUERY ( aud <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'alternate usage definition') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(aud.
                relating_shape_aspect)) )) <= 1);
      wr4 : (SIZEOF(QUERY ( sfi <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
-- tt mapping table is inconsistent and this should be left alone
                name = 'stratum feature implementation') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STRATUM_FEATURE') IN TYPEOF(sfi.relating_shape_aspect)) )) 
                = 1);
      wr5 : ((NOT (SELF\shape_aspect.description IN ['functional land',
                'via dependent land','via and contact size dependent land',
                'component termination passage dependent land',
                'contact size dependent land','component termination passage and contact size dependent land'])) 
                OR (SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_SHAPE_ASPECT') IN TYPEOF(ac.related_shape_aspect)) 
                AND (ac.related_shape_aspect\shape_aspect.description = 
                'land interface terminal')) )) = 1));
      wr6 : ((NOT (SELF\shape_aspect.description IN ['functional land',
                'via dependent land','via and contact size dependent land',
                'component termination passage dependent land',
                'contact size dependent land','component termination passage and contact size dependent land'])) 
                OR (SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_TERMINAL') IN TYPEOF(ac.related_shape_aspect)) 
                AND (ac.related_shape_aspect\shape_aspect.description = 
                'land join terminal')) )) >= 1));
      wr7 : ((NOT (SELF\shape_aspect.description IN ['non functional land',
                'via dependent non functional land',
                'via and contact size dependent non functional land','component termination passage dependent non functional land',
                'contact size dependent non functional land',
                'component termination passage and contact size ' + 
                'dependent non functional land',
                'unsupported passage dependent non functional land'])) OR (
                SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_SHAPE_ASPECT') IN TYPEOF(ac.related_shape_aspect)) 
                AND (ac.related_shape_aspect\shape_aspect.description = 
                'non functional land interface terminal')) )) = 1));
      wr8 : ((NOT (SELF\shape_aspect.description IN ['non functional land',
                'via dependent non functional land',
                'via and contact size dependent non functional land','component termination passage dependent non functional land',
                'contact size dependent non functional land',
                'component termination passage and contact size ' + 
                'dependent non functional land',
                'unsupported passage dependent non functional land'])) OR (
                SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated component') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'COMPONENT_TERMINAL') IN TYPEOF(ac.related_shape_aspect)) 
                AND (ac.related_shape_aspect\shape_aspect.description = 
                'non functional land join terminal')) )) >= 1));
      wr9 : ((NOT (SELF\shape_aspect.description IN ['component termination passage and contact size dependent land',
                'component termination passage and contact size dependent' 
                + 'non functional land',
                'component termination passage dependent land','component termination passage dependent non functional land'])) 
                OR (SIZEOF(QUERY ( rp <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'reference passage') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PLATED_PASSAGE') IN TYPEOF(rp.relating_shape_aspect)) AND 
                (rp.related_shape_aspect\shape_aspect.description = 
                'component termination passage')) )) = 1));
      wr10: ((NOT (SELF\shape_aspect.description IN [
                'via and contact size dependent land',
                'via and contact size dependent non functional land',
                'via dependent land','via dependent non functional land'])) 
                OR (SIZEOF(QUERY ( rv <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'reference via') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PLATED_PASSAGE') IN TYPEOF(rv.relating_shape_aspect)) AND 
                (rv.related_shape_aspect\shape_aspect.description IN ['buried via',
                'interfacial connection','bonded conductive base blind via',
                'non conductive base blind via',
                'plated conductive base blind via'])) )) = 1));
      wr11: ((NOT (SELF\shape_aspect.description = 
                'unsupported passage dependent non functional land')) OR (
                SIZEOF(QUERY ( rp <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'reference passage') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'INTER_STRATUM_FEATURE') IN TYPEOF(rp.relating_shape_aspect)) 
                AND (rp.relating_shape_aspect\shape_aspect.description = 
                'unsupported passage')) )) = 1));
      wr12: ((NOT (SELF\shape_aspect.description IN [
                'component termination passage dependent land','component termination passage dependent non functional land'])) 
                OR (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.
                description = 'default component termination passage based')) )) 
                = 1));
      wr13: ((NOT (SELF\shape_aspect.description IN ['component termination passage and contact size dependent land','component termination passage and contact size dependent ' 
                + 'non functional land'])) OR (SIZEOF(QUERY ( it <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.
                description = (
                'default attachment size and component termination ' + 
                'passage based'))) )) = 1));
      wr14: ((NOT (SELF\shape_aspect.description IN [
                'contact size dependent land',
                'contact size dependent non functional land'])) OR (SIZEOF(
                QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.
                description = 'default attachment size based')) )) = 1));
      wr15: ((NOT (SELF\shape_aspect.description IN [
                'via and contact size dependent land',
                'via and contact size dependent non functional land'])) OR 
                (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.
                description = 'default attachment size and via based')) )) 
                = 1));
      wr16: ((NOT (SELF\shape_aspect.description IN ['via dependent land',
                'via dependent non functional land'])) OR (SIZEOF(
                QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.
                description = 'default via based')) )) = 1));
      wr17: ((NOT (SELF\shape_aspect.description = (
                'unsupported passage dependent ' + 'non functional land'))) 
                OR (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'instantiated template') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(it.
                relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
                description = 'default unsupported passage based')) )) = 1));
  END_ENTITY; -- land

  ENTITY land_physical_template
    SUBTYPE OF (part_template_definition);
    WHERE
      wr1 : (SIZEOF(QUERY ( ada <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (SIZEOF(
                QUERY ( duc <* USEDIN(ada.assigned_document,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (duc.subject_element 
                = 'pre defined classification code') )) = 1) )) <= 1);
      wr2 : (SIZEOF(QUERY ( am <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
--tt correct name of sar.
                (sar\shape_aspect_relationship.
                name = 'associated definition') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LAND_TEMPLATE_TERMINAL') IN TYPEOF(am.related_shape_aspect)) )) 
                >= 2);
      wr3 : ((NOT (SELF.description IN ['default attachment size based','default attachment size and component termination passage based',
                'default attachment size and via based'])) OR (SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'minimum attachment region size') AND (sar.
                related_shape_aspect\shape_aspect.description = 'connection zone')) )) =
                 1));
      wr4 : ((NOT (SELF.description IN ['default attachment size based','default attachment size and component termination passage based',
                'default attachment size and via based'])) OR (SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'maximum attachment region size') AND (sar\shape_aspect_relationship.
                related_shape_aspect\shape_aspect.description = 'connection zone')) )) =
                 1));
      wr5 : ((NOT (SELF.description IN [
                'default component termination passage based','default attachment size and component termination passage based'])) 
                OR (SIZEOF(QUERY ( tu <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'technology usage') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(tu.related_shape_aspect)) 
                AND (tu.related_shape_aspect\shape_aspect.description = 
                'default component termination passage definition')) )) = 1));
      wr6 : ((NOT (SELF.description IN ['default attachment size and component termination passage based',
                'default attachment size based',
                'default attachment size and via based',
                'default component termination passage based',
                'default via based','default unsupported passage based'])) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( tu <* 
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                 | (pdr\property_definition_relationship.name = 'technology usage') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STRATUM_TECHNOLOGY') IN TYPEOF(tu.
                relating_property_definition.definition)) )) = 1) )) = 1));
      wr7 : ((NOT (SELF.description IN ['default attachment size and component termination passage based',
                'default attachment size and via based',
                'default component termination passage based',
                'default via based','default unsupported passage based'])) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) )) = 2) )) =
                 1)) )) = 0));
      wr8 : ((NOT (SELF.description IN ['default attachment size and component termination passage based',
                'default attachment size and via based',
                'default component termination passage based',
                'default via based','default unsupported passage based'])) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum standard fabrication allowance')) )) = 1) )) = 1)) )) 
                = 0));
      wr9 : ((NOT (SELF.description IN ['default attachment size and component termination passage based',
                'default attachment size and via based',
                'default component termination passage based',
                'default via based','default unsupported passage based'])) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum annular ring')) )) = 1) )) = 1)) )) = 0));
      wr10: ((NOT (SELF.description IN ['default attachment size and component termination passage based',
                'default attachment size and via based',
                'default component termination passage based',
                'default via based','default unsupported passage based'])) 
                OR (SIZEOF(QUERY ( tu <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'technology usage') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(tu.related_shape_aspect)) )) 
                = 1));
      wr11: ((NOT (SELF.description IN ['default via based',
                'default attachment size and via based'])) OR (SIZEOF(
                QUERY ( tu <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'technology usage') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(tu.related_shape_aspect)) 
                AND (tu.related_shape_aspect\shape_aspect.description = 
                'default via definition')) )) = 1));
      wr12: ((NOT (SELF.description = 'default unsupported passage')) OR (
                SIZEOF(QUERY ( tu <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'technology usage') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(tu.related_shape_aspect)) 
                AND (tu.related_shape_aspect\shape_aspect.description = 
                'default unsupported passage definition')) )) = 1));
  END_ENTITY; -- land_physical_template

  ENTITY land_template_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF.description IN ['interface terminal','join terminal']);
      wr2: (SIZEOF(QUERY ( tcz <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
               name = 'terminal connection zone') AND (sar\shape_aspect_relationship.description IN [
               'edge curve','edge point','surface area','surface point'])) )
                | (tcz.related_shape_aspect\shape_aspect.description = 'connection zone') )) 
               >= 1);
      wr3: (SIZEOF(QUERY ( tcz <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'terminal connection zone') ) | (NOT (SIZEOF(
               QUERY ( tcz_1 <* (QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'terminal connection zone') ) - tcz) | (NOT (tcz.
               description = tcz_1.description)) )) = 0)) )) = 0);
  END_ENTITY; -- land_template_terminal

  ENTITY layer
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1: (SIZEOF(QUERY ( ada <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (SIZEOF(
               QUERY ( duc <* USEDIN(ada.assigned_document,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (duc.subject_element =
                'layer definition') )) = 1) )) <= 1);
      wr2: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(SELF.of_shape.
               definition)) AND (SELF.of_shape.definition.name = 
               'inter stratum extent'));
  END_ENTITY; -- layer

  ENTITY layer_connection_point
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF\shape_aspect.of_shape.
               definition.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'design layer') )) >= 1);
      wr2: (SIZEOF(QUERY ( cp <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'connected point') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(cp.relating_shape_aspect)) )) 
               >= 1);
      wr3: ((NOT (SELF\shape_aspect.description = 'dependently located')) 
               OR (SIZEOF(QUERY ( ado <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated design object') ) | (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTER_STRATUM_FEATURE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTERCONNECT_MODULE_TERMINAL'] * TYPEOF(ado.
               relating_shape_aspect)) = 1) )) = 1));
      wr4: ((NOT (SELF\shape_aspect.description = 'explicitly located')) 
               OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) 
               AND (pdr.used_representation\representation.name = 
               'connection point location') AND (SIZEOF(QUERY ( it <* pdr.
               used_representation.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CARTESIAN_POINT') IN TYPEOF(it)) )) = 1)) )) = 1)) )) = 0));
  END_ENTITY; -- layer_connection_point

  ENTITY layer_connection_point_link
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    WHERE
      wr1: (SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\
               shape_aspect_relationship.relating_shape_aspect);
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LAYER_CONNECTION_POINT') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect));
      wr3: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LAYER_CONNECTION_POINT') IN TYPEOF(SELF\
               shape_aspect_relationship.relating_shape_aspect));
--tt corrected number back to 3
--tt corrected number
      wr4: (SIZEOF(TYPEOF(SELF)) = 3);
      wr5: (SELF\shape_aspect.name = '');
      wr6: (SELF\shape_aspect_relationship.name = '');
      wr7: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1);
  END_ENTITY; -- layer_connection_point_link

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- length_unit

  ENTITY library_defined_assembly_definition
    SUBTYPE OF (library_defined_physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'assembly module') )) >= 1);
      wr2: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.
               description = 'pca terminal')) )) >= 2)) )) = 0));
  END_ENTITY; -- library_defined_assembly_definition

  ENTITY library_defined_bare_die
    SUBTYPE OF (library_defined_physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( ifdu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 
               'implemented function') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(ifdu.
               relating_product_definition)) AND (ifdu.
               relating_product_definition.frame_of_reference.name = 
               'functional design usage')) )) = 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( dut <* 
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'device unit technology') ) | (dut.
               relating_property_definition\property_definition.name = 'unit technology') )) = 
               1) )) = 1);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BARE_DIE_TERMINAL') IN TYPEOF(sa)) )) >= 2)) )) = 0);
  END_ENTITY; -- library_defined_bare_die

  ENTITY library_defined_functional_unit
    SUBTYPE OF (externally_defined_functional_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( esr <* USEDIN(SELF.source,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNAL_SOURCE_RELATIONSHIP.RELATING_SOURCE') | (esr.name 
               = 'revision') )) = 0);
  END_ENTITY; -- library_defined_functional_unit

  ENTITY library_defined_interconnect_definition
    SUBTYPE OF (library_defined_physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1);
  END_ENTITY; -- library_defined_interconnect_definition

  ENTITY library_defined_model
    SUBTYPE OF (externally_defined_item, analytical_model, 
        product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( esr <* USEDIN(SELF.source,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNAL_SOURCE_RELATIONSHIP.RELATING_SOURCE') | (esr.name 
               = 'revision') )) = 1);
  END_ENTITY; -- library_defined_model

  ENTITY library_defined_package
    SUBTYPE OF (library_defined_physical_unit);
    WHERE
      wr1: (SELF.frame_of_reference.name = 'physical design usage');
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
               used_representation\representation.name = 'registered case style') )) >= 1)) )) 
               = 0);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr)) ) | (sr_pdr.
               used_representation\representation.name = 'seating plane') )) = 1)) )) = 0);
      wr4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_BODY') IN TYPEOF(sa)) )) <= 1)) )) = 0);
      wr5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_TERMINAL') IN TYPEOF(sa)) )) >= 1)) )) = 0);
      wr6: ((NOT (SELF.description = 'altered package')) OR (SIZEOF(
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ((pdr\product_definition_relationship.name = 'package preparation') AND (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGE'] * TYPEOF(pdr.
               relating_product_definition)) = 1)) )) = 1));
  END_ENTITY; -- library_defined_package

  ENTITY library_defined_packaged_connector
    SUBTYPE OF (library_defined_packaged_part);
  END_ENTITY; -- library_defined_packaged_connector

  ENTITY library_defined_packaged_part
    SUBTYPE OF (library_defined_physical_unit);
    WHERE
      wr1: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART_TERMINAL') IN TYPEOF(sa)) )) >= 2)) )) = 0));
      wr2: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_DESIGNATION.DEFINITIONS')) = 1));
      wr3: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( ifu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'implemented function') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(ifu.relating_product_definition)) 
               AND (ifu.relating_product_definition.frame_of_reference.name 
               = 'functional design usage')) )) = 1));
      wr4: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( upkg <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'used package') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE') IN TYPEOF(upkg.related_product_definition)) )) = 
               1));
      wr5: ((NOT (SELF.description = 'altered packaged part')) OR (SIZEOF(
               QUERY ( bpp <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'base packaged part') ) | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(bpp.
               relating_product_definition)) = 1) AND (bpp.
               relating_product_definition.frame_of_reference.name = 
               'physical design usage')) )) >= 1));
      wr6: ((NOT (SELF.description = 'altered packaged part')) OR (SIZEOF(
               QUERY ( upkg <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'used package') ) | (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(upkg.
               relating_product_definition)) = 1) )) >= 1));
  END_ENTITY; -- library_defined_packaged_part

  ENTITY library_defined_physical_unit
    SUPERTYPE OF (ONEOF (library_defined_package,
        library_defined_assembly_definition,
        library_defined_interconnect_definition,
        library_defined_packaged_part,library_defined_bare_die))
    SUBTYPE OF (externally_defined_physical_unit);
    WHERE
      wr1: (SIZEOF(QUERY ( esr <* USEDIN(SELF.source,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNAL_SOURCE_RELATIONSHIP.RELATING_SOURCE') | (esr.name 
               = 'revision') )) = 0);
  END_ENTITY; -- library_defined_physical_unit

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: (dir.dim = pnt.dim);
  END_ENTITY; -- line

  ENTITY linear_profile_tolerance
    SUBTYPE OF (physical_unit_geometric_tolerance);
    WHERE
      wr1: ((NOT (SELF\geometric_tolerance.name = 
               'linear profile refinement')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND (gtr.name = 
               'linear profile refining control') AND ((gtr.
               relating_geometric_tolerance.name = 
               'linear profile locating') OR (gtr.
               relating_geometric_tolerance.name = 
               'linear profile refinement'))) )) = 1));
      wr2: ((NOT (SELF\geometric_tolerance.name = 
               'linear profile locating')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND (gtr.
               relating_geometric_tolerance.name = 
               'linear profile refinement') AND (gtr.name = 
               'linear profile refining control')) )) = 1));
      wr3: ((NOT (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM') IN 
               TYPEOF(SELF)) AND (SELF\geometric_tolerance.name = 
               'linear profile refinement'))) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND (gtr.
               relating_geometric_tolerance.name = 
               'linear profile refinement') AND (gtr.name = 
               'linear profile refining control')) )) = 0));
      wr4: ((NOT (SELF\geometric_tolerance.name = 
               'linear profile refinement')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND (gtr.
               related_geometric_tolerance.name = 
               'linear profile refinement') AND (gtr.name = 
               'linear profile refining control')) )) <= 1));
      wr5: (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF)));
  END_ENTITY; -- linear_profile_tolerance

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
      effectivity_lot_id   : identifier;
      effectivity_lot_size : measure_with_unit;
  END_ENTITY; -- lot_effectivity

  ENTITY luminous_intensity_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LUMINOUS_INTENSITY_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- luminous_intensity_measure_with_unit

  ENTITY luminous_intensity_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 1));
  END_ENTITY; -- luminous_intensity_unit

  ENTITY make_from_connectivity_relationship
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(SELF.
               relating_shape_aspect));
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(SELF.
               related_shape_aspect));
  END_ENTITY; -- make_from_connectivity_relationship

  ENTITY make_from_feature_relationship
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      wr1: (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_INTERFACE_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT'] * TYPEOF(SELF.
               relating_shape_aspect)) = 1);
      wr2: (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_INTERFACE_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT'] * TYPEOF(SELF.related_shape_aspect)) 
               = 1);
      wr3: ((NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(SELF.
               relating_shape_aspect))) OR (SELF.relating_shape_aspect\shape_aspect.
               description IN ['component feature',
               'component termination passage interface terminal',
               'land or non functional land interface terminal',
               'printed connector component interface terminal']));
      wr4: ((NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(SELF.
               related_shape_aspect))) OR (SELF.related_shape_aspect\shape_aspect.
               description IN ['component feature',
               'component termination passage interface terminal',
               'land or non functional land interface terminal',
               'printed connector component interface terminal']));
  END_ENTITY; -- make_from_feature_relationship

  ENTITY make_from_usage_option
    SUBTYPE OF (product_definition_usage);
      ranking           : INTEGER;
      ranking_rationale : text;
      quantity          : measure_with_unit;
    WHERE
      wr1: (ranking > 0);
  END_ENTITY; -- make_from_usage_option

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY manifold_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D'] 
                * TYPEOF(it)) = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM'] 
                * TYPEOF(it)) = 1) )) > 0);
      wr3 : (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
                IN TYPEOF(it)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' 
                IN TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation))) )) = 0);
      wr4 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( sh <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL'] 
                * TYPEOF(sh)) = 1)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (
                SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE'] 
                * TYPEOF(fa)) = 1)) )) = 0)) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( f_sf <* QUERY ( fa <* cfs\connected_face_set.
                cfs_faces | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE' 
                IN TYPEOF(fa)) ) | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(f_sf)) OR (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE'] 
                * TYPEOF(f_sf\face_surface.face_geometry)) = 1))) )) = 0)) )) 
                = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR msf_surface_check(fa\face_surface.
                face_geometry))) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( bnds <* fa.bounds | (NOT 
                (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP'] 
                * TYPEOF(bnds.bound)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) 
                = 0);
      wr9 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* fa.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds\path.edge_list | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' 
                IN TYPEOF(oe.edge_element))) )) = 0)) )) = 0))) )) = 0)) )) 
                = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* fa.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe_cv <* 
                QUERY ( oe <* elp_fbnds\path.edge_list | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' 
                IN TYPEOF(oe.edge_element)) ) | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE'] 
                * TYPEOF(oe_cv.edge_element\edge_curve.edge_geometry)) = 1)) )) 
                = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* fa.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds\path.edge_list | (NOT msf_curve_check(oe.
                edge_element\edge_curve.edge_geometry)) )) = 0)) )) = 0))) )) 
                = 0)) )) = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* fa.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds\path.edge_list | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(oe.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(oe.edge_element.edge_end)))) )) = 0)) )) = 0))) )) 
                = 0)) )) = 0)) )) = 0);
      wr13: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* fa.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* 
                elp_fbnds\path.edge_list | (NOT ((SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE'] 
                * TYPEOF(oe.edge_element.edge_start\vertex_point.
                vertex_geometry)) = 1) AND (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE'] 
                * TYPEOF(oe.edge_element.edge_end\vertex_point.
                vertex_geometry)) = 1))) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) 
                = 0);
      wr14: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( vlp_fbnds <* 
                QUERY ( bnds <* fa.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(vlp_fbnds\vertex_loop.loop_vertex))) )) = 0))) )) 
                = 0)) )) = 0)) )) = 0);
      wr15: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' 
                IN TYPEOF(fa)) OR (SIZEOF(QUERY ( vlp_fbnds <* 
                QUERY ( bnds <* fa.bounds | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' 
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE'] 
                * TYPEOF(vlp_fbnds\vertex_loop.loop_vertex\vertex_point.
                vertex_geometry)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
  END_ENTITY; -- manifold_surface_shape_representation

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
END_ENTITY; -- mapped_item

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MASS_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- mass_measure_with_unit

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 1) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- mass_unit

  ENTITY material_designation;
      name        : label;
      definitions : SET [1:?] OF characterized_definition;
  END_ENTITY; -- material_designation

  ENTITY material_designation_characterization;
      name        : label;
      description : text;
      designation : material_designation;
      property    : characterized_material_property;
  END_ENTITY; -- material_designation_characterization

  ENTITY material_electrical_conductivity_category
    SUBTYPE OF (group);
    WHERE
      wr1: (SELF\group.name IN ['conductive','non conductive','resistive',
               'semi conductive']);
  END_ENTITY; -- material_electrical_conductivity_category

  ENTITY material_property
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : SELF\property_definition.name, SELF\property_definition.definition;
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTERIZED_OBJECT' 
               IN TYPEOF(SELF\property_definition.definition)) OR (SIZEOF(
               bag_to_set(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - 
               QUERY ( temp <* bag_to_set(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_PROPERTY_REPRESENTATION') IN TYPEOF(temp)) )) = 0));
  END_ENTITY; -- material_property

  ENTITY material_property_representation
    SUBTYPE OF (property_definition_representation);
      dependent_environment : data_environment;
  END_ENTITY; -- material_property_representation

  ENTITY measure_qualification;
      name              : label;
      description       : text;
      qualified_measure : measure_with_unit;
      qualifiers        : SET [1:?] OF value_qualifier;
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* qualifiers | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRECISION_QUALIFIER' 
               IN TYPEOF(temp)) )) < 2);
  END_ENTITY; -- measure_qualification

  ENTITY measure_representation_item
    SUBTYPE OF (representation_item, measure_with_unit);
  END_ENTITY; -- measure_representation_item

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,mass_measure_with_unit,
        time_measure_with_unit,electric_current_measure_with_unit,
        thermodynamic_temperature_measure_with_unit,
        amount_of_substance_measure_with_unit,
        luminous_intensity_measure_with_unit,plane_angle_measure_with_unit,
        solid_angle_measure_with_unit,area_measure_with_unit,
        volume_measure_with_unit,ratio_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY minimally_defined_bare_die_terminal
    SUPERTYPE OF (bare_die_terminal)
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BARE_DIE') IN TYPEOF(SELF.of_shape.definition));
      wr2: (SIZEOF(QUERY ( eca <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'external connection area') ) | (eca.
               related_shape_aspect\shape_aspect.description = 'connection zone') )) <= 
               1);
      wr3: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1);
      wr4: (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'member connected terminal') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_CONNECTED_TERMINALS_DEFINITION') IN TYPEOF(mct.
               relating_shape_aspect)) )) <= 1);
  END_ENTITY; -- minimally_defined_bare_die_terminal

  ENTITY model_parameter
    SUBTYPE OF (representation_item);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1);
      wr2: (SIZEOF(QUERY ( cri <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COORDINATED_REPRESENTATION_ITEM') IN TYPEOF(cri)) AND (cri\
               representation.name = 
               'model parameter with valid range value')) )) <= 1);
      wr3: (SIZEOF(QUERY ( aga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT.ITEMS') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PARAMETER_TYPE') IN TYPEOF(aga.assigned_group)) AND (aga.
               assigned_group\group.name IN ['string property type',
               'logical property type','physical property type',
               'boolean property type'])) )) = 1);
  END_ENTITY; -- model_parameter

  ENTITY modified_geometric_tolerance
    SUBTYPE OF (geometric_tolerance);
      modifier : limit_condition;
  END_ENTITY; -- modified_geometric_tolerance

  ENTITY mounting_restriction_area
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition)) 
               AND (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(sar.related_shape_aspect)) 
               AND (sar\shape_aspect_relationship.name = 'mounting surface') AND (sar.
               related_shape_aspect.of_shape.definition = sar.
               relating_shape_aspect.of_shape.definition)) )) = 1));
      wr2: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(sar.
               relating_shape_aspect.of_shape.definition)) AND (sar.
               relating_shape_aspect.of_shape.definition.name = 
               'inter stratum extent')) )) >= 1);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )) 
               = 1)) )) = 0);
      wr4: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(sar.related_shape_aspect)) 
               AND (sar\shape_aspect_relationship.name = 'mounting surface') AND (sar.
               related_shape_aspect\shape_aspect.description = 
               'interconnect module component surface feature')) )) = 1);
  END_ENTITY; -- mounting_restriction_area

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit,
        context_dependent_unit) ANDOR ONEOF (length_unit,mass_unit,
        time_unit,electric_current_unit,thermodynamic_temperature_unit,
        amount_of_substance_unit,luminous_intensity_unit,plane_angle_unit,
        solid_angle_unit,area_unit,volume_unit,ratio_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY network_node_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SELF.frame_of_reference.name = 'functional network design');
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(
               QUERY ( funtdna <* QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'functional unit network terminal definition node assignment') )
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_SHAPE') IN TYPEOF(funtdna.
               related_property_definition)) AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') IN TYPEOF(funtdna.
               related_property_definition.definition))) )) <= 1) )) <= 1);
      wr3: (SIZEOF(QUERY ( funn <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(funn.
               relating_product_definition)) AND (funn.
               relating_product_definition.frame_of_reference.name = 
               'functional network design')) )) = 1);
  END_ENTITY; -- network_node_definition

  ENTITY next_assembly_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- next_assembly_usage_occurrence

  ENTITY offset_curve_2d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
    WHERE
      wr1: (basis_curve.dim = 2);
  END_ENTITY; -- offset_curve_2d

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: ((basis_curve.dim = 3) AND (ref_direction.dim = 3));
  END_ENTITY; -- offset_curve_3d

  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY; -- offset_surface

  ENTITY one_direction_repeat_factor
    SUBTYPE OF (geometric_representation_item);
      repeat_factor : vector;
  END_ENTITY; -- one_direction_repeat_factor

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY opposing_boundary_dimensional_size
    SUBTYPE OF (dimensional_size);
    WHERE
      wr1: (SELF\dimensional_size.name IN ['angular','linear']);
  END_ENTITY; -- opposing_boundary_dimensional_size

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_relationship;
      name                  : label;
      description           : text;
      relating_organization : organization;
      related_organization  : organization;
  END_ENTITY; -- organization_relationship

  ENTITY organization_role;
      name : label;
  END_ENTITY; -- organization_role

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : text;
  END_ENTITY; -- organizational_address

  ENTITY organizational_project;
      name                      : label;
      description               : text;
      responsible_organizations : SET [1:?] OF organization;
  END_ENTITY; -- organizational_project

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' 
               IN TYPEOF(SELF.closed_shell_element)));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_EDGE' 
               IN TYPEOF(SELF.edge_element)));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' 
               IN TYPEOF(SELF.face_element)));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_OPEN_SHELL' 
               IN TYPEOF(SELF.open_shell_element)));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' 
               IN TYPEOF(SELF.path_element)));
  END_ENTITY; -- oriented_path

  ENTITY outer_boundary_curve
    SUBTYPE OF (boundary_curve);
  END_ENTITY; -- outer_boundary_curve

  ENTITY package
    SUBTYPE OF (physical_unit);
    WHERE
      wr1 : (SELF.frame_of_reference.name = 'physical design usage');
      wr2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 'registered case style') )) >= 1) )) 
                >= 1);
      wr3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGE_BODY') IN TYPEOF(sa)) )) = 1) )) <= 1);
      wr4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGE_TERMINAL') IN TYPEOF(sa)) )) >= 1) )) >= 1);
      wr5 : ((NOT (SELF.description = 'altered package')) OR (SIZEOF(
                QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | ((pdr\product_definition_relationship.name = 'package alteration') AND (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EXTERNALLY_DEFINED_PACKAGE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LIBRARY_DEFINED_PACKAGE'] * TYPEOF(pdr.
                relating_product_definition)) = 1)) )) = 1));
      wr6 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 'package mounting data') )) = 1) )) 
                = 1);
      wr7 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'maximum body height above seating plane') )) = 1)) )) = 1) )) 
                = 1);
      wr8 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'maximum body height below seating plane') )) = 1)) )) = 1) )) 
                <= 1);
      wr9 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'maximum body clearance above seating plane') )) = 1)) )) =
                 1) )) <= 1);
      wr10: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'maximum body clearance below seating plane') )) = 1)) )) =
                 1) )) <= 1);
      wr11: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'minimum body clearance above seating plane') )) = 1)) )) =
                 1) )) <= 1);
      wr12: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'minimum body clearance below seating plane') )) = 1)) )) =
                 1) )) <= 1);
      wr13: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'maximum lead length below seating plane') )) = 1)) )) = 1) )) 
                <= 1);
      wr14: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 'package mounting data') AND (
                SIZEOF(QUERY ( item <* USEDIN(pdr.used_representation,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS') | (item\representation_item.name = 
                'least lead length below seating plane') )) = 1)) )) = 1) )) 
                <= 1);
      wr15: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | (SIZEOF(QUERY ( sar <* USEDIN(sa,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'package seating plane') )) = 1) )) = 1) )) = 1);
      wr16: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SEATING_PLANE') IN TYPEOF(sa)) )) = 1) )) = 1);
  END_ENTITY; -- package

  ENTITY package_body
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF.of_shape.definition) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGE']) = 1);
      wr2: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
  END_ENTITY; -- package_body

  ENTITY package_body_bottom_surface
    SUBTYPE OF (package_body_surface);
  END_ENTITY; -- package_body_bottom_surface

  ENTITY package_body_surface
    ABSTRACT SUPERTYPE OF (ONEOF (package_body_top_surface,
        package_body_bottom_surface))
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF.of_shape.definition) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGE']) = 1);
      wr2: SELF\shape_aspect.product_definitional;
      wr3: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (TYPEOF(
               sar\shape_aspect_relationship.relating_shape_aspect) = [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_BODY']) )) = 1);
  END_ENTITY; -- package_body_surface

  ENTITY package_body_top_surface
    SUBTYPE OF (package_body_surface);
  END_ENTITY; -- package_body_top_surface

  ENTITY package_terminal
    SUPERTYPE OF (primary_reference_terminal)
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1 : (SELF\shape_aspect.description IN ['altered package terminal',
                'guided wave terminal','wire terminal',
                'primary reference terminal','']);
      wr2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )) 
                >= 1)) )) = 0);
      wr3 : (SIZEOF(TYPEOF(SELF.of_shape.definition) * [
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EXTERNALLY_DEFINED_PACKAGE',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LIBRARY_DEFINED_PACKAGE']) = 1);
      wr4 : (SIZEOF(QUERY ( md <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MATERIAL_DESIGNATION.DEFINITIONS') | (SIZEOF(
                QUERY ( pd <* QUERY ( defs <* md.definitions | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION') IN TYPEOF(defs)) ) | (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | ((pdr\product_definition_relationship.name = 'material assembly relationship') AND (pdr\product_definition_relationship.
                description = 'terminal core material') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(pdr))) )) = 1) )) = 1) )) 
                = 1);
      wr5 : (SIZEOF(QUERY ( md <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MATERIAL_DESIGNATION.DEFINITIONS') | (SIZEOF(
                QUERY ( pd <* QUERY ( defs <* md.definitions | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION') IN TYPEOF(defs)) ) | (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                 | ((pdr\product_definition_relationship.name = 'material assembly relationship') AND (pdr.
                description = 'terminal surface material') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(pdr))) )) = 1) )) = 1) )) 
                = 1);
      wr6 : (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'member connected terminal') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_CONNECTED_TERMINALS_DEFINITION') IN TYPEOF(mct.
                relating_shape_aspect)) )) <= 1);
      wr7 : ((NOT (SELF\shape_aspect.description = 
                'altered package terminal')) OR (SIZEOF(QUERY ( mct <* 
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name IN ['length trimmed preparation',
                'shape formed preparation','surface preparation']) ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PACKAGE_TERMINAL') IN TYPEOF(mct.relating_shape_aspect)) )) 
                = 1));
      wr8 : ((NOT (SELF\shape_aspect.description = 
                'altered package terminal')) OR (SELF.of_shape.definition\
                product_definition.description = 'altered package'));
      wr9 : ((NOT (SELF\shape_aspect.description = 
                'length trimmed terminal')) OR (SIZEOF(QUERY ( pd <* 
                USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) )) = 2) )) =
                 1)) )) = 0));
      wr10: ((NOT (SELF\shape_aspect.description = 
                'length trimmed terminal')) OR (SIZEOF(QUERY ( pd <* 
                USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'maximum trimmed length')) )) = 1) )) = 1)) )) = 0));
      wr11: ((NOT (SELF\shape_aspect.description = 
                'length trimmed terminal')) OR (SIZEOF(QUERY ( pd <* 
                USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum trimmed length')) )) = 1) )) = 1)) )) = 0));
      wr12: ((NOT (SELF\shape_aspect.description = 'shape formed terminal')) 
                OR (SIZEOF(QUERY ( ada <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EE_SPECIFICATION') IN TYPEOF(ada.assigned_document)) AND (
                ada.assigned_document.kind.product_data_type = 
                'lead form specification') AND (SIZEOF(QUERY ( dr <* 
                USEDIN(ada.assigned_document,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT') | (dr.
                relating_document.kind.product_data_type = 
                'material specification') )) = 1)) )) = 1));
      wr13: ((NOT (SELF\shape_aspect.description = 
                'surface prepped terminal')) OR (SIZEOF(QUERY ( ada <* 
                USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EE_SPECIFICATION') IN TYPEOF(ada.assigned_document)) AND (
                ada.assigned_document.kind.product_data_type = 
                'surface finish specification')) )) = 1));
      wr14: ((NOT (SELF\shape_aspect.description = 'wire terminal')) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_UNIT') IN TYPEOF(it\measure_with_unit.
                unit_component))) )) = 2) )) = 1)) )) = 0));
      wr15: ((NOT (SELF\shape_aspect.description = 'wire terminal')) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name 
                = 'maximum wire terminal length') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_UNIT') IN TYPEOF(it\measure_with_unit.
                unit_component))) )) = 1) )) = 1)) )) = 0));
      wr16: ((NOT (SELF\shape_aspect.description = 'wire terminal')) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it\representation_item.name 
                = 'minimum wire terminal length') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_UNIT') IN TYPEOF(it\measure_with_unit.
                unit_component))) )) = 1) )) = 1)) )) = 0));
      wr17: ((NOT (SELF\shape_aspect.description = 'wire terminal')) OR (
                SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'internal connection zone') AND (sar.
                related_shape_aspect\shape_aspect.description = 'connection zone')) )) =
                 1));
      wr18: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'external connection zone') AND (sar.
                related_shape_aspect\shape_aspect.description = 'connection zone')) )) =
                 1);
      wr19: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( lmwu <* QUERY ( it <* pdr.used_representation.items
                 | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) ) | (lmwu.
                name = 'maximum terminal diametrical extent') )) <= 1) )) 
                <= 1) )) <= 1);
      wr20: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
                USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( lmwu <* QUERY ( it <* pdr.used_representation.items
                 | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) ) | (lmwu.
                name = 'minimum terminal diametrical extent') )) <= 1) )) 
                <= 1) )) <= 1);
  END_ENTITY; -- package_terminal

  ENTITY packaged_component
    SUBTYPE OF (component_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( ip <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'instantiated part') ) | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(ip.
               relating_product_definition)) = 1) AND (ip.
               relating_product_definition.frame_of_reference.name = 
               'physical design usage')) )) = 1);
      wr2: (SIZEOF(QUERY ( pa <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'package alternate') ) | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGE'] * TYPEOF(pa.
               relating_product_definition)) = 1) AND (pa.
               relating_product_definition\product_definition.description = 'altered package')) )) 
               <= 1);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.description = 
               'packaged component join terminal')) )) >= 1)) )) = 0);
      wr4: ((NOT (SELF.description = 'packaged connector component')) OR (
               SIZEOF(QUERY ( ip <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'instantiated part') ) | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(ip.
               relating_product_definition)) = 1) AND (ip.
               relating_product_definition.frame_of_reference.name = 
               'packaged connector')) )) = 1));
      wr5: ((NOT (SELF.description = 'packaged connector component')) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.description = 
               'packaged component join terminal')) )) >= 1)) )) = 0));
      wr6: ((NOT (SELF.description = 'routed packaged component')) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (SIZEOF(QUERY ( pd <* USEDIN(sa,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1) )) = 
               1) )) = 1)) )) = 0));
  END_ENTITY; -- packaged_component

  ENTITY packaged_connector
    SUBTYPE OF (packaged_part);
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP') IN TYPEOF(sa)) )) 
               = 1) )) >= 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (SIZEOF(QUERY ( sar <* USEDIN(sa,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'interface plane') )) = 1) )) = 1) )) <= 1);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SEATING_PLANE') IN TYPEOF(sa)) )) = 1) )) <= 1);
  END_ENTITY; -- packaged_connector

  ENTITY packaged_connector_terminal_relationship
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    WHERE
      wr1: ((SIZEOF(TYPEOF(SELF.of_shape.definition) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART']) = 1) AND (SELF.of_shape.
               definition\product_definition.description = 
               'packaged connector'));
      wr2: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART_TERMINAL') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect)) AND (SELF\
               shape_aspect_relationship.related_shape_aspect\shape_aspect.description =
                'interface terminal'));
      wr3: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART_TERMINAL') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect)) AND (SELF\
               shape_aspect_relationship.related_shape_aspect\shape_aspect.description =
                'join terminal'));
  END_ENTITY; -- packaged_connector_terminal_relationship

  ENTITY packaged_part
    SUPERTYPE OF (packaged_connector)
    SUBTYPE OF (physical_unit);
    WHERE
      wr1: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART_TERMINAL') IN TYPEOF(sa)) )) >= 2)) )) = 0));
      wr2: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1));
      wr3: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( ifu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'implemented function') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'FUNCTIONAL_UNIT') IN TYPEOF(ifu.relating_product_definition)) 
               AND (ifu.relating_product_definition.frame_of_reference.name 
               = 'functional design usage')) )) = 1));
      wr4: ((NOT (SELF.frame_of_reference.name = 'physical design usage')) 
               OR (SIZEOF(QUERY ( upkg <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'used package') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE') IN TYPEOF(upkg.relating_product_definition)) )) =
                1));
      wr5: ((NOT (SELF.description = 'altered packaged part')) OR (SIZEOF(
               QUERY ( bpp <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'base packaged part') ) | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(bpp.
               relating_product_definition)) = 1) AND (bpp.
               relating_product_definition.frame_of_reference.name = 
               'physical design usage')) )) >= 1));
      wr6: ((NOT (SELF.description = 'altered packaged part')) OR (SIZEOF(
               QUERY ( upkg <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'used package') ) | (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(upkg.
               relating_product_definition)) = 1) )) >= 1));
  END_ENTITY; -- packaged_part

  ENTITY packaged_part_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF\shape_aspect.description IN ['interface terminal',
               'join terminal']);
      wr2: ((SIZEOF(TYPEOF(SELF.of_shape.definition) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_PACKAGED_PART',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LIBRARY_DEFINED_PACKAGED_PART']) = 1) AND (SELF.of_shape.
               definition\product_definition.frame_of_reference.name = 
               'physical design usage'));
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )) 
               >= 1)) )) = 0);
      wr4: (SIZEOF(QUERY ( top <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'terminal of package') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_TERMINAL') IN TYPEOF(top.related_shape_aspect)) )) 
               = 1);
      wr5: (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'member connected terminal') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_CONNECTED_TERMINALS_DEFINITION') IN TYPEOF(mct.
               relating_shape_aspect)) )) <= 1);
      wr6: ((NOT (SELF\shape_aspect.description = 'interface terminal')) 
               OR (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP') IN TYPEOF(sar)) 
               AND (sar.relating_shape_aspect\shape_aspect.description = 'join terminal')) )) 
               >= 1));
      wr7: ((NOT (SELF\shape_aspect.description = 'join terminal')) OR (
               SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP') IN TYPEOF(sar)) 
               AND (sar.relating_shape_aspect\shape_aspect.description = 
               'interface terminal')) )) <= 1));
  END_ENTITY; -- packaged_part_terminal

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: (focal_dist <> 0);
  END_ENTITY; -- parabola

  ENTITY parallelism_tolerance
    SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
    WHERE
      wr1: (SELF\geometric_tolerance.name = 'parallelism');
  END_ENTITY; -- parallelism_tolerance

  ENTITY parameter_assignment_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: (SIZEOF(SELF.items) = 2);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | ((it\representation_item.name = 
               'assigned parameter') AND (SIZEOF(TYPEOF(it) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODEL_PARAMETER',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM']) = 1)) )) = 1);
  END_ENTITY; -- parameter_assignment_representation

  ENTITY parameter_type
    SUBTYPE OF (group);
    WHERE
      wr1: (SELF\group.name IN ['string property type',
               'logical property type','physical property type',
               'boolean property type']);
  END_ENTITY; -- parameter_type

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY part_connected_terminals_definition
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1: (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'member connected terminal') ) | (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_MODULE_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'BARE_DIE_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'INTERCONNECT_MODULE_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGED_PART_TERMINAL'] * TYPEOF(mct.related_shape_aspect)) 
               = 1) )) >= 2);
  END_ENTITY; -- part_connected_terminals_definition

  ENTITY part_mounting_feature
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
               name = 'mounting area') AND (sar.related_shape_aspect\shape_aspect.
               description = 'connection zone')) )) = 1);
  END_ENTITY; -- part_mounting_feature

  ENTITY part_template_definition
    SUBTYPE OF (shape_aspect, externally_defined_item);
    WHERE
      wr1 : (SELF\shape_aspect.of_shape\property_definition.definition.
                frame_of_reference\application_context_element.name = 
                'template definition');
      wr2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'ANALYTICAL_MODEL') IN TYPEOF(pdr.used_representation)) AND
                 (pdr.used_representation\representation.name = 
                'part template analytical model')) )) <= 1)) )) = 0);
      wr3 : ((NOT (SELF.description = 
                'component termination passage template')) OR (SIZEOF(
                QUERY ( ctpt <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'component termination passage technology') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(ctpt.relating_shape_aspect)) 
                AND (ctpt.relating_shape_aspect\shape_aspect.description = 
                'default component termination passage definition')) )) = 1));
      wr4 : ((NOT (SELF.description = 
                'component termination passage template')) OR (SIZEOF(
                QUERY ( am <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'access mechanism') ) | (am.related_shape_aspect\shape_aspect.
                description IN ['component termination passage template interface terminal',
                'component termination passage template join terminal']) )) 
                >= 2));
      wr5 : ((NOT (SELF.description = 'default trace template')) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( tu <* 
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                 | (pdr\property_definition_relationship.name = 'technology usage') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STRATUM_TECHNOLOGY') IN TYPEOF(tu.
                relating_property_definition.definition)) )) = 1) )) = 1));
      wr6 : ((NOT (SELF.description = 'inter stratum feature template')) 
                OR (SIZEOF(QUERY ( isfpt <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'inter stratum feature passage technology') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(isfpt.relating_shape_aspect)) )) 
                = 1));
      wr7 : ((NOT (SELF.description = 'printed connector template')) OR (
                SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name IN ['connector interface terminal',
                'connector join terminal']) )) >= 1));
      wr8 : ((NOT (SELF.description = 
                'printed part cross section template')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'ANALYTICAL_MODEL') IN TYPEOF(pdr.used_representation)) AND
                 (pdr.used_representation\representation.name = 'transmission line model')) )) 
                = 1)) )) = 0));
      wr9 : ((NOT (SELF.description = 
                'printed part cross section template')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) )) = 2) )) =
                 1)) )) = 0));
      wr10: ((NOT (SELF.description = 
                'printed part cross section template')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'maximum width')) )) = 1) )) = 1)) )) = 0));
      wr11: ((NOT (SELF.description = 
                'printed part cross section template')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
                QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum width')) )) = 1) )) = 1)) )) = 0));
      wr12: ((NOT (SELF.description = 
                'printed part cross section template')) OR (SIZEOF(
                QUERY ( am <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'access mechanism') ) | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL') IN TYPEOF(
                am.related_shape_aspect)) )) >= 2));
      wr13: ((NOT (SELF.description = 'printed part template')) OR (
                SIZEOF(QUERY ( impl_func <* QUERY ( pdr <* USEDIN(SELF.
                of_shape.definition,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP.' + 
                'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 
                'implemented function') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'FUNCTIONAL_UNIT') IN TYPEOF(impl_func.
                relating_product_definition)) AND (impl_func.
                relating_product_definition.frame_of_reference.name = 
                'functional design usage')) )) = 1));
      wr14: ((NOT (SELF.description = 'printed part template')) OR (
                SIZEOF(QUERY ( cs <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'cross section') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PART_TEMPLATE_DEFINITION') IN TYPEOF(cs.
                relating_shape_aspect)) AND (cs.relating_shape_aspect\shape_aspect.
                description = 'printed part cross section template')) )) <=
                 1));
      wr15: ((NOT (SELF.description = 'printed part template')) OR (
                SIZEOF(QUERY ( ad <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'associated definition') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(ad.
                related_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect.
                description IN ['interface terminal','join terminal'])) )) 
                >= 2));
--tt this rule corrected to agree with mapping table 
      wr16: ((NOT (SELF.description = 'trace template')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
--tt this segment to be added
                  pdr.used_representation\representation.name = 'curve style parameters'
--tt this segment can be tossed
(*
                (SIZEOF(QUERY ( si <* QUERY ( it <* pdr.used_representation.items
                 | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'STYLED_ITEM') IN TYPEOF(it)) ) | ((si\representation_item.name = 'trace style') 
                AND (SIZEOF(QUERY ( psa <* si.styles | (NOT (SIZEOF(
                QUERY ( sty <* psa.styles | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'CURVE_STYLE') IN TYPEOF(sty)) )) = 1)) )) = 0)) )) = 1) 
*)
                )) 
                = 1)) )) = 0));
      wr17: ((NOT (SELF.description = 'unsupported passage template')) OR 
                (SIZEOF(QUERY ( upt <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'unsupported passage technology') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(upt.relating_shape_aspect)) 
                AND (upt.relating_shape_aspect\shape_aspect.description = 
                'default unsupported passage definition')) )) = 1));
      wr18: ((NOT (SELF.description = 'via template')) OR (SIZEOF(
                QUERY ( vpt <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'via passage technology') ) | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PASSAGE_TECHNOLOGY') IN TYPEOF(vpt.relating_shape_aspect)) 
                AND (vpt.relating_shape_aspect\shape_aspect.description = 
                'default via definition')) )) = 1));
      wr19: ((NOT (SELF.description = 'via template')) OR (SIZEOF(
                QUERY ( am <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'access mechanism') ) | (am.related_shape_aspect\shape_aspect.
                description = 'via template terminal') )) >= 2));
      wr20: (SIZEOF(QUERY ( esr <* USEDIN(SELF.source,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EXTERNAL_SOURCE_RELATIONSHIP.RELATING_SOURCE') | (esr.name 
                = 'revision') )) = 1);
  END_ENTITY; -- part_template_definition

  ENTITY part_text_template_definition
    SUBTYPE OF (part_template_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( it <* pdr.used_representation.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TEXT_LITERAL') IN TYPEOF(it)) )) = 1) )) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
               = 'maximum font vertical extent')) )) = 1) )) = 1)) )) = 0);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( it <* pdr.used_representation.items | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
               = 'maximum font horizontal extent')) )) = 1) )) = 1)) )) = 0);
  END_ENTITY; -- part_text_template_definition

  ENTITY part_tooling_feature
    SUPERTYPE OF (fiducial_part_feature)
    SUBTYPE OF (shape_aspect);
  END_ENTITY; -- part_tooling_feature

  ENTITY passage_technology
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1 : (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION') IN TYPEOF(SELF.of_shape.definition));
      wr2 : (SIZEOF(USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1);
      wr3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') )) = 1)) )) = 0);
      wr4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT ((1 <= 
                SIZEOF(pcr.used_representation.items)) AND (SIZEOF(pcr.
                used_representation.items) <= 8))) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | (NOT (
                it\representation_item.name IN ['maximum aspect ratio','plated passage',
                'maximum allowed component terminal extent',
                'minimum allowed component terminal extent',
                'maximum as finished deposition thickness',
                'minimum as finished deposition thickness',
                'maximum as finished passage extent',
                'minimum as finished passage extent'])) )) = 0)) )) = 0)) )) 
                = 0);
      wr6 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'RATIO_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'maximum aspect ratio') AND (it\measure_with_unit.
                value_component > 1)) )) <= 1)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
                name = 'plated passage') AND (it.description IN ['true',
                'false'])) )) = 1)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum as finished passage extent')) )) <= 1)) )) = 0)) )) 
                = 0);
      wr9 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'maximum as finished deposition thickness')) )) <= 1)) )) 
                = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum as finished deposition thickness')) )) <= 1)) )) 
                = 0)) )) = 0);
      wr11: ((NOT (SELF\shape_aspect.description IN [
                'default component termination passage definition',
                'default via definition'])) OR (SIZEOF(USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MATERIAL_DESIGNATION.DEFINITIONS')) = 1));
      wr12: ((NOT (SELF\shape_aspect.description IN [
                'default component termination passage definition',
                'default unsupported passage definition',
                'default via definition'])) OR (SIZEOF(QUERY ( pd <* 
                USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum as finished passage extent')) )) = 1)) )) = 0)) )) 
                = 0));
      wr13: ((NOT (SELF\shape_aspect.description = 
                'default component termination passage definition')) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum as finished deposition thickness')) )) = 1)) )) 
                = 0)) )) = 0));
      wr14: ((NOT (SELF\shape_aspect.description = 
                'default component termination passage definition')) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum allowed component terminal extent')) )) = 1)) )) 
                = 0)) )) = 0));
      wr15: ((NOT (SELF\shape_aspect.description = 
                'default component termination passage definition')) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'maximum allowed component terminal extent')) )) = 1)) )) 
                = 0)) )) = 0));
      wr16: ((NOT (SELF\shape_aspect.description = 
                'default via definition')) OR (SIZEOF(QUERY ( pd <* USEDIN(
                SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum as finished deposition thickness')) )) = 1)) )) 
                = 0)) )) = 0));
      wr17: (SIZEOF(QUERY ( rpt <* QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
                name = 'as finished inter stratum extent') ) | ((rpt.
                related_shape_aspect.of_shape\property_definition.
                description = 'finished stratum extent') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(rpt.
                related_shape_aspect.of_shape\property_definition.
                definition)) AND (rpt.related_shape_aspect.of_shape\
                property_definition.definition.name = 
                'inter stratum extent')) )) = 1);
  END_ENTITY; -- passage_technology

  ENTITY path
    SUPERTYPE OF (ONEOF (edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' 
               IN TYPEOF(reference_to_curve\representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- pcurve

  ENTITY perpendicularity_tolerance
    SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
    WHERE
      wr1: (SELF\geometric_tolerance.name = 'perpendicularity');
  END_ENTITY; -- perpendicularity_tolerance

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    UNIQUE
      ur1 : id;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
  END_ENTITY; -- person_and_organization_role

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
      assigned_person : person;
      role            : person_role;
  END_ENTITY; -- person_assignment

  ENTITY person_role;
      name : label;
  END_ENTITY; -- person_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : text;
  END_ENTITY; -- personal_address

  ENTITY physical_connectivity_definition
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1: (SIZEOF(QUERY ( at <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated terminals') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(at.related_shape_aspect)) )) 
               > 1);
      wr2: (SIZEOF(QUERY ( pdr <* USEDIN(SELF.of_shape.definition,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'connectivity allocation') )) <= 1);
  END_ENTITY; -- physical_connectivity_definition

  ENTITY physical_connectivity_element
    SUBTYPE OF (shape_aspect_relationship, shape_aspect);
    WHERE
      wr1: ((SELF.relating_shape_aspect\shape_aspect.description = 
               'topological junction') XOR (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CONNECTIVITY_SUB_STRUCTURE'] * TYPEOF(SELF.
               relating_shape_aspect)) = 1));
      wr2: ((SELF.related_shape_aspect\shape_aspect.description = 
               'topological junction') XOR (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CONNECTIVITY_SUB_STRUCTURE'] * TYPEOF(SELF.
               related_shape_aspect)) = 1));
      wr3: (SIZEOF(QUERY ( se <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'structure element') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(se.
               relating_shape_aspect)) )) = 1);
      wr4: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT') IN TYPEOF(SELF.of_shape.definition)) AND (
               SELF.of_shape.definition\product_definition.
               frame_of_reference.name = 'physical design'));
  END_ENTITY; -- physical_connectivity_element

  ENTITY physical_network
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1: (SIZEOF(QUERY ( cr <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'connectivity requirement') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(cr.related_shape_aspect)) )) 
               >= 2);
      wr2: (SIZEOF(QUERY ( nt <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'network topology') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(nt.related_shape_aspect)) )) 
               >= 1);
  END_ENTITY; -- physical_network

  ENTITY physical_unit
    SUPERTYPE OF (ONEOF (bare_die,package,packaged_part,
        assembly_definition,interconnect_definition))
    SUBTYPE OF (product_definition);
    WHERE
      wr1 : ((NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS') IN TYPEOF(
                SELF))) OR (SIZEOF(QUERY ( docs <* SELF\
                product_definition_with_associated_documents.
                documentation_ids | (docs.kind.product_data_type = 
                'CAD filename') )) <= 1));
      wr2 : ((SIZEOF(QUERY ( adta <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adta.role.name 
                = 'creation date') )) + SIZEOF(QUERY ( ada <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_DATE_ASSIGNMENT.ITEMS') | (ada.role.name = 
                'creation date') ))) = 1);
      wr3 : (SIZEOF(USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1);
      wr4 : ((SIZEOF(QUERY ( apoa <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | (apoa
                .role.name = 'creator') )) + SIZEOF(QUERY ( apoa <* USEDIN(
                SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (apoa.role.name 
                = 'creator') ))) >= 1);
      wr5 : (SIZEOF(USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1);
      wr6 : (SELF.frame_of_reference.name IN ['physical design',
                'physical design usage']);
      wr7 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.name = 
                'unit technology') )) <= 1);
      wr8 : ((NOT ((SELF.frame_of_reference.name = 'physical design') AND 
                (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( du <* QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP.' + 
                'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 'design usage') )
                 | ((du.relating_product_definition.frame_of_reference.name 
                = 'physical design usage') AND (SIZEOF(QUERY ( prpc <* 
                USEDIN(du.related_product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1)) )) = 1));
      wr9 : ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( sa <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(sa)) )) >= 2)) )) = 0));
      wr10: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'maximum negative component height') )) <= 1)) )) = 0));
      wr11: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'maximum positive component height') )) <= 1)) )) = 0));
      wr12: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP.' + 
                'RELATED_PRODUCT_DEFINITION') | ((pdr\product_definition_relationship.name = 
                'implemented function') AND (pdr.
                relating_product_definition.frame_of_reference.name = 
                'functional design usage')) )) = 1));
      wr13: ((NOT ((SELF.frame_of_reference.name = 'physical design') AND 
                (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'assembly module') )) >= 1))) OR (
                SIZEOF(QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP.' + 
                'RELATED_PRODUCT_DEFINITION') | (pdr.
                relating_product_definition\product_definition.description = 
                'laminate component') )) = 0));
      wr14: ((NOT ((SELF.frame_of_reference.name = 'physical design') AND 
                (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( du <* QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP.' + 
                'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 'design usage') )
                 | ((du.relating_product_definition.frame_of_reference.name 
                = 'physical design usage') AND (SIZEOF(QUERY ( prpc <* 
                USEDIN(du.related_product_definition.formation.of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1)) )) 
                = 1));
      wr15: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP.' + 
                'RELATED_PRODUCT_DEFINITION') | ((pdr\product_definition_relationship.name = 
                'implemented function') AND (pdr.
                relating_product_definition.frame_of_reference.name = 
                'functional design usage')) )) = 1));
      wr16: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd1 <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_SHAPE') IN TYPEOF(pd1)) AND (SIZEOF(
                QUERY ( cd <* USEDIN(pd1,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT.OF_SHAPE') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'CHARACTERIZED_DEFINITION') IN TYPEOF(cd)) AND (SIZEOF(
                QUERY ( pd2 <* USEDIN(cd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | ((pd2\property_definition.name = 
                'located interconnect module thickness') AND (SIZEOF(
                USEDIN(pd2,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) > 1)) )) 
                = 1)) )) = 1)) )) <= 1));
      wr17: ((NOT (SELF.frame_of_reference.name = 'physical design')) OR (
                SIZEOF(QUERY ( du <* QUERY ( pdr <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_DEFINITION_RELATIONSHIP.' + 
                'RELATED_PRODUCT_DEFINITION') | (pdr\product_definition_relationship.name = 'design usage') )
                 | (du.relating_product_definition.frame_of_reference.name 
                = 'physical design usage') )) = 1));
      wr18: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.name = 
                'interconnect module usage view physical characteristics') )) 
                <= 1));
      wr19: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.name = 
                'interconnect module usage view physical characteristics') 
                AND (SIZEOF(QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 
                'minimum thickness over metal requirement') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(pdr.
                used_representation))) )) <= 1)) )) <= 1));
      wr20: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.name = 
                'interconnect module usage view physical characteristics') 
                AND (SIZEOF(QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 
                'maximum thickness over metal requirement') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(pdr.
                used_representation))) )) <= 1)) )) <= 1));
      wr21: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.name = 
                'interconnect module usage view physical characteristics') 
                AND (SIZEOF(QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 
                'minimum thickness over dielectric requirement') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(pdr.
                used_representation))) )) <= 1)) )) <= 1));
      wr22: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.name = 
                'interconnect module usage view physical characteristics') 
                AND (SIZEOF(QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
                used_representation\representation.name = 
                'maximum thickness over dielectric requirement') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(pdr.
                used_representation))) )) <= 1)) )) <= 1));
      wr23: ((NOT ((SELF.frame_of_reference.name = 'physical design usage') 
                AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.
                of_product,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
                product_category.name = 'interconnect module') )) >= 1))) 
                OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.name = 'restraint') 
                OR (pd\property_definition.name = 'tolerance specific restraint')) )) <= 1));
  END_ENTITY; -- physical_unit

  ENTITY physical_unit_datum
    SUPERTYPE OF (edge_segment_vertex)
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1 : (SELF\shape_aspect.description IN ['axis','plane','point','']);
      wr2 : (SELF\shape_aspect.product_definitional = FALSE);
      wr3 : (SELF\shape_aspect.name IN ['single datum','common datum','']);
      wr4 : ((NOT (SELF\shape_aspect.name = 'common datum')) OR (SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'datum feature usage in datum system') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DATUM_SYSTEM') IN TYPEOF(sar))) )) >= 1));
      wr5 : ((NOT (SELF\shape_aspect.name = 'common datum')) OR (SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'datum feature usage in common datum') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DATUM_SYSTEM') IN TYPEOF(sar))) )) >= 2));
      wr6 : ((NOT ((SELF\shape_aspect.description = 'axis') AND (SELF\
                shape_aspect.name IN ['common datum','single datum']))) OR 
                (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((NOT (
                sar\shape_aspect_relationship.name = 'reference axis')) AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DATUM_REFERENCE_FRAME') IN TYPEOF(sar))) )) = 1));
      wr7 : ((NOT ((SELF\shape_aspect.description = 'plane') AND (SELF\
                shape_aspect.name IN ['common datum','single datum']))) OR 
                (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((NOT (
                sar\shape_aspect_relationship.name = 'reference plane')) AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DATUM_REFERENCE_FRAME') IN TYPEOF(sar))) )) = 1));
      wr8 : ((NOT ((SELF\shape_aspect.description = 'point') AND (SELF\
                shape_aspect.name IN ['common datum','single datum']))) OR 
                (SIZEOF(QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((NOT (
                sar\shape_aspect_relationship.name = 'reference origin')) AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DATUM_REFERENCE_FRAME') IN TYPEOF(sar))) )) = 1));
      wr9 : ((NOT (SELF\shape_aspect.name = 'single datum')) OR (SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'datum usage in datum system') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DATUM_SYSTEM') IN TYPEOF(sar))) )) >= 1));
      wr10: ((NOT (SELF\shape_aspect.name = 'single datum')) OR (SIZEOF(
                QUERY ( sar <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
                name = 'datum feature usage in single datum') AND ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DATUM_SYSTEM') IN TYPEOF(sar))) )) = 1));
      wr11: (NOT ((SELF\shape_aspect.name IN ['']) AND (SELF\shape_aspect.
                description IN [''])));
      wr12: ((NOT (SELF\shape_aspect.description = 'plane')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
                'datum direction property') )) <= 2));
  END_ENTITY; -- physical_unit_datum

  ENTITY physical_unit_datum_feature
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.' + 'DEFINITION') | (pd\property_definition.description = 
               'datum feature identification') )) = 1);
      wr2: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name IN ['datum feature usage in common datum',
               'datum feature usage in single datum']) )) >= 1);
      wr3: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'datum feature usage in single datum') )) <= 1);
  END_ENTITY; -- physical_unit_datum_feature

  ENTITY physical_unit_datum_target
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'datum target usage') )) >= 1);
  END_ENTITY; -- physical_unit_datum_target

  ENTITY physical_unit_datum_target_set
    SUBTYPE OF (physical_unit_datum_feature);
    WHERE
      wr1: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'datum target usage') )) >= 1);
      wr2: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'constituent') )) = 0);
  END_ENTITY; -- physical_unit_datum_target_set

  ENTITY physical_unit_geometric_tolerance
    SUBTYPE OF (geometric_tolerance, property_definition);
    WHERE
      wr1: (SELF\geometric_tolerance.name = SELF\property_definition.name);
      wr2: (SELF\geometric_tolerance.toleranced_shape_aspect = SELF\
               property_definition.definition);
      wr3: ((NOT (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LINEAR_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITION_TOLERANCE'] * TYPEOF(SELF)) = 0)) OR (SELF\
               geometric_tolerance.name IN ['circularity','cylindricity',
               'flatness','straightness']));
      wr4: ((NOT (SELF\geometric_tolerance.name = 'circularity')) OR (NOT 
               (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF))));
      wr5: ((NOT (SELF\geometric_tolerance.name = 'cylindricity')) OR (
               NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF))));
      wr6: ((NOT (SELF\geometric_tolerance.name = 'flatness')) OR (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF))));
      wr7: (SIZEOF(QUERY ( pugt <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'group geometric tolerance') ) | (pugt.
               relating_shape_aspect\shape_aspect.description = 
               'simultaneous requirement') )) <= 1);
  END_ENTITY; -- physical_unit_geometric_tolerance

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY planar_extent
    SUBTYPE OF (geometric_representation_item);
      size_in_x : length_measure;
      size_in_y : length_measure;
  END_ENTITY; -- planar_extent

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE_ANGLE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- plane_angle_measure_with_unit

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- plane_angle_unit

  ENTITY plated_cutout_edge_segment
    SUBTYPE OF (cutout_edge_segment, plated_inter_stratum_feature);
    WHERE
      wr1: (SELF.description IN ['plated cutout edge segment']);
      wr2: (SIZEOF(QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(ji.relating_shape_aspect)) 
               AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join')) )) 
               <= 1);
      wr3: ((NOT (SELF.description = 'plated cutout edge segment')) OR (
               SIZEOF(QUERY ( cc <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'composed cutout') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PLATED_INTER_STRATUM_FEATURE') IN TYPEOF(cc.
               relating_shape_aspect)) AND (cc.relating_shape_aspect\shape_aspect.
               description = 'plated cutout')) )) = 1));
  END_ENTITY; -- plated_cutout_edge_segment

  ENTITY plated_inter_stratum_feature
    SUPERTYPE OF (ONEOF (plated_passage,plated_cutout_edge_segment,
        plated_interconnect_module_edge_segment))
    SUBTYPE OF (inter_stratum_feature);
    WHERE
      wr1: ((SELF.description IN ['bonded conductive base blind via',
               'buried via','component termination passage',
               'interfacial connection','non conductive base blind via',
               'plated conductive base blind via','plated cutout',
               'plated interconnect module edge']) OR (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PLATED_CUTOUT_EDGE_SEGMENT',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PLATED_INTERCONNECT_MODULE_EDGE_SEGMENT'] * TYPEOF(SELF)) =
                1));
      wr2: (SIZEOF(QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(ji.relating_shape_aspect)) 
               AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join')) )) 
               <= 1);
  END_ENTITY; -- plated_inter_stratum_feature

  ENTITY plated_interconnect_module_edge_segment
    SUBTYPE OF (interconnect_module_edge_segment, 
        plated_inter_stratum_feature);
    WHERE
      wr1: (SELF.description IN ['plated interconnect module edge segment']);
      wr2: (SIZEOF(QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(ji.relating_shape_aspect)) 
               AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join')) )) 
               <= 1);
      wr3: ((NOT (SELF.description = 
               'plated interconnect module edge segment')) OR (SIZEOF(
               QUERY ( ce <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'composed edge') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PLATED_INTER_STRATUM_FEATURE') IN TYPEOF(ce.
               relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.
               description = 'plated interconnect module edge')) )) = 1));
  END_ENTITY; -- plated_interconnect_module_edge_segment

  ENTITY plated_passage
    SUBTYPE OF (plated_inter_stratum_feature);
    WHERE
      wr1: (SELF.description IN ['bonded conductive base blind via',
               'buried via','component termination passage',
               'interfacial connection','non conductive base blind via',
               'plated conductive base blind via']);
      wr2: ((NOT (SELF.description = 'bonded conductive base blind via')) 
               OR (SIZEOF(QUERY ( fj <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'features join') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_CONCEPT_RELATIONSHIP') IN TYPEOF(fj.
               relating_shape_aspect)) AND (fj.relating_shape_aspect\shape_aspect.name =
                'stratum feature conductive join')) )) = 1));
      wr3: ((NOT (SELF.description = 'component termination passage')) OR 
               (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'instantiated template') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
               relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
               description = 'component termination passage template')) )) 
               = 1));
      wr4: ((NOT (SELF.description = 'component termination passage')) OR 
               (SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated component') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(ac.related_shape_aspect)) 
               AND (ac.related_shape_aspect\shape_aspect.description = 
               'component termination passage interface terminal')) )) = 1));
      wr5: ((NOT (SELF.description = 'component termination passage')) OR 
               (SIZEOF(QUERY ( ac <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated component') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(ac.related_shape_aspect)) 
               AND (ac.related_shape_aspect\shape_aspect.description = 
               'component termination passage join terminal')) )) >= 1));
      wr6: ((NOT (SELF.description IN ['bonded conductive base blind via',
               'buried via','interfacial connection',
               'non conductive base blind via',
               'plated conductive base blind via'])) OR (SIZEOF(
               QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'instantiated template') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
               relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
               description = 'via template')) )) = 1));
  END_ENTITY; -- plated_passage

  ENTITY plus_minus_tolerance;
      range                : tolerance_method_definition;
      toleranced_dimension : dimensional_characteristic;
    UNIQUE
      ur1 : toleranced_dimension;
  END_ENTITY; -- plus_minus_tolerance

  ENTITY point
    SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface,
        point_replica,degenerate_pcurve))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY; -- point_on_curve

  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY; -- point_on_surface

  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_pt.dim);
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY; -- point_replica

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY position_tolerance
    SUBTYPE OF (physical_unit_geometric_tolerance);
    WHERE
      wr1: ((NOT (SELF\geometric_tolerance.name = 
               'boundary based position')) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF)));
      wr2: ((NOT (SELF\geometric_tolerance.name = 
               'boundary based position')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM') IN 
               TYPEOF(gtr.related_geometric_tolerance)) AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               related_geometric_tolerance)) AND (gtr.
               related_geometric_tolerance.name IN ['surface profile',
               'surface profile locating','surface profile refinement']) 
               AND (gtr.name = 'profile control')) )) <= 1));
      wr3: ((NOT (SELF\geometric_tolerance.name = 
               'feature relating position')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')
                | ((gtr.name = 'position refining control') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITION_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND (gtr.
               relating_geometric_tolerance.name IN [
               'feature locating position','feature relating position'])) )) 
               = 1));
      wr4: ((NOT (SELF\geometric_tolerance.name = 
               'feature locating position')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITION_TOLERANCE') IN TYPEOF(gtr.
               related_geometric_tolerance)) AND (gtr.
               related_geometric_tolerance.name = 
               'feature relating position') AND (gtr.name = 
               'position refining control')) )) = 1));
      wr5: ((NOT (SELF\geometric_tolerance.name = 
               'feature relating position')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITION_TOLERANCE') IN TYPEOF(gtr.
               related_geometric_tolerance)) AND (gtr.
               related_geometric_tolerance.name = 
               'feature relating position') AND (gtr.name = 
               'position refining control')) )) <= 1));
  END_ENTITY; -- position_tolerance

  ENTITY positional_boundary
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF\shape_aspect.description IN [
               'dimension related positional boundary',
               'profile related positional boundary']);
      wr2: (SELF\shape_aspect.product_definitional = FALSE);
      wr3: ((NOT (SELF\shape_aspect.description = 
               'dimension related positional boundary')) OR (SIZEOF(
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITIONAL_BOUNDARY_MEMBER') IN TYPEOF(sar.
               related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'boundary member')) )) 
               >= 1));
      wr4: ((NOT (SELF\shape_aspect.description = 
               'dimension related positional boundary')) OR ((SIZEOF(
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar.
               related_shape_aspect.product_definitional = TRUE) AND (sar\shape_aspect_relationship.
               name = 'constrained feature')) )) + SIZEOF(QUERY ( sar <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(sar.
               related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'constrained feature')) ))) 
               = 1));
      wr5: ((NOT (SELF\shape_aspect.description = 
               'dimension related positional boundary')) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
               'dimension related positional boundary property') )) = 1));
      wr6: ((NOT (SELF\shape_aspect.description = 
               'profile related positional boundary')) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
               'profile related positional boundary property') )) = 1));
      wr7: ((NOT (SELF\shape_aspect.description = 
               'profile related positional boundary')) OR (SIZEOF(
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITIONAL_BOUNDARY_MEMBER') IN TYPEOF(sar.
               related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 
               'positional boundary and profile boundary member')) )) = 1));
  END_ENTITY; -- positional_boundary

  ENTITY positional_boundary_member
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF\shape_aspect.product_definitional = FALSE);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
               'positional boundary member property') )) = 1);
      wr3: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
               name = 'boundary member') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'POSITIONAL_BOUNDARY') IN TYPEOF(sar.relating_shape_aspect)) 
               AND (sar.relating_shape_aspect\shape_aspect.description = 
               'dimension related positional boundary')) )) = 1);
  END_ENTITY; -- positional_boundary_member

  ENTITY pre_defined_curve_font
    SUBTYPE OF (pre_defined_item);
  END_ENTITY; -- pre_defined_curve_font

  ENTITY pre_defined_item;
      name : label;
  END_ENTITY; -- pre_defined_item

  ENTITY precision_qualifier;
      precision_value : INTEGER;
  END_ENTITY; -- precision_qualifier

  ENTITY presentation_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: (SELF\representation.context_of_items\
               geometric_representation_context.coordinate_space_dimension 
               = 2);
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
  END_ENTITY; -- presentation_representation

  ENTITY presentation_style_assignment;
      styles : SET [1:?] OF presentation_style_select;
    WHERE
      wr1: (SIZEOF(QUERY ( style1 <* SELF.styles | (NOT (SIZEOF(
               QUERY ( style2 <* (SELF.styles - style1) | (NOT ((TYPEOF(
               style1) <> TYPEOF(style2)) OR (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_STYLE_USAGE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_STYLE'] * TYPEOF(style1)) = 1))) )) = 0)) )) 
               = 0);
      wr2: (SIZEOF(QUERY ( style1 <* SELF.styles | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_STYLE_USAGE' 
               IN TYPEOF(style1)) )) <= 2);
  END_ENTITY; -- presentation_style_assignment

  ENTITY presentation_style_by_context
    SUBTYPE OF (presentation_style_assignment);
      style_context : style_context_select;
  END_ENTITY; -- presentation_style_by_context

  ENTITY primary_orientation_feature
    SUBTYPE OF (physical_unit_datum_feature);
    WHERE
      wr1: (SELF\shape_aspect.product_definitional = TRUE);
      wr2: (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated body vertical extent') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_BODY_BOTTOM_SURFACE') IN TYPEOF(it.
               relating_shape_aspect)) )) <= 1);
      wr3: (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated body vertical extent') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_BODY_TOP_SURFACE') IN TYPEOF(it.
               relating_shape_aspect)) )) <= 1);
  END_ENTITY; -- primary_orientation_feature

  ENTITY primary_reference_terminal
    SUBTYPE OF (package_terminal);
  END_ENTITY; -- primary_reference_terminal

  ENTITY printed_component
    SUBTYPE OF (component_definition);
    WHERE
      wr1: (SELF.frame_of_reference.name = 'physical occurrence');
      wr2: (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pt_occ <* QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (sa\shape_aspect.description = 
               'part template occurrence') ) | (SIZEOF(QUERY ( it <* 
               QUERY ( sar <* USEDIN(pt_occ,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'instantiated template') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
               relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
               description IN ['printed part template',
               'printed part cross section template',
               'printed connector template'])) )) = 1) )) = 1)) )) = 0);
      wr4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL') IN TYPEOF(sa)) AND (sa\shape_aspect.description = 
               'printed component join terminal')) )) >= 1)) )) = 0);
      wr5: ((NOT (SELF.description = 
               'join 2 physical connectivity definition supporting')) OR (
               SIZEOF(QUERY ( propd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( ri <* 
               QUERY ( propdr <* USEDIN(propd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (propdr\property_definition_relationship.name = 'requirement implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP') IN TYPEOF(ri.
               relating_property_definition.definition)) AND (ri.
               relating_property_definition.definition.name = 
               'ordered physical connectivity definition') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(ri.
               relating_property_definition.definition.related_shape_aspect)) 
               AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(ri.
               relating_property_definition.definition.
               relating_shape_aspect))) )) = 1) )) = 1));
      wr6: ((NOT (SELF.description = 'printed connector component')) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(sa)) AND (sa\shape_aspect.description 
               = 'printed connector component interface terminal')) )) >= 1)) )) 
               = 0));
      wr7: ((NOT (SELF.description = 'printed connector component')) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pt_occ <* QUERY ( sa <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (sa\shape_aspect.description = 
               'part template occurrence') ) | (SIZEOF(QUERY ( it <* 
               QUERY ( sar <* USEDIN(pt_occ,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'instantiated template') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(it.
               relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.
               description = 'printed connector template')) )) = 1) )) = 1)) )) 
               = 0));
      wr8: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (SIZEOF(QUERY ( sar <* USEDIN(sa,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(sar.relating_shape_aspect)) AND
                (sar\shape_aspect_relationship.name = 'stratum feature implementation')) )) >= 1) )) 
               >= 1) )) >= 1);
  END_ENTITY; -- printed_component

  ENTITY printed_connector_template_terminal_relationship
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    WHERE
      wr1: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
               name = 'connector') AND (sar.relating_shape_aspect\shape_aspect.
               description = 'printed connector template')) )) = 1);
      wr2: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect)) AND (SELF\
               shape_aspect_relationship.related_shape_aspect\shape_aspect.description =
                'interface terminal'));
      wr3: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(SELF\
               shape_aspect_relationship.related_shape_aspect)) AND (SELF\
               shape_aspect_relationship.related_shape_aspect\shape_aspect.description =
                'join terminal'));
  END_ENTITY; -- printed_connector_template_terminal_relationship

  ENTITY printed_part_cross_section_template_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( am <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'access mechanism') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(am.
               relating_shape_aspect)) AND (am.relating_shape_aspect\shape_aspect.
               description = 'printed part cross section template')) )) = 1);
  END_ENTITY; -- printed_part_cross_section_template_terminal

  ENTITY printed_part_template_connected_terminals_definition
    SUBTYPE OF (shape_aspect);
    UNIQUE
      ur1 : SELF\shape_aspect.name;
    WHERE
      wr1: (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'member connected terminal') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(mct.
               related_shape_aspect)) AND (mct.related_shape_aspect\shape_aspect.
               description IN ['interface terminal','join terminal'])) )) 
               >= 2);
  END_ENTITY; -- printed_part_template_connected_terminals_definition

  ENTITY printed_part_template_terminal
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF.description IN ['interface terminal','join terminal']);
      wr2: (SIZEOF(QUERY ( ga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT.ITEMS') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY') 
               IN TYPEOF(ga.assigned_group)) )) = 1);
      wr3: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar.
               related_shape_aspect\shape_aspect.description = 'connection zone') )) >= 
               1);
      wr4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )) 
               >= 1)) )) = 0);
      wr5: (SIZEOF(QUERY ( ad <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated definition') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(ad.
               relating_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect.
               description = 'printed part template')) )) = 1);
      wr6: (SIZEOF(QUERY ( mct <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'member connected terminal') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION') IN 
               TYPEOF(mct.relating_shape_aspect)) )) <= 1);
  END_ENTITY; -- printed_part_template_terminal

  ENTITY printed_part_template_terminal_connection_zone_category
    SUBTYPE OF (group);
    WHERE
      wr1: (SELF\group.name IN ['area edge segment','curve edge segment',
               'surface area','surface point']);
  END_ENTITY; -- printed_part_template_terminal_connection_zone_category

  ENTITY probe_access_area
    SUBTYPE OF (component_shape_aspect);
    WHERE
      wr1: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition)) 
               AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF.of_shape.definition.
               formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
               product_category.name = 'interconnect module') )) >= 1));
      wr2: (SIZEOF(QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar.
               related_shape_aspect\shape_aspect.description = 'connection zone') )) = 1);
      wr3: (SIZEOF(QUERY ( pli <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'probed layout item') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(pli.related_shape_aspect)) )) =
                1);
      wr4: ((NOT (SELF\shape_aspect.description = 
               'internal probe access area')) OR (SIZEOF(QUERY ( i <* 
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'implementation') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(i.relating_shape_aspect)) )) = 
               1));
  END_ENTITY; -- probe_access_area

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : text;
      frame_of_reference : SET [1:?] OF product_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_concept;
      id             : identifier;
      name           : label;
      description    : text;
      market_context : product_concept_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product_concept

  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
      market_segment_type : label;
  END_ENTITY; -- product_concept_context

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
      usage : product_definition_relationship;
    UNIQUE
      ur1 : usage, SELF\effectivity.id;
  END_ENTITY; -- product_definition_effectivity

  ENTITY product_definition_formation;
      id          : identifier;
      description : text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_formation_relationship;
      id                                    : identifier;
      name                                  : label;
      description                           : text;
      relating_product_definition_formation : product_definition_formation;
      related_product_definition_formation  : product_definition_formation;
  END_ENTITY; -- product_definition_formation_relationship

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
  END_ENTITY; -- product_definition_formation_with_specified_source

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : SELF\property_definition.definition;
    WHERE
      wr1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_DEFINITION' 
               IN TYPEOF(SELF\property_definition.definition)));
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_usage
    SUPERTYPE OF (ONEOF (make_from_usage_option,assembly_component_usage))
    SUBTYPE OF (product_definition_relationship);
    UNIQUE
      ur1 : SELF\product_definition_relationship.id,
            SELF\product_definition_relationship.relating_product_definition,
            SELF\product_definition_relationship.related_product_definition;
    WHERE
      wr1: acyclic_product_definition_relationship(SELF,[SELF\
               product_definition_relationship.related_product_definition],'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_USAGE');
  END_ENTITY; -- product_definition_usage

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY; -- product_definition_with_associated_documents

  ENTITY product_material_composition_relationship
    SUBTYPE OF (product_definition_relationship);
      class                : label;
      constituent_amount   : SET [1:?] OF measure_with_unit;
      composition_basis    : label;
      determination_method : text;
  END_ENTITY; -- product_material_composition_relationship

  ENTITY product_related_characterized_product_category
    SUBTYPE OF (characterized_product_category, 
        product_related_product_category);
    WHERE
      wr1: (SIZEOF(SELF\product_related_product_category.products) = 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.description = 
               'product category parameter') AND (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODEL_PARAMETER',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MEASURE_REPRESENTATION_ITEM',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(pdr.
               used_representation)) = 1) )) = 1)) )) = 1);
      wr3: (SIZEOF(QUERY ( pcr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY') | ((pcr.
               description = 'product value assignment') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY') IN TYPEOF(pcr.category))) )) 
               = 1);
  END_ENTITY; -- product_related_characterized_product_category

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY projected_zone_definition
    SUBTYPE OF (tolerance_zone_definition);
      projection_end   : shape_aspect;
      projected_length : measure_with_unit;
    WHERE
      wr1: (projected_length.value_component > 0);
  END_ENTITY; -- projected_zone_definition

  ENTITY promissory_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- promissory_usage_occurrence

  ENTITY property_definition;
      name        : label;
      description : text;
      definition  : characterized_definition;
  END_ENTITY; -- property_definition

  ENTITY property_definition_relationship;
      name                         : label;
      description                  : text;
      relating_property_definition : property_definition;
      related_property_definition  : property_definition;
  END_ENTITY; -- property_definition_relationship

  ENTITY property_definition_representation;
      definition          : property_definition;
      used_representation : representation;
  END_ENTITY; -- property_definition_representation

  ENTITY qualitative_uncertainty
    SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : text;
  END_ENTITY; -- qualitative_uncertainty

  ENTITY quantified_assembly_component_usage
    SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
  END_ENTITY; -- quantified_assembly_component_usage

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY ratio_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- ratio_measure_with_unit

  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- ratio_unit

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list));
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1])));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY rectangular_composite_surface
    SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
    WHERE
      wr1: ([] = QUERY ( s <* segments | (n_v <> SIZEOF(s)) ));
      wr2: constraints_rectangular_composite_surface(SELF);
  END_ENTITY; -- rectangular_composite_surface

  ENTITY rectangular_trimmed_surface
    SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
      wr1: (u1 <> u2);
      wr2: (v1 <> v2);
      wr3: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE' 
               IN TYPEOF(basis_surface)) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' 
               IN TYPEOF(basis_surface)))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_OF_REVOLUTION' 
               IN TYPEOF(basis_surface)) OR (usense = (u2 > u1)));
      wr4: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPHERICAL_SURFACE' 
               IN TYPEOF(basis_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TOROIDAL_SURFACE' 
               IN TYPEOF(basis_surface)) OR (vsense = (v2 > v1)));
  END_ENTITY; -- rectangular_trimmed_surface

  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
    WHERE
      wr1: (param_length > 0);
  END_ENTITY; -- reparametrised_composite_curve_segment

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      wr1: (SELF\representation_relationship.rep_1.context_of_items :<>: 
               SELF\representation_relationship.rep_2.context_of_items);
  END_ENTITY; -- representation_relationship_with_transformation

  ENTITY requirement_allocation_group
    SUBTYPE OF (group, property_definition_relationship);
    WHERE
      wr1: (SIZEOF(QUERY ( aga <* QUERY ( ga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT') IN TYPEOF(ga)) ) | (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_FORMATION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'CONFIGURATION_ITEM'] * TYPEOF(aga.items)) = 1) )) = 1);
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(SELF\
               property_definition_relationship.
               relating_property_definition));
      wr3: ((NOT (SELF\property_definition_relationship.name = 
               'derived from operation')) OR (SELF\
               property_definition_relationship.
               relating_property_definition :=: SELF\
               property_definition_relationship.related_property_definition));
  END_ENTITY; -- requirement_allocation_group

  ENTITY requirements_property
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : SELF\property_definition.name;
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'requirements property composition') )) <= 1);
      wr2: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( it <* pdr.used_representation.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'requirements description')) )) = 1) )) <= 1);
      wr3: (SIZEOF(QUERY ( dr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EE_SPECIFICATION') IN TYPEOF(dr.assigned_document)) )) >= 1);
      wr4: ((NOT (SELF\property_definition.description IN ['constraint',
               'part based constraint'])) OR (SIZEOF(QUERY ( dc <* 
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'design constraint') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_DEFINITION') IN TYPEOF(dc.relating_property_definition
               .definition)) )) = 1));
      wr5: ((NOT (SELF\property_definition.description = 
               'part based constraint')) OR (SIZEOF(QUERY ( cp <* 
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'constraining part') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(cp.
               relating_property_definition.definition)) AND (cp.
               relating_property_definition.definition.name = 
               'constraining part') AND (cp.relating_property_definition.
               definition.related_product_definition.frame_of_reference.
               name = 'design requirement')) )) = 1));
      wr6: ((NOT (SELF\property_definition.description = 
               'interface requirement')) OR (SIZEOF(QUERY ( itnha <* 
               QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'interface to next higher assembly') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION') IN TYPEOF(itnha.
               relating_property_definition.definition)) AND (itnha.
               relating_property_definition.definition.frame_of_reference.
               name = 'design requirement') AND (SIZEOF(QUERY ( hai <* 
               QUERY ( pdr <* USEDIN(itnha.relating_property_definition.
               definition,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (pdr\product_definition_relationship.name = 'higher assembly interface') ) | (SIZEOF(
               QUERY ( pdr <* USEDIN(hai,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SPECIFIED_HIGHER_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) = 1) )) 
               = 1)) )) = 1));
  END_ENTITY; -- requirements_property

  ENTITY requirements_property_group
    SUBTYPE OF (requirements_property, group);
    WHERE
      wr1: (SIZEOF(QUERY ( rpc <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'requirements property composition') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(rpc.
               related_property_definition)) )) >= 1);
  END_ENTITY; -- requirements_property_group

  ENTITY revolved_area_solid
    SUBTYPE OF (swept_area_solid);
      axis  : axis1_placement;
      angle : plane_angle_measure;
    DERIVE
      axis_line : line := dummy_gri || curve() || line(axis.location,
                     dummy_gri || vector(axis.z,1));
  END_ENTITY; -- revolved_area_solid

  ENTITY revolved_face_solid
    SUBTYPE OF (swept_face_solid);
      axis  : axis1_placement;
      angle : plane_angle_measure;
    DERIVE
      axis_line : line := dummy_gri || curve() || line(axis.location,
                     dummy_gri || vector(axis.z,1));
  END_ENTITY; -- revolved_face_solid

  ENTITY right_angular_wedge
    SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
      ltx      : length_measure;
    WHERE
      wr1: ((0 <= ltx) AND (ltx < x));
  END_ENTITY; -- right_angular_wedge

  ENTITY right_circular_cone
    SUBTYPE OF (geometric_representation_item);
      position   : axis1_placement;
      height     : positive_length_measure;
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- right_circular_cone

  ENTITY right_circular_cylinder
    SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height   : positive_length_measure;
      radius   : positive_length_measure;
  END_ENTITY; -- right_circular_cylinder

  ENTITY routed_printed_component
    SUBTYPE OF (printed_component);
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | (SIZEOF(QUERY ( sar <* USEDIN(sa,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PART_TEMPLATE_DEFINITION') IN TYPEOF(sar.
               relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.
               description = 'printed part cross section template') AND (
               sar\shape_aspect_relationship.name = 'instantiated template')) )) = 1) )) = 1) )) = 1);
      wr2: (SIZEOF(QUERY ( csa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(csa)) AND (SIZEOF(
               QUERY ( sar <* USEDIN(csa,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((
               SIZEOF(QUERY ( pdr <* USEDIN(sar,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(pdr)) AND (pdr.
               name = 'inter stratum extent')) )) = 1) AND (sar\shape_aspect_relationship.name = 
               'component extent')) )) = 1)) )) = 1);
  END_ENTITY; -- routed_printed_component

  ENTITY rule_action
    SUBTYPE OF (action);
    WHERE
      wr1: (SIZEOF(QUERY ( aaa <* QUERY ( aa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_ACTION_ASSIGNMENT') IN TYPEOF(aa)) ) | (SIZEOF(
               QUERY ( it <* aaa.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_DEFINITION') IN TYPEOF(it)) )) = 1) )) = 1);
      wr2: ((SIZEOF(QUERY ( adta <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adta.role.name 
               = 'participant date and time') )) + SIZEOF(QUERY ( ada <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DATE_ASSIGNMENT.ITEMS') | (ada.role.name = 
               'participant date') ))) = 1);
      wr3: ((NOT (SELF\action.name = 'rule justification')) OR (SIZEOF(
               QUERY ( ja <* QUERY ( ar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_RELATIONSHIP.RELATED_ACTION') | (ar\action_relationship.name = 
               'justified action') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_ACTION') IN TYPEOF(ja.relating_action)) )) = 1));
      wr4: ((NOT (SELF\action.name = 'rule modification')) OR (SIZEOF(
               QUERY ( mr <* QUERY ( ar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_RELATIONSHIP.RELATED_ACTION') | (ar\action_relationship.name = 
               'modification rationale') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_ACTION') IN TYPEOF(mr.relating_action)) AND (mr.
               relating_action\action.name = 'rule change request')) )) = 1));
      wr5: ((NOT (SELF\action.name = 'rule replacement from')) OR (SIZEOF(
               QUERY ( rrfa <* QUERY ( aa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_REPLACEMENT_FROM_ASSIGNMENT') IN TYPEOF(aa)) ) | (
               SIZEOF(QUERY ( it <* rrfa.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_DEFINITION') IN TYPEOF(it)) )) = 1) )) = 1));
      wr6: ((NOT (SELF\action.name = 'rule replacement to')) OR (SIZEOF(
               QUERY ( rrta <* QUERY ( aa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_REPLACEMENT_TO_ASSIGNMENT') IN TYPEOF(aa)) ) | (
               SIZEOF(QUERY ( it <* rrta.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_DEFINITION') IN TYPEOF(it)) )) = 1) )) = 1));
  END_ENTITY; -- rule_action

  ENTITY rule_complex_clause
    SUBTYPE OF (representation);
    UNIQUE
      ur1 : SELF\representation.name;
    WHERE
      wr1: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_SIMPLE_CLAUSE') IN TYPEOF(rr.rep_1)) )) >= 1);
      wr2: (SIZEOF(TYPEOF(SELF)) = 2);
  END_ENTITY; -- rule_complex_clause

  ENTITY rule_conclusion_definition
    SUBTYPE OF (representation);
    WHERE
      wr1: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | (rr\
               representation_relationship.rep_1\representation.description 
               = 'rule definition') )) = 1);
      wr2: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_SIMPLE_CLAUSE') IN TYPEOF(rr\
               representation_relationship.rep_1)) )) >= 1);
      wr3: (SIZEOF(TYPEOF(SELF)) = 2);
  END_ENTITY; -- rule_conclusion_definition

  ENTITY rule_definition
    SUBTYPE OF (characterized_object, externally_defined_item);
    UNIQUE
      ur1 : SELF\characterized_object.name, SELF\externally_defined_item.item_id; 
    WHERE
      wr1: ((SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) + SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'))) <= 1);
      wr2: (SIZEOF(QUERY ( aaa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_ACTION_ASSIGNMENT.ITEMS') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_ACTION') IN TYPEOF(aaa.assigned_action)) )) >= 1);
      wr3: (SIZEOF(QUERY ( esr <* USEDIN(SELF.source,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNAL_SOURCE_RELATIONSHIP.RELATING_SOURCE') | (esr.name 
               = 'revision') )) = 1);
      wr4: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_1') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_CONCLUSION_DEFINITION') IN TYPEOF(rr\
               representation_relationship.rep_2)) )) = 1);
      wr5: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_1') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_PREMISE_DEFINITION') IN TYPEOF(rr\
               representation_relationship.rep_2)) )) = 1);
  END_ENTITY; -- rule_definition

  ENTITY rule_function_definition
    SUBTYPE OF (representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'MODEL_PARAMETER') IN TYPEOF(it)) )) >= 1);
      wr2: (SIZEOF(QUERY ( adf <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS') | ((adf\
               document_reference.assigned_document.kind.product_data_type 
               = 'reference document') AND (SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EE_SPECIFICATION',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DOCUMENT'] * TYPEOF(adf\document_reference.
               assigned_document)) >= 1)) )) = 1);
      wr3: (SIZEOF(QUERY ( adf <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS') | ((adf\
               document_reference.assigned_document.kind.product_data_type 
               = 'source code') AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EE_SPECIFICATION') IN TYPEOF(adf\document_reference.
               assigned_document))) )) = 1);
  END_ENTITY; -- rule_function_definition

  ENTITY rule_premise_definition
    SUBTYPE OF (representation);
    WHERE
      wr1: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | (rr\
               representation_relationship.rep_1\representation.description 
               = 'rule definition') )) = 1);
      wr2: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_COMPLEX_CLAUSE') IN TYPEOF(rr\
               representation_relationship.rep_1)) )) >= 1);
      wr3: (SIZEOF(TYPEOF(SELF)) = 2);
  END_ENTITY; -- rule_premise_definition

  ENTITY rule_replacement_from_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF replacement_from_item;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_RELATIONSHIP.' + 'RELATING_ACTION')) = 1);
  END_ENTITY; -- rule_replacement_from_assignment

  ENTITY rule_replacement_from_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF replacement_from_item;
  END_ENTITY; -- rule_replacement_from_request_assignment

  ENTITY rule_replacement_to_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF replacement_to_item;
  END_ENTITY; -- rule_replacement_to_assignment

  ENTITY rule_replacement_to_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF replacement_to_item;
    WHERE
      wr1: (SIZEOF(QUERY ( rrfa <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_REPLACEMENT_FROM_ASSIGNMENT') IN TYPEOF(rrfa)) )) >= 1);
  END_ENTITY; -- rule_replacement_to_request_assignment

  ENTITY rule_set
    SUBTYPE OF (group);
    UNIQUE
      ur1 : SELF\group.name;
    WHERE
      wr1: ((SIZEOF(QUERY ( aga <* QUERY ( ga <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_GROUP_ASSIGNMENT') IN TYPEOF(ga)) ) | (SIZEOF(
               QUERY ( rd <* QUERY ( it <* aga.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_DEFINITION') IN TYPEOF(it)) ) | (SIZEOF(QUERY ( pd <* 
               USEDIN(rd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
               used_representation\representation.name = 'rule priority') )) >= 1) )) >= 1) )) 
               >= 1) )) >= 1) OR (SIZEOF(QUERY ( rsge <* QUERY ( gr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GROUP_RELATIONSHIP.RELATING_GROUP') | (gr.name = 
               'rule set group element') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_SET') IN TYPEOF(rsge.related_group)) )) >= 2));
  END_ENTITY; -- rule_set

  ENTITY rule_simple_clause
    SUBTYPE OF (representation);
    UNIQUE
      ur1 : SELF\representation.name;
    WHERE
      wr1: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_1') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PARAMETER_ASSIGNMENT_REPRESENTATION') IN TYPEOF(rr.rep_2)) )) 
               >= 1);
      wr2: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'RULE_FUNCTION_DEFINITION') IN TYPEOF(rr.rep_1)) )) = 1);
      wr3: (SIZEOF(TYPEOF(SELF)) = 2);
  END_ENTITY; -- rule_simple_clause

  ENTITY runout_zone_definition
    SUBTYPE OF (tolerance_zone_definition);
      orientation : runout_zone_orientation;
  END_ENTITY; -- runout_zone_definition

  ENTITY runout_zone_orientation;
      angle : measure_with_unit;
  END_ENTITY; -- runout_zone_orientation

  ENTITY runout_zone_orientation_reference_direction
    SUBTYPE OF (runout_zone_orientation);
      orientation_defining_relationship : shape_aspect_relationship;
  END_ENTITY; -- runout_zone_orientation_reference_direction

  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               = associated_surface(SELF\surface_curve.associated_geometry[
               2]));
      wr3: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
               IN TYPEOF(SELF\surface_curve.associated_geometry[1]));
      wr4: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
               IN TYPEOF(SELF\surface_curve.associated_geometry[2]));
  END_ENTITY; -- seam_curve

  ENTITY seating_plane
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF)) = 2);
  END_ENTITY; -- seating_plane

  ENTITY secondary_orientation_feature
    SUBTYPE OF (physical_unit_datum_feature);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF) * [
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRIMARY_ORIENTATION_FEATURE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SEATING_PLANE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'VIEWING_PLANE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_DATUM',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT']) = 0);
      wr2: (SELF.product_definitional = TRUE);
      wr3: (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated body vertical extent') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_BODY_BOTTOM_SURFACE') IN TYPEOF(it.
               relating_shape_aspect)) )) <= 1);
      wr4: (SIZEOF(QUERY ( it <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'associated body vertical extent') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PACKAGE_BODY_TOP_SURFACE') IN TYPEOF(it.
               relating_shape_aspect)) )) <= 1);
  END_ENTITY; -- secondary_orientation_feature

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY; -- security_classification

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
  END_ENTITY; -- security_classification_assignment

  ENTITY security_classification_level;
      name : label;
  END_ENTITY; -- security_classification_level

  ENTITY sequential_laminate_passage_based_fabrication_joint
    SUBTYPE OF (shape_aspect);
  END_ENTITY; -- sequential_laminate_passage_based_fabrication_joint

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id   : OPTIONAL identifier;
  END_ENTITY; -- serial_numbered_effectivity

  ENTITY shape_aspect;
      name                 : label;
      description          : text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_deriving_relationship
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DERIVED_SHAPE_ASPECT' 
               IN TYPEOF(SELF\shape_aspect_relationship.
               relating_shape_aspect));
  END_ENTITY; -- shape_aspect_deriving_relationship

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_DEFINITION' 
               IN TYPEOF(SELF.definition.definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_SHAPE' 
               IN TYPEOF(SELF.definition)));
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_REPRESENTATION' 
               IN TYPEOF(SELF.used_representation));
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_dimension_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF.items | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MEASURE_REPRESENTATION_ITEM' 
               IN TYPEOF(temp))) )) = 0);
      wr2: (SIZEOF(SELF.items) <= 2);
      wr3: (SIZEOF(QUERY ( pos_mri <* QUERY ( real_mri <* SELF.items | (
               'REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)) )
                | (NOT (pos_mri\measure_with_unit.value_component > 0)) )) 
               = 0);
  END_ENTITY; -- shape_dimension_representation

  ENTITY shape_modification
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(QUERY ( dim <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'design intent modification') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(dim.relating_shape_aspect)) )) 
               = 1);
      wr2: ((SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) AND (pd\property_definition.description 
               = 'modification causal')) )) = 1) OR (SIZEOF(QUERY ( mcf <* 
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'modification causal feature') ) | ((SIZEOF([
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_INTERFACE_TERMINAL',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE'] * TYPEOF(mcf.relating_shape_aspect)) = 1) 
               OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM') IN TYPEOF(mcf.relating_shape_aspect.of_shape.
               definition))) )) = 1));
      wr3: ((NOT (SELF.description IN ['electrical isolation removal',
               'thermal isolation removal'])) OR (SIZEOF(QUERY ( pd <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) AND (pd\property_definition.description 
               = 'spacing requirement')) )) = 1));
      wr4: ((NOT (SELF.description IN ['electrical isolation removal',
               'thermal isolation removal'])) OR (SIZEOF(QUERY ( di <* 
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'design intent') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(di.relating_shape_aspect)) AND 
               (di.relating_shape_aspect\shape_aspect.description IN [
               'conductive filled area','connected filled area'])) )) = 1));
      wr5: ((NOT (SELF.description = 'thermal isolation removal')) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) AND (pd\property_definition.description 
               = 'angular orientation requirement')) )) = 1));
      wr6: ((NOT (SELF.description = 'thermal isolation removal')) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) AND (pd\property_definition.description 
               = 'effective current capacity requirement')) )) = 1));
  END_ENTITY; -- shape_modification

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_REPRESENTATION' 
               IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(
               SELF\representation_relationship.rep_2)));
  END_ENTITY; -- shape_representation_relationship

  ENTITY shell_based_2d_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MAPPED_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'AXIS2_PLACEMENT_2D'] * TYPEOF(it)) = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >= 1);
      wr3 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_LOOP') IN TYPEOF(wsb)) ) | (NOT (SIZEOF(
                QUERY ( el <* eloop\path.edge_list | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_CURVE') IN TYPEOF(el.edge_element))) )) = 0)) )) = 0)) )) 
                = 0)) )) = 0);
      wr4 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_LOOP') IN TYPEOF(wsb)) ) | (NOT (SIZEOF(
                QUERY ( pline_el <* QUERY ( el <* eloop\path.edge_list | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'POLYLINE') IN TYPEOF(el.edge_element\edge_curve.
                edge_geometry)) ) | (NOT (SIZEOF(pline_el.edge_element\
                edge_curve.edge_geometry\polyline.points) > 2)) )) = 0)) )) 
                = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_LOOP') IN TYPEOF(wsb)) ) | (NOT (SIZEOF(
                QUERY ( el <* eloop\path.edge_list | (NOT 
                valid_2d_wireframe_edge_curve(el.edge_element\edge_curve.
                edge_geometry,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_LOOP') IN TYPEOF(wsb)) ) | (NOT (SIZEOF(
                QUERY ( el <* eloop\path.edge_list | (NOT (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_POINT') IN TYPEOF(el.edge_element.edge_start)) AND 
                (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                + 'VERTEX_POINT') IN TYPEOF(el.edge_element.edge_end)))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_LOOP') IN TYPEOF(wsb)) ) | (NOT (SIZEOF(
                QUERY ( el <* eloop\path.edge_list | (NOT (
                valid_wireframe_vertex_point(el.edge_element.edge_start\
                vertex_point.vertex_geometry) AND 
                valid_wireframe_vertex_point(el.edge_element.edge_end\
                vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0);
      wr8 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'EDGE_LOOP') IN TYPEOF(wsb)) ) | (NOT (SIZEOF(
                QUERY ( con_edges <* QUERY ( el <* eloop\path.edge_list | (
                ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                 'CONIC') IN TYPEOF(el.edge_element\edge_curve.
                edge_geometry)) ) | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'AXIS2_PLACEMENT_2D') IN TYPEOF(con_edges.edge_element\
                edge_curve.edge_geometry\conic.position))) )) = 0)) )) = 0)) )) 
                = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_LOOP') IN TYPEOF(wsb)) ) | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_POINT') IN TYPEOF(vloop\vertex_loop.loop_vertex))) )) 
                = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( ws <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'WIRE_SHELL') IN TYPEOF(sb)) ) | (NOT (SIZEOF(
                QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_LOOP') IN TYPEOF(wsb)) ) | (NOT 
                valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)) )) = 0)) )) = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( vs <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_SHELL') IN TYPEOF(sb)) ) | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_POINT') IN TYPEOF(vs\vertex_shell.
                vertex_shell_extent.loop_vertex))) )) = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_MODEL') IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( vs <* QUERY ( sb <* sbwm\
                shell_based_wireframe_model.sbwm_boundary | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'VERTEX_SHELL') IN TYPEOF(sb)) ) | (NOT 
                valid_wireframe_vertex_point(vs\vertex_shell.
                vertex_shell_extent.loop_vertex\vertex_point.
                vertex_geometry)) )) = 0)) )) = 0);
      wr13: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF\representation.items
                 | ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MAPPED_ITEM') IN TYPEOF(it)) ) | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(
                mi\mapped_item.mapping_source.mapped_representation))) )) =
                 0);
      wr14: (SELF.context_of_items\geometric_representation_context.
                coordinate_space_dimension = 2);
  END_ENTITY; -- shell_based_2d_wireframe_shape_representation

  ENTITY shell_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_surface_model(SELF);
  END_ENTITY; -- shell_based_surface_model

  ENTITY shell_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_wireframe_model(SELF);
  END_ENTITY; -- shell_based_wireframe_model

  ENTITY shell_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D'] 
                * TYPEOF(it)) = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM'] 
                * TYPEOF(it)) = 1) )) >= 1);
      wr3 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
                IN TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' 
                IN TYPEOF(el.edge_element))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0);
      wr4 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
                IN TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( pline_el <* 
                QUERY ( el <* eloop\path.edge_list | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
                IN TYPEOF(el.edge_element\edge_curve.edge_geometry)) ) | (
                NOT (SIZEOF(pline_el.edge_element\edge_curve.edge_geometry\
                polyline.points) > 2)) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
                IN TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT valid_wireframe_edge_curve(el.edge_element
                \edge_curve.edge_geometry)) )) = 0)) )) = 0)) )) = 0)) )) =
                 0);
      wr6 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
                IN TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(el.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(el.edge_element.edge_end)))) )) = 0)) )) = 0)) )) 
                = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
                IN TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (valid_wireframe_vertex_point(el.
                edge_element.edge_start\vertex_point.vertex_geometry) AND 
                valid_wireframe_vertex_point(el.edge_element.edge_end\
                vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0);
      wr8 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
                IN TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( vloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(vloop\vertex_loop.loop_vertex))) )) = 0)) )) = 0)) )) 
                = 0);
      wr9 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
                IN TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( vloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT valid_wireframe_vertex_point(vloop
                \vertex_loop.loop_vertex\vertex_point.vertex_geometry)) )) 
                = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' 
                IN TYPEOF(sb)) ) | (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' 
                IN TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex))) )) 
                = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' 
                IN TYPEOF(sb)) ) | (NOT valid_wireframe_vertex_point(vs\
                vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.
                vertex_geometry)) )) = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
                IN TYPEOF(it)) ) | (NOT ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation))) )) = 0);
      wr13: (SELF.context_of_items\geometric_representation_context.
                coordinate_space_dimension = 3);
  END_ENTITY; -- shell_based_wireframe_shape_representation

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(SELF.name);
  END_ENTITY; -- si_unit

  ENTITY signal
    SUBTYPE OF (characterized_object, property_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( aca <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SIGNAL_CATEGORY') IN TYPEOF(aca.assigned_group)) )) >= 1);
      wr2: ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNAL_DEFINITION') IN TYPEOF(SELF)) XOR (SIZEOF(
               QUERY ( ada <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (SIZEOF(
               QUERY ( duc <* USEDIN(ada.assigned_document,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (duc.subject_element =
                'signal category') )) = 1) )) = 1));
      wr3: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1);
  END_ENTITY; -- signal

  ENTITY signal_category
    SUBTYPE OF (group, externally_defined_item);
    WHERE
      wr1: (SELF\group.description IN ['signal characteristic category',
               'signal property category']);
  END_ENTITY; -- signal_category

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_ANGLE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- solid_angle_measure_with_unit

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- solid_angle_unit

  ENTITY solid_curve_font
    SUBTYPE OF (pre_defined_curve_font);
  END_ENTITY; -- solid_curve_font

  ENTITY solid_model
    SUPERTYPE OF (ONEOF (csg_solid,manifold_solid_brep,swept_face_solid,
        swept_area_solid,solid_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY solid_replica
    SUBTYPE OF (solid_model);
      parent_solid   : solid_model;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_solid_replica(SELF,parent_solid);
  END_ENTITY; -- solid_replica

  ENTITY specified_higher_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage  : next_assembly_usage_occurrence;
    UNIQUE
      ur1 : upper_usage, next_usage;
    WHERE
      wr1: (SELF :<>: upper_usage);
      wr2: (SELF\product_definition_relationship.
               relating_product_definition :=: upper_usage.
               relating_product_definition);
      wr3: (SELF\product_definition_relationship.
               related_product_definition :=: next_usage.
               related_product_definition);
      wr4: (upper_usage.related_product_definition :=: next_usage.
               relating_product_definition);
      wr5: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PROMISSORY_USAGE_OCCURRENCE' 
               IN TYPEOF(upper_usage)));
  END_ENTITY; -- specified_higher_usage_occurrence

  ENTITY sphere
    SUBTYPE OF (geometric_representation_item);
      radius : positive_length_measure;
      centre : point;
  END_ENTITY; -- sphere

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY standard_uncertainty
    SUPERTYPE OF (expanded_uncertainty)
    SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : REAL;
  END_ENTITY; -- standard_uncertainty

  ENTITY start_request
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF start_request_item;
  END_ENTITY; -- start_request

  ENTITY start_work
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DIRECTED_ACTION') IN TYPEOF(SELF.assigned_action));
  END_ENTITY; -- start_work

  ENTITY statistical_dimensional_location
    SUBTYPE OF (dimensional_location);
  END_ENTITY; -- statistical_dimensional_location

  ENTITY statistical_dimensional_size
    SUBTYPE OF (dimensional_size_property);
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DIMENSIONAL_SIZE') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr\property_definition_relationship.name = 
               'substitutable dimension')) )) <= 1) )) <= 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr\property_definition_relationship.name = 
               'dimensional tolerance statistical control requirement')) )) 
               <= 1) )) <= 1);
      wr3: ((NOT (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DIMENSIONAL_SIZE') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr\property_definition_relationship.name = 
               'substitutable dimension')) )) <= 1) )) <= 1)) OR (NOT (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( pdr <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DIMENSIONAL_SIZE') IN TYPEOF(pdr.
               related_property_definition)) AND (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STATISTICAL_DIMENSIONAL_SIZE') IN TYPEOF(pdr.
               related_property_definition))) AND (pdr\property_definition_relationship.name = 
               'substitutable dimension')) )) <= 1) )) <= 1)));
  END_ENTITY; -- statistical_dimensional_size

  ENTITY statistical_geometric_tolerance
    SUBTYPE OF (physical_unit_geometric_tolerance);
    WHERE
      wr1: (SIZEOF(QUERY ( gtr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND (gtr.name = 
               'substitutable geometric tolerance')) )) <= 1);
      wr2: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pdr.
               related_property_definition)) AND (pdr\property_definition_relationship.name = 
               'geometric tolerance statistical control requirement')) )) =
                1);
      wr3: (SIZEOF(QUERY ( gtr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STATISTICAL_GEOMETRIC_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND (gtr.name = 
               'substitutable geometric tolerance')) )) <= 0);
  END_ENTITY; -- statistical_geometric_tolerance

  ENTITY stratum
    SUBTYPE OF (product_definition);
    UNIQUE
      ur1 : SELF\product_definition.id;
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( tu <* 
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'technology usage') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_TECHNOLOGY') IN TYPEOF(tu.
               relating_property_definition.definition)) )) = 1) )) = 1);
      wr2: ((SIZEOF(QUERY ( ada <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (SIZEOF(
               QUERY ( duc <* USEDIN(ada.assigned_document,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (duc.subject_element =
                'attachment region size') )) = 1) )) <= 1) OR (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( tu <* 
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'stratum usage') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNAL_DEFINITION') IN TYPEOF(tu.
               relating_property_definition)) )) = 1) )) <= 1));
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )
                | (sr_pdr.used_representation\representation.name = 
               '3d bound volume shape') )) <= 1)) )) = 0);
      wr4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sr_pdr <* QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) )
                | (sr_pdr.used_representation\representation.name = 
               'planar projected shape') )) <= 1)) )) = 0);
      wr5: (SIZEOF(QUERY ( acu <* QUERY ( pdr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(pdr)) ) | (acu\product_definition_relationship.name = 
               'interconnect module stratum assembly relationship') )) >= 1);
      wr6: ((NOT (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
               product_category.name = 'design layer') )) >= 1)) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( tu <* 
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'technology usage') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_TECHNOLOGY') IN TYPEOF(tu.
               relating_property_definition.definition)) AND (tu.
               relating_property_definition.definition.description = 
               'design layer')) )) = 1) )) = 1));
      wr7: ((NOT (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
               product_category.name = 'design layer') )) >= 1)) OR (
               SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LAYER_CONNECTION_POINT') IN TYPEOF(sa)) )) >= 1) )) >= 1));
      wr8: ((NOT (SIZEOF(QUERY ( prpc <* USEDIN(SELF.formation.of_product,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS') | (prpc\
               product_category.name = 'documentation layer') )) >= 1)) OR 
               (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( tu <* 
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                | (pdr\property_definition_relationship.name = 'technology usage') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_TECHNOLOGY') IN TYPEOF(tu.
               relating_property_definition.definition)) AND (tu.
               relating_property_definition.definition.description = 
               'documentation layer')) )) = 1) )) = 1));
  END_ENTITY; -- stratum

  ENTITY stratum_concept_relationship
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    WHERE
      wr1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REQUIREMENTS_PROPERTY') IN TYPEOF(pd)) )) >= 1);
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1) )) = 
               1);
      wr3: ((NOT (SELF\shape_aspect_relationship.name = 
               'dielectric crossover area')) OR (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(SELF.relating_shape_aspect)) 
               AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(SELF.related_shape_aspect))));
      wr4: ((NOT (SELF\shape_aspect_relationship.name = 
               'dielectric crossover area')) OR (SIZEOF(QUERY ( rdc <* 
               QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'resulting dielectric crossover') ) | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM_FEATURE') IN TYPEOF(rdc.relating_shape_aspect)) )) 
               = 1));
      wr5: ((NOT (SELF\shape_aspect_relationship.name = 
               'stratum feature conductive join')) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LAND') IN TYPEOF(SELF.relating_shape_aspect)) OR (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(SELF.
               relating_shape_aspect)) AND (SELF.relating_shape_aspect\shape_aspect.
               description = 'stratum feature template component')));
      wr6: ((NOT (SELF\shape_aspect_relationship.name = 
               'stratum feature conductive join')) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'LAND') IN TYPEOF(SELF.related_shape_aspect)) OR (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'COMPONENT_SHAPE_ASPECT') IN TYPEOF(SELF.
               related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.
               description = 'stratum feature template component')));
      wr7: ((NOT (SELF\shape_aspect_relationship.name = 
               'stratum feature conductive join')) OR (SIZEOF(
               QUERY ( fj <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'features join') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PLATED_PASSAGE') IN TYPEOF(fj.related_shape_aspect)) AND (
               fj.related_shape_aspect\shape_aspect.description = 
               'bonded conductive base blind via')) )) <= 1));
      wr8: ((NOT ((SELF\shape_aspect.description = 'physical network supporting stratum feature conductive join') 
               AND (SELF\shape_aspect_relationship.name = 
               'stratum feature conductive join'))) OR (SIZEOF(
               QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(ji.relating_shape_aspect)) 
               AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join')) )) 
               = 1));
  END_ENTITY; -- stratum_concept_relationship

  ENTITY stratum_feature
    SUPERTYPE OF (fiducial_stratum_feature)
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM') IN TYPEOF(SELF.of_shape.definition));
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (SIZEOF(
               QUERY ( it <* pdr.used_representation.items | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
               name = 'feature of size') AND (it.description IN ['true',
               'false'])) )) = 1) )) = 1)) )) = 0);
      wr3: ((NOT (SELF.description = 'conductor')) OR (SIZEOF(
               QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(ji.relating_shape_aspect)) 
               AND (ji.relating_shape_aspect\shape_aspect.name = 'intra stratum join')) )) 
               >= 1));
      wr4: ((NOT (SELF.description = 'connected filled area')) OR (SIZEOF(
               QUERY ( ji <* QUERY ( sar <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.
               name = 'join implementation') ) | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'JOIN_SHAPE_ASPECT') IN TYPEOF(ji.relating_shape_aspect)) 
               AND (ji.relating_shape_aspect\shape_aspect.name = 'intra stratum join')) )) 
               = 1));
  END_ENTITY; -- stratum_feature

  ENTITY stratum_surface
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF\shape_aspect.description IN ['primary surface',
               'secondary surface','average surface']);
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRATUM') IN TYPEOF(SELF\shape_aspect.of_shape.definition));
  END_ENTITY; -- stratum_surface

  ENTITY stratum_technology
    SUBTYPE OF (characterized_object);
    UNIQUE
      ur1 : SELF\characterized_object.name;
    WHERE
      wr1 : (SIZEOF(USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      wr2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 'stiffness class representation') )) 
                <= 1)) )) = 0);
      wr3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
--tt remove NOT
                'PROPERTY_DEFINITION.DEFINITION') | ((SIZEOF(
                QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
--tt change last 0 to 1
                'physical characteristics representation') )) = 1)) )) = 1);
      wr4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( scr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 'stratum class representation') )
                 | (NOT (SIZEOF(QUERY ( it <* scr.used_representation.items
                 | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
                name = 'laminate stiffness class') AND (it.description IN [
                'fluid like','conformal coat','stiff laminate'])) )) = 1)) )) 
                = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT(SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
--tt change cardinality
                'physical characteristics representation') ) | (NOT((2 <= 
                SIZEOF(pcr.used_representation.items)) AND (SIZEOF(pcr.
                used_representation.items) <= 8))) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | (NOT (
--tt changed string
                it\representation_item.name IN ['layer purpose',
--tt changed string
                'layer position',
                'maximum feature size requirement',
                'minimum finished feature spacing',
                'minimum finished feature size',
--tt changed string
                'maximum thickness',
--tt changed string
                'minimum thickness'])) )) = 0)) )) = 0)) )) = 0);
--tt where rule only applicable for design layers.
      wr7: ((NOT (SELF.description = 'design layer')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name =
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name
                = 'minimum finished feature size')) )) = 1)) )) = 0)) ))
                = 0));
      wr8 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
--tt changed string
                = 'maximum thickness')) )) = 1)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
--tt changed string
                = 'minimum thickness')) )) = 1)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'maximum feature size requirement')) )) <= 1)) )) = 0)) )) 
                = 0);
      wr11: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum finished feature spacing')) )) <= 1)) )) = 0)) )) 
                = 0);
      wr12: ((NOT (SELF.description = 'documentation layer')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
                name = 'layer purpose')) )) = 1)) )) = 0)) )) = 0));
      wr13: ((NOT (SELF.description = 'design layer')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | ((
                SIZEOF([
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'MEASURE_REPRESENTATION_ITEM',
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND (it\representation_item.name 
                = 'minimum finished feature spacing')) )) = 1)) )) = 0)) )) 
                = 0));
      wr14: ((NOT (SELF.description = 'design layer')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
                name = 'layer purpose') AND (it.description IN [
                'power or ground','other signal','lands only'])) )) = 1)) )) 
                = 0)) )) = 0));
      wr15: ((NOT (SELF.description = 'design layer')) OR (SIZEOF(
                QUERY ( pd <* USEDIN(SELF,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
                QUERY ( pcr <* QUERY ( pdr <* USEDIN(pd,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
                used_representation\representation.name = 
                'physical characteristics representation') ) | (NOT (
                SIZEOF(QUERY ( it <* pcr.used_representation.items | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(it)) AND (it.
                name = 'layer position') AND (it.description IN ['primary',
                'secondary','internal'])) )) = 1)) )) = 0)) )) = 0));
  END_ENTITY; -- stratum_technology

  ENTITY structured_text_representation_context
    SUBTYPE OF (representation_context);
    WHERE
      wr1: (SIZEOF(QUERY ( rep <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.CONTEXT_OF_ITEMS') | (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRUCTURED_TEXT_REPRESENTATION_ITEM') IN TYPEOF(rep))) )) =
                0);
  END_ENTITY; -- structured_text_representation_context

  ENTITY structured_text_representation_item
    SUBTYPE OF (representation, descriptive_representation_item);
    WHERE
      wr1: (SIZEOF(QUERY ( rr <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_2') | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'STRUCTURED_TEXT_REPRESENTATION_ITEM') IN TYPEOF(rr.rep_1)) )) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'APPLIED_DOCUMENT_REFERENCE.ITEMS')) >= 1);
      wr3: (SIZEOF(QUERY ( it <* SELF\representation.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'EXTERNALLY_DEFINED_REPRESENTATION_ITEM') IN TYPEOF(it)) )) 
               = 1);
  END_ENTITY; -- structured_text_representation_item

  ENTITY styled_item
    SUBTYPE OF (representation_item);
      styles : SET [1:?] OF presentation_style_assignment;
      item   : representation_item;
    WHERE
      wr1: ((SIZEOF(SELF.styles) = 1) XOR (SIZEOF(QUERY ( pres_style <* 
               SELF.styles | (NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRESENTATION_STYLE_BY_CONTEXT') IN TYPEOF(pres_style))) )) 
               = 0));
  END_ENTITY; -- styled_item

  ENTITY supplied_part_relationship
    SUBTYPE OF (product_definition_relationship);
    WHERE
      wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE') IN 
               TYPEOF(SELF.related_product_definition.formation));
      wr2: (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'PROPERTY_DEFINITION.DEFINITION') IN ROLESOF(SELF)));
  END_ENTITY; -- supplied_part_relationship

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface,
        offset_surface,surface_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (intersection_curve,seam_curve) ANDOR 
        bounded_surface_curve)
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (curve_3d.dim = 3);
      wr2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
               IN TYPEOF(associated_geometry[1])) OR (master_representation 
               <> pcurve_s1));
      wr3: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
               IN TYPEOF(associated_geometry[2])) OR (master_representation 
               <> pcurve_s2));
      wr4: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
               IN TYPEOF(curve_3d)));
  END_ENTITY; -- surface_curve

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := dummy_gri || curve() || line(axis_position.
                     location,dummy_gri || vector(axis_position.z,1));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_patch
    SUBTYPE OF (founded_item);
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR 
                          segments;
    WHERE
      wr1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_BOUNDED_SURFACE' 
               IN TYPEOF(parent_surface)));
  END_ENTITY; -- surface_patch

  ENTITY surface_profile_tolerance
    SUBTYPE OF (physical_unit_geometric_tolerance);
    WHERE
      wr1: ((NOT (SELF\geometric_tolerance.name = 
               'surface profile refinement')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               relating_geometric_tolerance)) AND ((gtr.
               relating_geometric_tolerance.name = 
               'surface profile locating') OR (gtr.
               relating_geometric_tolerance.name = 
               'surface profile refinement')) AND (gtr.name = 
               'surface profile refining control')) )) = 1));
      wr2: ((NOT (SELF\geometric_tolerance.name = 
               'surface profile locating')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               related_geometric_tolerance)) AND (gtr.
               related_geometric_tolerance.name = 
               'surface profile refinement') AND (gtr.name = 
               'surface profile refining control')) )) = 1));
      wr3: ((NOT ((NOT ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM') IN 
               TYPEOF(SELF))) AND (SELF\geometric_tolerance.name = 
               'surface profile refinement'))) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               related_geometric_tolerance)) AND (gtr.
               related_geometric_tolerance.name = 
               'surface profile refinement') AND (gtr.name = 
               'surface profile refining control')) )) = 0));
      wr4: ((NOT (SELF\geometric_tolerance.name = 
               'surface profile refinement')) OR (SIZEOF(QUERY ( gtr <* 
               USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')
                | (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'SURFACE_PROFILE_TOLERANCE') IN TYPEOF(gtr.
               related_geometric_tolerance)) AND (gtr.
               related_geometric_tolerance.name = 
               'surface profile refinement') AND (gtr.name = 
               'surface profile refining control')) )) = 1));
      wr5: (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF)));
  END_ENTITY; -- surface_profile_tolerance

  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY; -- surface_replica

  ENTITY swept_area_solid
    SUPERTYPE OF (ONEOF (revolved_area_solid,extruded_area_solid))
    SUBTYPE OF (solid_model);
      swept_area : curve_bounded_surface;
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' 
               IN TYPEOF(swept_area.basis_surface));
  END_ENTITY; -- swept_area_solid

  ENTITY swept_face_solid
    SUPERTYPE OF (ONEOF (extruded_face_solid,revolved_face_solid))
    SUBTYPE OF (solid_model);
      swept_face : face_surface;
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' 
               IN TYPEOF(swept_face.face_geometry));
  END_ENTITY; -- swept_face_solid

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY symbol_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- symbol_representation

  ENTITY symbol_representation_map
    SUBTYPE OF (representation_map);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_REPRESENTATION' 
               IN TYPEOF(SELF\representation_map.mapped_representation));
      wr2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' 
               IN TYPEOF(SELF\representation_map.mapping_origin));
  END_ENTITY; -- symbol_representation_map

  ENTITY symbol_target
    SUBTYPE OF (geometric_representation_item);
      placement : axis2_placement;
      x_scale   : positive_ratio_measure;
      y_scale   : positive_ratio_measure;
  END_ENTITY; -- symbol_target

  ENTITY symmetric_shape_aspect
    SUBTYPE OF (shape_aspect);
    INVERSE
      basis_relationships : SET [1:?] OF shape_aspect_relationship FOR 
                               relating_shape_aspect;
    WHERE
      wr1: (SIZEOF(QUERY ( x <* SELF.basis_relationships | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CENTRE_OF_SYMMETRY' 
               IN TYPEOF(x.related_shape_aspect)) )) >= 1);
  END_ENTITY; -- symmetric_shape_aspect

  ENTITY symmetry_tolerance
    SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
    WHERE
      wr1: (SELF\geometric_tolerance.name = 'symmetry');
  END_ENTITY; -- symmetry_tolerance

  ENTITY tangent
    SUBTYPE OF (derived_shape_aspect);
    WHERE
      wr1: (SIZEOF(SELF\derived_shape_aspect.deriving_relationships) = 1);
  END_ENTITY; -- tangent

  ENTITY text_font;
      id          : identifier;
      name        : label;
      description : text;
    INVERSE
      glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
  END_ENTITY; -- text_font

  ENTITY text_font_family;
      id          : identifier;
      name        : label;
      description : text;
    INVERSE
      fonts : SET [1:?] OF text_font_in_family FOR family;
  END_ENTITY; -- text_font_family

  ENTITY text_font_in_family;
      font   : text_font;
      family : text_font_family;
  END_ENTITY; -- text_font_in_family

  ENTITY text_literal
    SUBTYPE OF (geometric_representation_item);
      literal   : presentable_text;
      placement : axis2_placement;
      alignment : text_alignment;
      path      : text_path;
      font      : font_select;
  END_ENTITY; -- text_literal

  ENTITY text_literal_with_associated_curves
    SUBTYPE OF (text_literal);
      associated_curves : SET [1:?] OF curve;
  END_ENTITY; -- text_literal_with_associated_curves

  ENTITY text_literal_with_extent
    SUBTYPE OF (text_literal);
      extent : planar_extent;
  END_ENTITY; -- text_literal_with_extent

  ENTITY text_string_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\representation.items | (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT'] 
               * TYPEOF(item)) = 0) )) = 0);
      wr2: (SIZEOF(QUERY ( item <* SELF\representation.items | (NOT (
               SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT'] 
               * TYPEOF(item)) = 0)) )) >= 1);
      wr3: (SIZEOF(QUERY ( a2p <* QUERY ( item <* SELF\representation.
               items | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' 
               IN TYPEOF(item)) ) | (NOT ((SIZEOF(QUERY ( at <* 
               QUERY ( item <* SELF\representation.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ANNOTATION_TEXT') IN TYPEOF(item)) ) | (at\mapped_item.
               mapping_target :=: a2p) )) >= 1) OR (SIZEOF(QUERY ( atc <* 
               QUERY ( item <* SELF\representation.items | ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'ANNOTATION_TEXT_CHARACTER') IN TYPEOF(item)) ) | (atc\
               mapped_item.mapping_target :=: a2p) )) >= 1))) )) = 0);
  END_ENTITY; -- text_string_representation

  ENTITY text_style;
      name                 : label;
      character_appearance : character_style_select;
  END_ENTITY; -- text_style

  ENTITY text_style_for_defined_font;
      text_colour : colour;
  END_ENTITY; -- text_style_for_defined_font

  ENTITY thermal_component
    SUBTYPE OF (component_definition);
  END_ENTITY; -- thermal_component

  ENTITY thermal_component_shape_aspect
    SUBTYPE OF (component_shape_aspect);
  END_ENTITY; -- thermal_component_shape_aspect

  ENTITY thermal_feature
    SUBTYPE OF (shape_aspect);
  END_ENTITY; -- thermal_feature

  ENTITY thermal_network
    SUBTYPE OF (functional_unit);
  END_ENTITY; -- thermal_network

  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- thermodynamic_temperature_measure_with_unit

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 1) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- thermodynamic_temperature_unit

  ENTITY time_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TIME_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- time_measure_with_unit

  ENTITY time_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 1) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- time_unit

  ENTITY tolerance_value;
      lower_bound : measure_with_unit;
      upper_bound : measure_with_unit;
    WHERE
      wr1: (upper_bound.value_component > lower_bound.value_component);
      wr2: (upper_bound.unit_component = lower_bound.unit_component);
  END_ENTITY; -- tolerance_value

  ENTITY tolerance_zone
    SUBTYPE OF (shape_aspect);
      defining_tolerance : SET [1:?] OF geometric_tolerance;
      form               : tolerance_zone_form;
  END_ENTITY; -- tolerance_zone

  ENTITY tolerance_zone_boundary
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: ((NOT (SELF\shape_aspect.description = 'conical')) OR (NOT (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET') IN TYPEOF(
               SELF)) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET') IN TYPEOF(
               SELF)))));
      wr2: ((NOT (SELF\shape_aspect.description = 
               'circular or cylindrical or spherical')) OR (NOT (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET') IN TYPEOF(
               SELF)) OR ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET') IN TYPEOF(
               SELF)))));
      wr3: (SELF\shape_aspect.product_definitional = FALSE);
      wr4: (NOT (((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET') IN TYPEOF(
               SELF)) AND ((
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET') IN TYPEOF(
               SELF))));
      wr5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.DEFINITION') | ((pd\property_definition.description = 
               'boundary zone definition with specified size') OR (pd.
               description = 'conical tolerance zone boundary')) )) = 1);
      wr6: (SIZEOF(USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'TOLERANCE_ZONE_DEFINITION.BOUNDARIES')) = 1);
  END_ENTITY; -- tolerance_zone_boundary

  ENTITY tolerance_zone_definition
    SUPERTYPE OF (ONEOF (projected_zone_definition,runout_zone_definition));
      zone       : tolerance_zone;
      boundaries : SET [1:?] OF shape_aspect;
  END_ENTITY; -- tolerance_zone_definition

  ENTITY tolerance_zone_explicit_opposing_boundary_set
    SUBTYPE OF (tolerance_zone_boundary);
  END_ENTITY; -- tolerance_zone_explicit_opposing_boundary_set

  ENTITY tolerance_zone_form;
      name : label;
  END_ENTITY; -- tolerance_zone_form

  ENTITY tolerance_zone_implicit_opposing_boundary_set
    SUBTYPE OF (tolerance_zone_boundary);
  END_ENTITY; -- tolerance_zone_implicit_opposing_boundary_set

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,vertex_shell,
        wire_shell,connected_edge_set,connected_face_set,loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY torus
    SUBTYPE OF (geometric_representation_item);
      position     : axis1_placement;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
    WHERE
      wr1: (major_radius > minor_radius);
  END_ENTITY; -- torus

  ENTITY total_runout_tolerance
    SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
    WHERE
      wr1: (SELF\geometric_tolerance.name = 'total runout');
      wr2: (NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'MODIFIED_GEOMETRIC_TOLERANCE') IN TYPEOF(SELF)));
  END_ENTITY; -- total_runout_tolerance

  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: ((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2])));
      wr2: ((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2])));
  END_ENTITY; -- trimmed_curve

  ENTITY two_direction_repeat_factor
    SUBTYPE OF (one_direction_repeat_factor);
      second_repeat_factor : vector;
  END_ENTITY; -- two_direction_repeat_factor

  ENTITY type_qualifier;
      name : label;
  END_ENTITY; -- type_qualifier

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY uncertainty_qualifier
    SUPERTYPE OF (ONEOF (standard_uncertainty,qualitative_uncertainty));
      measure_name : label;
      description  : text;
  END_ENTITY; -- uncertainty_qualifier

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY; -- vector

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : text;
  END_ENTITY; -- versioned_action_request

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY vertex_shell
    SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
  END_ENTITY; -- vertex_shell

  ENTITY viewing_plane
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SELF\shape_aspect.description = 'affected plane');
      wr2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION.' + 'DEFINITION') | (pd\property_definition.description = 
               'viewing plane property') )) = 1);
      wr3: (NOT SELF\shape_aspect.product_definitional);
  END_ENTITY; -- viewing_plane

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VOLUME_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- volume_measure_with_unit

  ENTITY volume_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- volume_unit

  ENTITY wire_shell
    SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
    WHERE
      wr1: (NOT mixed_loop_type_set(wire_shell_extent));
  END_ENTITY; -- wire_shell

  RULE acu_requires_security_classification FOR (assembly_component_usage, 
               applied_security_classification_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( acu <* assembly_component_usage | (NOT (SIZEOF(
             QUERY ( asca <* applied_security_classification_assignment | (
             acu IN asca.items) )) = 1)) )) = 0);

  END_RULE; -- acu_requires_security_classification

  RULE add_design_object_management_relationship_unique_constraint FOR (
             add_design_object_assignment, 
             add_design_object_request_assignment);

    LOCAL
      pdr_bag   : BAG OF product_definition_relationship := [];
      adoa_bag  : BAG OF add_design_object_assignment;
      pd_bag    : BAG OF product_definition := [];
      mdo_bag   : BAG OF managed_design_object;
      adora_bag : BAG OF add_design_object_request_assignment;
      pass      : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(add_design_object_assignment) BY 1;
      REPEAT j := 1 TO SIZEOF(add_design_object_assignment[i].items) BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(
            add_design_object_assignment[i].items[j])) AND (
            add_design_object_assignment[i].items[j].name = 
            'design object addition') THEN
          IF EXISTS(add_design_object_assignment[i].items[j].
              related_product_definition) THEN
            IF NOT (add_design_object_assignment[i].items[j].
                related_product_definition IN pd_bag) THEN
              pd_bag := pd_bag + add_design_object_assignment[i].items[j].
                  related_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(add_design_object_request_assignment) BY 1;
      REPEAT j := 1 TO SIZEOF(add_design_object_request_assignment[i].
          items) BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(
            add_design_object_request_assignment[i].items[j])) AND (
            add_design_object_request_assignment[i].items[j].name = 
            'design object addition') THEN
          IF EXISTS(add_design_object_request_assignment[i].items[j].
              related_product_definition) THEN
            IF NOT (add_design_object_request_assignment[i].items[j].
                related_product_definition IN pd_bag) THEN
              pd_bag := pd_bag + add_design_object_request_assignment[i].
                  items[j].related_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      mdo_bag := [];
      pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | (
          pdr\product_definition_relationship.name = 'design object addition') );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        adoa_bag := QUERY ( adoa <* add_design_object_assignment | (
            pdr_bag[j] IN adoa.items) );
        REPEAT k := 1 TO SIZEOF(adoa_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(adoa_bag[k].items) BY 1;
            IF EXISTS(adoa_bag[k].items[l]) THEN
              IF adoa_bag[k].items[l] IN mdo_bag THEN
                pass := FALSE;
                ESCAPE;
              ELSE
                mdo_bag := mdo_bag + adoa_bag[k].items[l];
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        adora_bag := QUERY ( adora <* add_design_object_request_assignment
             | (pdr_bag[j] IN adora.items) );
        REPEAT k := 1 TO SIZEOF(adora_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(adora_bag[k].items) BY 1;
            IF adora_bag[k].items[l] IN mdo_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + adora_bag[k].items[l];
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- add_design_object_management_relationship_unique_constraint

  RULE adjacent_stratum_surface_definition_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'adjacent stratum surface definition') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_SURFACE') IN TYPEOF(sar.related_shape_aspect)) AND (
             sar.related_shape_aspect\shape_aspect.description IN ['secondary surface'])))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'adjacent stratum surface definition') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_SURFACE') IN TYPEOF(sar.relating_shape_aspect)) AND (
             sar.relating_shape_aspect\shape_aspect.description IN ['primary surface'])))) )) 
             = 0);

  END_RULE; -- adjacent_stratum_surface_definition_constraint

  RULE adjacent_stratum_surface_definition_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      sss_bag  : BAG OF stratum_surface;
      pss_bag  : BAG OF stratum_surface := [];
      name_bag : BAG OF STRING := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      pass1    : BOOLEAN := TRUE;
      pass2    : BOOLEAN := TRUE;
      assd     : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                  shape_aspect_relationship | (sar\shape_aspect_relationship.description = 
                  'adjacent stratum surface definition') );
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(assd) BY 1;
      IF EXISTS(assd[i]\shape_aspect_relationship.name) THEN
        IF assd[i]\shape_aspect_relationship.name IN name_bag THEN
          pass1 := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + assd[i]\shape_aspect_relationship.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(assd) BY 1;
      IF EXISTS(assd[i].relating_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'STRATUM_SURFACE') IN TYPEOF(assd[i].relating_shape_aspect)
             THEN
          IF NOT (assd[i].relating_shape_aspect IN pss_bag) THEN
            pss_bag := pss_bag + assd[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pss_bag) BY 1;
      IF NOT pass2 THEN
        ESCAPE;
      END_IF;
      sss_bag := [];
      sar_bag := QUERY ( sar <* assd | (sar.relating_shape_aspect :=: 
          pss_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'STRATUM_SURFACE') IN TYPEOF(assd[j].related_shape_aspect)
               THEN
            IF sar_bag[j].related_shape_aspect IN sss_bag THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              sss_bag := sss_bag + sar_bag[j].related_shape_aspect;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass1;
    wr2: pass2;

  END_RULE; -- adjacent_stratum_surface_definition_unique_constraint

  RULE aggregate_connectivity_requirement_unique_constraint FOR (
             product_definition_relationship);

    LOCAL
      acr    : BAG OF product_definition_relationship := QUERY ( pdr <* 
                product_definition_relationship | (pdr\product_definition_relationship.name = 
                'aggregate connectivity requirement') );
      pd_bag : BAG OF product_definition := [];
      pass   : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(acr) BY 1;
      IF EXISTS(acr[i].related_product_definition) THEN
        IF acr[i].id = 'design composition path' THEN
          IF acr[i].related_product_definition IN pd_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            pd_bag := pd_bag + acr[i].related_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- aggregate_connectivity_requirement_unique_constraint

  RULE analytical_model_port_unique_constraint FOR (analytical_model_port);

    LOCAL
      rr_bag   : BAG OF representation_relationship;
      name_bag : BAG OF STRING := [];
      amp_bag  : BAG OF analytical_model_port;
      am_bag   : BAG OF analytical_model;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(analytical_model_port) BY 1;
      IF EXISTS(analytical_model_port[i].name) THEN
        IF NOT (analytical_model_port[i].name IN name_bag) THEN
          name_bag := name_bag + analytical_model_port[i].name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      amp_bag := QUERY ( amp <* analytical_model_port | (amp.name = 
          name_bag[i]) );
      am_bag := [];
      REPEAT j := 1 TO SIZEOF(amp_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        rr_bag := QUERY ( rr <* USEDIN(amp_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'REPRESENTATION_RELATIONSHIP.REP_2') | ((rr\representation_relationship.name = 
            'access mechanism') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'ANALYTICAL_MODEL') IN TYPEOF(rr.rep_1))) );
        REPEAT k := 1 TO SIZEOF(rr_bag) BY 1;
          IF EXISTS(rr_bag[k].rep_1) THEN
            IF rr_bag[k].rep_1 IN am_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              am_bag := am_bag + rr_bag[k].rep_1;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- analytical_model_port_unique_constraint

  RULE angular_dimension_with_direction_vector_unique_constraint FOR (
             angular_dimension_with_orientation);

    LOCAL
      p_bag   : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_relationship;
      pd_bag  : BAG OF property_definition := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(angular_dimension_with_orientation) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      p_bag := QUERY ( pd <* USEDIN(angular_dimension_with_orientation[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
          'dimensional location property') );
      REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(p_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
             | ((pdr\property_definition_relationship.name = 'measurement orientation') AND (pdr.
            related_property_definition\property_definition.description = 
            'datum based vector orientation')) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].related_property_definition) THEN
            IF pdr_bag[k].related_property_definition IN pd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pd_bag := pd_bag + pdr_bag[k].related_property_definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- angular_dimension_with_direction_vector_unique_constraint

  RULE application_context_requires_ap_definition FOR (application_context, 
             application_protocol_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( ac <* application_context | (NOT (SIZEOF(
             QUERY ( apd <* application_protocol_definition | ((ac :=: apd.
             application) AND (apd.
             application_interpreted_model_schema_name = 
             'electronic_assembly_interconnect_and_packaging_design')) )) =
              1)) )) = 0);

  END_RULE; -- application_context_requires_ap_definition

  RULE approval_requires_approval_date_time FOR (approval, 
             approval_date_time);

  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( adt <* 
             approval_date_time | (app :=: adt.dated_approval) )) = 1)) )) 
             = 0);

  END_RULE; -- approval_requires_approval_date_time

  RULE approval_requires_approval_person_organization FOR (approval, 
             approval_person_organization);

  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( apo <* 
             approval_person_organization | (app :=: apo.
             authorized_approval) )) >= 1)) )) = 0);

  END_RULE; -- approval_requires_approval_person_organization

  RULE approvals_are_assigned FOR (approval, approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( aa <* 
             approval_assignment | (app :=: aa.assigned_approval) )) >= 1)) )) 
             = 0);

  END_RULE; -- approvals_are_assigned

  RULE assembly_composition_relationship_unique_constraint FOR (
             assembly_component_usage);

    LOCAL
      acu_bag : BAG OF assembly_component_usage;
      acr     : BAG OF assembly_component_usage := QUERY ( acu <* 
                 assembly_component_usage | (acu\product_definition_relationship.name = 
                 'assembly composition') );
      cd_bag  : BAG OF component_definition;
      pu_bag  : BAG OF physical_unit := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(acr) BY 1;
      IF EXISTS(acr[i].relating_product_definition) THEN
        IF (acr[i].relating_product_definition.frame_of_reference.name = 
            'physical design') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(acr[i].relating_product_definition))
             THEN
          IF NOT (acr[i].relating_product_definition IN pu_bag) THEN
            pu_bag := pu_bag + acr[i].relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      cd_bag := [];
      acu_bag := QUERY ( acu <* acr | (acu.relating_product_definition :=:
           pu_bag[i]) );
      REPEAT j := 1 TO SIZEOF(acu_bag) BY 1;
        IF EXISTS(acu_bag[j].related_product_definition) THEN
          IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'COMPONENT_DEFINITION') IN TYPEOF(acu_bag[j].
              related_product_definition) THEN
            IF acu_bag[j].related_product_definition IN cd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              cd_bag := cd_bag + acu_bag[j].related_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- assembly_composition_relationship_unique_constraint

  RULE assembly_module_usage_view_connector_relationship_unique_constraint FOR (
             assembly_module_usage_view_connector_relationship);

    LOCAL
      rr_bag   : BAG OF representation_relationship;
      pdr_bag  : BAG OF property_definition_representation;
      desc_bag : BAG OF STRING;
      pd_bag   : BAG OF property_definition;
      amuvcr   : BAG OF assembly_module_usage_view_connector_relationship;
      pu_bag   : BAG OF physical_unit := [];
      pass     : BOOLEAN := TRUE;
      r_bag    : BAG OF representation;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(
        assembly_module_usage_view_connector_relationship) BY 1;
      r_bag := USEDIN(assembly_module_usage_view_connector_relationship[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'REPRESENTATION.ITEMS');
      REPEAT j := 1 TO SIZEOF(r_bag) BY 1;
        pdr_bag := QUERY ( pdr <* USEDIN(r_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | (((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(pdr.definition.definition)) AND (pdr
            .definition.definition.frame_of_reference.name = 
            'physical design usage') AND (SIZEOF(QUERY ( prpc <* USEDIN(pdr
            .definition.definition.formation.of_product,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc.name = 
            'assembly module') )) > 0)) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].definition.definition) THEN
            IF NOT (pdr_bag[k].definition.definition IN pu_bag) THEN
              pu_bag := pu_bag + pdr_bag[k].definition.definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      desc_bag := [];
      pd_bag := USEDIN(pu_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION.DEFINITION');
      REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := USEDIN(pd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          amuvcr := QUERY ( r <* 
              assembly_module_usage_view_connector_relationship | (r IN 
              pdr_bag[k].used_representation.items) );
          REPEAT l := 1 TO SIZEOF(amuvcr) BY 1;
            IF NOT pass THEN
              ESCAPE;
            END_IF;
            r_bag := USEDIN(amuvcr[l],
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'REPRESENTATION.ITEMS');
            REPEAT m := 1 TO SIZEOF(r_bag) BY 1;
              IF NOT pass THEN
                ESCAPE;
              END_IF;
              rr_bag := QUERY ( rr <* USEDIN(r_bag[m],
                  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                  + 'REPRESENTATION_RELATIONSHIP.REP_2') | ((rr.name = 
                  'reference designation assignment') AND (rr.rep_1\representation.name = 
                  'externally visible partial reference designation') AND (
                  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                  + 'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(rr.rep_1.
                  items[1])) AND (rr.rep_1.items[1]\representation_item.name = 
                  'partial reference designation')) );
              REPEAT n := 1 TO SIZEOF(rr_bag) BY 1;
                IF EXISTS(rr_bag[n].rep_1.items[1].description) THEN
                  IF rr_bag[n].rep_1.items[1].description IN desc_bag
                       THEN
                    pass := FALSE;
                    ESCAPE;
                  ELSE
                    desc_bag := desc_bag + rr_bag[n].rep_1.items[1].
                        description;
                  END_IF;
                END_IF;
              END_REPEAT;
            END_REPEAT;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- assembly_module_usage_view_connector_relationship_unique_constraint

  RULE bare_die_unique_constraint FOR (bare_die, 
             externally_defined_bare_die, library_defined_bare_die);

    LOCAL
      fu_bag  : BAG OF functional_unit := [];
      pdr_bag : BAG OF product_definition_relationship;
      pd_bag  : BAG OF property_definition;
      ut_bag  : BAG OF property_definition;
      pu_bag  : BAG OF physical_unit;
      ldbd    : BAG OF physical_unit := QUERY ( r <* 
                 library_defined_bare_die | (r.frame_of_reference.name = 
                 'physical design usage') );
      pu      : BAG OF physical_unit;
      bd      : BAG OF physical_unit := QUERY ( r <* bare_die | (r.
                 frame_of_reference.name = 'physical design usage') );
      pass    : BOOLEAN := TRUE;
      edbd    : BAG OF physical_unit := QUERY ( r <* 
                 externally_defined_bare_die | (r.frame_of_reference.name =
                  'physical design usage') );
    END_LOCAL;
    pu := bd + edbd + ldbd;
    REPEAT i := 1 TO SIZEOF(pu) BY 1;
      pdr_bag := QUERY ( pdr <* USEDIN(pu[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | (
          (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.
          relating_product_definition.frame_of_reference.name = 
          'functional design usage') AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'FUNCTIONAL_UNIT') IN TYPEOF(pdr.relating_product_definition))) );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF EXISTS(pdr_bag[j].relating_product_definition) THEN
          IF NOT (pdr_bag[j].relating_product_definition IN fu_bag) THEN
            fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(fu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pu_bag := QUERY ( r <* pu | (SIZEOF(QUERY ( pdr <* USEDIN(fu_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
          ((pdr\product_definition_relationship.name = 'implemented function') AND (pdr.
          related_product_definition :=: r)) )) > 0) );
      pd_bag := [];
      REPEAT j := 1 TO SIZEOF(pu_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        ut_bag := QUERY ( pd <* USEDIN(pu_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.name = 
            'unit technology') );
        REPEAT k := 1 TO SIZEOF(ut_bag) BY 1;
          IF EXISTS(ut_bag[k]) THEN
            IF ut_bag[k] IN pd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pd_bag := pd_bag + ut_bag[k];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- bare_die_unique_constraint

  RULE boundary_size_characteristic_constraint FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | (((rep\representation.name = 
             'diametrical boundary size') OR (rep\representation.name = 
             'opposing boundary set size')) AND (NOT (SIZEOF(
             QUERY ( lmwu <* rep.items | (lmwu\representation_item.name = 'tolerance value') )) 
             = 1))) )) = 0);

  END_RULE; -- boundary_size_characteristic_constraint

  RULE bus_element_relationship_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr.
             name = 'bus element composition') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(pdr.
             relating_product_definition)))) )) = 0);

  END_RULE; -- bus_element_relationship_constraint

  RULE bus_element_relationship_unique_constraint FOR (
             product_definition_relationship);

    LOCAL
      pdr_bag : BAG OF product_definition_relationship;
      bsd_bag : BAG OF bus_structural_definition := [];
      pd_bag  : BAG OF product_definition;
      ber     : BAG OF product_definition_relationship := QUERY ( pdr <* 
                 product_definition_relationship | (pdr\product_definition_relationship.name = 
                 'bus element composition') );
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ber) BY 1;
      IF EXISTS(ber[i].relating_product_definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(ber[i].
            relating_product_definition) THEN
          IF NOT (ber[i].relating_product_definition IN bsd_bag) THEN
            bsd_bag := bsd_bag + ber[i].relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(bsd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pdr_bag := QUERY ( pdr <* ber | (pdr.relating_product_definition :=:
           bsd_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(pdr_bag[i].
            related_product_definition)) OR (((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'NETWORK_NODE_DEFINITION') IN TYPEOF(pdr_bag[i].
            related_product_definition)) AND (pdr_bag[i].
            related_product_definition.frame_of_reference.name = 
            'functional network design')) THEN
          IF EXISTS(pdr_bag[j].related_product_definition) THEN
            IF pdr_bag[j].related_product_definition IN pd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pd_bag := pd_bag + pdr_bag[j].related_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- bus_element_relationship_unique_constraint

  RULE bus_structural_definition_unique_constraint FOR (
             bus_structural_definition, product_definition_formation, 
             product);

    LOCAL
      name_bag : BAG OF STRING := [];
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(bus_structural_definition) BY 1;
      IF EXISTS(bus_structural_definition[i].formation.of_product.name)
           THEN
        IF bus_structural_definition[i].formation.of_product.name IN 
            name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + bus_structural_definition[i]\
              product_definition.formation.of_product.name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- bus_structural_definition_unique_constraint

  RULE cartesian_coordinate_system_constraint FOR (
             global_unit_assigned_context, geometric_representation_context, 
             global_uncertainty_assigned_context);

  WHERE
    wr1: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT (
             SIZEOF(guac.units) <= 3)) )) = 0);
    wr2: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT ((
             SIZEOF(QUERY ( u <* guac.units | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT' 
             IN TYPEOF(u)) )) = 1) AND (SIZEOF(QUERY ( u <* guac.units | (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE_ANGLE_UNIT' 
             IN TYPEOF(u)) AND ((u.name = radian) OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONVERSION_BASED_UNIT' 
             IN TYPEOF(u)) AND (u\conversion_based_unit.name = 'degree') 
             AND (u\conversion_based_unit.conversion_factor.value_component 
             = 0.0174533) AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PLANE_ANGLE_MEASURE_WITH_UNIT') IN TYPEOF(u\
             conversion_based_unit.conversion_factor))))) )) = 1) AND (
             SIZEOF(QUERY ( u <* guac.units | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_ANGLE_UNIT' 
             IN TYPEOF(u)) )) <= 1))) )) = 0);
    wr3: (SIZEOF(QUERY ( grc <* geometric_representation_context | (NOT ((
             grc.coordinate_space_dimension = 2) OR (grc.
             coordinate_space_dimension = 3))) )) = 0);
    wr4: (SIZEOF(QUERY ( guac <* global_uncertainty_assigned_context | (
             NOT (SIZEOF(QUERY ( u <* guac.uncertainty | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(u)) )) = 1)) )) = 0);

  END_RULE; -- cartesian_coordinate_system_constraint

  RULE cartesian_transformation_operator_2d_constraint FOR (
             cartesian_transformation_operator_2d);

  WHERE
    wr1: (SIZEOF(QUERY ( cto2 <* cartesian_transformation_operator_2d | (
             NOT (EXISTS(cto2.axis1) AND EXISTS(cto2.axis2) AND (cto2.scale 
             > 0))) )) = 0);

  END_RULE; -- cartesian_transformation_operator_2d_constraint

  RULE certification_requires_date_or_date_and_time FOR (certification, 
             applied_date_and_time_assignment, applied_date_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( cert <* certification | (NOT ((SIZEOF(
             QUERY ( adata <* applied_date_and_time_assignment | (cert IN 
             adata.items) )) = 1) OR (SIZEOF(QUERY ( ada <* 
             applied_date_assignment | (cert IN ada.items) )) = 1))) )) = 0);

  END_RULE; -- certification_requires_date_or_date_and_time

  RULE certification_unique_constraint FOR (certification);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF certification := QUERY ( r <* certification | TRUE );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i].name) THEN
        IF r[i]\certification.name IN name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + r[i].name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- certification_unique_constraint

  RULE change_design_object_management_relationship_unique_constraint FOR (
             change_from_design_object_assignment, 
             change_from_design_object_request_assignment, 
             change_to_design_object_assignment, 
             change_to_design_object_request_assignment);

    LOCAL
      pdr_bag    : BAG OF product_definition_relationship;
      pd_bag     : BAG OF product_definition := [];
      pass1      : BOOLEAN := TRUE;
      pass2      : BOOLEAN := TRUE;
      ctdora_bag : BAG OF change_to_design_object_request_assignment;
      cfdora_bag : BAG OF change_from_design_object_request_assignment;
      mdo_bag    : BAG OF managed_design_object;
      ctdoa_bag  : BAG OF change_to_design_object_assignment;
      cfdoa_bag  : BAG OF change_from_design_object_assignment;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(change_from_design_object_assignment) BY 1;
      REPEAT j := 1 TO SIZEOF(change_from_design_object_assignment[i].
          items) BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(
            change_from_design_object_assignment[i].items[j])) AND (
            change_from_design_object_assignment[i].items[j].name = 
            'design object change') THEN
          IF EXISTS(change_from_design_object_assignment[i].items[j].
              relating_product_definition) THEN
            IF NOT (change_from_design_object_assignment[i].items[j].
                relating_product_definition IN pd_bag) THEN
              pd_bag := pd_bag + change_from_design_object_assignment[i].
                  items[j].relating_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(change_from_design_object_request_assignment)
         BY 1;
      REPEAT j := 1 TO SIZEOF(change_from_design_object_request_assignment
          [i].items) BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(
            change_from_design_object_request_assignment[i].items[j])) AND 
            (change_from_design_object_request_assignment[i].items[j].name 
            = 'design object change') THEN
          IF EXISTS(change_from_design_object_request_assignment[i].items[
              j].relating_product_definition) THEN
            IF NOT (change_from_design_object_request_assignment[i].items[
                j].relating_product_definition IN pd_bag) THEN
              pd_bag := pd_bag + 
                  change_from_design_object_request_assignment[i].items[j].
                  relating_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
      IF NOT (pass1 AND pass2) THEN
        ESCAPE;
      END_IF;
      IF pass1 THEN
        mdo_bag := [];
        pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[i],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
             | (pdr\product_definition_relationship.name = 'design object change') );
        REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
          IF NOT pass1 THEN
            ESCAPE;
          END_IF;
          ctdoa_bag := QUERY ( ctdoa <* change_to_design_object_assignment
               | (pdr_bag[j] IN ctdoa.items) );
          REPEAT k := 1 TO SIZEOF(ctdoa_bag) BY 1;
            IF NOT pass1 THEN
              ESCAPE;
            END_IF;
            REPEAT l := 1 TO SIZEOF(ctdoa_bag[k].items) BY 1;
              IF EXISTS(ctdoa_bag[k].items[l]) THEN
                IF ctdoa_bag[k].items[l] IN mdo_bag THEN
                  pass1 := FALSE;
                  ESCAPE;
                ELSE
                  mdo_bag := mdo_bag + ctdoa_bag[k].items[l];
                END_IF;
              END_IF;
            END_REPEAT;
          END_REPEAT;
        END_REPEAT;
        REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
          IF NOT pass1 THEN
            ESCAPE;
          END_IF;
          ctdora_bag := QUERY ( ctdora <* 
              change_to_design_object_request_assignment | (pdr_bag[j] IN 
              ctdora.items) );
          REPEAT k := 1 TO SIZEOF(ctdora_bag) BY 1;
            IF NOT pass1 THEN
              ESCAPE;
            END_IF;
            REPEAT l := 1 TO SIZEOF(ctdora_bag[k].items) BY 1;
              IF EXISTS(ctdora_bag[k].items[l]) THEN
                IF ctdora_bag[k].items[l] IN mdo_bag THEN
                  pass1 := FALSE;
                  ESCAPE;
                ELSE
                  mdo_bag := mdo_bag + ctdora_bag[k].items[l];
                END_IF;
              END_IF;
            END_REPEAT;
          END_REPEAT;
        END_REPEAT;
      END_IF;
      IF pass2 THEN
        mdo_bag := [];
        pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[i],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
             | (pdr\product_definition_relationship.name = 'design object change') );
        REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
          IF NOT pass2 THEN
            ESCAPE;
          END_IF;
          cfdoa_bag := QUERY ( cfdoa <* 
              change_from_design_object_assignment | (pdr_bag[j] IN cfdoa.
              items) );
          REPEAT k := 1 TO SIZEOF(cfdoa_bag) BY 1;
            IF NOT pass2 THEN
              ESCAPE;
            END_IF;
            REPEAT l := 1 TO SIZEOF(cfdoa_bag[k].items) BY 1;
              IF EXISTS(cfdoa_bag[k].items[l]) THEN
                IF cfdoa_bag[k].items[l] IN mdo_bag THEN
                  pass2 := FALSE;
                  ESCAPE;
                ELSE
                  mdo_bag := mdo_bag + cfdoa_bag[k].items[l];
                END_IF;
              END_IF;
            END_REPEAT;
          END_REPEAT;
        END_REPEAT;
        REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
          IF NOT pass2 THEN
            ESCAPE;
          END_IF;
          cfdora_bag := QUERY ( cfdora <* 
              change_from_design_object_request_assignment | (pdr_bag[j] IN
               cfdora.items) );
          REPEAT k := 1 TO SIZEOF(cfdora_bag) BY 1;
            IF NOT pass2 THEN
              ESCAPE;
            END_IF;
            REPEAT l := 1 TO SIZEOF(cfdora_bag[k].items) BY 1;
              IF EXISTS(cfdora_bag[k].items[l]) THEN
                IF cfdora_bag[k].items[l] IN mdo_bag THEN
                  pass2 := FALSE;
                  ESCAPE;
                ELSE
                  mdo_bag := mdo_bag + cfdora_bag[k].items[l];
                END_IF;
              END_IF;
            END_REPEAT;
          END_REPEAT;
        END_REPEAT;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass1;
    wr2: pass2;

  END_RULE; -- change_design_object_management_relationship_unique_constraint

  RULE change_request_unique_constraint FOR (versioned_action_request);

    LOCAL
      var_bag     : BAG OF versioned_action_request;
      version_bag : BAG OF STRING := [];
      pass        : BOOLEAN := TRUE;
      id_bag      : BAG OF STRING;
      cr          : BAG OF versioned_action_request := QUERY ( v <* 
                     versioned_action_request | (SIZEOF(QUERY ( ara <* 
                     USEDIN(v,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                     + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')
                      | (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                     + 'CHANGE_REQUEST') IN TYPEOF(ara)) )) > 0) );
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(versioned_action_request) BY 1;
      IF EXISTS(versioned_action_request[i].version) THEN
        IF NOT (versioned_action_request[i].version IN version_bag) THEN
          version_bag := version_bag + versioned_action_request[i].version;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(version_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      var_bag := QUERY ( v <* versioned_action_request | (v.version = 
          version_bag[i]) );
      id_bag := [];
      REPEAT j := 1 TO SIZEOF(var_bag) BY 1;
        IF EXISTS(var_bag[j].id) THEN
          IF var_bag[j].id IN id_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            id_bag := id_bag + var_bag[j].id;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- change_request_unique_constraint

  RULE characteristic_unique_constraint FOR (representation_item);

    LOCAL
      name_bag : BAG OF STRING := [];
      ri_bag   : BAG OF representation_item;
      adr_bag  : BAG OF applied_document_reference;
      pass     : BOOLEAN := TRUE;
      d_bag    : BAG OF document;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(representation_item) BY 1;
      IF EXISTS(representation_item[i]\representation_item.name) THEN
        IF NOT (representation_item[i]\representation_item.name IN name_bag) THEN
          name_bag := name_bag + representation_item[i]\representation_item.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ri_bag := QUERY ( ri <* representation_item | (ri\representation_item.name = name_bag[i]) );
      d_bag := [];
      REPEAT j := 1 TO SIZEOF(ri_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        adr_bag := USEDIN(ri_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_DOCUMENT_REFERENCE.ITEMS');
        REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
          IF EXISTS(adr_bag[k].assigned_document) THEN
            IF adr_bag[k].assigned_document IN d_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              d_bag := d_bag + adr_bag[k].assigned_document;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- characteristic_unique_constraint

  RULE compatible_dimension FOR (cartesian_point, direction, 
             representation_context, geometric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0);

  END_RULE; -- compatible_dimension

  RULE component_external_reference_constraint FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'component external reference') AND (SIZEOF(QUERY ( dri <* rep
             .items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'design owner'))) )) = 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'component external reference') AND (SIZEOF(QUERY ( dri <* rep
             .items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'part number'))) )) = 1)) )) = 0);
    wr3: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'component external reference') AND (SIZEOF(QUERY ( dri <* rep
             .items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'revision code'))) )) = 1)) )) = 0);
    wr4: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'component external reference') AND (SIZEOF(QUERY ( dri <* rep
             .items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'product definition id'))) )) = 1)) )) = 0);
    wr5: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'component external reference') AND (SIZEOF(QUERY ( dri <* rep
             .items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'reference designation'))) )) = 1)) )) = 0);

  END_RULE; -- component_external_reference_constraint

  RULE component_feature_external_reference_unique_constraint FOR (
             descriptive_representation_item);

    LOCAL
      desc_bag : BAG OF STRING := [];
      dri_bag  : BAG OF descriptive_representation_item;
      cfer     : BAG OF descriptive_representation_item := QUERY ( dri <* 
                  descriptive_representation_item | (dri\representation_item.name = 
                  'component feature external reference') );
      rep_bag  : BAG OF representation;
      pass     : BOOLEAN := TRUE;
      r_bag    : BAG OF representation;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(cfer) BY 1;
      IF EXISTS(cfer[i].description) THEN
        IF NOT (cfer[i].description IN desc_bag) THEN
          desc_bag := desc_bag + cfer[i].description;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(desc_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      r_bag := [];
      dri_bag := QUERY ( dri <* cfer | (dri.description = desc_bag[i]) );
      REPEAT j := 1 TO SIZEOF(dri_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        rep_bag := QUERY ( r <* USEDIN(dri_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'REPRESENTATION.ITEMS') | (r\representation.name = 
            'component external reference') );
        REPEAT k := 1 TO SIZEOF(rep_bag) BY 1;
          IF EXISTS(rep_bag[k]) THEN
            IF rep_bag[k] IN r_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              r_bag := r_bag + rep_bag[k];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- component_feature_external_reference_unique_constraint

  RULE component_feature_to_layout_feature_relationship_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'component feature to layout feature') AND (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_INTERFACE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_TERMINAL'] * TYPEOF(sar.relating_shape_aspect)) > 0))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'component feature to layout feature') AND (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_FEATURE'] * TYPEOF(sar.related_shape_aspect)) > 0))) )) 
             = 0);

  END_RULE; -- component_feature_to_layout_feature_relationship_constraint

  RULE component_feature_unique_constraint FOR (component_terminal, 
             component_interface_terminal);

    LOCAL
      cd_bag  : BAG OF component_definition := [];
      sar_bag : BAG OF shape_aspect_relationship;
      cit     : BAG OF shape_aspect := QUERY ( cit <* 
                 component_interface_terminal | (cit\shape_aspect.description IN [
                 'interconnect component interface terminal',
                 'packaged connector component interface terminal']) );
      def_bag : BAG OF shape_aspect;
      pass    : BOOLEAN := TRUE;
      cf      : BAG OF shape_aspect;
      ct      : BAG OF shape_aspect := QUERY ( ct <* component_terminal | 
                 (ct\shape_aspect.description IN ['assembly module component terminal',
                 'bare die component terminal',
                 'interconnect component join terminal',
                 'interconnect module component terminal',
                 'interconnect module component stratum based terminal',
                 'minimally defined component terminal',
                 'packaged component join terminal']) );
      sa_bag  : BAG OF shape_aspect;
    END_LOCAL;
    cf := ct + cit;
    REPEAT i := 1 TO SIZEOF(cf) BY 1;
      IF EXISTS(cf[i].of_shape.definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'COMPONENT_DEFINITION') IN TYPEOF(cf[i].of_shape.definition)
             THEN
          IF NOT (cf[i].of_shape.definition IN cd_bag) THEN
            cd_bag := cd_bag + cf[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      def_bag := [];
      sa_bag := QUERY ( sa <* cf | (sa.of_shape.definition :=: cd_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(sa_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name =
             'instantiated feature') );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
            IF sar_bag[k].relating_shape_aspect IN def_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              def_bag := def_bag + sar_bag[k].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- component_feature_unique_constraint

  RULE component_mounting_clearance_relationship_constraint FOR (
             representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'mounting clearance') AND (SIZEOF(QUERY ( lmwu <* rep.items | 
             ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'minimum height')) )) = 0)) )) = 0);

  END_RULE; -- component_mounting_clearance_relationship_constraint

  RULE component_overlap_relationship_constraint FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'overlap clearance') AND (SIZEOF(QUERY ( lmwu <* rep.items | (
             (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'minimum clearance')) )) = 0)) )) = 0);

  END_RULE; -- component_overlap_relationship_constraint

  RULE component_part_2d_geometric_representation_relationship_constraint FOR (
             shape_representation_relationship);

    LOCAL
      rr : SET OF representation_relationship := QUERY ( srr <* 
            shape_representation_relationship | (srr\
            representation_relationship.name = 
            'component part planar shape') );
    END_LOCAL;

  WHERE
    wr1: (SIZEOF(QUERY ( srr_t <* rr | (NOT (srr_t.rep_1 :=: srr_t.rep_2)) )) 
             = 0);

  END_RULE; -- component_part_2d_geometric_representation_relationship_constraint

  RULE component_part_3d_geometric_representation_relationship_constraint FOR (
             shape_representation_relationship);

    LOCAL
      rr : SET OF representation_relationship := QUERY ( srr <* 
            shape_representation_relationship | (srr\
            representation_relationship.name = 'component part 3d shape') );
    END_LOCAL;

  WHERE
    wr1: (SIZEOF(QUERY ( srr_t <* rr | (NOT (srr_t.rep_1 :=: srr_t.rep_2)) )) 
             = 0);

  END_RULE; -- component_part_3d_geometric_representation_relationship_constraint

  RULE component_placement_restriction_assignment_constraint FOR (
             property_definition_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* property_definition_representation | ((pdr
             .used_representation\representation.name = 
             'component placement restriction assignment') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MOUNTING_RESTRICTION_AREA') IN TYPEOF(pdr.definition.
             definition)))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* property_definition_representation | ((pdr
             .used_representation\representation.name = 
             'component placement restriction assignment') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUPED_REQUIREMENTS_PROPERTY') IN TYPEOF(pdr.definition)) 
             AND (pdr.definition\group.name = 
             'item restricted requirements property')))) )) = 0);

  END_RULE; -- component_placement_restriction_assignment_constraint

  RULE component_terminal_to_assembly_module_terminal_assignment_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                 shape_aspect_relationship | (sar\shape_aspect_relationship.name = 'design usage') );
      amt_bag : BAG OF assembly_module_terminal := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
      IF EXISTS(cttamta[i].relating_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(cttamta[i].
            relating_shape_aspect) THEN
          IF cttamta[i].relating_shape_aspect IN amt_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- component_terminal_to_assembly_module_terminal_assignment_unique_constraint

  RULE component_terminal_to_interconnect_module_terminal_assignment_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      imt_bag : BAG OF interconnect_module_terminal := [];
      pass    : BOOLEAN := TRUE;
      cttimta : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                 shape_aspect_relationship | (sar\shape_aspect_relationship.name = 'design usage') );
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(cttimta) BY 1;
      IF EXISTS(cttimta[i].relating_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(cttimta[i].
            relating_shape_aspect) THEN
          IF cttimta[i].relating_shape_aspect IN imt_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- component_terminal_to_interconnect_module_terminal_assignment_unique_constraint

  RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                 shape_aspect_relationship | (sar\shape_aspect_relationship.name = 'design usage') );
      amt_bag : BAG OF assembly_module_terminal := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
      IF EXISTS(cttamta[i].relating_shape_aspect) THEN
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(cttamta[i].
            relating_shape_aspect)) AND (cttamta[i].relating_shape_aspect\shape_aspect.
            description = 'pca terminal') THEN
          IF cttamta[i].relating_shape_aspect IN amt_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- component_terminal_to_pca_terminal_assignment_unique_constraint

  RULE component_termination_passage_template_terminal_unique_constraint FOR (
             shape_aspect);

    LOCAL
      name_bag : BAG OF STRING := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      pass     : BOOLEAN := TRUE;
      ptd_bag  : BAG OF part_template_definition;
      ctptt    : BAG OF shape_aspect := QUERY ( sa <* shape_aspect | ((sa\shape_aspect.
                  description = 'component termination passage template interface terminal') 
                  OR (sa\shape_aspect.description = 
                  'component termination passage template join terminal')) );
      sa_bag   : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ctptt) BY 1;
      IF EXISTS(ctptt[i]\shape_aspect.name) THEN
        IF NOT (ctptt[i]\shape_aspect.name IN name_bag) THEN
          name_bag := name_bag + ctptt[i]\shape_aspect.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ptd_bag := [];
      sa_bag := QUERY ( sa <* ctptt | (sa\shape_aspect.name = name_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(sa_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
            = 'access mechanism') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PART_TEMPLATE_DEFINITION') IN TYPEOF(sar.relating_shape_aspect)) 
            AND (sar.relating_shape_aspect\shape_aspect.name = 
            'component termination passage template')) );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
            IF sar_bag[k].relating_shape_aspect IN ptd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- component_termination_passage_template_terminal_unique_constraint

  RULE composite_shape_element_constraint FOR (composite_shape_aspect);

  WHERE
    wr1: (SIZEOF(QUERY ( csa <* composite_shape_aspect | (SIZEOF(
             QUERY ( sar <* USEDIN(csa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name 
             = 'composing') )) < 2) )) = 0);

  END_RULE; -- composite_shape_element_constraint

  RULE conductive_interconnect_element_terminal_unique_constraint FOR (
             component_terminal);

    LOCAL
      name_bag : BAG OF STRING := [];
      csa_bag  : BAG OF component_shape_aspect;
      sar_bag  : BAG OF shape_aspect_relationship;
      ciet     : BAG OF component_terminal := QUERY ( ct <* 
                  component_terminal | (ct\shape_aspect.description = 
                  'conductive interconnect element terminal') );
      ct_bag   : BAG OF component_terminal;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ciet) BY 1;
      IF EXISTS(ciet[i]\shape_aspect.name) THEN
        IF NOT (ciet[i]\shape_aspect.name IN name_bag) THEN
          name_bag := name_bag + ciet[i]\shape_aspect.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ct_bag := QUERY ( ct <* ciet | (ct\shape_aspect.name = name_bag[i]) );
      csa_bag := [];
      REPEAT j := 1 TO SIZEOF(ct_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(ct_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
            = 'associated component') AND (sar.relating_shape_aspect\shape_aspect.
            description IN [
            'conductive interconnect element with pre defined transitions','conductive interconnect element with user defined single transition']) 
            AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
            + 'COMPONENT_SHAPE_ASPECT') IN TYPEOF(sar.relating_shape_aspect))) );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
            IF sar_bag[k].relating_shape_aspect IN csa_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              csa_bag := csa_bag + sar_bag[k].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- conductive_interconnect_element_terminal_unique_constraint

  RULE configuration_item_requires_person_organization FOR (
             configuration_item, applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT ((SIZEOF(
             QUERY ( apaoa <* applied_person_and_organization_assignment | 
             (ci IN apaoa.items) )) = 1) OR (SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | (ci IN aoa.items) )) = 1))) )) 
             = 0);

  END_RULE; -- configuration_item_requires_person_organization

  RULE connection_zone_constraint FOR (shape_aspect, representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sa <* shape_aspect | ((sa\shape_aspect.description = 
             'connection zone') AND (NOT (SIZEOF(QUERY ( pd <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sdr <* 
             USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (sdr.
             used_representation.context_of_items.context_type = 
             'connection zone colour') )) = 1) )) = 1))) )) = 0);
    wr2: (SIZEOF(QUERY ( sa <* shape_aspect | ((sa\shape_aspect.description = 
             'connection zone') AND (NOT (SIZEOF(QUERY ( pd <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sdr <* 
             USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_REPRESENTATION') IN TYPEOF(sdr.used_representation)) 
             AND (sdr.used_representation\representation.name = 'zone shape')) )) = 1) )) 
             = 1))) )) = 0);
    wr3: (SIZEOF(QUERY ( sa <* shape_aspect | ((sa\shape_aspect.description = 
             'connection zone') AND (NOT (SIZEOF(QUERY ( sar <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name 
             IN ['terminal connection zone','external connection zone',
             'external connection area','minimum attachment region size']) )) 
             <= 1))) )) = 0);
    wr4: (SIZEOF(QUERY ( sa <* shape_aspect | ((sa\shape_aspect.description = 
             'connection zone') AND (NOT (SIZEOF(QUERY ( sar <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name 
             IN ['internal connection zone']) )) <= 1))) )) = 0);

  END_RULE; -- connection_zone_constraint

  RULE connectivity_allocation_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'connectivity allocation') AND (SIZEOF(QUERY ( pds <* 
             USEDIN(pdr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_SHAPE') IN TYPEOF(pds)) AND (SIZEOF(
             QUERY ( pcd <* USEDIN(pds,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT.OF_SHAPE') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(pcd)) )) >= 1)) )) 
             = 0)) )) = 0);

  END_RULE; -- connectivity_allocation_constraint

  RULE connectivity_allocation_unique_constraint FOR (
             product_definition_relationship);

    LOCAL
      pd_bag  : BAG OF property_definition;
      pass    : BOOLEAN := TRUE;
      ca      : BAG OF product_definition_relationship := QUERY ( pdr <* 
                 product_definition_relationship | (pdr\product_definition_relationship.name = 
                 'connectivity allocation') );
      pcd_bag : BAG OF physical_connectivity_definition := [];
      sa_bag  : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ca) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pd_bag := USEDIN(ca[i].related_product_definition,
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION.DEFINITION');
      REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sa_bag := QUERY ( sa <* USEDIN(pd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT.OF_SHAPE') | ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(sa)) );
        REPEAT k := 1 TO SIZEOF(sa_bag) BY 1;
          IF EXISTS(sa_bag[k]) THEN
            IF sa_bag[k] IN pcd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pcd_bag := pcd_bag + sa_bag[k];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- connectivity_allocation_unique_constraint

  RULE contract_constraint FOR (contract);

  WHERE
    wr1: (SIZEOF(QUERY ( c <* contract | (SIZEOF(USEDIN(c,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0) )) = 0);

  END_RULE; -- contract_constraint

  RULE contract_unique_constraint FOR (contract);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF contract := QUERY ( r <* contract | TRUE );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i]\contract.name) THEN
        IF r[i]\contract.name IN name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + r[i]\contract.name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- contract_unique_constraint

  RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);

  WHERE
    wr1: (SIZEOF(QUERY ( nauo <* next_assembly_usage_occurrence | (NOT 
             assembly_shape_is_defined(nauo,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')) )) =
              0);

  END_RULE; -- coordinated_assembly_and_shape

  RULE curve_style_font_and_scaling_unique_constraint FOR (
             curve_style_font_and_scaling);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF curve_style_font_and_scaling := QUERY ( r <* 
                  curve_style_font_and_scaling | TRUE );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i]\curve_style_font_and_scaling.name) THEN
        IF r[i]\curve_style_font_and_scaling.name IN name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + r[i]\curve_style_font_and_scaling.name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- curve_style_font_and_scaling_unique_constraint

  RULE curve_style_requires_length_measure_with_unit FOR (curve_style);

  WHERE
    wr1: (SIZEOF(QUERY ( cs <* curve_style | (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(cs))) )) = 0);

  END_RULE; -- curve_style_requires_length_measure_with_unit

  RULE curve_style_unique_constraint FOR (representation);

    LOCAL
      desc_bag : BAG OF STRING := [];
      pass     : BOOLEAN := TRUE;
      cs       : BAG OF representation := QUERY ( r <* representation | ((
                  r\representation.name = 'curve style parameters') AND (r.
                  context_of_items.context_type = 
                  'curve style parametric context')) );
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(cs) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      REPEAT j := 1 TO SIZEOF(cs[i].items) BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(cs[i].items[j])) 
            AND (cs[i].items[j]\representation_item.name = 'curve style name') THEN
          IF EXISTS(cs[i].items[j].description) THEN
            IF cs[i].items[j].description IN desc_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              desc_bag := desc_bag + cs[i].items[j].description;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- curve_style_unique_constraint

  RULE date_and_time_require_minute_and_second FOR (date_and_time);

  WHERE
    wr1: (SIZEOF(QUERY ( dat <* date_and_time | (NOT EXISTS(dat.
             time_component.minute_component)) )) = 0);
    wr2: (SIZEOF(QUERY ( dat <* date_and_time | (NOT EXISTS(dat.
             time_component.second_component)) )) = 0);

  END_RULE; -- date_and_time_require_minute_and_second

  RULE date_constraint FOR (date);

  WHERE
    wr1: (SIZEOF(QUERY ( d <* date | (d.year_component < 1856) )) = 0);

  END_RULE; -- date_constraint

  RULE datum_feature_usage_in_datum_relationship_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      pud_bag  : BAG OF physical_unit_datum;
      pudf_bag : BAG OF physical_unit_datum_feature := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      dfuidr   : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                  shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
                  'datum feature usage in common datum') OR (sar\shape_aspect_relationship.name = 
                  'datum feature usage in single datum')) );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dfuidr) BY 1;
      IF EXISTS(dfuidr[i].relating_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT_DATUM') IN TYPEOF(dfuidr[i].
            relating_shape_aspect) THEN
          IF NOT (dfuidr[i].relating_shape_aspect IN pud_bag) THEN
            pud_bag := pud_bag + dfuidr[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pud_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pudf_bag := [];
      sar_bag := QUERY ( sar <* dfuidr | ((sar.relating_shape_aspect :=: 
          pud_bag[i]) AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PHYSICAL_UNIT_DATUM_FEATURE') IN TYPEOF(sar.related_shape_aspect))) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF sar_bag[j].related_shape_aspect IN pudf_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            pudf_bag := pudf_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- datum_feature_usage_in_datum_relationship_unique_constraint

  RULE datum_precedence_assignment_unique_constraint FOR (
             property_definition);

    LOCAL
      pdr_bag  : BAG OF property_definition_relationship;
      name_bag : BAG OF STRING := [];
      pd_bag   : BAG OF property_definition;
      dpa      : BAG OF property_definition := QUERY ( pd <* 
                  property_definition | (pd\property_definition.description = 
                  'datum precedence assignment') );
      pass     : BOOLEAN := TRUE;
      pds      : BAG OF property_definition;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dpa) BY 1;
      IF EXISTS(dpa[i]\property_definition.name) THEN
        IF NOT (dpa[i]\property_definition.name IN name_bag) THEN
          name_bag := name_bag + dpa[i]\property_definition.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pds := [];
      pd_bag := QUERY ( pd <* dpa | (pd\property_definition.name = name_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
             | ((pdr\property_definition_relationship.name = 'assigned datum precedence') AND (pdr.
            relating_property_definition\property_definition.description IN [
            'datum system property with material conditions',
            'datum system property without material conditions'])) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].relating_property_definition) THEN
            IF pdr_bag[k].relating_property_definition IN pds THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pds := pds + pdr_bag[k].relating_property_definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- datum_precedence_assignment_unique_constraint

  RULE datum_target_usage_in_datum_target_set_relationship_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      sar_bag   : BAG OF shape_aspect_relationship;
      pass1     : BOOLEAN := TRUE;
      pass2     : BOOLEAN := TRUE;
      dtuidts   : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                   shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
                   'datum target usage') );
      pudt_bag  : BAG OF physical_unit_datum_target;
      pudts_bag : BAG OF physical_unit_datum_target_set := [];
      num_bag   : BAG OF STRING;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dtuidts) BY 1;
      IF EXISTS(dtuidts[i].relating_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT_DATUM_TARGET_SET') IN TYPEOF(dtuidts[i].
            relating_shape_aspect) THEN
          IF NOT (dtuidts[i].relating_shape_aspect IN pudts_bag) THEN
            pudts_bag := pudts_bag + dtuidts[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pudts_bag) BY 1;
      IF NOT (pass1 AND pass2) THEN
        ESCAPE;
      END_IF;
      num_bag := [];
      pudt_bag := [];
      sar_bag := QUERY ( sar <* dtuidts | (sar.relating_shape_aspect :=: 
          pudts_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF NOT (pass1 AND pass2) THEN
          ESCAPE;
        END_IF;
        IF pass1 AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT_DATUM_TARGET') IN TYPEOF(sar_bag[j].
            related_shape_aspect)) THEN
          IF EXISTS(sar_bag[j].related_shape_aspect) THEN
            IF sar_bag[j].related_shape_aspect IN pudt_bag THEN
              pass1 := FALSE;
            ELSE
              pudt_bag := pudt_bag + sar_bag[j].related_shape_aspect;
            END_IF;
          END_IF;
        END_IF;
        IF pass2 THEN
          IF EXISTS(sar_bag[j]\shape_aspect_relationship.description) THEN
            IF sar_bag[j]\shape_aspect_relationship.description IN num_bag THEN
              pass2 := FALSE;
            ELSE
              num_bag := num_bag + sar_bag[j]\shape_aspect_relationship.description;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass1;
    wr2: pass2;

  END_RULE; -- datum_target_usage_in_datum_target_set_relationship_unique_constraint

  RULE datum_usage_in_datum_system_relationship_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      ds_bag  : BAG OF datum_system := [];
      pud_bag : BAG OF physical_unit_datum;
      sar_bag : BAG OF shape_aspect_relationship;
      duidsr  : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                 shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
                 'datum usage in datum system') );
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(duidsr) BY 1;
      IF EXISTS(duidsr[i].relating_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'DATUM_SYSTEM') IN TYPEOF(duidsr[i].relating_shape_aspect)
             THEN
          IF NOT (duidsr[i].relating_shape_aspect IN ds_bag) THEN
            ds_bag := ds_bag + duidsr[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(ds_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pud_bag := [];
      sar_bag := QUERY ( sar <* duidsr | (sar.relating_shape_aspect :=: 
          ds_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'PHYSICAL_UNIT_DATUM') IN TYPEOF(sar_bag[j].
              related_shape_aspect) THEN
            IF sar_bag[j].related_shape_aspect IN pud_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pud_bag := pud_bag + sar_bag[j].related_shape_aspect;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- datum_usage_in_datum_system_relationship_unique_constraint

  RULE default_assembly_bond_shape_constraint FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'default assembly bond shape') AND (NOT (SIZEOF(
             QUERY ( pdr <* USEDIN(sr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') IN 
             TYPEOF(pdr.definition.definition)) )) = 1))) )) = 0);

  END_RULE; -- default_assembly_bond_shape_constraint

  RULE default_passage_based_land_physical_template_unique_constraint FOR (
             land_physical_template);

    LOCAL
      pdr_bag : BAG OF property_definition_relationship;
      sar_bag : BAG OF shape_aspect_relationship;
      st_bag  : BAG OF stratum_technology;
      dpblpt  : BAG OF land_physical_template := QUERY ( lpt <* 
                 land_physical_template | (lpt\shape_aspect.description IN 
                 ['default via based',
                 'default attachment size and via based',
                 'default unsupported passage based',
                 'default component termination passage based','default attachment size and component termination passage based']) );
      pt_bag  : BAG OF passage_technology := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dpblpt) BY 1;
      sar_bag := QUERY ( sar <* USEDIN(dpblpt[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
           'technology usage') AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PASSAGE_TECHNOLOGY') IN TYPEOF(sar.related_shape_aspect))) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF NOT (sar_bag[j].related_shape_aspect IN pt_bag) THEN
            pt_bag := pt_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pt_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      st_bag := [];
      sar_bag := QUERY ( sar <* USEDIN(pt_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name = 
          'technology usage') AND (sar.relating_shape_aspect IN dpblpt)) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(sar_bag[j].relating_shape_aspect\shape_aspect.
            of_shape,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
             | ((pdr\property_definition_relationship.name = 'technology usage') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'STRATUM_TECHNOLOGY') IN TYPEOF(pdr.
            relating_property_definition.definition))) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].relating_property_definition.definition)
               THEN
            IF pdr_bag[k].relating_property_definition.definition IN 
                st_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              st_bag := st_bag + pdr_bag[k].relating_property_definition.
                  definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- default_passage_based_land_physical_template_unique_constraint

  RULE delete_design_object_management_relationship_unique_constraint FOR (
             delete_design_object_assignment, 
             delete_design_object_request_assignment);

    LOCAL
      pdr_bag   : BAG OF product_definition_relationship := [];
      ddoa_bag  : BAG OF delete_design_object_assignment;
      pd_bag    : BAG OF product_definition := [];
      ddora_bag : BAG OF delete_design_object_request_assignment;
      mdo_bag   : BAG OF managed_design_object;
      pass      : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(delete_design_object_assignment) BY 1;
      REPEAT j := 1 TO SIZEOF(delete_design_object_assignment[i].items)
           BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(
            delete_design_object_assignment[i].items[j])) AND (
            delete_design_object_assignment[i].items[j].name = 
            'design object deletion') THEN
          IF EXISTS(delete_design_object_assignment[i].items[j].
              relating_product_definition) THEN
            IF NOT (delete_design_object_assignment[i].items[j].
                relating_product_definition IN pd_bag) THEN
              pd_bag := pd_bag + delete_design_object_assignment[i].items[
                  j].relating_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(delete_design_object_request_assignment) BY 1;
      REPEAT j := 1 TO SIZEOF(delete_design_object_request_assignment[i].
          items) BY 1;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(
            delete_design_object_request_assignment[i].items[j])) AND (
            delete_design_object_request_assignment[i].items[j].name = 
            'design object deletion') THEN
          IF EXISTS(delete_design_object_request_assignment[i].items[j].
              relating_product_definition) THEN
            IF NOT (delete_design_object_request_assignment[i].items[j].
                relating_product_definition IN pd_bag) THEN
              pd_bag := pd_bag + delete_design_object_request_assignment[i]
                  .items[j].relating_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      mdo_bag := [];
      pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
          (pdr\product_definition_relationship.name = 'design object deletion') );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        ddoa_bag := QUERY ( ddoa <* delete_design_object_assignment | (
            pdr_bag[j] IN ddoa.items) );
        REPEAT k := 1 TO SIZEOF(ddoa_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(ddoa_bag[k].items) BY 1;
            IF EXISTS(ddoa_bag[k].items[l]) THEN
              IF ddoa_bag[k].items[l] IN mdo_bag THEN
                pass := FALSE;
                ESCAPE;
              ELSE
                mdo_bag := mdo_bag + ddoa_bag[k].items[l];
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        ddora_bag := QUERY ( ddora <* 
            delete_design_object_request_assignment | (pdr_bag[j] IN ddora.
            items) );
        REPEAT k := 1 TO SIZEOF(ddora_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(ddora_bag[k].items) BY 1;
            IF EXISTS(ddora_bag[k].items[l]) THEN
              IF ddora_bag[k].items[l] IN mdo_bag THEN
                pass := FALSE;
                ESCAPE;
              ELSE
                mdo_bag := mdo_bag + ddora_bag[k].items[l];
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- delete_design_object_management_relationship_unique_constraint

  RULE dependent_instantiable_action_directive FOR (action_directive);

  WHERE
    wr1: (SIZEOF(QUERY ( ad <* action_directive | (NOT (SIZEOF(USEDIN(ad,
             '')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_action_directive

  RULE dependent_instantiable_address FOR (address);

  WHERE
    wr1: (SIZEOF(QUERY ( add <* address | (NOT (SIZEOF(USEDIN(add,'')) >= 
             1)) )) = 0);

  END_RULE; -- dependent_instantiable_address

  RULE dependent_instantiable_approval_status FOR (approval_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (SIZEOF(USEDIN(ast,
             '')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_approval_status

  RULE dependent_instantiable_certification_type FOR (certification_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (SIZEOF(USEDIN(ct,
             '')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_certification_type

  RULE dependent_instantiable_contract_type FOR (contract_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (SIZEOF(USEDIN(ct,'')) 
             >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_contract_type

  RULE dependent_instantiable_date FOR (date);

  WHERE
    wr1: (SIZEOF(QUERY ( dt <* date | (NOT (SIZEOF(USEDIN(dt,'')) >= 1)) )) 
             = 0);

  END_RULE; -- dependent_instantiable_date

  RULE dependent_instantiable_date_role FOR (date_role);

  WHERE
    wr1: (SIZEOF(QUERY ( dr <* date_role | (NOT (SIZEOF(USEDIN(dr,'')) >= 
             1)) )) = 0);

  END_RULE; -- dependent_instantiable_date_role

  RULE dependent_instantiable_date_time_role FOR (date_time_role);

  WHERE
    wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (SIZEOF(USEDIN(dtr,
             '')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_date_time_role

  RULE dependent_instantiable_document_type FOR (document_type);

  WHERE
    wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (SIZEOF(USEDIN(dt,'')) 
             >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_document_type

  RULE dependent_instantiable_named_unit FOR (named_unit);

  WHERE
    wr1: (SIZEOF(QUERY ( nu <* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) >=
              1)) )) = 0);

  END_RULE; -- dependent_instantiable_named_unit

  RULE dependent_instantiable_organization_role FOR (organization_role);

  WHERE
    wr1: (SIZEOF(QUERY ( org <* organization_role | (NOT (SIZEOF(USEDIN(
             org,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_organization_role

  RULE dependent_instantiable_parametric_representation_context FOR (
             parametric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( prc <* parametric_representation_context | (NOT (
             SIZEOF(USEDIN(prc,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_parametric_representation_context

  RULE dependent_instantiable_person_and_organization_role FOR (
             person_and_organization_role);

  WHERE
    wr1: (SIZEOF(QUERY ( poar <* person_and_organization_role | (NOT (
             SIZEOF(USEDIN(poar,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_person_and_organization_role

  RULE dependent_instantiable_representation_item FOR (representation_item);

  WHERE
    wr1: (SIZEOF(QUERY ( ri <* representation_item | (NOT (SIZEOF(USEDIN(
             ri,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_representation_item

  RULE dependent_instantiable_security_classification_level FOR (
             security_classification_level);

  WHERE
    wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (
             SIZEOF(USEDIN(scl,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_security_classification_level

  RULE dependent_instantiable_shape_representation FOR (
             shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT (SIZEOF(USEDIN(
             sr,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_shape_representation

  RULE dependent_instantiable_tolerance_value FOR (tolerance_value);

  WHERE
    wr1: (SIZEOF(QUERY ( tv <* tolerance_value | (NOT (SIZEOF(USEDIN(tv,'')) 
             >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_tolerance_value

  RULE dependently_located_layer_connection_point_unique_constraint FOR (
             layer_connection_point);

    LOCAL
      sar_bag : BAG OF shape_aspect_relationship;
      s_bag   : BAG OF stratum := [];
      lcp_bag : BAG OF layer_connection_point;
      pass    : BOOLEAN := TRUE;
      dllcp   : BAG OF layer_connection_point := QUERY ( lcp <* 
                 layer_connection_point | (lcp.description = 
                 'dependently located') );
      sa_bag  : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dllcp) BY 1;
      IF EXISTS(dllcp[i].of_shape.definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'STRATUM') IN TYPEOF(dllcp[i].of_shape.definition) THEN
          IF NOT (dllcp[i].of_shape.definition IN s_bag) THEN
            s_bag := s_bag + dllcp[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      lcp_bag := QUERY ( lcp <* dllcp | (lcp.of_shape.definition :=: s_bag
          [i]) );
      sa_bag := [];
      REPEAT j := 1 TO SIZEOF(lcp_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(lcp_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
            = 'associated design object') AND (((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'INTER_STRATUM_FEATURE') IN TYPEOF(sar.relating_shape_aspect)) 
            OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'INTERCONNECT_MODULE_TERMINAL') IN TYPEOF(sar.
            relating_shape_aspect)))) );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
            IF sar_bag[k].relating_shape_aspect IN sa_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              sa_bag := sa_bag + sar_bag[k].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- dependently_located_layer_connection_point_unique_constraint

  RULE design_functional_unit_allocation_to_assembly_component_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr.
             name = 
             'design functional unit allocation to assembly component') AND
              (NOT ((pdr.relating_product_definition\product_definition.description = 
             'design definition path') AND (pdr.relating_product_definition
             .id = 'design composition path')))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr.
             name = 
             'design functional unit allocation to assembly component') AND
              (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_DEFINITION') IN TYPEOF(pdr.
             related_product_definition)))) )) = 0);

  END_RULE; -- design_functional_unit_allocation_to_assembly_component_constraint

  RULE design_functional_unit_allocation_to_assembly_component_unique_constraint FOR (
             product_definition_relationship);

    LOCAL
      pdr_bag : BAG OF product_definition_relationship;
      dfuatac : BAG OF product_definition_relationship := QUERY ( pdr <* 
                 product_definition_relationship | (pdr\product_definition_relationship.name = 
                 'design functional unit allocation to assembly component') );
      cd_bag  : BAG OF component_definition := [];
      pass    : BOOLEAN := TRUE;
      id_bag  : BAG OF STRING;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dfuatac) BY 1;
      IF EXISTS(dfuatac[i].related_product_definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'COMPONENT_DEFINITION') IN TYPEOF(dfuatac[i].
            related_product_definition) THEN
          IF NOT (dfuatac[i].related_product_definition IN cd_bag) THEN
            cd_bag := cd_bag + dfuatac[i].related_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pdr_bag := QUERY ( pdr <* dfuatac | (pdr.related_product_definition 
          :=: cd_bag[i]) );
      id_bag := [];
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF EXISTS(pdr_bag[j].id) THEN
          IF pdr_bag[j].id IN id_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            id_bag := id_bag + pdr_bag[j].id;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- design_functional_unit_allocation_to_assembly_component_unique_constraint

  RULE design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR (
             product_definition_relationship);

    LOCAL
      dfuataj : BAG OF product_definition_relationship := QUERY ( pdr <* 
                 product_definition_relationship | (pdr\product_definition_relationship.name = 
                 'design functional unit allocation to assembly joint') );
      pd_bag  : BAG OF product_definition := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dfuataj) BY 1;
      IF EXISTS(dfuataj[i].relating_product_definition) THEN
        IF dfuataj[i].relating_product_definition.id = 
            'design composition path' THEN
          IF dfuataj[i].relating_product_definition IN pd_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            pd_bag := pd_bag + dfuataj[i].relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- design_functional_unit_allocation_to_assembly_joint_unique_constraint

  RULE design_functional_unit_allocation_to_fabrication_joint_unique_constraint FOR (
             product_definition_relationship);

    LOCAL
      dfuatfj : BAG OF product_definition_relationship := QUERY ( pdr <* 
                 product_definition_relationship | (pdr\product_definition_relationship.name = 
                 'design functional unit allocation to fabrication joint') );
      pd_bag  : BAG OF product_definition := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dfuatfj) BY 1;
      IF EXISTS(dfuatfj[i].relating_product_definition) THEN
        IF dfuatfj[i].relating_product_definition.id = 
            'design composition path' THEN
          IF dfuatfj[i].relating_product_definition IN pd_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            pd_bag := pd_bag + dfuatfj[i].relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- design_functional_unit_allocation_to_fabrication_joint_unique_constraint

  RULE design_intent_modification_in_stratum_3d_position_constraint FOR (
             mapped_item);

  WHERE
    wr1: (SIZEOF(QUERY ( mi <* mapped_item | ((mi\representation_item.name = 
             'positioned design intent modification shape in stratum') AND 
             (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_3D') IN TYPEOF(mi.mapping_target)))) )) = 0);

  END_RULE; -- design_intent_modification_in_stratum_3d_position_constraint

  RULE design_intent_modification_in_stratum_planar_position_constraint FOR (
             mapped_item);

  WHERE
    wr1: (SIZEOF(QUERY ( mi <* mapped_item | ((mi\representation_item.name = 
             'design intent modification in stratum planar position') AND (
             NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'AXIS2_PLACEMENT_2D') IN TYPEOF(mi.mapping_target)))) )) = 0);
    wr2: (SIZEOF(QUERY ( mi <* mapped_item | ((mi\representation_item.name = 
             'design intent modification in stratum planar position') AND (
             SIZEOF(QUERY ( rep <* USEDIN(mi,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REPRESENTATION.ITEMS') | (SIZEOF(USEDIN(rep,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) = 0) )) 
             = 0)) )) = 0);
    wr3: (SIZEOF(QUERY ( mi <* mapped_item | ((mi\representation_item.name = 
             'design intent modification in stratum planar position') AND (
             NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'AXIS2_PLACEMENT_2D') IN TYPEOF(mi.mapping_source.
             mapped_representation)))) )) = 0);

  END_RULE; -- design_intent_modification_in_stratum_planar_position_constraint

  RULE design_intent_modification_sequence_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'shape modification sequence') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_MODIFICATION') IN TYPEOF(sar.relating_shape_aspect)))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'shape modification sequence') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_MODIFICATION') IN TYPEOF(sar.related_shape_aspect)))) )) 
             = 0);

  END_RULE; -- design_intent_modification_sequence_constraint

  RULE design_intent_modification_sequence_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      dims    : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                 shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
                 'shape modification sequence') );
      sar_bag : BAG OF shape_aspect_relationship;
      pm_bag  : BAG OF shape_modification := [];
      pass    : BOOLEAN := TRUE;
      sm_bag  : BAG OF shape_modification;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dims) BY 1;
      IF EXISTS(dims[i].relating_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_MODIFICATION') IN TYPEOF(dims[i].relating_shape_aspect)
             THEN
          IF NOT (dims[i].relating_shape_aspect IN pm_bag) THEN
            pm_bag := pm_bag + dims[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pm_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar_bag := QUERY ( sar <* dims | (sar.relating_shape_aspect :=: 
          pm_bag[i]) );
      sm_bag := [];
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'SHAPE_MODIFICATION') IN TYPEOF(sar_bag[j].
              related_shape_aspect) THEN
            IF sar_bag[j].related_shape_aspect IN sm_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              sm_bag := sm_bag + sar_bag[j].related_shape_aspect;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- design_intent_modification_sequence_unique_constraint

  RULE device_terminal_map_relationship_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'device terminal map relationship') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DEVICE_TERMINAL_MAP') IN TYPEOF(sar.relating_shape_aspect)))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'device terminal map relationship') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DEVICE_TERMINAL_MAP') IN TYPEOF(sar.related_shape_aspect)))) )) 
             = 0);

  END_RULE; -- device_terminal_map_relationship_constraint

  RULE dimension_along_curve_unique_constraint FOR (
             dimensional_location_with_path);

    LOCAL
      pass   : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dimensional_location_with_path) BY 1;
      IF EXISTS(dimensional_location_with_path[i].path) THEN
        IF dimensional_location_with_path[i].path IN sa_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sa_bag := sa_bag + dimensional_location_with_path[i].path;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- dimension_along_curve_unique_constraint

  RULE dimension_location_with_direction_vector_unique_constraint FOR (
             dimensional_location_with_direction);

    LOCAL
      p_bag     : BAG OF property_definition;
      pdr_bag   : BAG OF property_definition_relationship;
      pdrep_bag : BAG OF property_definition_representation;
      pd_bag    : BAG OF property_definition := [];
      place_bag : BAG OF placement := [];
      pass      : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dimensional_location_with_direction) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      p_bag := QUERY ( pd <* USEDIN(dimensional_location_with_direction[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
          'dimensional location property') );
      REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(p_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
             | ((pdr\property_definition_relationship.name = 'measurement orientation') AND (pdr.
            related_property_definition\property_definition.description = 
            'datum based vector orientation')) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].related_property_definition) THEN
            IF pdr_bag[k].related_property_definition IN pd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pd_bag := pd_bag + pdr_bag[k].related_property_definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
      REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdrep_bag := USEDIN(p_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
        REPEAT k := 1 TO SIZEOF(pdrep_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(pdrep_bag[k].used_representation.items)
               BY 1;
            IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                + 'PLACEMENT') IN TYPEOF(pdrep_bag[k].used_representation.
                items[l])) AND (pdrep_bag[k].used_representation.items[l].
                name = 'orientation') THEN
              IF EXISTS(pdrep_bag[k].used_representation.items[l]) THEN
                IF pdrep_bag[k].used_representation.items[l] IN place_bag
                     THEN
                  pass := FALSE;
                  ESCAPE;
                ELSE
                  place_bag := place_bag + pdrep_bag[k].
                      used_representation.items[l];
                END_IF;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- dimension_location_with_direction_vector_unique_constraint

  RULE directed_action_requires_approval FOR (directed_action, 
             applied_approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( da <* directed_action | (NOT (SIZEOF(
             QUERY ( aaa <* applied_approval_assignment | (da IN aaa.items) )) 
             = 1)) )) = 0);

  END_RULE; -- directed_action_requires_approval

  RULE directed_action_requires_date_or_date_and_time FOR (directed_action, 
             applied_date_and_time_assignment, applied_date_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( da <* directed_action | (NOT ((SIZEOF(
             QUERY ( adata <* applied_date_and_time_assignment | ((da IN 
             adata.items) AND (adata.role.name = 'start date')) )) = 1) OR 
             (SIZEOF(QUERY ( ada <* applied_date_assignment | ((da IN ada.
             items) AND (ada.role.name = 'start date')) )) = 1))) )) = 0);

  END_RULE; -- directed_action_requires_date_or_date_and_time

  RULE directed_axis_constraint FOR (derived_shape_aspect);

  WHERE
    wr1: (SIZEOF(QUERY ( dsa <* derived_shape_aspect | ((dsa\shape_aspect.description =
              'directed axis') AND (NOT (SIZEOF(QUERY ( sar <* USEDIN(dsa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
             name = 'derived axis') AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CENTRE_OF_SYMMETRY') IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect)) 
             AND (sar\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'axis')) )) =
              1))) )) = 0);
    wr2: (SIZEOF(QUERY ( dsa <* derived_shape_aspect | ((dsa\shape_aspect.description =
              'directed axis') AND (NOT (SIZEOF(QUERY ( sar <* USEDIN(dsa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
             name = 'end shape aspect') AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT') IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))) )) 
             = 1))) )) = 0);
    wr3: (SIZEOF(QUERY ( dsa <* derived_shape_aspect | ((dsa\shape_aspect.description =
              'directed axis') AND (NOT (SIZEOF(QUERY ( sar <* USEDIN(dsa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.
             name = 'start shape aspect') AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT') IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))) )) 
             = 1))) )) = 0);

  END_RULE; -- directed_axis_constraint

  RULE directed_axis_unique_constraint FOR (derived_shape_aspect);

    LOCAL
      cos_bag  : BAG OF centre_of_symmetry := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      da       : BAG OF derived_shape_aspect := QUERY ( r <* 
                  derived_shape_aspect | (r\shape_aspect.description = 'directed axis') );
      pass     : BOOLEAN := TRUE;
      sar2_bag : BAG OF shape_aspect_relationship;
      sa_bag   : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(da) BY 1;
      sar_bag := QUERY ( sar <* USEDIN(da[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
           'derived axis') AND (sar.related_shape_aspect\shape_aspect.description = 
          'axis') AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'CENTRE_OF_SYMMETRY') IN TYPEOF(sar.related_shape_aspect))) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF NOT (sar_bag[j].related_shape_aspect IN cos_bag) THEN
            cos_bag := cos_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(cos_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sa_bag := [];
      sar_bag := QUERY ( sar <* USEDIN(cos_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name = 
          'derived axis') AND (sar.relating_shape_aspect IN da)) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar2_bag := QUERY ( sar <* USEDIN(sar_bag[j].relating_shape_aspect,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name 
            = 'start shape aspect') );
        REPEAT k := 1 TO SIZEOF(sar2_bag) BY 1;
          IF EXISTS(sar2_bag[k].related_shape_aspect) THEN
            IF sar2_bag[k].related_shape_aspect IN sa_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              sa_bag := sa_bag + sar2_bag[k].related_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- directed_axis_unique_constraint

  RULE direction_element_constraint FOR (property_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'direction element') AND (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
              | ((pdr\property_definition_relationship.name = 'element direction vector') AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION') IN TYPEOF(pdr.
             related_property_definition)) AND (pdr.
             related_property_definition\property_definition.description = 
             'datum direction_property')) )) = 1))) )) = 0);
    wr2: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'direction element') AND (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
              | ((pdr\property_definition_relationship.name = 'half datum plane direction vector') AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION') IN TYPEOF(pdr.
             related_property_definition)) AND (pdr.
             related_property_definition\property_definition.description = 
             'datum direction_property')) )) = 1))) )) = 0);
    wr3: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'direction element') AND (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
              | ((pdr\property_definition_relationship.name = 'direction component') AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION') IN TYPEOF(pdr.
             related_property_definition)) AND (pdr.
             related_property_definition\property_definition.description = 
             'datum based vector orientation')) )) = 1))) )) = 0);

  END_RULE; -- direction_element_constraint

  RULE edge_segment_vertex_constraint FOR (shape_aspect_relationship, 
             edge_segment_vertex);

    LOCAL
      sar  : BAG OF shape_aspect_relationship := [];
      esv  : BAG OF edge_segment_vertex := QUERY ( e <* 
              edge_segment_vertex | (e <> []) );
      pass : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(esv) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar := QUERY ( sar <* shape_aspect_relationship | (esv[i] = sar\
          shape_aspect_relationship.related_shape_aspect) );
      pass := SIZEOF(sar) = 2;
      REPEAT j := 2 TO SIZEOF(sar) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pass := sar[j] :<>: sar[j - 1];
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pass := TYPEOF(sar[j]) = TYPEOF(sar[j - 1]);
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pass := sar[j].relating_shape_aspect :=: sar[j - 1].
            relating_shape_aspect;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- edge_segment_vertex_constraint

  RULE edge_segment_vertex_unique_constraint FOR (edge_segment_vertex);

    LOCAL
      pdr_bag  : BAG OF property_definition_representation;
      desc_bag : BAG OF STRING := [];
      pd_bag   : BAG OF property_definition;
      esv      : BAG OF edge_segment_vertex := QUERY ( r <* 
                  edge_segment_vertex | (r\shape_aspect.name = 'single datum') );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(esv) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pd_bag := QUERY ( pd <* USEDIN(esv[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
          'shape element characterization') );
      REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := USEDIN(pd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          IF (pdr_bag[k].used_representation\representation.name = 
              'shape element characterization') AND ((
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(pdr_bag[k].
              used_representation.items[1])) THEN
            IF EXISTS(pdr_bag[k].used_representation.items[1].description)
                 THEN
              IF pdr_bag[k].used_representation.items[1].description IN 
                  desc_bag THEN
                pass := FALSE;
                ESCAPE;
              ELSE
                desc_bag := desc_bag + pdr_bag[k].used_representation.
                    items[1].description;
              END_IF;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- edge_segment_vertex_unique_constraint

  RULE ee_colour_unique_constraint FOR (colour_rgb, colour_specification);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF colour_rgb := QUERY ( r <* colour_rgb | TRUE );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i]\colour_specification.name) THEN
        IF r[i]\colour_specification.name IN name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + r[i]\colour_specification.name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_colour_unique_constraint

  RULE ee_document_constraint FOR (document);

  WHERE
    wr1: (SIZEOF(QUERY ( doc <* document | (SIZEOF(QUERY ( adata <* 
             USEDIN(doc,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adata.role.name =
              'creation date') )) = 0) )) = 0);
    wr2: (SIZEOF(QUERY ( doc <* document | (NOT ((SIZEOF(QUERY ( aoa <* 
             USEDIN(doc,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (aoa.role.name = 
             'publisher') )) = 1) OR (SIZEOF(QUERY ( apaoa <* USEDIN(doc,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | (apaoa.
             role.name = 'publisher') )) = 1))) )) = 0);

  END_RULE; -- ee_document_constraint

  RULE ee_document_identifier_unique_constraint FOR (document);

    LOCAL
      pass   : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(document) BY 1;
      IF EXISTS(document[i].id) THEN
        IF document[i].id IN id_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + document[i].id;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_document_identifier_unique_constraint

  RULE ee_document_unique_constraint FOR (document);

    LOCAL
      pass   : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(document) BY 1;
      IF EXISTS(document[i].id) THEN
        IF document[i].id IN id_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + document[i].id;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_document_unique_constraint

  RULE ee_material_unique_constraint FOR (material_designation);

    LOCAL
      name_bag : BAG OF STRING := [];
      adr_bag  : BAG OF applied_document_reference;
      doc_bag  : BAG OF ee_specification;
      pass     : BOOLEAN := TRUE;
      md_bag   : BAG OF material_designation;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(material_designation) BY 1;
      IF EXISTS(material_designation[i].name) THEN
        IF NOT (material_designation[i].name IN name_bag) THEN
          name_bag := name_bag + material_designation[i].name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      md_bag := QUERY ( md <* material_designation | (md.name = name_bag[i]) );
      doc_bag := [];
      REPEAT j := 1 TO SIZEOF(md_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        adr_bag := QUERY ( adr <* USEDIN(md_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_DOCUMENT_REFERENCE.ITEMS') | ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'DOCUMENT') IN TYPEOF(adr.assigned_document)) );
        REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
          IF EXISTS(adr_bag[k].assigned_document) THEN
            IF adr_bag[k].assigned_document IN doc_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              doc_bag := doc_bag + adr_bag[k].assigned_document;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_material_unique_constraint

  RULE ee_product_configuration_unique_constraint FOR (configuration_item);

    LOCAL
      cd_bag  : BAG OF configuration_design;
      ci_bag  : BAG OF configuration_item;
      pass    : BOOLEAN := TRUE;
      id_bag  : BAG OF STRING := [];
      pdf_bag : BAG OF product_definition_formation;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(configuration_item) BY 1;
      IF EXISTS(configuration_item[i].id) THEN
        IF NOT (configuration_item[i].id IN id_bag) THEN
          id_bag := id_bag + configuration_item[i].id;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pdf_bag := [];
      ci_bag := QUERY ( ci <* configuration_item | (ci.id = id_bag[i]) );
      REPEAT j := 1 TO SIZEOF(ci_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        cd_bag := USEDIN(ci_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'CONFIGURATION_DESIGN.CONFIGURATION');
        REPEAT k := 1 TO SIZEOF(cd_bag) BY 1;
          IF EXISTS(cd_bag[k].design) THEN
            IF cd_bag[k].design IN pdf_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pdf_bag := pdf_bag + cd_bag[k].design;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_product_configuration_unique_constraint

  RULE ee_product_constraint FOR (product);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT ((SIZEOF(QUERY ( aoa <* 
             USEDIN(prod,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (aoa.role.name = 
             'design owner') )) = 1) OR (SIZEOF(QUERY ( apaoa <* USEDIN(
             prod,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | (apaoa
             .role.name = 'design owner') )) = 1))) )) = 0);
    wr2: (SIZEOF(QUERY ( p <* product | (SIZEOF(USEDIN(p,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT')) = 0) )) = 0);
--tt temporary patch for wr3, cardinality still not correct
    wr3: (SIZEOF(QUERY ( p <* product | (SIZEOF(USEDIN(p,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')) = 0) )) = 0);

  END_RULE; -- ee_product_constraint

  RULE ee_product_definition_constraint FOR (
             product_definition_with_associated_documents);

  WHERE
    wr1: (SIZEOF(QUERY ( pdwad <* 
             product_definition_with_associated_documents | (NOT (SIZEOF(
             QUERY ( adata <* USEDIN(pdwad,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adata.role.name =
              'creation date') )) = 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( pdwad <* 
             product_definition_with_associated_documents | (NOT ((SIZEOF(
             QUERY ( aoa <* USEDIN(pdwad,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (aoa.role.name = 
             'creator') )) = 1) OR (SIZEOF(QUERY ( apaoa <* USEDIN(pdwad,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | (apaoa.
             role.name = 'creator') )) = 1))) )) = 0);
    wr3: (SIZEOF(QUERY ( pdwad <* 
             product_definition_with_associated_documents | (NOT (SIZEOF(
             USEDIN(pdwad,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1)) )) = 0);
    wr4: (SIZEOF(QUERY ( pdwad <* 
             product_definition_with_associated_documents | (NOT (SIZEOF(
             USEDIN(pdwad,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1)) )) 
             = 0);

  END_RULE; -- ee_product_definition_constraint

  RULE ee_product_definition_unique_constraint FOR (
             product_definition_with_associated_documents, physical_unit, 
             functional_unit);

    LOCAL
      epd     : BAG OF product_definition;
      lcs_bag : BAG OF STRING;
      pd_bag  : BAG OF product_definition;
      fu      : BAG OF product_definition := QUERY ( r <* functional_unit
                  | TRUE );
      pass1   : BOOLEAN := TRUE;
      pass2   : BOOLEAN := TRUE;
      pu      : BAG OF product_definition := QUERY ( r <* physical_unit | 
                 TRUE );
      pdwad   : BAG OF product_definition := QUERY ( r <* 
                 product_definition_with_associated_documents | TRUE );
      id_bag  : BAG OF STRING;
      pdf_bag : BAG OF product_definition_formation;
    END_LOCAL;
    epd := pdwad + pu + fu;
    REPEAT i := 1 TO SIZEOF(epd) BY 1;
      IF EXISTS(epd[i].formation) THEN
        IF NOT (epd[i].formation IN pdf_bag) THEN
          pdf_bag := pdf_bag + epd[i].formation;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pdf_bag) BY 1;
      IF NOT (pass1 OR pass2) THEN
        ESCAPE;
      END_IF;
      lcs_bag := [];
      id_bag := [];
      pd_bag := QUERY ( pd <* epd | (pd.formation :=: pdf_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
        IF NOT (pass1 OR pass2) THEN
          ESCAPE;
        END_IF;
        IF pass1 THEN
          IF EXISTS(pd_bag[j].frame_of_reference.life_cycle_stage) THEN
            IF pd_bag[j].frame_of_reference.life_cycle_stage IN lcs_bag
                 THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              lcs_bag := lcs_bag + pd_bag[j].frame_of_reference.
                  life_cycle_stage;
            END_IF;
          END_IF;
        END_IF;
        IF pass2 THEN
          IF EXISTS(pd_bag[j].id) THEN
            IF pd_bag[j].id IN id_bag THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              id_bag := id_bag + pd_bag[j].id;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass1;
    wr2: pass2;

  END_RULE; -- ee_product_definition_unique_constraint

  RULE ee_product_model_unique_constraint FOR (product_concept);

    LOCAL
      r      : BAG OF product_concept := QUERY ( r <* product_concept | 
                TRUE );
      pass   : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i].id) THEN
        IF r[i]\product_concept.id IN id_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + r[i].id;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_product_model_unique_constraint

  RULE ee_product_unique_constraint FOR (product);

    LOCAL
      aoa_bag   : BAG OF applied_organization_assignment;
      p_bag     : BAG OF product;
      pao_bag   : BAG OF person_and_organization;
      o_bag     : BAG OF organization;
      apaoa_bag : BAG OF applied_person_and_organization_assignment;
      pass      : BOOLEAN := TRUE;
      id_bag    : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(product) BY 1;
      IF EXISTS(product[i].id) THEN
        IF NOT (product[i].id IN id_bag) THEN
          id_bag := id_bag + product[i].id;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      o_bag := [];
      pao_bag := [];
      p_bag := QUERY ( p <* product | (p.id = id_bag[i]) );
      REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        aoa_bag := QUERY ( aoa <* USEDIN(p_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'ORGANIZATION') IN TYPEOF(aoa.assigned_organization)) AND (aoa.
            role.name = 'design owner')) );
        REPEAT k := 1 TO SIZEOF(aoa_bag) BY 1;
          IF EXISTS(aoa_bag[k].assigned_organization) THEN
            IF aoa_bag[k].assigned_organization IN o_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              o_bag := o_bag + aoa_bag[k].assigned_organization;
            END_IF;
          END_IF;
        END_REPEAT;
        apaoa_bag := QUERY ( apaoa <* USEDIN(p_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | (((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PERSON_AND_ORGANIZATION') IN TYPEOF(apaoa.
            assigned_person_and_organization)) AND (apaoa.role.name = 
            'design owner')) );
        REPEAT k := 1 TO SIZEOF(apaoa_bag) BY 1;
          IF EXISTS(apaoa_bag[k].assigned_person_and_organization) THEN
            IF apaoa_bag[k].assigned_person_and_organization IN pao_bag
                 THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pao_bag := pao_bag + apaoa_bag[k].
                  assigned_person_and_organization;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_product_unique_constraint

  RULE ee_product_version_constraint FOR (product_definition_formation);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (SIZEOF(
             QUERY ( aoa <* USEDIN(pdf,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | ((aoa.role.name = 
             'product supplier') OR (aoa.role.name = 'design supplier')) )) 
             > 0) )) > 0);

  END_RULE; -- ee_product_version_constraint

  RULE ee_product_version_unique_constraint FOR (
             product_definition_formation);

    LOCAL
      pass : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(product_definition_formation) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      REPEAT j := i + 1 TO SIZEOF(product_definition_formation) BY 1;
        IF (product_definition_formation[i].id = 
            product_definition_formation[j].id) AND (
            product_definition_formation[i].of_product :=: 
            product_definition_formation[j].of_product) THEN
          pass := FALSE;
          ESCAPE;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_product_version_unique_constraint

  RULE ee_rule_conclusion_definition_unique_constraint FOR (
             rule_conclusion_definition, representation, 
             representation_relationship);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF representation := QUERY ( r <* representation | (r
                  \representation.name = 'rule definition') );
      rr       : BAG OF representation_relationship := [];
      pass     : BOOLEAN := TRUE;
      count    : INTEGER := 0;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      count := 0;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      rr := USEDIN(r[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'REPRESENTATION_RELATIONSHIP.REP_1');
      REPEAT j := 1 TO SIZEOF(rr) BY 1;
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'RULE_CONCLUSION_DEFINITION') IN TYPEOF(rr[j].rep_2) THEN
          IF EXISTS(rr[j].rep_2\representation.name) THEN
            IF rr[j].rep_2\representation.name IN name_bag THEN
              pass := FALSE;
            ELSE
              name_bag := name_bag + rr[j].rep_2\representation.name;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_rule_conclusion_definition_unique_constraint

  RULE ee_rule_definition_constraint FOR (representation);

  WHERE
    wr1: ((SIZEOF(QUERY ( rep <* representation | (rep\representation.name = 
             'rule definition') )) = 0) OR (SIZEOF(QUERY ( rep <* 
             representation | (SIZEOF(QUERY ( dri <* rep.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'identifier')) )) = 1) )) = 1));
    wr2: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'rule definition') AND (SIZEOF(QUERY ( pdr <* USEDIN(rep,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'RULE_DEFINITION') IN TYPEOF(pdr.definition.definition)) )) = 
             0)) )) = 0);

  END_RULE; -- ee_rule_definition_constraint

  RULE ee_rule_definition_unique_constraint FOR (representation);

    LOCAL
      pdr_bag : BAG OF property_definition_representation;
      rd_bag  : BAG OF rule_definition := [];
      pd_bag  : BAG OF property_definition;
      pass    : BOOLEAN := TRUE;
      id_bag  : BAG OF STRING;
      erd     : BAG OF representation := QUERY ( r <* representation | (r\representation.
                 name = 'rule definition') );
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(erd) BY 1;
      pdr_bag := QUERY ( pdr <* USEDIN(erd[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'RULE_DEFINITION') IN TYPEOF(pdr.definition.definition)) );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF EXISTS(pdr_bag[j].definition.definition) THEN
          IF NOT (pdr_bag[j].definition.definition IN rd_bag) THEN
            rd_bag := rd_bag + pdr_bag[j].definition.definition;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(rd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      id_bag := [];
      pd_bag := USEDIN(rd_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION.DEFINITION');
      REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
            used_representation IN erd) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(pdr_bag[k].used_representation.items)
               BY 1;
            IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                + 'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(pdr_bag[k].
                used_representation.items[l])) AND (pdr_bag[k].
                used_representation.items[l]\representation_item.name = 
                'identifier') THEN
              IF EXISTS(pdr_bag[k].used_representation.items[l].
                  description) THEN
                IF pdr_bag[k].used_representation.items[l].description IN 
                    id_bag THEN
                  pass := FALSE;
                  ESCAPE;
                ELSE
                  id_bag := id_bag + pdr_bag[k].used_representation.items[
                      l].description;
                END_IF;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_rule_definition_unique_constraint

  RULE ee_rule_function_unique_constraint FOR (rule_function_definition);

    LOCAL
      name_bag : BAG OF STRING := [];
      adr_bag  : BAG OF applied_document_reference;
      doc_bag  : BAG OF document;
      pass     : BOOLEAN := TRUE;
      rfd_bag  : BAG OF rule_function_definition;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(rule_function_definition) BY 1;
      IF EXISTS(rule_function_definition[i]\representation.name) THEN
        IF NOT (rule_function_definition[i]\representation.name IN name_bag) THEN
          name_bag := name_bag + rule_function_definition[i]\representation.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      doc_bag := [];
      rfd_bag := QUERY ( am <* rule_function_definition | (am\representation.name = 
          name_bag[i]) );
      REPEAT j := 1 TO SIZEOF(rfd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        adr_bag := QUERY ( adr <* USEDIN(rfd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (adr.assigned_document.
            kind.product_data_type = 'reference document') );
        REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
          IF EXISTS(adr_bag[k].assigned_document) THEN
            IF adr_bag[k].assigned_document IN doc_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              doc_bag := doc_bag + adr_bag[k].assigned_document;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_rule_function_unique_constraint

  RULE ee_rule_premise_definition_unique_constraint FOR (
             rule_premise_definition, representation, 
             representation_relationship);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF representation := QUERY ( r <* representation | (r
                  \representation.name = 'rule definition') );
      rr       : BAG OF representation_relationship := [];
      pass     : BOOLEAN := TRUE;
      count    : INTEGER := 0;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      count := 0;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      rr := USEDIN(r[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'REPRESENTATION_RELATIONSHIP.REP_1');
      REPEAT j := 1 TO SIZEOF(rr) BY 1;
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'RULE_PREMISE_DEFINITION') IN TYPEOF(rr[j].rep_2) THEN
          IF EXISTS(rr[j].rep_2\representation.name) THEN
            IF rr[j].rep_2\representation.name IN name_bag THEN
              pass := FALSE;
            ELSE
              name_bag := name_bag + rr[j].rep_2\representation.name;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_rule_premise_definition_unique_constraint

  RULE ee_rule_unique_constraint FOR (rule_definition);

    LOCAL
      rd_bag : BAG OF rule_definition;
      ii_bag : BAG OF STRING := [];
      si_bag : BAG OF STRING;
      pass   : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(rule_definition) BY 1;
      IF EXISTS(rule_definition[i]\externally_defined_item.item_id) THEN
        IF NOT (rule_definition[i]\externally_defined_item.item_id IN 
            ii_bag) THEN
          ii_bag := ii_bag + rule_definition[i]\externally_defined_item.
              item_id;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(ii_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      si_bag := [];
      rd_bag := QUERY ( rd <* rule_definition | (rd\
          externally_defined_item.item_id = ii_bag[i]) );
      REPEAT j := 1 TO SIZEOF(rd_bag) BY 1;
        IF EXISTS(rd_bag[j]\externally_defined_item.source.source_id)
             THEN
          IF rd_bag[j]\externally_defined_item.source.source_id IN si_bag
               THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            si_bag := si_bag + rd_bag[j]\externally_defined_item.source.
                source_id;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- ee_rule_unique_constraint

  RULE explicitly_located_layer_connection_point_unique_constraint FOR (
             layer_connection_point);

    LOCAL
      pdr_bag : BAG OF property_definition_representation;
      pd_bag  : BAG OF property_definition;
      s_bag   : BAG OF stratum := [];
      cp_bag  : BAG OF cartesian_point;
      lcp_bag : BAG OF layer_connection_point;
      ellcp   : BAG OF layer_connection_point := QUERY ( lcp <* 
--tt changed following line
                 layer_connection_point | (lcp\shape_aspect.description = 
                 'explicitly located') );
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ellcp) BY 1;
      IF EXISTS(ellcp[i].of_shape.definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'STRATUM') IN TYPEOF(ellcp[i].of_shape.definition) THEN
          IF NOT (ellcp[i].of_shape.definition IN s_bag) THEN
            s_bag := s_bag + ellcp[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      cp_bag := [];
      lcp_bag := QUERY ( lcp <* ellcp | (lcp.of_shape.definition :=: s_bag
          [i]) );
      REPEAT j := 1 TO SIZEOF(lcp_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pd_bag := USEDIN(lcp_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION.DEFINITION');
        REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[k],
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((pdr.
              used_representation\representation.name = 'connection point location') AND (
              ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'CARTESIAN_POINT') IN TYPEOF(pdr.used_representation.items[1]))) );
          REPEAT l := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[l].used_representation.items[1]) THEN
              IF pdr_bag[l].used_representation.items[1] IN cp_bag THEN
                pass := FALSE;
                ESCAPE;
              ELSE
                cp_bag := cp_bag + pdr_bag[l].used_representation.items[1];
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- explicitly_located_layer_connection_point_unique_constraint

  RULE feature_group_relationship_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'feature group relationship') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPOSITE_SHAPE_ASPECT') IN TYPEOF(sar.relating_shape_aspect)))) )) 
             = 0);

  END_RULE; -- feature_group_relationship_constraint

  RULE feature_shape_occurrence_constraint FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'feature shape') AND (NOT (SIZEOF(QUERY ( pdr <* USEDIN(sr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
--tt changed cardinality sense
             'SHAPE_ASPECT') IN TYPEOF(pdr.definition.definition)) )) <= 1))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'datum shape') AND (NOT (SIZEOF(QUERY ( pdr <* USEDIN(sr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
--tt changed cardinality sense
             'SHAPE_ASPECT') IN TYPEOF(pdr.definition.definition)) )) <= 1))) )) 
             = 0);
    wr3: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'zone shape') AND (NOT (SIZEOF(QUERY ( pdr <* USEDIN(sr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
--tt changed cardinality sense
             'SHAPE_ASPECT') IN TYPEOF(pdr.definition.definition)) )) <= 1))) )) 
             = 0);

  END_RULE; -- feature_shape_occurrence_constraint

  RULE fill_area_occurrence_constraint FOR (
             annotation_fill_area_occurrence);

  WHERE
    wr1: (SIZEOF(QUERY ( afao <* annotation_fill_area_occurrence | (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ANNOTATION_FILL_AREA') IN TYPEOF(afao.item))) )) = 0);
    wr2: (SIZEOF(QUERY ( afao <* annotation_fill_area_occurrence | (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CARTESIAN_POINT') IN TYPEOF(afao.fill_style_target))) )) = 0);
    wr3: (SIZEOF(QUERY ( afao <* annotation_fill_area_occurrence | (
             SIZEOF(QUERY ( psa <* afao.styles | (SIZEOF(QUERY ( cs <* psa.
             styles | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CURVE_STYLE') IN TYPEOF(cs)) )) = 0) )) = 0) )) = 0);

  END_RULE; -- fill_area_occurrence_constraint

  RULE fill_area_style_constraint FOR (fill_area_style);

  WHERE
    wr1: (SIZEOF(QUERY ( fas <* fill_area_style | (NOT (SIZEOF(fas.
             fill_styles) = 1)) )) = 0);

  END_RULE; -- fill_area_style_constraint

  RULE fill_area_style_unique_constraint FOR (fill_area_style);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF fill_area_style := QUERY ( r <* fill_area_style | 
                  TRUE );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i].name) THEN
        IF r[i]\fill_area_style.name IN name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + r[i].name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- fill_area_style_unique_constraint

  RULE functional_unit_definition_unique_constraint FOR (functional_unit);

    LOCAL
      name_bag : BAG OF STRING := [];
      fud      : BAG OF functional_unit := QUERY ( fu <* functional_unit
                   | (fu.frame_of_reference.name IN [
                  'functional network design','functional design usage']) );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(fud) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      IF EXISTS(fud[i].formation.of_product.name) THEN
        IF fud[i].formation.of_product.name IN name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + fud[i].formation.of_product.name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- functional_unit_definition_unique_constraint

  RULE functional_unit_network_node_definition_unique_constraint FOR (
             network_node_definition);

    LOCAL
      fu_bag   : BAG OF functional_unit;
      pdr_bag  : BAG OF product_definition_relationship;
      name_bag : BAG OF STRING := [];
      nnd_bag  : BAG OF network_node_definition;
      funnd    : BAG OF network_node_definition := QUERY ( nnd <* 
                  network_node_definition | (nnd.frame_of_reference.name = 
                  'functional network design') );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(funnd) BY 1;
      IF EXISTS(funnd[i].formation.of_product.name) THEN
        IF NOT (funnd[i].formation.of_product.name IN name_bag) THEN
          name_bag := name_bag + funnd[i].formation.of_product.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      fu_bag := [];
      nnd_bag := QUERY ( nnd <* funnd | (nnd.formation.of_product.name = 
          name_bag[i]) );
      REPEAT j := 1 TO SIZEOF(nnd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(nnd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
             | ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
            + 'FUNCTIONAL_UNIT') IN TYPEOF(pdr.relating_product_definition)) 
            AND (pdr\product_definition_relationship.name = 'functional unit network node')) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].relating_product_definition) THEN
            IF pdr_bag[k].relating_product_definition IN fu_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- functional_unit_network_node_definition_unique_constraint

  RULE functional_unit_network_terminal_definition_bus_assignment_constraint FOR (
             property_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* property_definition_relationship | ((pdr\property_definition_relationship.
             name = 
             'functional unit network terminal definition bus assignment') 
             AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(pdr.
             relating_property_definition.definition)))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* property_definition_relationship | ((pdr\property_definition_relationship.
             name = 
             'functional unit network terminal definition bus assignment') 
             AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_SHAPE') IN TYPEOF(pdr.
             related_property_definition.definition)) AND (SIZEOF(
             QUERY ( futd <* USEDIN(pdr.related_property_definition.
             definition,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT.OF_SHAPE') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_UNIT_TERMINAL_DEFINITION.OF_SHAPE') IN TYPEOF(futd)) )) 
             > 0)))) )) = 0);

  END_RULE; -- functional_unit_network_terminal_definition_bus_assignment_constraint

  RULE functional_unit_terminal_bus_assignment_constraint FOR (
             property_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* property_definition_relationship | ((pdr\property_definition_relationship.
             name = 'functional unit terminal bus assignment') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'BUS_STRUCTURAL_DEFINITION') IN TYPEOF(pdr.
             relating_property_definition.definition)))) )) = 0);

  END_RULE; -- functional_unit_terminal_bus_assignment_constraint

  RULE functional_unit_unique_constraint FOR (component_functional_unit);

    LOCAL
      cfu_bag : BAG OF component_functional_unit;
      fu_bag  : BAG OF functional_unit;
      pdr_bag : BAG OF product_definition_relationship;
      fu      : BAG OF component_functional_unit := QUERY ( cfu <* 
                 component_functional_unit | (cfu.frame_of_reference.name =
                  'functional occurrence') );
      pass    : BOOLEAN := TRUE;
      id_bag  : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(fu) BY 1;
      IF EXISTS(fu[i].id) THEN
        IF NOT (fu[i].id IN id_bag) THEN
          id_bag := id_bag + fu[i].id;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      fu_bag := [];
      cfu_bag := QUERY ( cfu <* fu | (cfu.id = id_bag[i]) );
      REPEAT j := 1 TO SIZEOF(cfu_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(cfu_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
             | ((pdr\product_definition_relationship.name = 'network composition') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'FUNCTIONAL_UNIT') IN TYPEOF(pdr.relating_product_definition)) 
            AND (pdr.relating_product_definition.frame_of_reference.name = 
            'functional network design')) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].relating_product_definition) THEN
            IF pdr_bag[k].relating_product_definition IN fu_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- functional_unit_unique_constraint

  RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR (
             functional_unit_terminal_definition);

    LOCAL
      fu_bag   : BAG OF functional_unit;
      futd_bag : BAG OF functional_unit_terminal_definition;
      name_bag : BAG OF STRING := [];
      adr_bag  : BAG OF applied_document_reference;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(functional_unit_terminal_definition) BY 1;
      IF EXISTS(functional_unit_terminal_definition[i]\shape_aspect.name) THEN
        IF NOT (functional_unit_terminal_definition[i]\shape_aspect.name IN name_bag)
             THEN
          name_bag := name_bag + functional_unit_terminal_definition[i]\shape_aspect.
              name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      fu_bag := [];
      futd_bag := QUERY ( futd <* functional_unit_terminal_definition | ((
          futd\shape_aspect.name = name_bag[i]) AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'FUNCTIONAL_UNIT') IN TYPEOF(futd.of_shape.definition)) AND (futd
          .of_shape.definition.frame_of_reference.name = 
          'functional design usage')) );
      REPEAT j := 1 TO SIZEOF(futd_bag) BY 1;
        IF EXISTS(futd_bag[j].of_shape.definition) THEN
          IF futd_bag[j].of_shape.definition IN fu_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            fu_bag := fu_bag + futd_bag[j].of_shape.definition;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- functional_unit_usage_view_terminal_definition_unique_constraint

  RULE functional_usage_view_to_part_terminal_assignment_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'functional terminal allocation') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') IN TYPEOF(sar.
             relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.
             description = 'scalar terminal')))) )) = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'functional terminal allocation') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_MODULE_TERMINAL') IN TYPEOF(sar.related_shape_aspect)) 
             OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'BARE_DIE_TERMINAL') IN TYPEOF(sar.related_shape_aspect)) OR
              (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERCONNECT_MODULE_TERMINAL') IN TYPEOF(sar.
             related_shape_aspect)) OR ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_TERMINAL') IN TYPEOF(sar.related_shape_aspect)) OR ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGED_PART_TERMINAL') IN TYPEOF(sar.related_shape_aspect))))) )) 
             = 0);

  END_RULE; -- functional_usage_view_to_part_terminal_assignment_constraint

  RULE functional_usage_view_to_part_terminal_assignment_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      futd_bag : BAG OF functional_unit_terminal_definition := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      fuvtpta  : BAG OF shape_aspect_relationship := QUERY ( r <* 
                  shape_aspect_relationship | (r\shape_aspect_relationship.name = 
                  'functional terminal allocation') );
      pass     : BOOLEAN := TRUE;
      sa_bag   : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(fuvtpta) BY 1;
      IF EXISTS(fuvtpta[i].relating_shape_aspect) THEN
        IF fuvtpta[i].relating_shape_aspect\shape_aspect.description = 
            'scalar terminal' THEN
          IF NOT (fuvtpta[i].relating_shape_aspect IN futd_bag) THEN
            futd_bag := futd_bag + fuvtpta[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(futd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar_bag := QUERY ( sar <* fuvtpta | ((sar.relating_shape_aspect :=: 
          futd_bag[i]) AND (SIZEOF([
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'ASSEMBLY_MODULE_TERMINAL',
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'BARE_DIE_TERMINAL',
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'INTERCONNECT_MODULE_TERMINAL',
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PACKAGE_TERMINAL',
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PACKAGED_PART_TERMINAL'] * TYPEOF(sar.related_shape_aspect)) > 0)) );
      sa_bag := [];
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF sar_bag[j].related_shape_aspect IN sa_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- functional_usage_view_to_part_terminal_assignment_unique_constraint

  RULE functional_usage_view_to_printed_part_template_terminal_assignment_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'functional terminal allocation') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') IN TYPEOF(sar.
             relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.
             description = 'scalar terminal')))) )) = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'functional terminal allocation') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(sar.
             related_shape_aspect)) AND ((sar.related_shape_aspect\shape_aspect.
             description = 'interface terminal') OR (sar.
             related_shape_aspect\shape_aspect.description = 'join terminal'))))) )) = 0);

  END_RULE; -- functional_usage_view_to_printed_part_template_terminal_assignment_constraint

  RULE functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      futd_bag  : BAG OF functional_unit_terminal_definition := [];
      sar_bag   : BAG OF shape_aspect_relationship;
      pptt_bag  : BAG OF printed_part_template_terminal;
      pass      : BOOLEAN := TRUE;
      fuvtpptta : BAG OF shape_aspect_relationship := QUERY ( r <* 
                   shape_aspect_relationship | (r\shape_aspect_relationship.name = 
                   'functional terminal allocation') );
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(fuvtpptta) BY 1;
      IF EXISTS(fuvtpptta[i].relating_shape_aspect) THEN
        IF fuvtpptta[i].relating_shape_aspect\shape_aspect.description = 
            'scalar terminal' THEN
          IF NOT (fuvtpptta[i].relating_shape_aspect IN futd_bag) THEN
            futd_bag := futd_bag + fuvtpptta[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(futd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pptt_bag := [];
      sar_bag := QUERY ( sar <* fuvtpptta | ((sar.relating_shape_aspect 
          :=: futd_bag[i]) AND (sar.related_shape_aspect\shape_aspect.description IN [
          'interface terminal','join terminal']) AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(sar.
          related_shape_aspect))) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF sar_bag[j].related_shape_aspect IN pptt_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            pptt_bag := pptt_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint

  RULE geometric_tolerance_qualifier_constraint FOR (measure_qualification);

  WHERE
    wr1: (SIZEOF(QUERY ( mq <* measure_qualification | (((mq.name = 
             'predefined geometric tolerance qualifier') OR (mq.name = 
             'user defined geometric tolerance qualifier')) AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_WITH_UNIT') IN TYPEOF(mq.qualified_measure)) AND (
             SIZEOF(QUERY ( pugt <* USEDIN(mq.qualified_measure,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GEOMETRIC_TOLERANCE.MAGNITUDE') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE') IN TYPEOF(pugt)) )) = 0)))) )) 
             = 0);

  END_RULE; -- geometric_tolerance_qualifier_constraint

  RULE inter_stratum_extent_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'inter stratum extent') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM') IN TYPEOF(pdr.related_product_definition)) AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM') IN TYPEOF(pdr.relating_product_definition))))) )) =
              0);

  END_RULE; -- inter_stratum_extent_constraint

  RULE interconnect_component_interface_terminal_unique_constraint FOR (
             component_interface_terminal);

    LOCAL
      cit_bag  : BAG OF component_interface_terminal;
      name_bag : BAG OF STRING;
      pass     : BOOLEAN := TRUE;
      icd_bag  : BAG OF interface_component_definition := [];
      icit     : BAG OF component_interface_terminal := QUERY ( cit <* 
                  component_interface_terminal | (cit.description = 
                  'interconnect component interface terminal') );
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(icit) BY 1;
      IF EXISTS(icit[i].of_shape.definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'INTERFACE_COMPONENT_DEFINITION') IN TYPEOF(icit[i].of_shape.
            definition) THEN
          IF NOT (icit[i].of_shape.definition IN icd_bag) THEN
            icd_bag := icd_bag + icit[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(icd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      name_bag := [];
      cit_bag := QUERY ( cit <* icit | (cit.of_shape.definition :=: 
          icd_bag[i]) );
      REPEAT j := 1 TO SIZEOF(cit_bag) BY 1;
        IF EXISTS(cit_bag[j]\shape_aspect.name) THEN
          IF cit_bag[j]\shape_aspect.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + cit_bag[j]\shape_aspect.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- interconnect_component_interface_terminal_unique_constraint

  RULE interconnect_component_join_terminal_unique_constraint FOR (
             component_terminal);

    LOCAL
      name_bag : BAG OF STRING;
      cd_bag   : BAG OF component_definition := [];
      icjt     : BAG OF component_terminal := QUERY ( ct <* 
                  component_terminal | (ct.description = 
                  'interconnect component join terminal') );
      ct_bag   : BAG OF component_terminal;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(icjt) BY 1;
      IF EXISTS(icjt[i].of_shape.definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'COMPONENT_DEFINITION') IN TYPEOF(icjt[i].of_shape.definition)
             THEN
          IF NOT (icjt[i].of_shape.definition IN cd_bag) THEN
            cd_bag := cd_bag + icjt[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      name_bag := [];
      ct_bag := QUERY ( ct <* icjt | (ct.of_shape.definition :=: cd_bag[i]) );
      REPEAT j := 1 TO SIZEOF(ct_bag) BY 1;
        IF EXISTS(ct_bag[j]\shape_aspect.name) THEN
          IF ct_bag[j]\shape_aspect.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + ct_bag[j]\shape_aspect.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- interconnect_component_join_terminal_unique_constraint

  RULE interconnect_module_stratum_assembly_relationship_constraint FOR (
             assembly_component_usage);

  WHERE
    wr1: (SIZEOF(QUERY ( acu <* assembly_component_usage | ((acu\product_definition_relationship.name = 
             'interconnect module stratum assembly relationship') AND (NOT 
             (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT') IN TYPEOF(acu.relating_product_definition)))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( acu <* assembly_component_usage | ((acu\product_definition_relationship.name = 
             'interconnect module stratum assembly relationship') AND (NOT 
             (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM') IN TYPEOF(acu.related_product_definition)))) )) = 0);

  END_RULE; -- interconnect_module_stratum_assembly_relationship_constraint

  RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR (
             assembly_component_usage);

    LOCAL
      acu_bag    : BAG OF assembly_component_usage;
      refdes_bag : BAG OF STRING;
      pu_bag     : BAG OF physical_unit := [];
      imsar      : BAG OF assembly_component_usage := QUERY ( acu <* 
                    assembly_component_usage | (acu\product_definition_relationship.name = 
                    'interconnect module stratum assembly relationship') );
      pass       : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(imsar) BY 1;
      IF EXISTS(imsar[i].relating_product_definition) THEN
        IF (imsar[i].relating_product_definition.frame_of_reference.name =
             'physical design') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(imsar[i].relating_product_definition))
             THEN
          IF NOT (imsar[i].relating_product_definition IN pu_bag) THEN
            pu_bag := pu_bag + imsar[i].relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      refdes_bag := [];
      acu_bag := QUERY ( acu <* imsar | (acu.relating_product_definition 
          :=: pu_bag[i]) );
      REPEAT j := 1 TO SIZEOF(acu_bag) BY 1;
        IF EXISTS(acu_bag[j].reference_designator) THEN
          IF acu_bag[j].reference_designator IN refdes_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            refdes_bag := refdes_bag + acu_bag[j].reference_designator;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- interconnect_module_stratum_assembly_relationship_unique_constraint

  RULE interconnect_module_surface_feature_constraint FOR (shape_aspect);

  WHERE
    wr1: (SIZEOF(QUERY ( sa <* shape_aspect | ((sa\shape_aspect.description = 
             'interconnect module surface feature') AND (NOT ((SIZEOF(
             QUERY ( prpc <* USEDIN(sa.of_shape.definition\
             product_definition.formation.of_product,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | (prpc\
             product_category.name = 'interconnect module') )) >= 1) AND (
             sa.of_shape.definition.frame_of_reference.name = 
             'physical design usage') AND (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT') IN TYPEOF(sa.of_shape.definition)) OR ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_PHYSICAL_UNIT') IN TYPEOF(sa.of_shape.
             definition)) OR ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LIBRARY_DEFINED_PHYSICAL_UNIT') IN TYPEOF(sa.of_shape.
             definition)))))) )) = 0);

  END_RULE; -- interconnect_module_surface_feature_constraint

  RULE interface_component_allocation_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'interface component allocation') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_DEFINITION') IN TYPEOF(pdr.
             relating_product_definition)) AND (pdr.
             relating_product_definition\product_definition.description = 'mating connector')))) )) 
             = 0);

  END_RULE; -- interface_component_allocation_constraint

  RULE internal_stratum_access_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      sar_bag : BAG OF shape_aspect_relationship;
      isa     : BAG OF shape_aspect_relationship := QUERY ( r <* 
                 shape_aspect_relationship | (r\shape_aspect_relationship.name = 
                 'internal stratum access') );
      paa_bag : BAG OF probe_access_area := [];
      pass    : BOOLEAN := TRUE;
      pp_bag  : BAG OF plated_passage;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(isa) BY 1;
      IF EXISTS(isa[i].relating_shape_aspect) THEN
        IF (isa[i].relating_shape_aspect\shape_aspect.description = 
            'internal probe access area') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROBE_ACCESS_AREA') IN TYPEOF(isa[i].relating_shape_aspect))
             THEN
          IF NOT (isa[i].relating_shape_aspect IN paa_bag) THEN
            paa_bag := paa_bag + isa[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(paa_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pp_bag := [];
      sar_bag := QUERY ( sar <* isa | ((sar.relating_shape_aspect :=: 
          paa_bag[i]) AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PLATED_PASSAGE') IN TYPEOF(sar.related_shape_aspect)) AND (sar.
          related_shape_aspect\shape_aspect.description IN [
          'bonded conductive base blind via','buried via',
          'interfacial connection','non conductive base blind via',
          'plated conductive base blind via'])) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF sar_bag[j].related_shape_aspect IN pp_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            pp_bag := pp_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- internal_stratum_access_unique_constraint

  RULE junction_vertex_allocation_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'junction vertex allocation') AND (NOT ((((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAYER_CONNECTION_POINT') IN TYPEOF(sar.related_shape_aspect)) 
             AND (sar.related_shape_aspect\shape_aspect.description = 
             'explicitly located')) OR (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'JOIN_SHAPE_ASPECT') IN TYPEOF(sar.related_shape_aspect)) AND 
             (sar.related_shape_aspect\shape_aspect.name = 'inter stratum join'))))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'junction vertex allocation') AND (NOT (sar.
             relating_shape_aspect\shape_aspect.description = 'topological junction'))) )) 
             = 0);

  END_RULE; -- junction_vertex_allocation_constraint

  RULE junction_vertex_allocation_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      jva    : BAG OF shape_aspect_relationship := QUERY ( sar <* 
                shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
                'junction vertex allocation') );
      pass   : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(jva) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      IF EXISTS(jva[i].relating_shape_aspect) THEN
        IF jva[i].relating_shape_aspect\shape_aspect.description = 
            'topological junction' THEN
          IF jva[i].relating_shape_aspect IN sa_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            sa_bag := sa_bag + jva[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- junction_vertex_allocation_unique_constraint

  RULE land_physical_template_unique_constraint FOR (
             land_physical_template);

    LOCAL
      duc_bag : BAG OF document_usage_constraint := [];
      adr_bag : BAG OF applied_document_reference;
      pass    : BOOLEAN := TRUE;
      duc     : BAG OF document_usage_constraint;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(land_physical_template) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      adr_bag := USEDIN(land_physical_template[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'APPLIED_DOCUMENT_REFERENCE.ITEMS');
      REPEAT j := 1 TO SIZEOF(adr_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        duc := QUERY ( r <* USEDIN(adr_bag[j].assigned_document,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (r.subject_element = 
            'predefined classification code') );
        REPEAT k := 1 TO SIZEOF(duc) BY 1;
          IF EXISTS(duc[k]) THEN
            IF duc[k] IN duc_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              duc_bag := duc_bag + duc[k];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- land_physical_template_unique_constraint

  RULE land_template_terminal_unique_constraint FOR (
             land_template_terminal);

    LOCAL
      ltt      : BAG OF land_template_terminal := QUERY ( sa <* 
                  land_template_terminal | (sa\shape_aspect.description IN [
                  'interface terminal','join terminal']) );
      lpt_bag  : BAG OF land_physical_template;
      name_bag : BAG OF STRING := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      ltt_bag  : BAG OF land_template_terminal;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ltt) BY 1;
      IF EXISTS(ltt[i]\shape_aspect.name) THEN
        IF NOT (ltt[i]\shape_aspect.name IN name_bag) THEN
          name_bag := name_bag + ltt[i]\shape_aspect.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      lpt_bag := [];
      ltt_bag := QUERY ( sa <* ltt | (sa\shape_aspect.name = name_bag[i]) );
      REPEAT j := 1 TO SIZEOF(ltt_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(ltt_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
            = 'associated definition') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'LAND_PHYSICAL_TEMPLATE') IN TYPEOF(sar.relating_shape_aspect))) );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
            IF sar_bag[k].relating_shape_aspect IN lpt_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              lpt_bag := lpt_bag + sar_bag[k].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- land_template_terminal_unique_constraint

  RULE layout_spacing_requirement_non_conforming_design_object_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'layout spacing requirement violation') AND (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_INTERFACE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_FEATURE'] * TYPEOF(sar.related_shape_aspect)) = 0)) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'layout spacing requirement violation') AND (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_INTERFACE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_FEATURE'] * TYPEOF(sar.relating_shape_aspect)) = 0)) )) 
             = 0);
    wr3: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'layout spacing requirement violation') AND (NOT (SIZEOF(
             QUERY ( grp <* USEDIN(sar,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUP') IN TYPEOF(grp)) AND (grp\group.name = 
             'layout spacing requirements property')) )) = 1))) )) = 0);

  END_RULE; -- layout_spacing_requirement_non_conforming_design_object_constraint

  RULE layout_spacing_requirement_occurrence_unique_constraint FOR (
             grouped_requirements_property, characterized_object);

    LOCAL
      pd_bag     : BAG OF property_definition;
      rga_bag    : BAG OF group_assignment;
      rdname_bag : BAG OF STRING;
      ga_bag     : BAG OF group_assignment;
      ddo        : BAG OF characterized_object := QUERY ( co <* 
                    characterized_object | (co.description = 
                    'dependent design object category') );
      grp_bag    : BAG OF grouped_requirements_property;
      lsro       : BAG OF grouped_requirements_property := QUERY ( grp <* 
                    grouped_requirements_property | (grp\group.name = 
                    'layout spacing requirements property') );
      pass       : BOOLEAN := TRUE;
      co_bag     : BAG OF characterized_object;
      ddname_bag : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(lsro) BY 1;
      ga_bag := USEDIN(lsro[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'GROUP_ASSIGNMENT.ASSIGNED_GROUP');
      REPEAT j := 1 TO SIZEOF(ga_bag) BY 1;
        REPEAT k := 1 TO SIZEOF(ga_bag[j].items) BY 1;
          IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'CHARACTERIZED_OBJECT') IN TYPEOF(ga_bag[j].items[k].
              definition)) AND (ga_bag[j].items[k].definition.description =
               'dependent design object category') THEN
            IF EXISTS(ga_bag[j].items[k].definition.name) THEN
              IF NOT (ga_bag[j].items[k].definition.name IN ddname_bag)
                   THEN
                ddname_bag := ddname_bag + ga_bag[j].items[k].definition.
                    name;
              END_IF;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(ddname_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      rdname_bag := [];
      co_bag := QUERY ( co <* ddo | (co\characterized_object.name = ddname_bag[i]) );
      REPEAT j := 1 TO SIZEOF(co_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pd_bag := USEDIN(co_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION.DEFINITION');
        REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          ga_bag := QUERY ( ga <* USEDIN(pd_bag[k],
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'APPLIED_GROUP_ASSIGNMENT.ITEMS') | ((
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'GROUPED_REQUIREMENTS_PROPERTY') IN TYPEOF(ga.assigned_group)) );
          REPEAT l := 1 TO SIZEOF(ga_bag) BY 1;
            IF NOT pass THEN
              ESCAPE;
            END_IF;
            IF NOT (ga_bag[l].assigned_group IN grp_bag) THEN
              grp_bag := grp_bag + ga_bag[l].assigned_group;
            END_IF;
          END_REPEAT;
          REPEAT l := 1 TO SIZEOF(grp_bag) BY 1;
            IF NOT pass THEN
              ESCAPE;
            END_IF;
            rga_bag := USEDIN(grp_bag[l],
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'GROUP_ASSIGNMENT.ASSIGNED_GROUP');
            REPEAT m := 1 TO SIZEOF(rga_bag) BY 1;
              IF NOT pass THEN
                ESCAPE;
              END_IF;
              REPEAT n := 1 TO SIZEOF(rga_bag[m].items) BY 1;
                IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                    + 'CHARACTERIZED_OBJECT') IN TYPEOF(rga_bag[m].items[n]
                    .definition)) AND (rga_bag[m].items[n].definition.
                    description = 'reference design object category') THEN
                  IF EXISTS(rga_bag[m].items[n].definition.name) THEN
                    IF rga_bag[m].items[n].definition.name IN rdname_bag
                         THEN
                      pass := FALSE;
                      ESCAPE;
                    ELSE
                      rdname_bag := rdname_bag + rga_bag[m].items[n].
                          definition.name;
                    END_IF;
                  END_IF;
                END_IF;
              END_REPEAT;
            END_REPEAT;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- layout_spacing_requirement_occurrence_unique_constraint

  RULE located_interconnect_module_thickness_requirement_unique_constraint FOR (
             property_definition_representation);

    LOCAL
      rr_bag  : BAG OF representation_relationship;
      pdr_bag : BAG OF property_definition_representation;
      ri_bag  : BAG OF representation_item;
      pu_bag  : BAG OF physical_unit := [];
      limrt   : BAG OF property_definition_representation := 
                 QUERY ( pdr <* property_definition_representation | (pdr.
                 definition\property_definition.name = 
                 'located interconnect module thickness') );
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(limrt) BY 1;
--tt fix all occurrences of definition.definition in this rule.
      IF EXISTS(limrt[i].definition.definition) THEN
        IF NOT (limrt[i].definition.definition IN 
            pu_bag) THEN
          pu_bag := pu_bag + limrt[i].definition.definition;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ri_bag := [];
      pdr_bag := QUERY ( pdr <* limrt | (pdr.definition.definition
                                                 :=: pu_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        rr_bag := QUERY ( rr <* USEDIN(pdr_bag[j].used_representation,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'REPRESENTATION_RELATIONSHIP.REP_2') | (rr\
            representation_relationship.name = 'reference location') );
        REPEAT k := 1 TO SIZEOF(rr_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(rr_bag[k].rep_1.items) BY 1;
            IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                + 'AXIS2_PLACEMENT_2D') IN TYPEOF(rr_bag[k].rep_1.items[l])) 
                OR ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'AXIS2_PLACEMENT_3D') IN TYPEOF(rr_bag[k].rep_1.items[l]))
                 THEN
              IF EXISTS(rr_bag[k].rep_1.items[l]) THEN
                IF rr_bag[k].rep_1.items[l] IN ri_bag THEN
                  pass := FALSE;
                  ESCAPE;
                ELSE
                  ri_bag := ri_bag + rr_bag[k].rep_1.items[l];
                END_IF;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- located_interconnect_module_thickness_requirement_unique_constraint

  RULE mandatory_product_related_product_category_value FOR (
             product_related_product_category, product);

    LOCAL
      coined                       : BOOLEAN := FALSE;
      molded                       : BOOLEAN := FALSE;
      detail                       : BOOLEAN := FALSE;
      domain_thing                 : BOOLEAN := FALSE;
      prpc                         : BAG OF
                                       product_related_product_category := 
                                      [];
      package                      : BOOLEAN := FALSE;
      tool                         : BOOLEAN := FALSE;
      machined                     : BOOLEAN := FALSE;
      inseparable_assembly         : BOOLEAN := FALSE;
      raw_material                 : BOOLEAN := FALSE;
      design_layer                 : BOOLEAN := FALSE;
      interconnect_module          : BOOLEAN := FALSE;
      rolled                       : BOOLEAN := FALSE;
      bare_die                     : BOOLEAN := FALSE;
      formed                       : BOOLEAN := FALSE;
      assembly_module              : BOOLEAN := FALSE;
      document                     : BOOLEAN := FALSE;
      customer_furnished_equipment : BOOLEAN := FALSE;
      assembly                     : BOOLEAN := FALSE;
      printed_part                 : BOOLEAN := FALSE;
      standard                     : BOOLEAN := FALSE;
      generic_thing                : BOOLEAN := FALSE;
      functionality                : BOOLEAN := FALSE;
      piece_part                   : BOOLEAN := FALSE;
      material                     : BOOLEAN := FALSE;
      extruded                     : BOOLEAN := FALSE;
      part                         : BOOLEAN := FALSE;
      documentation_layer          : BOOLEAN := FALSE;
      template_model               : BOOLEAN := FALSE;
      requirements_model           : BOOLEAN := FALSE;
      simulation_model             : BOOLEAN := FALSE;
      pass                         : BOOLEAN := TRUE;
      drawn                        : BOOLEAN := FALSE;
      sheared                      : BOOLEAN := FALSE;
      cast                         : BOOLEAN := FALSE;
      packaged_part                : BOOLEAN := FALSE;
      forged                       : BOOLEAN := FALSE;
      interconnect                 : BOOLEAN := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(product) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      prpc := USEDIN(product[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
      IF SIZEOF(prpc) = 1 THEN
        ESCAPE;
      ELSE
        IF SIZEOF(prpc) > 1 THEN
          bare_die := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'bare die') )) 
              = 1;
          design_layer := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'design layer') )) = 1;
          documentation_layer := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'documentation layer') )) = 1;
          functionality := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'functionality') )) = 1;
          interconnect := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'interconnect') )) = 1;
          interconnect_module := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'interconnect module') )) = 1;
          package := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'package') )) = 
              1;
          packaged_part := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'packaged part') )) = 1;
          printed_part := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'printed part') )) = 1;
          requirements_model := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'requirements model') )) = 1;
          simulation_model := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'simulation model') )) = 1;
          template_model := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'template model') )) = 1;
          raw_material := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'raw material') )) = 1;
          cast := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'cast') )) = 1;
          coined := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'coined') )) = 1;
          drawn := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'drawn') )) = 1;
          extruded := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'extruded') )) 
              = 1;
          forged := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'forged') )) = 1;
          formed := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'formed') )) = 1;
          machined := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'machined') )) 
              = 1;
          molded := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'molded') )) = 1;
          piece_part := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'piece part') )) 
              = 1;
          rolled := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'rolled') )) = 1;
          customer_furnished_equipment := SIZEOF(QUERY ( p <* prpc | (p.
              name = 'customer furnished equipment') )) = 1;
          inseparable_assembly := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 
              'inseparable assembly') )) = 1;
          standard := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'standard') )) 
              = 1;
          assembly := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'assembly') )) 
              = 1;
          detail := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'detail') )) = 1;
          part := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'part') )) = 1;
          document := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'document') )) 
              = 1;
          tool := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'tool') )) = 1;
          material := SIZEOF(QUERY ( p <* prpc | (p\product_category.name = 'material') )) 
              = 1;
          generic_thing := part OR tool OR material OR cast OR coined OR 
              drawn OR extruded OR forged OR formed OR machined OR molded 
              OR piece_part OR raw_material OR rolled OR 
              customer_furnished_equipment OR inseparable_assembly OR 
              sheared;
          domain_thing := assembly_module OR bare_die OR design_layer OR 
              documentation_layer OR functionality OR interconnect OR 
              interconnect_module OR package OR packaged_part OR 
              printed_part OR requirements_model OR simulation_model OR 
              template_model;
          pass := (assembly XOR detail) OR (generic_thing XOR document) OR
               standard OR (domain_thing XOR document);
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;
    wr2: (SIZEOF(QUERY ( prpc <* product_related_product_category | (NOT (
             prpc\product_category.name IN ['assembly','assembly module',
             'bare die','cast','coined','customer furnished equipment',
             'design layer','detail','documentation layer','drawn',
             'extruded','forged','formed','functionality',
             'inseparable assembly','interconnect','interconnect module',
             'machined','material','molded','package','packaged part',
             'part','piece part','printed part','raw material',
             'requirements model','rolled','sheared','simulation model',
             'standard','template model','tool'])) )) = 0);

  END_RULE; -- mandatory_product_related_product_category_value

  RULE marking_constraint FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 'marking') 
             AND (SIZEOF(QUERY ( pdr <* USEDIN(rep,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT') IN TYPEOF(pdr.definition)) )) > 0) AND (NOT (
             SIZEOF(QUERY ( place <* rep.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PLACEMENT') IN TYPEOF(place)) AND (place\representation_item.name = 
             'marking location')) )) = 1))) )) = 0);

  END_RULE; -- marking_constraint

  RULE material_assembly_relationship_constraint FOR (
             assembly_component_usage);

  WHERE
    wr1: (SIZEOF(QUERY ( acu <* assembly_component_usage | ((acu\product_definition_relationship.name = 
             'material assembly relationship') AND (SIZEOF(USEDIN(acu.
             relating_product_definition,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MATERIAL_DESIGNATION.DEFINITIONS')) = 0)) )) = 0);
    wr2: (SIZEOF(QUERY ( acu <* assembly_component_usage | ((acu\product_definition_relationship.name = 
             'material assembly relationship') AND (SIZEOF(USEDIN(acu.
             related_product_definition,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MATERIAL_DESIGNATION.DEFINITIONS')) = 0)) )) = 0);

  END_RULE; -- material_assembly_relationship_constraint

  RULE material_assembly_relationship_unique_constraint FOR (
             assembly_component_usage);

    LOCAL
      acu_bag : BAG OF assembly_component_usage;
      md      : BAG OF material_designation;
      mar     : BAG OF assembly_component_usage := QUERY ( acu <* 
                 assembly_component_usage | (acu\product_definition_relationship.name = 
                 'material assembly relationship') );
      pass    : BOOLEAN := TRUE;
      id_bag  : BAG OF STRING := [];
      md_bag  : BAG OF material_designation;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(mar) BY 1;
      IF EXISTS(mar[i].related_product_definition.formation.of_product.id)
           THEN
        IF NOT (mar[i].related_product_definition.formation.of_product.id 
            IN id_bag) THEN
          id_bag := id_bag + mar[i].related_product_definition.formation.
              of_product.id;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      md_bag := [];
      acu_bag := QUERY ( acu <* mar | (acu.related_product_definition.
          formation.of_product.id = id_bag[i]) );
      REPEAT j := 1 TO SIZEOF(acu_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        md := USEDIN(acu_bag[j].relating_product_definition,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'MATERIAL_DESIGNATION.DEFINITIONS');
        REPEAT k := 1 TO SIZEOF(md) BY 1;
          IF EXISTS(md[k]) THEN
            IF md[k] IN md_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              md_bag := md_bag + md[k];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- material_assembly_relationship_unique_constraint

  RULE mating_connector_placement_relationship_constraint FOR (
             shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'mating connector placement') AND (SIZEOF(QUERY ( p <* sr.
             items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PLACEMENT') IN TYPEOF(p)) AND (p\representation_item.name = 'connector placement')) )) 
             = 0)) )) = 0);

  END_RULE; -- mating_connector_placement_relationship_constraint

  RULE mating_connector_termination_constraint FOR (shape_aspect);

  WHERE
    wr1: (SIZEOF(QUERY ( sa <* shape_aspect | ((sa\shape_aspect.description = 
             'mating connector termination') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_DEFINITION') IN TYPEOF(sa.of_shape)) AND (sa.
             of_shape.description = 'mating connector')))) )) = 0);

  END_RULE; -- mating_connector_termination_constraint

  RULE mating_connector_termination_unique_constraint FOR (shape_aspect);

    LOCAL
      cd_bag  : BAG OF component_definition := [];
      sar_bag : BAG OF shape_aspect_relationship;
      ppt_bag : BAG OF packaged_part_terminal;
      mct     : BAG OF shape_aspect := QUERY ( sa <* shape_aspect | (sa\shape_aspect.
                 description = 'mating connector termination') );
      pass    : BOOLEAN := TRUE;
      sa_bag  : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(mct) BY 1;
      IF EXISTS(mct[i].of_shape.definition) THEN
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'COMPONENT_DEFINITION') IN TYPEOF(mct[i].of_shape.definition)) 
            AND (mct[i].of_shape.definition.description = 
            'mating connector') THEN
          IF NOT (mct[i].of_shape.definition IN cd_bag) THEN
            cd_bag := cd_bag + mct[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ppt_bag := [];
      sa_bag := QUERY ( sa <* mct | (sa.of_shape.definition :=: cd_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(sa_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
            = 'instantiated terminal') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PACKAGED_PART_TERMINAL') IN TYPEOF(sar.relating_shape_aspect))) );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
            IF sar_bag[k].relating_shape_aspect IN ppt_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ppt_bag := ppt_bag + sar_bag[k].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- mating_connector_termination_unique_constraint

  RULE model_parameter_unique_constraint FOR (model_parameter);

    LOCAL
      mp_bag   : BAG OF model_parameter;
      name_bag : BAG OF STRING := [];
      adr_bag  : BAG OF applied_document_reference;
      pass     : BOOLEAN := TRUE;
      d_bag    : BAG OF document;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(model_parameter) BY 1;
      IF EXISTS(model_parameter[i]\representation_item.name) THEN
        IF NOT (model_parameter[i]\representation_item.name IN name_bag) THEN
          name_bag := name_bag + model_parameter[i]\representation_item.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      mp_bag := QUERY ( mp <* model_parameter | (mp\representation_item.name = name_bag[i]) );
      d_bag := [];
      REPEAT j := 1 TO SIZEOF(mp_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        adr_bag := USEDIN(mp_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_DOCUMENT_REFERENCE.ITEMS');
        REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
          IF EXISTS(adr_bag[k].assigned_document) THEN
            IF adr_bag[k].assigned_document IN d_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              d_bag := d_bag + adr_bag[k].assigned_document;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- model_parameter_unique_constraint

  RULE next_higher_assembly_interface_requirement_constraint FOR (
             specified_higher_usage_occurrence);

  WHERE
    wr1: (SIZEOF(QUERY ( shuo <* specified_higher_usage_occurrence | (NOT 
             (SIZEOF(QUERY ( pd <* USEDIN(shuo,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
             QUERY ( pdr <* USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_REPRESENTATION') IN TYPEOF(pdr.used_representation)) 
             AND (pdr.used_representation\representation.name = '3d bound volume shape')) )) 
             = 0)) )) = 0)) )) = 0);

  END_RULE; -- next_higher_assembly_interface_requirement_constraint

  RULE next_higher_assembly_relationship_unique_constraint FOR (
             next_assembly_usage_occurrence);

    LOCAL
      refdes_bag : BAG OF STRING;
      pu_bag     : BAG OF physical_unit := [];
      nauo_bag   : BAG OF next_assembly_usage_occurrence;
      pass       : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(next_assembly_usage_occurrence) BY 1;
      IF EXISTS(next_assembly_usage_occurrence[i].
          relating_product_definition) THEN
        IF (next_assembly_usage_occurrence[i].relating_product_definition.
            frame_of_reference.name = 'physical design') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(next_assembly_usage_occurrence[i].
            relating_product_definition)) THEN
          IF NOT (next_assembly_usage_occurrence[i].
              relating_product_definition IN pu_bag) THEN
            pu_bag := pu_bag + next_assembly_usage_occurrence[i].
                relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      refdes_bag := [];
      nauo_bag := QUERY ( nauo <* next_assembly_usage_occurrence | (nauo.
          relating_product_definition :=: pu_bag[i]) );
      REPEAT j := 1 TO SIZEOF(nauo_bag) BY 1;
        IF EXISTS(nauo_bag[j].reference_designator) THEN
          IF nauo_bag[j].reference_designator IN refdes_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            refdes_bag := refdes_bag + nauo_bag[j].reference_designator;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- next_higher_assembly_relationship_unique_constraint

  RULE no_shape_for_make_from FOR (make_from_usage_option);

  WHERE
    wr1: (SIZEOF(QUERY ( mfuo <* make_from_usage_option | (NOT (SIZEOF(
             QUERY ( pd <* USEDIN(mfuo,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_SHAPE') IN TYPEOF(pd)) )) = 0)) )) = 0);

  END_RULE; -- no_shape_for_make_from

  RULE operational_requirement_occurrence_relationship_constraint FOR (
             property_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* property_definition_relationship | (((pdr\property_definition_relationship.
             name = 'and operation') OR (pdr\property_definition_relationship.name = 'or operation')) AND (
             NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'REQUIREMENTS_PROPERTY') IN TYPEOF(pdr.
             related_property_definition)))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* property_definition_relationship | (((pdr\property_definition_relationship.
             name = 'and operation') OR (pdr\property_definition_relationship.name = 'or operation')) AND (
             NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'REQUIREMENTS_PROPERTY') IN TYPEOF(pdr.
             relating_property_definition)))) )) = 0);

  END_RULE; -- operational_requirement_occurrence_relationship_constraint

  RULE organization_unique_constraint FOR (organization);

    LOCAL
      r      : BAG OF organization := QUERY ( r <* organization | TRUE );
      pass   : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i].id) THEN
        IF r[i]\organization.id IN id_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + r[i].id;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- organization_unique_constraint

  RULE package_external_reference_constraint FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'package external reference') AND (SIZEOF(QUERY ( dri <* rep.
             items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'design owner'))) )) = 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'package external reference') AND (SIZEOF(QUERY ( dri <* rep.
             items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'part number'))) )) = 1)) )) = 0);
    wr3: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'package external reference') AND (SIZEOF(QUERY ( dri <* rep.
             items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'revision code'))) )) = 1)) )) = 0);
    wr4: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'package external reference') AND (SIZEOF(QUERY ( dri <* rep.
             items | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'product definition id'))) )) = 1)) )) = 0);

  END_RULE; -- package_external_reference_constraint

  RULE package_terminal_external_reference_constraint FOR (
             descriptive_representation_item);

  WHERE
    wr1: (SIZEOF(QUERY ( dri <* descriptive_representation_item | ((dri.
             name = 'package terminal external reference') AND (SIZEOF(
             QUERY ( rep <* USEDIN(dri,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REPRESENTATION.ITEMS') | (rep\representation.name = 
             'package external reference') )) = 0)) )) = 0);

  END_RULE; -- package_terminal_external_reference_constraint

  RULE package_terminal_external_reference_unique_constraint FOR (
             descriptive_representation_item);

    LOCAL
      pter     : BAG OF descriptive_representation_item := QUERY ( dri <* 
                  descriptive_representation_item | (dri\representation_item.name = 
                  'package terminal external reference') );
      desc_bag : BAG OF STRING := [];
      dri_bag  : BAG OF descriptive_representation_item;
      rep_bag  : BAG OF representation;
      pass     : BOOLEAN := TRUE;
      r_bag    : BAG OF representation;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pter) BY 1;
      IF EXISTS(pter[i].description) THEN
        IF NOT (pter[i].description IN desc_bag) THEN
          desc_bag := desc_bag + pter[i].description;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(desc_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      r_bag := [];
      dri_bag := QUERY ( dri <* pter | (dri.description = desc_bag[i]) );
      REPEAT j := 1 TO SIZEOF(dri_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        rep_bag := QUERY ( r <* USEDIN(dri_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'REPRESENTATION.ITEMS') | (r\representation.name = 
            'package external reference') );
        REPEAT k := 1 TO SIZEOF(rep_bag) BY 1;
          IF EXISTS(rep_bag[k]) THEN
            IF rep_bag[k] IN r_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              r_bag := r_bag + rep_bag[k];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- package_terminal_external_reference_unique_constraint

  RULE package_unique_constraint FOR (package, externally_defined_package, 
             library_defined_package);

    LOCAL
      edp     : BAG OF physical_unit := QUERY ( r <* 
                 externally_defined_package | (r.frame_of_reference.name = 
                 'physical design usage') );
      pdr_bag : BAG OF property_definition_representation;
      pd_bag  : BAG OF property_definition;
      p       : BAG OF physical_unit := QUERY ( r <* package | (r.
                 frame_of_reference.name = 'physical design usage') );
      pu      : BAG OF physical_unit;
      ldp     : BAG OF physical_unit := QUERY ( r <* 
                 library_defined_package | (r.frame_of_reference.name = 
                 'physical design usage') );
      pass    : BOOLEAN := TRUE;
      r_bag   : BAG OF representation := [];
    END_LOCAL;
    pu := p + edp + ldp;
    REPEAT i := 1 TO SIZEOF(pu) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pd_bag := USEDIN(pu[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION.DEFINITION');
      REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(pd_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (pdr.
            used_representation\representation.name = 'registered case style') );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].used_representation) THEN
            IF pdr_bag[k].used_representation IN r_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              r_bag := r_bag + pdr_bag[k].used_representation;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- package_unique_constraint

  RULE packaged_connector_terminal_relationship_unique_constraint FOR (
             packaged_connector_terminal_relationship);

    LOCAL
      it_bag   : BAG OF packaged_part_terminal;
      pctr_bag : BAG OF packaged_connector_terminal_relationship;
      pass1    : BOOLEAN := TRUE;
      pass2    : BOOLEAN := TRUE;
      pu_bag   : BAG OF physical_unit := [];
      jt_bag   : BAG OF packaged_part_terminal;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(packaged_connector_terminal_relationship) BY 1;
      IF EXISTS(packaged_connector_terminal_relationship[i].of_shape.
          definition) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(
            packaged_connector_terminal_relationship[i].of_shape.definition)
             THEN
          IF NOT (packaged_connector_terminal_relationship[i].of_shape.
              definition IN pu_bag) THEN
            pu_bag := pu_bag + packaged_connector_terminal_relationship[i]
                .of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT (pass1 OR pass2) THEN
        ESCAPE;
      END_IF;
      it_bag := [];
      jt_bag := [];
      pctr_bag := QUERY ( r <* packaged_connector_terminal_relationship | 
          (r.of_shape.definition :=: pu_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pctr_bag) BY 1;
        IF NOT (pass1 OR pass2) THEN
          ESCAPE;
        END_IF;
        IF pass1 AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PACKAGED_PART_TERMINAL') IN TYPEOF(pctr_bag[j].
            relating_shape_aspect)) AND (pctr_bag[j].relating_shape_aspect\shape_aspect.
            description = 'join terminal') THEN
          IF EXISTS(pctr_bag[j].relating_shape_aspect) THEN
            IF pctr_bag[j].relating_shape_aspect IN jt_bag THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              jt_bag := jt_bag + pctr_bag[j].relating_shape_aspect;
            END_IF;
          END_IF;
        END_IF;
        IF pass2 AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PACKAGED_PART_TERMINAL') IN TYPEOF(pctr_bag[j].
            related_shape_aspect)) AND (pctr_bag[j].related_shape_aspect\shape_aspect.
            description = 'interface terminal') THEN
          IF EXISTS(pctr_bag[j].related_shape_aspect) THEN
            IF pctr_bag[j].related_shape_aspect IN it_bag THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              it_bag := it_bag + pctr_bag[j].related_shape_aspect;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass1;
    wr2: pass2;

  END_RULE; -- packaged_connector_terminal_relationship_unique_constraint

  RULE packaged_part_unique_constraint FOR (packaged_part, 
             externally_defined_packaged_part, 
             library_defined_packaged_part);

    LOCAL
      p_bag   : BAG OF physical_unit;
      fu_bag  : BAG OF functional_unit := [];
      pdr_bag : BAG OF product_definition_relationship;
      edpp    : BAG OF physical_unit := QUERY ( r <* 
                 externally_defined_packaged_part | (r.frame_of_reference.
                 name = 'physical design usage') );
      aaa_bag : BAG OF applied_action_assignment;
      ldpp    : BAG OF physical_unit := QUERY ( r <* 
                 library_defined_packaged_part | (r.frame_of_reference.name 
                 = 'physical design usage') );
      pp      : BAG OF physical_unit := QUERY ( r <* packaged_part | (r.
                 frame_of_reference.name = 'physical design usage') );
      pu      : BAG OF physical_unit;
      pass    : BOOLEAN := TRUE;
      pp_bag  : BAG OF packaged_part;
    END_LOCAL;
    pu := pp + edpp + ldpp;
    REPEAT i := 1 TO SIZEOF(pu) BY 1;
      pdr_bag := QUERY ( pdr <* USEDIN(pu[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | (
          (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.
          relating_product_definition.frame_of_reference.name = 
          'functional design usage') AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'FUNCTIONAL_UNIT') IN TYPEOF(pdr.relating_product_definition))) );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF EXISTS(pdr_bag[j].relating_product_definition) THEN
          IF NOT (pdr_bag[j].relating_product_definition IN fu_bag) THEN
            fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(fu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pp_bag := QUERY ( r <* pu | (SIZEOF(QUERY ( pdr <* USEDIN(fu_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
          ((pdr\product_definition_relationship.name = 'implemented function') AND (pdr.
          related_product_definition :=: r)) )) > 0) );
      p_bag := [];
      REPEAT j := 1 TO SIZEOF(pp_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pdr_bag := QUERY ( pdr <* USEDIN(pp_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
             | ((pdr\product_definition_relationship.name = 'used package') AND (pdr.
            relating_product_definition.frame_of_reference.name = 
            'physical design usage') AND (((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PACKAGE') IN TYPEOF(pdr.relating_product_definition)) OR ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'EXTERNALLY_DEFINED_PACKAGE') IN TYPEOF(pdr.
            relating_product_definition)) OR ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'LIBRARY_DEFINED_PACKAGE') IN TYPEOF(pdr.
            relating_product_definition)))) );
        REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
          IF EXISTS(pdr_bag[k].relating_product_definition) THEN
            IF pdr_bag[k].relating_product_definition IN p_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              p_bag := p_bag + pdr_bag[k].relating_product_definition;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- packaged_part_unique_constraint

  RULE part_device_terminal_model_port_assignment_unique_constraint FOR (
             property_definition_representation);

    LOCAL
      pdr_bag : BAG OF property_definition_representation;
      amp_bag : BAG OF analytical_model_port := [];
      pass    : BOOLEAN := TRUE;
      sa_bag  : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(property_definition_representation) BY 1;
      IF EXISTS(property_definition_representation[i].used_representation)
           THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'ANALYTICAL_MODEL_PORT') IN TYPEOF(
            property_definition_representation[i].used_representation)
             THEN
          IF NOT (property_definition_representation[i].
              used_representation IN amp_bag) THEN
            amp_bag := amp_bag + property_definition_representation[i].
                used_representation;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(amp_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sa_bag := [];
      pdr_bag := QUERY ( pdr <* property_definition_representation | (pdr.
          used_representation :=: amp_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF EXISTS(pdr_bag[j].definition.definition) THEN
          IF pdr_bag[j].definition.definition IN sa_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            sa_bag := sa_bag + pdr_bag[j].definition.definition;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- part_device_terminal_model_port_assignment_unique_constraint

  RULE part_device_terminal_unique_constraint FOR (shape_aspect);

    LOCAL
      pdr_bag : BAG OF product_definition_relationship := [];
      pd_bag  : BAG OF property_definition;
      bdt_bag : BAG OF bare_die_terminal;
      sa      : BAG OF bare_die_terminal;
      pass    : BOOLEAN := TRUE;
      sa_bag  : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(shape_aspect) BY 1;
      IF EXISTS(shape_aspect[i].of_shape.definition) THEN
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF(shape_aspect[i].
            of_shape.definition)) AND (shape_aspect[i].of_shape.definition.
            description = 'part device') THEN
          IF NOT (shape_aspect[i].of_shape.definition IN pdr_bag) THEN
            pdr_bag := pdr_bag + shape_aspect[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pdr_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      bdt_bag := [];
      sa_bag := QUERY ( sa <* shape_aspect | (sa.of_shape.definition :=: 
          pdr_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pd_bag := QUERY ( pd <* USEDIN(sa_bag[j].of_shape.definition.
            related_product_definition,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF([
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'BARE_DIE',
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'EXTERNALLY_DEFINED_BARE_DIE',
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'LIBRARY_DEFINED_BARE_DIE'] * TYPEOF(pd.definition)) > 0) );
        REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          sa := QUERY ( bdt <* USEDIN(pd_bag[k],
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'SHAPE_ASPECT.OF_SHAPE') | ((
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'BARE_DIE_TERMINAL') IN TYPEOF(bdt)) );
          REPEAT l := 1 TO SIZEOF(sa) BY 1;
            IF EXISTS(sa[l]) THEN
              IF sa[l] IN bdt_bag THEN
                pass := FALSE;
                ESCAPE;
              ELSE
                bdt_bag := bdt_bag + sa[l];
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- part_device_terminal_unique_constraint

  RULE part_device_unique_constraint FOR (product_definition_relationship);

    LOCAL
      pdr_bag  : BAG OF product_definition_relationship;
      name_bag : BAG OF STRING;
      pu_bag   : BAG OF physical_unit := [];
      pd       : BAG OF product_definition_relationship := QUERY ( pdr <* 
                  product_definition_relationship | (pdr\product_definition_relationship.description = 
                  'part device') );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pd) BY 1;
      IF EXISTS(pd[i].relating_product_definition) THEN
        IF (pd[i].relating_product_definition.frame_of_reference.name = 
            'physical design usage') AND (SIZEOF([
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PACKAGED_PART',
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'EXTERNALLY_DEFINED_PACKAGED_PART',
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'LIBRARY_DEFINED_PACKAGED_PART'] * TYPEOF(pd[i].
            relating_product_definition)) > 0) THEN
          IF NOT (pd[i].relating_product_definition IN pu_bag) THEN
            pu_bag := pu_bag + pd[i].relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      name_bag := [];
      pdr_bag := QUERY ( pdr <* pd | (pdr.relating_product_definition :=: 
          pu_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
        IF EXISTS(pdr_bag[j]\product_definition_relationship.name) THEN
          IF pdr_bag[j]\product_definition_relationship.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + pdr_bag[j]\product_definition_relationship.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- part_device_unique_constraint

  RULE part_feature_constraint FOR (shape_aspect, product_definition, 
             shape_aspect_relationship);

    LOCAL
      name_bag : BAG OF STRING := [];
      sa       : BAG OF shape_aspect := [];
      pd       : BAG OF product_definition := QUERY ( pd <* 
                  product_definition | (pd.frame_of_reference\
                  application_context_element.name = 
                  'physical design usage') );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pd) BY 1;
      name_bag := [];
      sa := QUERY ( sa <* shape_aspect | ((sa.of_shape\property_definition
          .definition = pd[i]) AND sa.product_definitional AND (NOT (sa\shape_aspect.
          description = 'connection zone'))) );
      REPEAT j := 1 TO SIZEOF(sa) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        IF sa[j]\shape_aspect.name IN name_bag THEN
          pass := FALSE;
        ELSE
          name_bag := name_bag + sa[j]\shape_aspect.name;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'precedent feature') AND (sar.related_shape_aspect = sar.
             relating_shape_aspect)) )) = 0);
    wr3: (SIZEOF(QUERY ( sa <* shape_aspect | (((sa\shape_aspect.description = 
             'part group feature') OR (sa\shape_aspect.description = 
             'part generic feature') OR (sa\shape_aspect.description = 
             'polarity indication feature') OR (sa\shape_aspect.description = 
             'interconnect module edge segment surface') OR (sa\shape_aspect.description 
             = 'interconnect module edge surface') OR (sa\shape_aspect.description = 
             'interconnect module primary surface') OR (sa\shape_aspect.description = 
             'interconnect module secondary surface') OR (sa\shape_aspect.description = 
             'interconnect module surface feature')) AND (SIZEOF(
             QUERY ( sar <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name 
             = 'precedent feature') )) > 1)) )) = 0);

  END_RULE; -- part_feature_constraint

  RULE part_feature_unique_constraint FOR (composite_shape_aspect, 
             shape_aspect, primary_orientation_feature, 
             secondary_orientation_feature, package_body, 
             part_tooling_feature, thermal_feature, part_mounting_feature, 
             package_terminal, assembly_module_terminal, bare_die_terminal, 
             interconnect_module_terminal, 
             minimally_defined_bare_die_terminal, packaged_part_terminal, 
             package_body_surface);

    LOCAL
      pbs      : BAG OF shape_aspect := QUERY ( r <* package_body_surface
                   | TRUE );
      ptf      : BAG OF shape_aspect := QUERY ( r <* part_tooling_feature
                   | TRUE );
      csa      : BAG OF shape_aspect := QUERY ( r <* 
                  composite_shape_aspect | (r\shape_aspect.description = 
                  'part group feature') );
      name_bag : BAG OF STRING;
      sof      : BAG OF shape_aspect := QUERY ( r <* 
                  secondary_orientation_feature | TRUE );
      tf       : BAG OF shape_aspect := QUERY ( r <* thermal_feature | 
                  TRUE );
      pu_bag   : BAG OF physical_unit := [];
      pof      : BAG OF shape_aspect := QUERY ( r <* 
                  primary_orientation_feature | TRUE );
      bdt      : BAG OF shape_aspect := QUERY ( r <* bare_die_terminal | 
                  TRUE );
      imt      : BAG OF shape_aspect := QUERY ( r <* 
                  interconnect_module_terminal | TRUE );
      ppt      : BAG OF shape_aspect := QUERY ( r <* 
                  packaged_part_terminal | TRUE );
      amt      : BAG OF shape_aspect := QUERY ( r <* 
                  assembly_module_terminal | TRUE );
      pmf      : BAG OF shape_aspect := QUERY ( r <* part_mounting_feature
                   | TRUE );
      sa       : BAG OF shape_aspect := QUERY ( r <* shape_aspect | (r\shape_aspect.
                  description IN ['part generic feature',
                  'polarity indication feature',
                  'interconnect module edge segment surface',
                  'interconnect module edge surface',
                  'interconnect module primary surface',
                  'interconnect module secondary surface',
                  'interconnect module surface feature']) );
      pt       : BAG OF shape_aspect := QUERY ( r <* package_terminal | 
                  TRUE );
      mdbdt    : BAG OF shape_aspect := QUERY ( r <* 
                  minimally_defined_bare_die_terminal | TRUE );
      pb       : BAG OF shape_aspect := QUERY ( r <* package_body | TRUE );
      pf       : BAG OF shape_aspect := [];
      pass     : BOOLEAN := TRUE;
      sa_bag   : BAG OF shape_aspect;
    END_LOCAL;
    sa := csa + sa + pof + sof + pb + ptf + tf + pmf + pt + amt + bdt + 
        imt + mdbdt + ppt + pbs;
    REPEAT i := 1 TO SIZEOF(sa) BY 1;
      IF EXISTS(sa[i]) THEN
        IF NOT (sa[i] IN pf) THEN
          pf := pf + sa[i];
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pf) BY 1;
      IF EXISTS(pf[i].of_shape.definition) THEN
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(pf[i].of_shape.definition)) AND (pf[
            i].of_shape.definition.frame_of_reference.name = 
            'physical design usage') THEN
          IF NOT (pf[i].of_shape.definition IN pu_bag) THEN
            pu_bag := pu_bag + pf[i].of_shape.definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      name_bag := [];
      sa_bag := QUERY ( sa <* pf | (sa.of_shape.definition :=: pu_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
        IF EXISTS(sa_bag[j]\shape_aspect.name) THEN
          IF sa_bag[j]\shape_aspect.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + sa_bag[j]\shape_aspect.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- part_feature_unique_constraint

  RULE part_template_non_planar_2d_shape_constraint FOR (
             manifold_surface_shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( mssr <* manifold_surface_shape_representation | (
             (mssr\representation.name = 'part template non planar 2d shape') AND (NOT (
             SIZEOF(QUERY ( a2p3d <* mssr.items | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_3D') IN TYPEOF(a2p3d)) )) = 1))) )) = 0);

  END_RULE; -- part_template_non_planar_2d_shape_constraint

  RULE part_template_unique_constraint FOR (part_template_definition);

    LOCAL
      name_bag : BAG OF STRING;
      sid_bag  : BAG OF STRING := [];
      pt       : BAG OF part_template_definition := QUERY ( r <* 
                  part_template_definition | (r.of_shape.definition.
                  frame_of_reference.name = 'template definition') );
      pass     : BOOLEAN := TRUE;
      ptd_bag  : BAG OF part_template_definition;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pt) BY 1;
      IF EXISTS(pt[i].source.source_id) THEN
        IF NOT (pt[i].source.source_id IN sid_bag) THEN
          sid_bag := sid_bag + pt[i].source.source_id;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(sid_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      name_bag := [];
      ptd_bag := QUERY ( ptd <* pt | (ptd.source.source_id = sid_bag[i]) );
      REPEAT j := 1 TO SIZEOF(ptd_bag) BY 1;
        IF EXISTS(ptd_bag[j]\shape_aspect.name) THEN
          IF ptd_bag[j]\shape_aspect.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + ptd_bag[j]\shape_aspect.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- part_template_unique_constraint

  RULE part_terminal_external_reference_unique_constraint FOR (
             representation);

    LOCAL
      pter    : BAG OF representation := QUERY ( r <* representation | (r\representation.
                 name = 'part terminal external reference') );
      pdr_bag : BAG OF property_definition_representation;
      ft_bag  : BAG OF STRING := [];
      pass    : BOOLEAN := TRUE;
      fn_bag  : BAG OF STRING := [];
      r_bag   : BAG OF representation;
      ptd_bag : BAG OF part_template_definition;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pter) BY 1;
      REPEAT j := 1 TO SIZEOF(pter[i].items) BY 1;
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(pter[i].items[j])
             THEN
          IF (pter[i].items[j]\representation_item.name = 'feature name') AND (NOT (pter[i].
              items[j].description IN fn_bag)) THEN
            fn_bag := fn_bag + pter[i].items[j].description;
          END_IF;
          IF (pter[i].items[j]\representation_item.name = 'feature type') AND (NOT (pter[i].
              items[j].description IN ft_bag)) THEN
            ft_bag := ft_bag + pter[i].items[j].description;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(fn_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      REPEAT j := 1 TO SIZEOF(ft_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        r_bag := QUERY ( r <* pter | ((SIZEOF(QUERY ( ri <* r.items | ((ri\descriptive_representation_item
            .description = ft_bag[j]) AND (ri\representation_item.name = 'feature type')) )) > 
            0) AND (SIZEOF(QUERY ( ri <* r.items | ((ri\descriptive_representation_item.description = 
            fn_bag[i]) AND (ri\representation_item.name = 'feature name')) )) > 0)) );
        ptd_bag := [];
        REPEAT k := 1 TO SIZEOF(r_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          pdr_bag := USEDIN(r_bag[k],
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
          REPEAT l := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[l].definition.definition) THEN
              IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                  + 'PHYSICAL_UNIT') IN TYPEOF(pdr_bag[l].definition.
                  definition) THEN
                IF pdr_bag[l].definition.definition IN ptd_bag THEN
                  pass := FALSE;
                  ESCAPE;
                ELSE
                  ptd_bag := ptd_bag + pdr_bag[l].definition.definition;
                END_IF;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- part_terminal_external_reference_unique_constraint

  RULE pdf_requires_security_classification FOR (
             product_definition_formation, 
             applied_security_classification_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( asca <* 
             applied_security_classification_assignment | (pdf IN asca.
             items) )) = 1)) )) = 0);

  END_RULE; -- pdf_requires_security_classification

  RULE person_and_organization_unique_constraint FOR (
             person_and_organization);

    LOCAL
      p_bag   : BAG OF person := [];
      pao_bag : BAG OF person_and_organization;
      o_bag   : BAG OF organization;
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(person_and_organization) BY 1;
      IF EXISTS(person_and_organization[i].the_person) THEN
        IF NOT (person_and_organization[i].the_person IN p_bag) THEN
          p_bag := p_bag + person_and_organization[i].the_person;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(p_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      o_bag := [];
      pao_bag := QUERY ( pao <* person_and_organization | (pao.the_person 
          :=: p_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pao_bag) BY 1;
        IF EXISTS(pao_bag[j].the_organization) THEN
          IF pao_bag[j].the_organization IN o_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            o_bag := o_bag + pao_bag[j].the_organization;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- person_and_organization_unique_constraint

  RULE physical_connectivity_abstraction_map_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      csa_bag : BAG OF component_shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      pcam    : BAG OF shape_aspect_relationship := QUERY ( r <* 
                 shape_aspect_relationship | (r\shape_aspect_relationship.name = 
                 'physical to topological abstraction map') );
      pce_bag : BAG OF physical_connectivity_element := [];
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pcam) BY 1;
      IF EXISTS(pcam[i].related_shape_aspect) THEN
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_CONNECTIVITY_ELEMENT') IN TYPEOF(pcam[i].
            related_shape_aspect) THEN
          IF NOT (pcam[i].related_shape_aspect IN pce_bag) THEN
            pce_bag := pce_bag + pcam[i].related_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pce_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      csa_bag := [];
      sar_bag := QUERY ( sar <* pcam | (sar.related_shape_aspect :=: 
          pce_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'COMPONENT_SHAPE_ASPECT') IN TYPEOF(sar_bag[j].
            relating_shape_aspect)) AND (sar_bag[j].relating_shape_aspect\shape_aspect.
            description IN [
            'conductive interconnect element with pre defined transitions','conductive interconnect element with user defined single transition'])
             THEN
          IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
            IF sar_bag[j].relating_shape_aspect IN csa_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              csa_bag := csa_bag + sar_bag[j].relating_shape_aspect;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- physical_connectivity_abstraction_map_unique_constraint

  RULE physical_connectivity_definition_relationship_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'physical connectivity definition change') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(sar.
             related_shape_aspect)))) )) = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'physical connectivity definition change') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(sar.
             relating_shape_aspect)))) )) = 0);
    wr3: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'physical connectivity definition change') AND (SIZEOF(
             QUERY ( rpd <* USEDIN(sar,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REQUIREMENTS_PROPERTY') IN TYPEOF(rpd)) )) = 0)) )) = 0);

  END_RULE; -- physical_connectivity_definition_relationship_constraint

  RULE physical_connectivity_element_unique_constraint FOR (
             physical_connectivity_element);

    LOCAL
      name_bag : BAG OF STRING := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      pce_bag  : BAG OF physical_connectivity_element;
      pass     : BOOLEAN := TRUE;
      pcd_bag  : BAG OF physical_connectivity_definition;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(physical_connectivity_element) BY 1;
      IF EXISTS(physical_connectivity_element[i]\shape_aspect.name) THEN
        IF NOT (physical_connectivity_element[i]\shape_aspect.name IN 
            name_bag) THEN
          name_bag := name_bag + physical_connectivity_element[i]\
              shape_aspect.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pcd_bag := [];
      pce_bag := QUERY ( pce <* physical_connectivity_element | (pce\
          shape_aspect.name = name_bag[i]) );
      REPEAT j := 1 TO SIZEOF(pce_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(pce_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
            = 'structure element') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(sar.
            relating_shape_aspect))) );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
            IF sar_bag[j].relating_shape_aspect IN pcd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              pcd_bag := pcd_bag + sar_bag[j].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- physical_connectivity_element_unique_constraint

  RULE physical_node_requirement_to_implementing_component_allocation_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'physical node requirement to implementation') AND (
             NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'COMPONENT_DEFINITION') IN TYPEOF(pdr.
             related_product_definition)))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'physical node requirement to implementation') AND (
             SIZEOF(QUERY ( pds <* USEDIN(pdr.relating_product_definition,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_SHAPE') IN TYPEOF(pds)) AND (SIZEOF(
             QUERY ( pcd <* USEDIN(pds,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT.OF_SHAPE') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(pcd)) )) = 0)) )) 
             = 0)) )) = 0);

  END_RULE; -- physical_node_requirement_to_implementing_component_allocation_constraint

  RULE placement_group_area_assignment_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'impacted group') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MOUNTING_RESTRICTION_AREA') IN TYPEOF(sar.
             related_shape_aspect)))) )) = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'impacted group') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUP_SHAPE_ASPECT') IN TYPEOF(sar.relating_shape_aspect)) OR
              ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
              'SHAPE_ASPECT') IN TYPEOF(sar.relating_shape_aspect)) AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUP_PRODUCT_DEFINITION') IN TYPEOF(sar.
             relating_shape_aspect.of_shape.definition)) AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_CONTEXT') IN TYPEOF(sar.
             relating_shape_aspect.of_shape.definition.frame_of_reference)) 
             AND (sar.relating_shape_aspect.of_shape.definition.
             frame_of_reference.name = 'design requirement'))))) )) = 0);

  END_RULE; -- placement_group_area_assignment_constraint

  RULE planar_curve_constraint FOR (shape_representation);

  WHERE
--tt correction
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (((sr\representation.name IN [
             'planar projected shape','bevel edge feature shape',
             'step edge feature shape','radius edge feature shape'])) AND (
             sr.context_of_items\geometric_representation_context.coordinate_space_dimension <> 
             2)) )) = 0);

  END_RULE; -- planar_curve_constraint

  RULE planar_projected_shape_constraint FOR (shape_representation, 
             representation_relationship_with_transformation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((NOT (sr\
             representation.name = 'planar projected shape')) OR (SIZEOF(
             QUERY ( rrwt <* 
             representation_relationship_with_transformation | (sr :=: rrwt
             \representation_relationship.rep_1) )) <= 1))) )) = 0);

  END_RULE; -- planar_projected_shape_constraint

  RULE planned_effectivity_constraint FOR (configuration_effectivity);

  WHERE
    wr1: (SIZEOF(QUERY ( ce <* configuration_effectivity | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(ce.usage)) AND (ce.usage\product_definition_relationship
             .name = 'assembly composition'))) )) = 0);
    wr2: (SIZEOF(QUERY ( ce <* configuration_effectivity | (SIZEOF(USEDIN(
             ce,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0) )) = 0);

  END_RULE; -- planned_effectivity_constraint

  RULE planned_effectivity_unique_constraint FOR (
             configuration_effectivity);

    LOCAL
      acu_bag : BAG OF assembly_component_usage;
      ci_bag  : BAG OF configuration_item := [];
      ce_bag  : BAG OF configuration_effectivity;
      pass    : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(configuration_effectivity) BY 1;
      IF EXISTS(configuration_effectivity[i].configuration.configuration)
           THEN
        IF NOT (configuration_effectivity[i].configuration.configuration 
            IN ci_bag) THEN
          ci_bag := ci_bag + configuration_effectivity[i].configuration.
              configuration;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(ci_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ce_bag := QUERY ( r <* configuration_effectivity | ((r.configuration
          .configuration :=: ci_bag[i]) AND (r.usage\product_definition_relationship.name = 
          'assembly composition') AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(r.usage))) );
      acu_bag := [];
      REPEAT j := 1 TO SIZEOF(ce_bag) BY 1;
        IF EXISTS(ce_bag[j].usage) THEN
          IF ce_bag[j].usage IN acu_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            acu_bag := acu_bag + ce_bag[j].usage;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- planned_effectivity_unique_constraint

  RULE plus_minus_tolerance_range_representation_constraint FOR (
             shape_dimension_representation, plus_minus_tolerance);

  WHERE
    wr1: (SIZEOF(QUERY ( pmt <* plus_minus_tolerance | (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_VALUE') IN TYPEOF(pmt.range))) )) = 0);

  END_RULE; -- plus_minus_tolerance_range_representation_constraint

  RULE polarity_indication_feature_constraint FOR (shape_aspect);

  WHERE
    wr1: (SIZEOF(QUERY ( sa <* shape_aspect | (NOT (SIZEOF(QUERY ( it <* 
             QUERY ( sar <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
             = 'associated body vertical extent') AND (sar.
             related_shape_aspect\shape_aspect.description = 
             'polarity indication feature')) ) | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_BODY_BOTTOM_SURFACE') IN TYPEOF(it.
             relating_shape_aspect)) )) <= 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( sa <* shape_aspect | (NOT (SIZEOF(QUERY ( it <* 
             QUERY ( sar <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
             = 'associated body vertical extent') AND (sar.
             related_shape_aspect\shape_aspect.description = 
             'polarity indication feature')) ) | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_BODY_TOP_SURFACE') IN TYPEOF(it.relating_shape_aspect)) )) 
             <= 1)) )) = 0);
(*
    wr3: (SIZEOF(QUERY ( sa <* shape_aspect | (NOT (SIZEOF(QUERY ( it <* 
             QUERY ( sar <* USEDIN(sa,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
             = 'associated terminal') AND (sar.related_shape_aspect\shape_aspect.
             description = 'polarity indication feature')) ) | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_TERMINAL') IN TYPEOF(it.relating_shape_aspect)) )) = 
             1)) )) = 0);
*)
  WR3: SIZEOF (QUERY ( sa <* shape_aspect | NOT 
--      if a then b   
       ( NOT (sa\shape_aspect.description = 'polarity indication feature')
	OR (
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'associated terminal') AND
       (sar.related_shape_aspect\shape_aspect.description = 'polarity indication feature'))
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL' IN
       TYPEOF (it.relating_shape_aspect))
       )) = 1)))
       )) = 0;

  END_RULE; -- polarity_indication_feature_constraint

  RULE positional_boundary_member_definition_constraint FOR (
             property_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'positional boundary member property') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY_MEMBER') IN TYPEOF(pd.definition)))) )) =
              0);
    wr2: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'positional boundary member property') AND (NOT (SIZEOF(
             QUERY ( pdr <* USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
              | ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'DIMENSIONAL_SIZE_PROPERTY') IN TYPEOF(pdr.
             related_property_definition)) AND (pdr\property_definition_relationship.name = 
             'boundary member associated dimension')) )) = 1))) )) = 0);

  END_RULE; -- positional_boundary_member_definition_constraint

  RULE positional_boundary_offset_constraint FOR (property_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'positional boundary offset') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_RELATIONSHIP') IN TYPEOF(pd.definition)) AND (pd
             .definition\shape_aspect_relationship.name = 
             'positional boundary and profile boundary member')))) )) = 0);
    wr2: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'positional boundary offset') AND (NOT (SIZEOF(QUERY ( pdr <* 
             USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
              | ((pdr\property_definition_relationship.name = 'boundary offset') AND (pdr.
             relating_property_definition\property_definition.name = 
             'profile related positional boundary property')) )) = 1))) )) 
             = 0);

  END_RULE; -- positional_boundary_offset_constraint

  RULE printed_connector_template_terminal_relationship_unique_constraint FOR (
             printed_connector_template_terminal_relationship);

    LOCAL
      it_bag    : BAG OF printed_part_template_terminal;
      sar_bag   : BAG OF shape_aspect_relationship;
      pass1     : BOOLEAN := TRUE;
      pass2     : BOOLEAN := TRUE;
      pcttr_bag : BAG OF printed_connector_template_terminal_relationship;
      jt_bag    : BAG OF printed_part_template_terminal;
      ptd_bag   : BAG OF part_template_definition := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(
        printed_connector_template_terminal_relationship) BY 1;
      sar_bag := QUERY ( sar <* USEDIN(
          printed_connector_template_terminal_relationship[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name = 
          'connector') AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PART_TEMPLATE_DEFINITION') IN TYPEOF(sar.relating_shape_aspect)) 
          AND (sar.relating_shape_aspect\shape_aspect.description = 
          'printed connector template')) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
          IF NOT (sar_bag[j].relating_shape_aspect IN ptd_bag) THEN
            ptd_bag := ptd_bag + sar_bag[j].relating_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(ptd_bag) BY 1;
      IF NOT (pass1 OR pass2) THEN
        ESCAPE;
      END_IF;
      it_bag := [];
      jt_bag := [];
      sar_bag := QUERY ( sar <* USEDIN(ptd_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name = 
          'connector') );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF NOT (pass1 OR pass2) THEN
          ESCAPE;
        END_IF;
        pcttr_bag := QUERY ( pcttr <* 
            printed_connector_template_terminal_relationship | (pcttr :=: 
            sar_bag[j].related_shape_aspect) );
        REPEAT k := 1 TO SIZEOF(pcttr_bag) BY 1;
          IF NOT (pass1 OR pass2) THEN
            ESCAPE;
          END_IF;
          IF pass1 AND ((
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(pcttr_bag[k].
              relating_shape_aspect)) AND (pcttr_bag[k].
              relating_shape_aspect\shape_aspect.description = 'join terminal') THEN
            IF EXISTS(pcttr_bag[k].relating_shape_aspect) THEN
              IF pcttr_bag[k].relating_shape_aspect IN jt_bag THEN
                pass1 := FALSE;
                ESCAPE;
              ELSE
                jt_bag := jt_bag + pcttr_bag[k].relating_shape_aspect;
              END_IF;
            END_IF;
          END_IF;
          IF pass2 AND ((
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(pcttr_bag[k].
              related_shape_aspect)) AND (pcttr_bag[k].related_shape_aspect
              .description = 'interface terminal') THEN
            IF EXISTS(pcttr_bag[k].related_shape_aspect) THEN
              IF pcttr_bag[k].related_shape_aspect IN it_bag THEN
                pass2 := FALSE;
                ESCAPE;
              ELSE
                it_bag := it_bag + pcttr_bag[k].related_shape_aspect;
              END_IF;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass1;
    wr2: pass2;

  END_RULE; -- printed_connector_template_terminal_relationship_unique_constraint

  RULE printed_part_template_terminal_relationship_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'printed part template terminal relationship') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(sar.
             related_shape_aspect)))) )) = 0);
    wr2: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'printed part template terminal relationship') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_TERMINAL') IN TYPEOF(sar.
             relating_shape_aspect)))) )) = 0);

  END_RULE; -- printed_part_template_terminal_relationship_constraint

  RULE printed_part_template_terminal_unique_constraint FOR (
             printed_part_template_terminal);

    LOCAL
      pptt     : BAG OF printed_part_template_terminal := QUERY ( r <* 
                  printed_part_template_terminal | (r\shape_aspect.description IN [
                  'interface terminal','join terminal']) );
      name_bag : BAG OF STRING := [];
      sar_bag  : BAG OF shape_aspect_relationship;
      pass     : BOOLEAN := TRUE;
      ptd_bag  : BAG OF part_template_definition;
      sa_bag   : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pptt) BY 1;
      IF EXISTS(pptt[i]\shape_aspect.name) THEN
        IF NOT (pptt[i]\shape_aspect.name IN name_bag) THEN
          name_bag := name_bag + pptt[i]\shape_aspect.name;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ptd_bag := [];
      sa_bag := QUERY ( sa <* pptt | (sa\shape_aspect.name = name_bag[i]) );
      REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        sar_bag := QUERY ( sar <* USEDIN(sa_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name 
            = 'associated definition') AND (sar.relating_shape_aspect\shape_aspect.
            description = 'printed part template')) );
        REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
          IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
            IF sar_bag[k].relating_shape_aspect IN ptd_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- printed_part_template_terminal_unique_constraint

  RULE product_association_constraint FOR (
             product_definition_formation_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdfr <* product_definition_formation_relationship
              | ((pdfr\product_definition_formation_relationship.name = 'product association') AND (SIZEOF(
             QUERY ( adr <* USEDIN(pdfr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_DOCUMENT_REFERENCE.ITEMS') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EE_SPECIFICATION') IN TYPEOF(adr.assigned_document)) )) = 0)) )) 
             = 0);

  END_RULE; -- product_association_constraint

  RULE product_association_unique_constraint FOR (
             product_definition_formation_relationship);

    LOCAL
      es_bag   : BAG OF ee_specification;
      pdfr_bag : BAG OF product_definition_formation_relationship;
      adr_bag  : BAG OF applied_document_reference;
      pass     : BOOLEAN := TRUE;
      pdfr     : BAG OF product_definition_formation_relationship := 
                  QUERY ( r <* product_definition_formation_relationship | 
                  (r\product_definition_formation_relationship.name = 'product association') );
      pdf_bag  : BAG OF product_definition_formation := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(pdfr) BY 1;
      IF EXISTS(pdfr[i].relating_product_definition_formation) THEN
        IF NOT (pdfr[i].relating_product_definition_formation IN pdf_bag)
             THEN
          pdf_bag := pdf_bag + pdfr[i].
              relating_product_definition_formation;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pdf_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pdfr_bag := QUERY ( r <* pdfr | (r.
          relating_product_definition_formation :=: pdf_bag[i]) );
      es_bag := [];
      REPEAT j := 1 TO SIZEOF(pdfr_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        adr_bag := QUERY ( adr <* USEDIN(pdfr_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_DOCUMENT_REFERENCE.ITEMS') | ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'EE_SPECIFICATION') IN TYPEOF(adr.assigned_document)) );
        REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
          IF EXISTS(adr_bag[k].assigned_document) THEN
            IF adr_bag[k].assigned_document IN es_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              es_bag := es_bag + adr_bag[k].assigned_document;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- product_association_unique_constraint

  RULE product_category_requires_product_related_product_category FOR (
             product_category, product_category_relationship);

    LOCAL
      pcr  : BAG OF product_category_relationship := [];
      pass : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(product_category) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pcr := USEDIN(product_category[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY');
      REPEAT j := 1 TO SIZEOF(pcr) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        pass := ((NOT (pcr[j].sub_category\product_category.name IN [
            'technology specific land pattern',
            'technology specific padstack',
            'reference packaged part interconnect implementation'])) OR ((
            pcr[j].category\product_category.name = 'interconnect module') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_RELATED_PRODUCT_CATEGORY') IN TYPEOF(pcr[j].category)))) 
            AND ((NOT (pcr[j].sub_category\product_category.name IN [
            'reference packaged part assembly implementation'])) OR ((pcr[j]
            .category\product_category.name = 'assembly module') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PRODUCT_RELATED_PRODUCT_CATEGORY') IN TYPEOF(pcr[j].category))));
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- product_category_requires_product_related_product_category

  RULE product_concept_requires_configuration_item FOR (product_concept, 
             configuration_item);

  WHERE
    wr1: (SIZEOF(QUERY ( pc <* product_concept | (NOT (SIZEOF(
             QUERY ( ci <* configuration_item | (pc :=: ci.item_concept) )) 
             >= 1)) )) = 0);

  END_RULE; -- product_concept_requires_configuration_item

  RULE product_definition_formation_requires_approval FOR (
             product_definition_formation, applied_approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( aaa <* applied_approval_assignment | (pdf IN 
             aaa.items) )) = 1)) )) = 0);

  END_RULE; -- product_definition_formation_requires_approval

  RULE product_definition_formation_requires_person_organization FOR (
             product_definition_formation, 
             applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
             SIZEOF(QUERY ( apaoa <* 
             applied_person_and_organization_assignment | ((pdf IN apaoa.
             items) AND (apaoa.role.name = 'creator')) )) = 1) OR (SIZEOF(
             QUERY ( aoa <* applied_organization_assignment | ((pdf IN aoa.
             items) AND (aoa.role.name = 'creator')) )) = 1))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
             SIZEOF(QUERY ( apaoa <* 
             applied_person_and_organization_assignment | ((pdf IN apaoa.
             items) AND (apaoa.role.name IN ['design supplier',
             'product supplier'])) )) >= 1) OR (SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | ((pdf IN aoa.items) AND (aoa
             .role.name IN ['design supplier','product supplier'])) )) >= 1))) )) 
             = 0);

  END_RULE; -- product_definition_formation_requires_person_organization

  RULE product_definition_requires_date_or_date_and_time FOR (
             product_definition, applied_date_and_time_assignment, 
             applied_date_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT ((SIZEOF(
             QUERY ( adata <* applied_date_and_time_assignment | (pd IN 
             adata.items) )) = 1) OR (SIZEOF(QUERY ( ada <* 
             applied_date_assignment | (pd IN ada.items) )) = 1))) )) = 0);

  END_RULE; -- product_definition_requires_date_or_date_and_time

  RULE product_definition_requires_person_organization FOR (
             product_definition, applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT ((SIZEOF(
             QUERY ( apaoa <* applied_person_and_organization_assignment | 
             (pd IN apaoa.items) )) = 1) OR (SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | (pd IN aoa.items) )) = 1))) )) 
             = 0);

  END_RULE; -- product_definition_requires_person_organization

  RULE product_requires_person_organization FOR (product, 
             applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT ((SIZEOF(QUERY ( apaoa <* 
             applied_person_and_organization_assignment | (prod IN apaoa.
             items) )) = 1) OR (SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | (prod IN aoa.items) )) = 1))) )) 
             = 0);

  END_RULE; -- product_requires_person_organization

  RULE product_requires_product_definition_formation FOR (product, 
             product_definition_formation);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( pdf <* 
             product_definition_formation | (prod :=: pdf.of_product) )) >=
              1)) )) = 0);

  END_RULE; -- product_requires_product_definition_formation

  RULE profile_boundary_definition_with_offsets_constraint FOR (
             property_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'boundary zone definition with specified size') AND (pd\property_definition.name =
              'profile boundary with offsets') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET') IN TYPEOF(pd.
             definition)))) )) = 0);

  END_RULE; -- profile_boundary_definition_with_offsets_constraint

  RULE profile_related_positional_boundary_definition_constraint FOR (
             property_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'profile related positional boundary property') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY') IN TYPEOF(pd.definition)) AND (pd.
             definition.description = 'profile related positional boundary')))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( pd <* property_definition | ((pd\property_definition.description = 
             'profile related positional boundary property') AND (NOT (
             SIZEOF(QUERY ( pdr <* USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
              | ((pdr.related_property_definition\property_definition.description = 
             'positional boundary offset') AND (pdr\property_definition_relationship.name = 
             'boundary offset')) )) = 1))) )) = 0);

  END_RULE; -- profile_related_positional_boundary_definition_constraint

  RULE projected_zone_and_base_relationship_constraint FOR (
             projected_zone_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pzd <* projected_zone_definition | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_TEMPLATE_DEFINITION') IN TYPEOF(pzd.projection_end)) OR 
             (pzd.projection_end.product_definitional = TRUE))) )) = 0);

  END_RULE; -- projected_zone_and_base_relationship_constraint

  RULE projected_zone_height_characteristic_constraint FOR (
             projected_zone_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pzd <* projected_zone_definition | (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(pzd.projected_length))) )) 
             = 0);

  END_RULE; -- projected_zone_height_characteristic_constraint

  RULE promissory_usage_relationship_constraint FOR (
             promissory_usage_occurrence);

  WHERE
    wr1: (SIZEOF(QUERY ( puo <* promissory_usage_occurrence | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT') IN TYPEOF(puo.relating_product_definition)) 
             AND (puo.relating_product_definition.frame_of_reference.name =
              'physical design')) )) = 0);
    wr2: (SIZEOF(QUERY ( puo <* promissory_usage_occurrence | (SIZEOF(
             USEDIN(puo,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 0) )) =
              0);

  END_RULE; -- promissory_usage_relationship_constraint

  RULE promissory_usage_relationship_unique_constraint FOR (
             promissory_usage_occurrence);

    LOCAL
      puo_bag  : BAG OF promissory_usage_occurrence;
      pu_bag   : BAG OF physical_unit := [];
      comp_bag : BAG OF physical_unit;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(promissory_usage_occurrence) BY 1;
      IF EXISTS(promissory_usage_occurrence[i].relating_product_definition)
           THEN
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(promissory_usage_occurrence[i].
            relating_product_definition)) AND (promissory_usage_occurrence[
            i].relating_product_definition.frame_of_reference.name = 
            'physical design') THEN
          IF NOT (promissory_usage_occurrence[i].
              relating_product_definition IN pu_bag) THEN
            pu_bag := pu_bag + promissory_usage_occurrence[i].
                relating_product_definition;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      puo_bag := QUERY ( puo <* promissory_usage_occurrence | (puo.
          relating_product_definition :=: pu_bag[i]) );
      comp_bag := [];
      REPEAT j := 1 TO SIZEOF(puo_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'PHYSICAL_UNIT') IN TYPEOF(puo_bag[j].
            related_product_definition)) AND (puo_bag[j].
            related_product_definition.frame_of_reference.name IN [
            'physical design','physical design usage']) THEN
          IF EXISTS(puo_bag[j].related_product_definition) THEN
            IF puo_bag[j].related_product_definition IN comp_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              comp_bag := comp_bag + puo_bag[j].related_product_definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- promissory_usage_relationship_unique_constraint

  RULE radius_edge_feature_shape_constraint FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'radius edge feature shape') AND (SIZEOF(QUERY ( lmwu <* sr.
             items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'maximum radius length')) )) = 0)) )) = 0);
    wr2: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'radius edge feature shape') AND (SIZEOF(QUERY ( lmwu <* sr.
             items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'minimum radius length')) )) = 0)) )) = 0);

  END_RULE; -- radius_edge_feature_shape_constraint

  RULE reference_composition_path_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'reference composition path') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_FUNCTIONAL_UNIT') IN TYPEOF(pdr.
             relating_product_definition)) AND (pdr.
             relating_product_definition\product_definition.description = 
             'reference definition path') AND (pdr.
             relating_product_definition.frame_of_reference.name = 
             'functional occurrence')))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'reference composition path') AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_FUNCTIONAL_UNIT') IN TYPEOF(pdr.
             related_product_definition)) AND (pdr.
             related_product_definition.frame_of_reference.name = 
             'functional occurrence')))) )) = 0);

  END_RULE; -- reference_composition_path_constraint

  RULE reference_functional_unit_assignment_to_part_constraint FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'reference functional unit assignment to part') AND (
             NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION') IN TYPEOF(pdr.related_product_definition)) 
             AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'APPLICATION_CONTEXT_ELEMENT') IN TYPEOF(pdr.
             related_product_definition.frame_of_reference)) AND ((pdr.
             relating_product_definition.frame_of_reference.name = 
             'physical design') OR (pdr.relating_product_definition.
             frame_of_reference.name = 'physical design usage'))))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* product_definition_relationship | ((pdr\product_definition_relationship.
             name = 'reference functional unit assignment to part') AND (
             NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION') IN TYPEOF(pdr.
             relating_product_definition)) AND (pdr.
             relating_product_definition\product_definition.description = 
             'design definition path') AND (pdr.relating_product_definition
             .id = 'reference composition path')))) )) = 0);

  END_RULE; -- reference_functional_unit_assignment_to_part_constraint

  RULE reference_functional_unit_assignment_to_part_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      sar     : BAG OF shape_aspect_relationship := QUERY ( r <* 
                 shape_aspect_relationship | (r\shape_aspect_relationship.name = 
                 'reference functional unit assignment to part') );
      pd_bag  : BAG OF product_definition;
      sar_bag : BAG OF shape_aspect_relationship;
      pass    : BOOLEAN := TRUE;
      d_bag   : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(sar) BY 1;
      IF EXISTS(sar[i].description) THEN
        IF NOT (sar[i].description IN d_bag) THEN
          d_bag := d_bag + sar[i].description;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(d_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar_bag := QUERY ( r <* sar | (r\shape_aspect_relationship.description = d_bag[i]) );
      pd_bag := [];
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect.of_shape.definition)
             THEN
          IF sar_bag[j].related_shape_aspect.of_shape.definition IN pd_bag
               THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            pd_bag := pd_bag + sar_bag[j].related_shape_aspect.of_shape.
                definition;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- reference_functional_unit_assignment_to_part_unique_constraint

  RULE registered_font_constraint FOR (externally_defined_text_font);

  WHERE
    wr1: (SIZEOF(QUERY ( edtf <* externally_defined_text_font | (SIZEOF(
             QUERY ( adr <* USEDIN(edtf,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (adr.assigned_document.
             kind.product_data_type = 'font registration document') )) = 0) )) 
             = 0);

  END_RULE; -- registered_font_constraint

  RULE registered_font_unique_constraint FOR (externally_defined_text_font);

    LOCAL
      ii_bag   : BAG OF STRING := [];
      es_bag   : BAG OF ee_specification;
      edtf_bag : BAG OF externally_defined_text_font;
      adr_bag  : BAG OF applied_document_reference;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(externally_defined_text_font) BY 1;
      IF EXISTS(externally_defined_text_font[i].item_id) THEN
        IF NOT (externally_defined_text_font[i].item_id IN ii_bag) THEN
          ii_bag := ii_bag + externally_defined_text_font[i].item_id;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(ii_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      edtf_bag := QUERY ( edtf <* externally_defined_text_font | (edtf.
          item_id = ii_bag[i]) );
      REPEAT j := 1 TO SIZEOF(edtf_bag) BY 1;
        adr_bag := QUERY ( adr <* USEDIN(edtf_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_DOCUMENT_REFERENCE.ITEMS') | (adr.assigned_document.
            kind.product_data_type = 'font registration document') );
        es_bag := [];
        REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
          IF EXISTS(adr_bag[k].assigned_document) THEN
            IF adr_bag[k].assigned_document IN es_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              es_bag := es_bag + adr_bag[k].assigned_document;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- registered_font_unique_constraint

  RULE registered_style_constraint FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'registered case style') AND (SIZEOF(QUERY ( dri <* rep.items
              | ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(dri)) AND (dri.
             name = 'case style code')) )) = 0)) )) = 0);
    wr2: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'registered case style') AND (SIZEOF(USEDIN(rep,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 0)) )) = 0);

  END_RULE; -- registered_style_constraint

  RULE registered_style_unique_constraint FOR (representation);

    LOCAL
      es_bag  : BAG OF ee_specification;
      rs      : BAG OF representation := QUERY ( r <* representation | (r\representation.
                 name = 'registered case style') );
      adr_bag : BAG OF applied_document_reference;
      dri_bag : BAG OF descriptive_representation_item := [];
      pass    : BOOLEAN := TRUE;
      r_bag   : BAG OF representation;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(rs) BY 1;
      REPEAT j := 1 TO SIZEOF(rs[i].items) BY 1;
        IF (rs[i].items[j]\representation_item.name = 'case style code') AND ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(rs[i].items[j]))
             THEN
          IF EXISTS(rs[i].items[j]) THEN
            IF NOT (rs[i].items[j] IN dri_bag) THEN
              dri_bag := dri_bag + rs[i].items[j];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(dri_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      r_bag := QUERY ( r <* rs | (dri_bag[i] IN r.items) );
      REPEAT j := 1 TO SIZEOF(r_bag) BY 1;
        adr_bag := USEDIN(r_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_DOCUMENT_REFERENCE.ITEMS');
        es_bag := [];
        REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
          IF EXISTS(adr_bag[k].assigned_document) THEN
            IF adr_bag[k].assigned_document IN es_bag THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              es_bag := es_bag + adr_bag[k].assigned_document;
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- registered_style_unique_constraint

  RULE requirement_composition_constraint FOR (
             property_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* property_definition_relationship | ((pdr\property_definition_relationship.
             name = 'requirements property composition') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REQUIREMENTS_PROPERTY') IN TYPEOF(pdr.
             related_property_definition)))) )) = 0);
    wr2: (SIZEOF(QUERY ( pdr <* property_definition_relationship | ((pdr\property_definition_relationship.
             name = 'requirements property composition') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REQUIREMENTS_PROPERTY_GROUP') IN TYPEOF(pdr.
             relating_property_definition)))) )) = 0);

  END_RULE; -- requirement_composition_constraint

  RULE restraint_condition_constraint FOR (property_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* property_definition | (((pd\property_definition.description = 
             'restraint') OR (pd\property_definition.description = 
             'tolerance specific restraint')) AND (SIZEOF(QUERY ( pdr <* 
             USEDIN(pd,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
              | ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'REQUIREMENTS_PROPERTY') IN TYPEOF(pdr.
             related_property_definition)) AND (pdr\property_definition_relationship.name = 
             'restraint description')) )) = 0)) )) = 0);

  END_RULE; -- restraint_condition_constraint

  RULE restrict_action_request_status FOR (action_request_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ars <* action_request_status | (NOT (ars.status 
             IN ['proposed','in work','issued','hold'])) )) = 0);

  END_RULE; -- restrict_action_request_status

  RULE restrict_approval_status FOR (approval_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (ast.name IN [
             'approved','not yet approved','disapproved','withdrawn'])) )) 
             = 0);

  END_RULE; -- restrict_approval_status

  RULE restrict_date_role FOR (date_role);

  WHERE
    wr1: (SIZEOF(QUERY ( dr <* date_role | (NOT (dr.name IN [
             'creation date','request date','release date','start date',
             'contract date','certification date','sign off date',
             'classification date','declassification date'])) )) = 0);

  END_RULE; -- restrict_date_role

  RULE restrict_manifold_surface_shape_representation FOR (
             manifold_surface_shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( mssr <* manifold_surface_shape_representation | (
             (mssr\representation.name IN ['stratum feature non planar 2d shape',
             'open shell based surface',
             'design intent modification non planar 2d shape',
             'part template non planar 2d shape']) AND (NOT (SIZEOF(
             QUERY ( sbsm <* mssr.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHELL_BASED_SURFACE_MODEL') IN TYPEOF(sbsm)) AND (SIZEOF(
             QUERY ( os <* sbsm\shell_based_surface_model.sbsm_boundary | (
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'OPEN_SHELL') IN TYPEOF(os)) )) = 1)) )) = 1))) )) = 0);

  END_RULE; -- restrict_manifold_surface_shape_representation

  RULE rule_action_unique_constraint FOR (rule_action);

    LOCAL
      rd_bag   : BAG OF rule_definition;
      aaa_bag  : BAG OF applied_action_assignment;
      adta     : BAG OF applied_date_and_time_assignment;
      pass     : BOOLEAN := TRUE;
      ra_bag   : BAG OF rule_action;
      adta_bag : BAG OF applied_date_and_time_assignment := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(rule_action) BY 1;
      adta := USEDIN(rule_action[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS');
      REPEAT j := 1 TO SIZEOF(adta) BY 1;
        IF EXISTS(adta[j]) THEN
          IF NOT (adta[j] IN adta_bag) THEN
            adta_bag := adta_bag + adta[j];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(adta_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ra_bag := QUERY ( r <* rule_action | (r IN adta_bag[i].items) );
      rd_bag := [];
      REPEAT j := 1 TO SIZEOF(ra_bag) BY 1;
        IF NOT pass THEN
          ESCAPE;
        END_IF;
        aaa_bag := QUERY ( aa <* USEDIN(ra_bag[j],
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | ((
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
            'APPLIED_ACTION_ASSIGNMENT') IN TYPEOF(aa)) );
        REPEAT k := 1 TO SIZEOF(aaa_bag) BY 1;
          IF NOT pass THEN
            ESCAPE;
          END_IF;
          REPEAT l := 1 TO SIZEOF(aaa_bag[k].items) BY 1;
            IF EXISTS(aaa_bag[k].items[l]) THEN
              IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                  + 'RULE_DEFINITION') IN TYPEOF(aaa_bag[k].items[l]) THEN
                IF aaa_bag[k].items[l] IN rd_bag THEN
                  pass := FALSE;
                  ESCAPE;
                ELSE
                  rd_bag := rd_bag + aaa_bag[k].items[l];
                END_IF;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- rule_action_unique_constraint

  RULE rule_priority_constraint FOR (representation);

    LOCAL
      rpc_group_1 : SET OF representation := QUERY ( rule_group_1 <* 
                     representation | (rule_group_1\representation.name = 'rule property') );
    END_LOCAL;

  WHERE
    wr1: (SIZEOF(QUERY ( x <* rpc_group_1 | (NOT (SIZEOF(QUERY ( y <* x.
             items | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(y)) )) = 1)) )) =
              0);
    wr2: (SIZEOF(QUERY ( x <* rpc_group_1 | (NOT (SIZEOF(QUERY ( y <* 
             USEDIN(x,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')
              | (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'RULE_DEFINITION') IN TYPEOF(y.definition.definition)) )) >=
              1)) )) = 0);

  END_RULE; -- rule_priority_constraint

  RULE security_classification_constraint FOR (security_classification, 
             applied_date_and_time_assignment, applied_date_assignment, 
             applied_person_assignment, applied_approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT ((SIZEOF(
             QUERY ( adata <* applied_date_and_time_assignment | ((sc IN 
             adata.items) AND ('classification date' = adata.role.name)) )) 
             = 1) OR (SIZEOF(QUERY ( ada <* applied_date_assignment | ((sc 
             IN ada.items) AND ('classification date' = ada.role.name)) )) 
             = 1))) )) = 0);
    wr2: (SIZEOF(QUERY ( sc <* security_classification | (SIZEOF(
             QUERY ( apa <* applied_person_assignment | ((sc IN apa.items) 
             AND (apa.role.name = 'classification officer')) )) = 0) )) = 0);
    wr3: (SIZEOF(QUERY ( sc <* security_classification | (SIZEOF(
             QUERY ( aaa <* applied_approval_assignment | (sc IN aaa.items) )) 
             = 0) )) = 0);

  END_RULE; -- security_classification_constraint

  RULE shape_dimension_representation_constraint FOR (
             shape_dimension_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sdr <* shape_dimension_representation | (NOT (
             SIZEOF(QUERY ( i <* sdr.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_WITH_UNIT') IN TYPEOF(i)) AND (SIZEOF(QUERY ( mq <* 
             USEDIN(i,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_QUALIFICATION.QUALIFIED_MEASURE') | (mq.name = 
             'dimension value qualifier') )) <= 1)) )) >= 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( sdr <* shape_dimension_representation | (SIZEOF(
             QUERY ( i <* sdr.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_WITH_UNIT') IN TYPEOF(i)) AND (SIZEOF(QUERY ( mq <* 
             USEDIN(i,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_QUALIFICATION.QUALIFIED_MEASURE') | ((mq.name = 
             'dimension value qualifier') AND (SIZEOF(QUERY ( q <* mq.
             qualifiers | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TYPE_QUALIFIER') IN TYPEOF(q)) )) <> 1)) )) > 0)) )) > 0) )) 
             = 0);
    wr3: (SIZEOF(QUERY ( sdr <* shape_dimension_representation | (SIZEOF(
             QUERY ( i <* sdr.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_WITH_UNIT') IN TYPEOF(i)) AND (SIZEOF(QUERY ( mq <* 
             USEDIN(i,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_QUALIFICATION.QUALIFIED_MEASURE') | ((mq.name = 
             'dimension value qualifier') AND (SIZEOF(QUERY ( q <* mq.
             qualifiers | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TYPE_QUALIFIER') IN TYPEOF(q)) AND (NOT (q.name IN [
             'theoretically exact','maximum dimension','minumum dimersion',
             'lower value','upper value','basic value']))) )) > 0)) )) > 0)) )) 
             > 0) )) = 0);
    wr4: (SIZEOF(QUERY ( sdr <* shape_dimension_representation | (SIZEOF(
             QUERY ( i <* sdr.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_WITH_UNIT') IN TYPEOF(i)) AND (SIZEOF(QUERY ( mq <* 
             USEDIN(i,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MEASURE_QUALIFICATION.QUALIFIED_MEASURE') | (NOT (mq.name IN 
             ['dimension value qualifier','predefined dimension qualifier',
             'user defined dimension qualifier'])) )) > 0)) )) > 0) )) = 0);
    wr5: (SIZEOF(QUERY ( sdr <* shape_dimension_representation | (NOT (
             SIZEOF(USEDIN(sdr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.' + 
             'REPRESENTATION')) >= 1)) )) = 0);

  END_RULE; -- shape_dimension_representation_constraint

  RULE shape_element_composing_relationship_constraint FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | ((sar\shape_aspect_relationship.name = 
             'composing') AND ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPOSITE_SHAPE_ASPECT') IN TYPEOF(sar.relating_shape_aspect))) )) 
             = 0);

  END_RULE; -- shape_element_composing_relationship_constraint

  RULE shape_element_constituent_relationship_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      sar     : BAG OF shape_aspect_relationship := QUERY ( r <* 
                 shape_aspect_relationship | (r\shape_aspect_relationship.name IN ['constituent',
                 'composing']) );
      sar_bag : BAG OF shape_aspect_relationship;
      pass    : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
      sa_bag  : BAG OF shape_aspect := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(sar) BY 1;
      IF EXISTS(sar[i].relating_shape_aspect) THEN
        IF NOT (sar[i].relating_shape_aspect IN sa_bag) THEN
          sa_bag := sa_bag + sar[i].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar_bag := QUERY ( r <* sar | (r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]) );
      rsa_bag := [];
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF sar_bag[j].related_shape_aspect IN rsa_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- shape_element_constituent_relationship_unique_constraint

  RULE shape_element_constraint FOR (shape_aspect);

    LOCAL
      name_bag : BAG OF STRING := [];
--tt redundant to shape_element_unique_constraint rule
 (*
     sab      : BAG OF shape_aspect := QUERY ( sa <* shape_aspect | ((sa\shape_aspect.
--tt eliminate ciewudst
                  name IN ['conductive interconnect element with user defined single transition',
                  'constrained intra layer join','intra stratum join',
                  'inter stratum join','common datum','single datum','']) 
                  OR (SIZEOF(TYPEOF(sa)) >= 1) OR (NOT (((
                  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
-- tt changed to just PRODUCT_DEFINITION from PRODUCT_DEFINITION_SHAPE
                  + 'PRODUCT_DEFINITION') IN TYPEOF(sa.of_shape.
                  definition)) AND (sa.of_shape.definition.
                  frame_of_reference.name = 'physical design usage')))) );
      pass2    : BOOLEAN := TRUE;
*)
      sa       : BAG OF shape_aspect := QUERY ( sa <* shape_aspect | (
                 (NOT (sa\shape_aspect.name IN [
--tt eliminate ciewudst
--                'conductive interconnect element with user defined single transition',
                  'constrained intra layer join','intra stratum join',
                  'inter stratum join','common datum','single datum',''])) 
--tt useless rule subclause                  OR 
--tt useless rule subclause (SIZEOF(TYPEOF(sa)) = 1) 

                  AND (NOT (((
                  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
-- tt changed to PHYSICAL_UNIT from PRODUCT_DEFINITION_SHAPE
                  + 'PHYSICAL_UNIT') IN TYPEOF(sa.of_shape.
                  definition)) AND (sa.of_shape.definition.
                  frame_of_reference.name = 'physical design usage')))

                  ) );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(sa) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      IF sa[i]\shape_aspect.name IN name_bag THEN
        pass := FALSE;
      ELSE
        name_bag := name_bag + sa[i]\shape_aspect.name;
      END_IF;
    END_REPEAT;
--tt redundant to shape_element_unique_constraint rule
(*
    REPEAT i := 1 TO SIZEOF(sab) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      IF NOT pass2 THEN
        ESCAPE;
      END_IF;
      IF sab[i]\shape_aspect.name IN name_bag THEN
        pass2 := FALSE;
      ELSE
        name_bag := name_bag + sab[i]\shape_aspect.name;
      END_IF;
    END_REPEAT;
*)

  WHERE
    wr1: pass;
--tt redundant to shape_element_unique_constraint rule
--    wr2: pass2;

  END_RULE; -- shape_element_constraint

  RULE shape_element_deriving_relationship_unique_constraint FOR (
             shape_aspect_deriving_relationship);

    LOCAL
      sadr_bag : BAG OF shape_aspect_deriving_relationship;
      pass     : BOOLEAN := TRUE;
      rsa_bag  : BAG OF shape_aspect;
      sa_bag   : BAG OF shape_aspect := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(shape_aspect_deriving_relationship) BY 1;
      IF EXISTS(shape_aspect_deriving_relationship[i].
          relating_shape_aspect) THEN
        IF NOT (shape_aspect_deriving_relationship[i].
            relating_shape_aspect IN sa_bag) THEN
          sa_bag := sa_bag + shape_aspect_deriving_relationship[i].
              relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sadr_bag := QUERY ( r <* shape_aspect_deriving_relationship | (r.
          relating_shape_aspect :=: sa_bag[i]) );
      rsa_bag := [];
      REPEAT j := 1 TO SIZEOF(sadr_bag) BY 1;
        IF EXISTS(sadr_bag[j].related_shape_aspect) THEN
          IF sadr_bag[j].related_shape_aspect IN rsa_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            rsa_bag := rsa_bag + sadr_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- shape_element_deriving_relationship_unique_constraint

  RULE shape_element_locating_relationship_unique_constraint FOR (
             dimensional_location);

    LOCAL
      dl_bag  : BAG OF dimensional_location;
      pass    : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
      sa_bag  : BAG OF shape_aspect := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(dimensional_location) BY 1;
      IF EXISTS(dimensional_location[i].relating_shape_aspect) THEN
        IF NOT (dimensional_location[i].relating_shape_aspect IN sa_bag)
             THEN
          sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      dl_bag := QUERY ( r <* dimensional_location | (r.
          relating_shape_aspect :=: sa_bag[i]) );
      rsa_bag := [];
      REPEAT j := 1 TO SIZEOF(dl_bag) BY 1;
        IF EXISTS(dl_bag[j].related_shape_aspect) THEN
          IF dl_bag[j].related_shape_aspect IN rsa_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- shape_element_locating_relationship_unique_constraint

  RULE shape_element_unique_constraint FOR (representation, 
             representation_item, property_definition_representation);

    LOCAL
      r               : BAG OF representation := QUERY ( r <* 
                         representation | (r\representation.name = 
                         'shape element name') );
      description_bag : BAG OF STRING := [];
      ri              : BAG OF representation_item := [];
      pass            : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pass := SIZEOF(QUERY ( pdr <* USEDIN(r[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | (pdr.
          definition.description = 'shape element characterization') )) = 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ri := QUERY ( ri <* representation_item | (ri IN r[i].items) );
      pass := SIZEOF(ri) = 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      IF NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'DESCRIPTIVE_REPRESENTATION_ITEM') IN TYPEOF(ri)) THEN
        pass := FALSE;
        ESCAPE;
      END_IF;
      REPEAT j := 1 TO SIZEOF(ri) BY 1;
        IF EXISTS(ri[j].description) THEN
          IF ri[j]\representation_item.description IN description_bag
               THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            description_bag := description_bag + ri[j].description;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- shape_element_unique_constraint

  RULE shape_representation_requires_origin FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF(
             QUERY ( it <* sr\representation.items | (((it\representation_item.name = 'origin') 
             OR (it\representation_item.name = 'orientation')) AND (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_2D') IN TYPEOF(it)) OR ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_2D') IN TYPEOF(it)))) )) = 1) OR (SIZEOF(
             QUERY ( it <* sr\representation.items | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STYLED_ITEM') IN TYPEOF(it)) )) >= 1) OR (SIZEOF(
             QUERY ( it <* sr\representation.items | (((it\representation_item.name = 'origin') 
             OR (it\representation_item.name = 'orientation')) AND ((sr\representation.name = 'zone shape') OR
              (sr.context_of_items.context_type = 'connection zone colour'))) )) 
             = 0))) )) = 0);

  END_RULE; -- shape_representation_requires_origin

  RULE step_edge_feature_shape_constraint FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'step edge feature shape') AND (NOT (SIZEOF(QUERY ( lmwu <* sr
             .items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'maximum step depth')) )) = 1))) )) = 0);
    wr2: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'step edge feature shape') AND (NOT (SIZEOF(QUERY ( lmwu <* sr
             .items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'maximum step width')) )) = 1))) )) = 0);
    wr3: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'step edge feature shape') AND (NOT (SIZEOF(QUERY ( lmwu <* sr
             .items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'minimum step depth')) )) = 1))) )) = 0);
    wr4: (SIZEOF(QUERY ( sr <* shape_representation | ((sr\representation.name = 
             'step edge feature shape') AND (NOT (SIZEOF(QUERY ( lmwu <* sr
             .items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'minimum step width')) )) = 1))) )) = 0);

  END_RULE; -- step_edge_feature_shape_constraint

  RULE stratum_average_surface_shape_constraint FOR (
             manifold_surface_shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( mssr <* manifold_surface_shape_representation | (
             (mssr\representation.name = 'stratum average surface shape') AND (NOT (
             SIZEOF(QUERY ( pdr <* USEDIN(mssr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_SURFACE') IN TYPEOF(pdr.definition.definition)) AND (
             pdr.definition.definition.description = 'average surface')) )) 
             = 1))) )) = 0);

  END_RULE; -- stratum_average_surface_shape_constraint

  RULE stratum_feature_non_planar_2d_shape_constraint FOR (
             manifold_surface_shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( mssr <* manifold_surface_shape_representation | (
             (mssr\representation.name = 'stratum feature non planar 2d shape') AND (NOT (
             SIZEOF(QUERY ( pdr <* USEDIN(mssr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_FEATURE') IN TYPEOF(pdr.definition.definition)) )) = 
             1))) )) = 0);

  END_RULE; -- stratum_feature_non_planar_2d_shape_constraint

  RULE stratum_feature_shape_stratum_average_surface_shape_relationship_constraint FOR (
             representation_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( rr <* representation_relationship | ((rr\representation_relationship.name = 'stratum feature shape stratum average surface shape relationship') 
             AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MANIFOLD_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(rr.rep_2)) 
             AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( rr <* representation_relationship | ((rr\representation_relationship.name = 'stratum feature shape stratum average surface shape relationship') 
             AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MANIFOLD_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(rr.rep_1)) 
             AND (rr.rep_1\representation.name = 'stratum average surface shape')))) )) = 
             0);

  END_RULE; -- stratum_feature_shape_stratum_average_surface_shape_relationship_constraint

  RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR (
             representation_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( rr <* representation_relationship | ((rr\representation_relationship.name = 
             'stratum feature shape stratum surface shape relationship') 
             AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MANIFOLD_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(rr.rep_2)) 
             AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')))) )) 
             = 0);
    wr2: (SIZEOF(QUERY ( rr <* representation_relationship | ((rr\representation_relationship.name = 
             'stratum feature shape stratum surface shape relationship') 
             AND (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MANIFOLD_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(rr.rep_1)) 
             AND (rr.rep_1\representation.name = 'stratum surface shape')))) )) = 0);

  END_RULE; -- stratum_feature_shape_stratum_surface_shape_relationship_constraint

  RULE stratum_feature_unique_constraint FOR (stratum_feature);

    LOCAL
      name_bag : BAG OF STRING;
      s_bag    : BAG OF stratum := [];
      sf_bag   : BAG OF stratum_feature;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(stratum_feature) BY 1;
      IF EXISTS(stratum_feature[i].of_shape.definition) THEN
        IF NOT (stratum_feature[i].of_shape.definition IN s_bag) THEN
          s_bag := s_bag + stratum_feature[i].of_shape.definition;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sf_bag := QUERY ( r <* stratum_feature | (r.of_shape.definition :=: 
          s_bag[i]) );
      name_bag := [];
      REPEAT j := 1 TO SIZEOF(sf_bag) BY 1;
        IF EXISTS(sf_bag[j]\shape_aspect.name) THEN
          IF sf_bag[j]\shape_aspect.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + sf_bag[j]\shape_aspect.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- stratum_feature_unique_constraint

  RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item);

  WHERE
    wr1: (SIZEOF(QUERY ( mi <* mapped_item | ((mi\representation_item.name = 
             '3d positioned stratum shape in interconnect module') AND (
             NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
             + 'AXIS2_PLACEMENT_3D') IN TYPEOF(mi.mapping_target)))) )) = 0);

  END_RULE; -- stratum_interconnect_module_3d_position_constraint

  RULE stratum_interconnect_module_planar_position_constraint FOR (
             mapped_item);

  WHERE
    wr1: (SIZEOF(QUERY ( mi <* mapped_item | ((mi\representation_item.name = 
             'planar positioned stratum shape in interconnect module') AND 
             (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_2D') IN TYPEOF(mi.mapping_target)))) )) = 0);

  END_RULE; -- stratum_interconnect_module_planar_position_constraint

  RULE stratum_make_from_relationship_constraint FOR (
             make_from_usage_option);

  WHERE
    wr1: (SIZEOF(QUERY ( mfuo <* make_from_usage_option | ((mfuo\product_definition_relationship.name = 
             'stratum make from') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM') IN TYPEOF(mfuo.related_product_definition)))) )) = 
             0);
    wr2: (SIZEOF(QUERY ( mfuo <* make_from_usage_option | ((mfuo\product_definition_relationship.name = 
             'stratum make from') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM') IN TYPEOF(mfuo.relating_product_definition)))) )) =
              0);

  END_RULE; -- stratum_make_from_relationship_constraint

  RULE stratum_planar_shape_constraint FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((NOT ((sr\representation.name 
             = 'planar projected shape') AND (SIZEOF(QUERY ( pdr <* USEDIN(
             sr,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM') IN TYPEOF(pdr.definition.definition)) )) = 1))) OR 
             (SIZEOF(QUERY ( a2p2d <* sr.items | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_2D') IN TYPEOF(a2p2d)) )) >= 0))) )) = 0);

  END_RULE; -- stratum_planar_shape_constraint

  RULE stratum_surface_in_stratum_3d_position_constraint FOR (mapped_item);

  WHERE
    wr1: (SIZEOF(QUERY ( mi <* mapped_item | ((mi\representation_item.name = 
             'stratum surface in stratum 3d position') AND (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_3D') IN TYPEOF(mi.mapping_target)))) )) = 0);

  END_RULE; -- stratum_surface_in_stratum_3d_position_constraint

  RULE stratum_surface_unique_constraint FOR (stratum_surface);

    LOCAL
      desc_bag : BAG OF STRING;
      s_bag    : BAG OF stratum := [];
      pass     : BOOLEAN := TRUE;
      ss_bag   : BAG OF stratum_surface;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(stratum_surface) BY 1;
      IF EXISTS(stratum_surface[i].of_shape.definition) THEN
        IF NOT (stratum_surface[i].of_shape.definition IN s_bag) THEN
          s_bag := s_bag + stratum_surface[i].of_shape.definition;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      ss_bag := QUERY ( r <* stratum_surface | (r.of_shape.definition :=: 
          s_bag[i]) );
      desc_bag := [];
      REPEAT j := 1 TO SIZEOF(ss_bag) BY 1;
        IF EXISTS(ss_bag[j].description) THEN
          IF ss_bag[j].description IN desc_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            desc_bag := desc_bag + ss_bag[j].description;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- stratum_surface_unique_constraint

  RULE stratum_technology_line_width_tolerance_assignment_constraint FOR (
             representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'stratum technology line width tolerance assignment') AND (
             NOT (SIZEOF(QUERY ( lmwu <* rep.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'maximum positive deviation')) )) = 1))) )) = 0);
    wr2: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'stratum technology line width tolerance assignment') AND (
             NOT (SIZEOF(QUERY ( si <* rep.items | ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STYLED_ITEM') IN TYPEOF(si)) )) = 1))) )) = 0);
    wr3: (SIZEOF(QUERY ( rep <* representation | ((rep\representation.name = 
             'stratum technology line width tolerance assignment') AND (
             NOT (SIZEOF(QUERY ( lmwu <* rep.items | (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LENGTH_MEASURE_WITH_UNIT') IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 
             'maximum negative deviation')) )) = 1))) )) = 0);

  END_RULE; -- stratum_technology_line_width_tolerance_assignment_constraint

  RULE substitute_product_constraint FOR (product, 
             assembly_component_usage_substitute);

  WHERE
    wr1: (SIZEOF(QUERY ( acus <* assembly_component_usage_substitute | 
             EXISTS(acus.substitute.reference_designator) )) = 0);

  END_RULE; -- substitute_product_constraint

  RULE subtype_combination_shape_aspect FOR (shape_aspect);

  WHERE
    wr1: (SIZEOF(QUERY ( sa <* shape_aspect | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_BOND_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_MODULE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_FUNCTIONAL_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_INTERFACE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CONNECTIVITY_SUB_STRUCTURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DATUM_REFERENCE_FRAME',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DATUM_SYSTEM',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DERIVED_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DEVICE_TERMINAL_MAP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FABRICATION_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUP_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERCONNECT_MODULE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERFACE_MOUNTED_JOIN',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'JOIN_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAND_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAYER',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAYER_CONNECTION_POINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MOUNTING_RESTRICTION_AREA',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_BODY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGED_PART_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_CONNECTED_TERMINALS_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_TEMPLATE_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PASSAGE_TECHNOLOGY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_ELEMENT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_NETWORK',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY_MEMBER',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_MODIFICATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_CONCEPT_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_FEATURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_SURFACE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_ZONE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_ZONE_BOUNDARY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'VIEWING_PLANE'] * TYPEOF(sa)) <= 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( sa <* shape_aspect | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_BOND_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_MODULE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_FUNCTIONAL_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_INTERFACE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CONNECTIVITY_SUB_STRUCTURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DATUM_REFERENCE_FRAME',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DATUM_SYSTEM',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DEVICE_TERMINAL_MAP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FABRICATION_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUP_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERCONNECT_MODULE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERFACE_MOUNTED_JOIN',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'JOIN_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAND_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAYER',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAYER_CONNECTION_POINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MOUNTING_RESTRICTION_AREA',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_BODY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGED_PART_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_CONNECTED_TERMINALS_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_TEMPLATE_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PASSAGE_TECHNOLOGY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_ELEMENT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_NETWORK',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_DATUM',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY_MEMBER',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_MODIFICATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_CONCEPT_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_FEATURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_SURFACE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_ZONE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_ZONE_BOUNDARY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'VIEWING_PLANE'] * TYPEOF(sa)) <= 1)) )) = 0);
    wr3: (SIZEOF(QUERY ( sa <* shape_aspect | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_BOND_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_FUNCTIONAL_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_INTERFACE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CONNECTIVITY_SUB_STRUCTURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DATUM_REFERENCE_FRAME',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DATUM_SYSTEM',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DERIVED_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DEVICE_TERMINAL_MAP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FABRICATION_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUP_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERFACE_MOUNTED_JOIN',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'JOIN_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAND_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAYER',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LAYER_CONNECTION_POINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MOUNTING_RESTRICTION_AREA',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGE_BODY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_CONNECTED_TERMINALS_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_TEMPLATE_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PASSAGE_TECHNOLOGY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_ELEMENT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_NETWORK',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_DATUM_FEATURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_DATUM_TARGET',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'POSITIONAL_BOUNDARY_MEMBER',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_TERMINAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_MODIFICATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_CONCEPT_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_FEATURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_SURFACE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_ZONE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TOLERANCE_ZONE_BOUNDARY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'VIEWING_PLANE'] * TYPEOF(sa)) <= 1)) )) = 0);
    wr4: (SIZEOF(QUERY ( sa <* shape_aspect | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_DATUM_FEATURE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_DATUM_TARGET',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_DATUM'] * TYPEOF(sa)) <= 1)) )) = 0);

  END_RULE; -- subtype_combination_shape_aspect

  RULE subtype_exclusive_action_request_assignment FOR (
             action_request_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ara <* action_request_assignment | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CHANGE_REQUEST',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'START_REQUEST'] * TYPEOF(ara)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_action_request_assignment

  RULE subtype_exclusive_dimensional_location FOR (dimensional_location);

  WHERE
    wr1: (SIZEOF(QUERY ( dl <* dimensional_location | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ANGULAR_DIMENSION_WITH_ORIENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DIMENSIONAL_LOCATION_WITH_DIRECTION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DIMENSIONAL_LOCATION_WITH_PATH'] * TYPEOF(dl)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_dimensional_location

  RULE subtype_exclusive_dimensional_size FOR (dimensional_size);

  WHERE
    wr1: (SIZEOF(QUERY ( ds <* dimensional_size | ((NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CURVE_DIMENSION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ANGULAR_SIZE'] * TYPEOF(ds)) <= 1)) OR (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CURVE_DIMENSION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE'] * TYPEOF(ds)) <= 1))) )) 
             = 0);

  END_RULE; -- subtype_exclusive_dimensional_size

  RULE subtype_exclusive_mapped_item FOR (mapped_item);

  WHERE
    wr1: (SIZEOF(QUERY ( mi <* mapped_item | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ANNOTATION_TEXT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_MODULE_USAGE_VIEW_CONNECTOR_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ANNOTATION_SYMBOL'] * TYPEOF(mi)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_mapped_item

  RULE subtype_exclusive_product_definition FOR (product_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'BUS_STRUCTURAL_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_FUNCTIONAL_UNIT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_UNIT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'NETWORK_NODE_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM'] * TYPEOF(pd)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_product_definition

  RULE subtype_exclusive_product_definition_relationship FOR (
             product_definition_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* product_definition_relationship | (NOT (
             SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_USAGE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SUPPLIED_PART_RELATIONSHIP'] * TYPEOF(pdr)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_product_definition_relationship

  RULE subtype_exclusive_property_definition FOR (property_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* property_definition | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DIMENSIONAL_SIZE_PROPERTY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GEOMETRIC_TOLERANCE_GROUP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MATERIAL_PROPERTY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRODUCT_DEFINITION_SHAPE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REQUIREMENTS_PROPERTY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SIGNAL'] * TYPEOF(pd)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_property_definition

  RULE subtype_exclusive_property_definition_representation FOR (
             property_definition_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( pdr <* property_definition_representation | (NOT 
             (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_DEFINITION_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MATERIAL_PROPERTY_REPRESENTATION'] * TYPEOF(pdr)) <= 1)) )) =
              0);

  END_RULE; -- subtype_exclusive_property_definition_representation

  RULE subtype_exclusive_representation FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ANALYTICAL_MODEL_PORT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPONENT_LOCATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'RULE_FUNCTION_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRUCTURED_TEXT_REPRESENTATION_ITEM',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TEXT_STRING_REPRESENTATION'] * TYPEOF(rep)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_representation

  RULE subtype_exclusive_representation_context FOR (
             representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( rc <* representation_context | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GEOMETRIC_REPRESENTATION_CONTEXT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PARAMETRIC_REPRESENTATION_CONTEXT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRUCTURED_TEXT_REPRESENTATION_CONTEXT'] * TYPEOF(rc)) <= 1)) )) 
             = 0);

  END_RULE; -- subtype_exclusive_representation_context

  RULE subtype_exclusive_shape_aspect_relationship FOR (
             shape_aspect_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( sar <* shape_aspect_relationship | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_JOINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DEVICE_TERMINAL_MAP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DIMENSIONAL_LOCATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERFACE_MOUNTED_JOIN',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MAKE_FROM_CONNECTIVITY_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MAKE_FROM_FEATURE_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_CONNECTIVITY_ELEMENT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT_DERIVING_RELATIONSHIP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_CONCEPT_RELATIONSHIP'] * TYPEOF(sar)) <= 1)) )) = 0);

  END_RULE; -- subtype_exclusive_shape_aspect_relationship

  RULE subtype_mandatory_action FOR (action);

  WHERE
    wr1: (SIZEOF(QUERY ( act <* action | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DIRECTED_ACTION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXECUTED_ACTION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'RULE_ACTION'] * TYPEOF(act)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_action

  RULE subtype_mandatory_address FOR (address);

  WHERE
    wr1: (SIZEOF(QUERY ( add <* address | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PERSONAL_ADDRESS',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ORGANIZATIONAL_ADDRESS'] * TYPEOF(add)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_address

  RULE subtype_mandatory_characterized_object FOR (characterized_object);

  WHERE
    wr1: (SIZEOF(QUERY ( co <* characterized_object | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CHARACTERIZED_PRODUCT_CATEGORY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'DESIGN_OBJECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNAL_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'RULE_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SIGNAL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STRATUM_TECHNOLOGY'] * TYPEOF(co)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_characterized_object

  RULE subtype_mandatory_colour FOR (colour);

  WHERE
    wr1: (SIZEOF(QUERY ( c <* colour | (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COLOUR_RGB') IN TYPEOF(c))) )) = 0);

  END_RULE; -- subtype_mandatory_colour

  RULE subtype_mandatory_composite_shape_aspect FOR (
             composite_shape_aspect);

  WHERE
    wr1: (SIZEOF(QUERY ( csa <* composite_shape_aspect | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPOSITE_GROUP_SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'COMPOSITE_UNIT_SHAPE_ASPECT'] * TYPEOF(csa)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_composite_shape_aspect

  RULE subtype_mandatory_date FOR (date);

  WHERE
    wr1: (SIZEOF(QUERY ( d <* date | (NOT ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CALENDAR_DATE') IN TYPEOF(d))) )) = 0);

  END_RULE; -- subtype_mandatory_date

  RULE subtype_mandatory_externally_defined_item FOR (
             externally_defined_item);

  WHERE
    wr1: (SIZEOF(QUERY ( edi <* externally_defined_item | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'BOND_CATEGORY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNAL_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_CURVE_FONT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_FUNCTIONAL_UNIT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_HATCH_STYLE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_PHYSICAL_UNIT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_REPRESENTATION_ITEM',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_SYMBOL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_TEXT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_TILE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EXTERNALLY_DEFINED_TILE_STYLE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'LIBRARY_DEFINED_MODEL',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PART_TEMPLATE_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'RULE_DEFINITION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SIGNAL_CATEGORY'] * TYPEOF(edi)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_externally_defined_item

  RULE subtype_mandatory_geometric_tolerance FOR (geometric_tolerance);

  WHERE
    wr1: (SIZEOF(QUERY ( gt <* geometric_tolerance | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE'] * TYPEOF(gt)) = 1)) )) = 
             0);

  END_RULE; -- subtype_mandatory_geometric_tolerance

  RULE subtype_mandatory_group FOR (group);

  WHERE
    wr1: (SIZEOF(QUERY ( grp <* group | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'BOND_CATEGORY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FUNCTIONAL_TERMINAL_GROUP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GROUPED_REQUIREMENTS_PROPERTY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MATERIAL_ELECTRICAL_CONDUCTIVITY_CATEGORY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PARAMETER_TYPE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REQUIREMENT_ALLOCATION_GROUP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'REQUIREMENTS_PROPERTY_GROUP',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'RULE_SET',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SIGNAL_CATEGORY'] * TYPEOF(grp)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_group

  RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item);

  WHERE
    wr1: (SIZEOF(QUERY ( pdi <* pre_defined_item | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRE_DEFINED_TEXT_FONT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PRE_DEFINED_CURVE_FONT'] * TYPEOF(pdi)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_pre_defined_item

  RULE subtype_mandatory_product_definition_usage FOR (
             product_definition_usage);

  WHERE
    wr1: (SIZEOF(QUERY ( pdu <* product_definition_usage | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ASSEMBLY_COMPONENT_USAGE',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MAKE_FROM_USAGE_OPTION'] * TYPEOF(pdu)) = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_product_definition_usage

  RULE subtype_mandatory_runout_zone_orientation FOR (
             runout_zone_orientation);

  WHERE
    wr1: (SIZEOF(QUERY ( rzo <* runout_zone_orientation | (NOT (SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION'] * TYPEOF(rzo)) 
             = 1)) )) = 0);

  END_RULE; -- subtype_mandatory_runout_zone_orientation

  RULE subtype_mandatory_shape_representation FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'ADVANCED_BREP_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CSG_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EDGE_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'FACETED_BREP_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_DIMENSION_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHELL_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION'] * TYPEOF(sr)) = 
             1) OR (SIZEOF(QUERY ( it <* sr\representation.items | (NOT (
             SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_2D',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'AXIS2_PLACEMENT_3D',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'CARTESIAN_POINT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MAPPED_ITEM',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'STYLED_ITEM'] * TYPEOF(it)) = 1)) )) = 0) OR (SIZEOF(
             QUERY ( pdr <* USEDIN(sr,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')
              | (NOT ((SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_DEFINITION_REPRESENTATION'] * TYPEOF(pdr)) >= 1) AND (
             SIZEOF([
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'SHAPE_ASPECT',
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
-- tt pdr.definition.definition
             'SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF(pdr.definition.definition)) >= 1))) )) 
             = 0))) )) = 0);

  END_RULE; -- subtype_mandatory_shape_representation

  RULE subtype_mandatory_text_literal FOR (text_literal);

  WHERE
    wr1: (SIZEOF(QUERY ( tl <* text_literal | (NOT (((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TEXT_LITERAL_WITH_EXTENT') IN TYPEOF(tl)) OR ((
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'TEXT_LITERAL_WITH_ASSOCIATED_CURVES') IN TYPEOF(tl)))) )) = 0);

  END_RULE; -- subtype_mandatory_text_literal

  RULE supplied_product_version_unique_constraint FOR (
             product_definition_formation_with_specified_source);

    LOCAL
      aoa_bag : BAG OF applied_organization_assignment;
      spv     : BAG OF product_definition_formation_with_specified_source
                  := QUERY ( r <* 
                 product_definition_formation_with_specified_source | (
                 SIZEOF(QUERY ( pd <* USEDIN(r,
                 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                  'PRODUCT_DEFINITION.FORMATION') | (SIZEOF(QUERY ( pdr <* 
                 USEDIN(pd,
                 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                  'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                  | ((
                 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                  'SUPPLIED_PART_RELATIONSHIP') IN TYPEOF(pdr)) )) > 0) )) 
                 > 0) );
      spn_bag : BAG OF STRING;
      o_bag   : BAG OF organization := [];
      pass    : BOOLEAN := TRUE;
      pdf_bag : BAG OF product_definition_formation_with_specified_source;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(spv) BY 1;
      aoa_bag := QUERY ( aoa <* USEDIN(spv[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (aoa.role.name = 
          'supplier') );
      REPEAT j := 1 TO SIZEOF(aoa_bag) BY 1;
        IF EXISTS(aoa_bag[j].assigned_organization) THEN
          IF NOT (aoa_bag[j].assigned_organization IN o_bag) THEN
            o_bag := o_bag + aoa_bag[j].assigned_organization;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(o_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      pdf_bag := QUERY ( pdf <* spv | (SIZEOF(QUERY ( aoa <* USEDIN(pdf,
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | ((aoa.role.name = 
          'supplier') AND (aoa.assigned_organization :=: o_bag[i])) )) > 0) );
      spn_bag := [];
      REPEAT j := 1 TO SIZEOF(pdf_bag) BY 1;
        IF EXISTS(pdf_bag[j].of_product.id) THEN
          IF pdf_bag[j].of_product.id IN spn_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            spn_bag := spn_bag + pdf_bag[j].of_product.id;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- supplied_product_version_unique_constraint

  RULE topological_junction_unique_constraint FOR (shape_aspect);

    LOCAL
      name_bag : BAG OF STRING;
      sar_bag  : BAG OF shape_aspect_relationship;
      s_bag    : BAG OF shape_aspect := [];
      tj       : BAG OF shape_aspect := QUERY ( r <* shape_aspect | (r\shape_aspect.
                  description = 'topological junction') );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(tj) BY 1;
      sar_bag := QUERY ( sar <* USEDIN(tj[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name = 
          'topological junction scope') AND ((
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'PHYSICAL_CONNECTIVITY_DEFINITION') IN TYPEOF(sar.
          relating_shape_aspect))) );
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
          IF NOT (sar_bag[j].relating_shape_aspect IN s_bag) THEN
            s_bag := s_bag + sar_bag[j].relating_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar_bag := QUERY ( sar <* USEDIN(s_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | (sar\shape_aspect_relationship.name = 
          'topological junction scope') );
      name_bag := [];
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect\shape_aspect.name) THEN
          IF sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- topological_junction_unique_constraint

  RULE transmission_line_functional_unit_terminal_allocation_unique_constraint FOR (
             shape_aspect_relationship);

    LOCAL
      sar_bag : BAG OF shape_aspect_relationship;
      ut_bag  : BAG OF shape_aspect := [];
      tlfuta  : BAG OF shape_aspect_relationship := QUERY ( r <* 
                 shape_aspect_relationship | (r\shape_aspect_relationship.name = 
                 'transmission line functional terminal allocation') );
      pass    : BOOLEAN := TRUE;
      sa_bag  : BAG OF shape_aspect;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(tlfuta) BY 1;
      IF EXISTS(tlfuta[i].relating_shape_aspect) THEN
        IF tlfuta[i].relating_shape_aspect\shape_aspect.description = 'unit terminal'
             THEN
          IF NOT (tlfuta[i].relating_shape_aspect IN ut_bag) THEN
            ut_bag := ut_bag + tlfuta[i].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(ut_bag) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar_bag := QUERY ( sar <* tlfuta | ((sar.related_shape_aspect\shape_aspect.
          description = 'printed component join terminal') AND (sar.
          relating_shape_aspect :=: ut_bag[i])) );
      sa_bag := [];
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect) THEN
          IF sar_bag[j].related_shape_aspect IN sa_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- transmission_line_functional_unit_terminal_allocation_unique_constraint

  RULE versioned_action_request_requires_approval FOR (
             versioned_action_request, applied_approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( varq <* versioned_action_request | (NOT (SIZEOF(
             QUERY ( aaa <* applied_approval_assignment | (varq IN aaa.
             items) )) = 1)) )) = 0);

  END_RULE; -- versioned_action_request_requires_approval

  RULE versioned_action_request_requires_date_or_date_and_time FOR (
             versioned_action_request, applied_date_and_time_assignment, 
             applied_date_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( varq <* versioned_action_request | (NOT ((SIZEOF(
             QUERY ( adata <* applied_date_and_time_assignment | (varq IN 
             adata.items) )) = 1) OR (SIZEOF(QUERY ( ada <* 
             applied_date_assignment | (varq IN ada.items) )) = 1))) )) = 0);

  END_RULE; -- versioned_action_request_requires_date_or_date_and_time

  RULE versioned_action_request_requires_person_organization FOR (
             versioned_action_request, 
             applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( varq <* versioned_action_request | (NOT ((SIZEOF(
             QUERY ( apaoa <* applied_person_and_organization_assignment | 
             (varq IN apaoa.items) )) >= 1) OR (SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | (varq IN aoa.items) )) >= 1))) )) 
             = 0);

  END_RULE; -- versioned_action_request_requires_person_organization

  RULE versioned_action_request_requires_status FOR (
             versioned_action_request, action_request_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
             QUERY ( ars <* action_request_status | (ar :=: ars.
             assigned_request) )) = 1)) )) = 0);

  END_RULE; -- versioned_action_request_requires_status

  RULE via_template_terminal_unique_constraint FOR (shape_aspect);

    LOCAL
      name_bag : BAG OF STRING;
      vt       : BAG OF shape_aspect := QUERY ( r <* shape_aspect | (r\shape_aspect.
                  description = 'via template') );
      sar_bag  : BAG OF shape_aspect_relationship;
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(vt) BY 1;
      IF NOT pass THEN
        ESCAPE;
      END_IF;
      sar_bag := QUERY ( sar <* USEDIN(vt[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
           'access mechanism') AND (sar.related_shape_aspect\shape_aspect.description = 
          'via template terminal')) );
      name_bag := [];
      REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
        IF EXISTS(sar_bag[j].related_shape_aspect\shape_aspect.name) THEN
          IF sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- via_template_terminal_unique_constraint

  RULE work_order_unique_constraint FOR (directed_action);

    LOCAL
      name_bag : BAG OF STRING := [];
      r        : BAG OF directed_action := QUERY ( r <* directed_action | 
                  (SIZEOF(QUERY ( aa <* USEDIN(r,
                  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                  + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | (((
                  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                  + 'CHANGE') IN TYPEOF(aa)) OR ((
                  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
                  + 'START_WORK') IN TYPEOF(aa))) )) > 0) );
      pass     : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i].directive.name) THEN
        IF r[i].directive.name IN name_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          name_bag := name_bag + r[i].directive.name;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- work_order_unique_constraint

  RULE work_request_unique_constraint FOR (versioned_action_request);

    LOCAL
      r      : BAG OF versioned_action_request := QUERY ( r <* 
                versioned_action_request | (SIZEOF(QUERY ( ara <* USEDIN(r,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST') | (((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'CHANGE_REQUEST') IN TYPEOF(ara)) OR ((
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                'START_REQUEST') IN TYPEOF(ara))) )) > 0) );
      pass   : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(r) BY 1;
      IF EXISTS(r[i].id) THEN
        IF r[i].id IN id_bag THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + r[i].id;
        END_IF;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: pass;

  END_RULE; -- work_request_unique_constraint

  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' 
        IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
        IN TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' 
            IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_point_replica(
               rep: point_replica;
               parent: point
      ): BOOLEAN;
    IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_REPLICA' 
        IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;

  END_FUNCTION; -- acyclic_point_replica

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): LOGICAL;

    LOCAL
      i              : INTEGER;
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_product_definition_relationship(
               relation: product_definition_relationship;
               relatives: SET [1:?] OF product_definition;
               specific_relation: STRING
      ): LOGICAL;

    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;
    IF relation.relating_product_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd <* bag_to_set(USEDIN(relation.
        relating_product_definition,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
        'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_relationship(x[i],relatives + 
          relation.relating_product_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_definition_relationship

  FUNCTION acyclic_solid_replica(
               rep: solid_replica;
               parent: solid_model
      ): BOOLEAN;
    IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA' 
        IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_solid_replica(rep,parent\solid_replica.parent_solid));
    END_IF;

  END_FUNCTION; -- acyclic_solid_replica

  FUNCTION acyclic_surface_replica(
               rep: surface_replica;
               parent: surface
      ): BOOLEAN;
    IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' 
        IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;

  END_FUNCTION; -- acyclic_surface_replica

--tt add document to creation date
  FUNCTION applied_date_correlation(
               e: applied_date_assignment;
               schema_name: STRING
      ): BOOLEAN;

    LOCAL
      d_role : STRING;
    END_LOCAL;
    d_role := e\date_assignment.role.name;
    CASE d_role OF
      'creation date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([schema_name + '.PRODUCT_DEFINITION',
            schema_name + '.DOCUMENT'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'request date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.VERSIONED_ACTION_REQUEST') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'release date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([schema_name + '.CHANGE',
            schema_name + '.START_WORK'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'start date'           :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([schema_name + '.CHANGE',
            schema_name + '.START_WORK'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'sign off date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contract date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + '.CONTRACT') IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'certification date'   :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + '.CERTIFICATION') IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'classification date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'declassification date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE              :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);

  END_FUNCTION; -- applied_date_correlation

--tt add document to creation date
  FUNCTION applied_date_time_correlation(
               e: applied_date_and_time_assignment;
               schema_name: STRING
      ): BOOLEAN;

    LOCAL
      dt_role : STRING;
    END_LOCAL;
    dt_role := e\date_and_time_assignment.role.name;
    CASE dt_role OF
      'creation date'            :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([schema_name + '.PRODUCT_DEFINITION',
            schema_name + '.DOCUMENT'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'request date'             :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.VERSIONED_ACTION_REQUEST') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'release date'             :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([schema_name + '.CHANGE',
            schema_name + '.START_WORK'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'start date'               :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([schema_name + '.CHANGE',
            schema_name + '.START_WORK'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'sign off date'            :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contract date'            :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + '.CONTRACT') IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'certification date'       :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + '.CERTIFICATION') IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'classification date'      :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'declassification date'    :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + 
            '.SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'participant date and time'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ((schema_name + '.RULE_ACTION') IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE                  :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);

  END_FUNCTION; -- applied_date_time_correlation

  FUNCTION assembly_shape_is_defined(
               assy: next_assembly_usage_occurrence;
               schma: STRING
      ): BOOLEAN;

    LOCAL
      srr_set   : SET OF shape_representation_relationship := [];
      i         : INTEGER;
      j         : INTEGER;
      sdr_set   : SET OF shape_definition_representation := [];
      pr1_set   : SET OF property_definition := [];
      pdrel_set : SET OF product_definition_relationship := [];
      pr2_set   : SET OF property_definition := [];
    END_LOCAL;
    pr1_set := bag_to_set(USEDIN(assy.related_product_definition,schma + 
        '.PROPERTY_DEFINITION.DEFINITION'));
    REPEAT i := 1 TO HIINDEX(pr1_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr1_set[i],schma + 
          '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma + 
          '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
    END_REPEAT;
    pdrel_set := bag_to_set(USEDIN(assy.related_product_definition,schma +
         '.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'));
    REPEAT j := 1 TO HIINDEX(pdrel_set) BY 1;
      pr2_set := pr2_set + USEDIN(pdrel_set[j],schma + 
          '.PROPERTY_DEFINITION.DEFINITION');
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(pr2_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr2_set[i],schma + 
          '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma + 
          '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
    END_REPEAT;
    IF SIZEOF(sdr_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
        srr_set := QUERY ( rr <* bag_to_set(USEDIN(sdr_set[i]\
            property_definition_representation.used_representation,schma + 
            '.REPRESENTATION_RELATIONSHIP.REP_2')) | ((schma + 
            '.SHAPE_REPRESENTATION_RELATIONSHIP') IN TYPEOF(rr)) );
        IF SIZEOF(srr_set) > 0 THEN
          REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
            IF SIZEOF(QUERY ( pdr <* bag_to_set(USEDIN(srr_set[j]\
                representation_relationship.rep_1,schma + 
                '.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                 | ((schma + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(
                pdr)) ) * QUERY ( pdr <* bag_to_set(USEDIN(assy.
                relating_product_definition,schma + 
                '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
                schma + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) )) 
                >= 1 THEN
              IF SIZEOF(QUERY ( cdsr <* USEDIN(srr_set[j],schma + 
                  '.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' + 
                  'REPRESENTATION_RELATION') | (NOT (cdsr\
                  context_dependent_shape_representation.
                  represented_product_relation\property_definition.
                  definition :=: assy)) )) > 0 THEN
                RETURN(FALSE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- assembly_shape_is_defined

  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN 
        TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      i       : INTEGER;
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1, choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri || 
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);

  END_FUNCTION; -- build_axes

  FUNCTION closed_shell_reversed(
               a_shell: closed_shell
      ): oriented_closed_shell;

    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' 
        IN TYPEOF(a_shell) THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- closed_shell_reversed

  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

  END_FUNCTION; -- conditional_reverse

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT (
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' 
          IN TYPEOF(c\composite_curve.segments[k].parent_curve))) AND (NOT 
          ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE_ON_SURFACE' 
          IN TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_geometry_shell_based_surface_model(
               m: shell_based_surface_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
      IF (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' 
          IN TYPEOF(m.sbsm_boundary[j]))) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' 
          IN TYPEOF(m.sbsm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_surface_model

  FUNCTION constraints_geometry_shell_based_wireframe_model(
               m: shell_based_wireframe_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
      IF (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' 
          IN TYPEOF(m.sbwm_boundary[j]))) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' 
          IN TYPEOF(m.sbwm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

  FUNCTION constraints_param_b_spline(
               degree, up_knots, up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;

    LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION constraints_rectangular_composite_surface(
               s: rectangular_composite_surface
      ): BOOLEAN;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' 
            IN TYPEOF(s.segments[i][j].parent_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_TRIMMED_SURFACE' 
            IN TYPEOF(s.segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_rectangular_composite_surface

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(
            v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[
            1])]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1,0);
        END_IF;
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- curve_weights_positive

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      i      : INTEGER;
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DERIVED_UNIT' 
        IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x   : SET OF representation;
      y   : representation_context;
      dim : dimension_count;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' 
        IN TYPEOF(item) THEN
      dim := SIZEOF(item\cartesian_point.coordinates);
      RETURN(dim);
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DIRECTION' 
        IN TYPEOF(item) THEN
      dim := SIZEOF(item\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN 
        TYPEOF(item) THEN
      dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    x := using_representations(item);
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION edge_reversed(
               an_edge: edge
      ): oriented_edge;

    LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_EDGE' 
        IN TYPEOF(an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' 
        IN TYPEOF(a_face_bound) THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT 
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(
               a_face: face
      ): oriented_face;

    LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' 
        IN TYPEOF(a_face) THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios <> [1,0,0] THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION gbsf_check_curve(
               cv: curve
      ): BOOLEAN;
    IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE'] * 
        TYPEOF(cv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' 
          IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE)
           THEN
        RETURN(TRUE);
      ELSE
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE' 
            IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE)
             THEN
          RETURN(SIZEOF(QUERY ( seg <* cv\composite_curve.segments | (NOT 
              gbsf_check_curve(seg.parent_curve)) )) = 0);
        ELSE
          IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA'] 
              * TYPEOF(cv)) = 1 THEN
            RETURN(gbsf_check_curve(cv\curve_replica.parent_curve));
          ELSE
            IF (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D'] 
                * TYPEOF(cv)) = 1) AND (cv\offset_curve_3d.self_intersect =
                 FALSE) THEN
              RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve));
            ELSE
              IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE'] 
                  * TYPEOF(cv)) = 1 THEN
                RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve.items
                    [1]) AND gbsf_check_surface(cv\pcurve.basis_surface));
              ELSE
                IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
                    IN TYPEOF(cv) THEN
                  IF (SIZEOF(cv\polyline.points) >= 3) AND (SIZEOF(
                      bag_to_set(USEDIN(cv,'')) - bag_to_set(USEDIN(cv,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE.CURVE_3D'))) 
                      = 0) THEN
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE'] 
                      * TYPEOF(cv)) = 1 THEN
                    IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                      REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                          associated_geometry) BY 1;
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' 
                            IN TYPEOF(cv\surface_curve.associated_geometry[
                            i]) THEN
                          IF NOT gbsf_check_surface(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        ELSE
                          IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
                              IN TYPEOF(cv\surface_curve.
                              associated_geometry[i]) THEN
                            IF NOT gbsf_check_curve(cv\surface_curve.
                                associated_geometry[i]) THEN
                              RETURN(FALSE);
                            END_IF;
                          END_IF;
                        END_IF;
                      END_REPEAT;
                      RETURN(TRUE);
                    END_IF;
                  ELSE
                    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' 
                        IN TYPEOF(cv) THEN
                      IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARABOLA','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.HYPERBOLA'] 
                          * TYPEOF(cv\trimmed_curve.basis_curve)) = 1 THEN
                        RETURN(TRUE);
                      ELSE
                        RETURN(gbsf_check_curve(cv\trimmed_curve.
                            basis_curve));
                      END_IF;
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_curve

  FUNCTION gbsf_check_point(
               pnt: point
      ): BOOLEAN;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' 
        IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE' 
          IN TYPEOF(pnt) THEN
        RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve));
      ELSE
        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' 
            IN TYPEOF(pnt) THEN
          RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface));
        ELSE
          IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE' 
              IN TYPEOF(pnt) THEN
            RETURN(gbsf_check_curve(pnt\degenerate_pcurve.
                reference_to_curve.items[1]) AND gbsf_check_surface(pnt\
                degenerate_pcurve.basis_surface));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_point

  FUNCTION gbsf_check_surface(
               sf: surface
      ): BOOLEAN;
    IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' 
        IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE)
         THEN
      RETURN(TRUE);
    ELSE
      IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPHERICAL_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TOROIDAL_SURFACE'] 
          * TYPEOF(sf)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_BOUNDED_SURFACE' 
            IN TYPEOF(sf) THEN
          IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONICAL_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CYLINDRICAL_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE'] 
              * TYPEOF(sf\curve_bounded_surface.basis_surface)) = 1 THEN
            RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
          ELSE
            IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface)
                 THEN
              RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                  boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
            END_IF;
          END_IF;
        ELSE
          IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE' 
              IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE)
               THEN
            RETURN(gbsf_check_surface(sf\offset_surface.basis_surface));
          ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' 
                IN TYPEOF(sf) THEN
              REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
                  segments) BY 1;
                REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
                    segments[i]) BY 1;
                  IF NOT gbsf_check_surface(sf\
                      rectangular_composite_surface.segments[i][j].
                      parent_surface) THEN
                    RETURN(FALSE);
                  END_IF;
                END_REPEAT;
              END_REPEAT;
              RETURN(TRUE);
            ELSE
              IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_TRIMMED_SURFACE' 
                  IN TYPEOF(sf) THEN
                IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONICAL_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CYLINDRICAL_SURFACE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE'] 
                    * TYPEOF(sf\rectangular_trimmed_surface.basis_surface)) 
                    = 1 THEN
                  RETURN(TRUE);
                ELSE
                  RETURN(gbsf_check_surface(sf\rectangular_trimmed_surface
                      .basis_surface));
                END_IF;
              ELSE
                IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' 
                    IN TYPEOF(sf) THEN
                  RETURN(gbsf_check_surface(sf\surface_replica.
                      parent_surface));
                ELSE
                  IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' 
                      IN TYPEOF(sf) THEN
                    RETURN(gbsf_check_curve(sf\swept_surface.swept_curve));
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_surface

  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN 
        TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' 
          IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE_ON_SURFACE' 
        IN TYPEOF(c) THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

  END_FUNCTION; -- get_basis_surface

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS') 
        * cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' 
          IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(
               f: face
      ): LIST [0:?] OF loop;

    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

  END_FUNCTION; -- list_face_loops

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_to_array(
               lis: LIST [0:?] OF GENERIC:t;
               low, u: INTEGER
      ): ARRAY OF GENERIC:t;

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      res := [lis[1],n];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(
               l: LIST [0:?] OF GENERIC:t
      ): SET OF GENERIC:t;

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

  END_FUNCTION; -- list_to_set

  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1, u1, low2, u2: INTEGER
      ): ARRAY OF ARRAY OF GENERIC:t;

    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN
      RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN
      RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN
        RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);

  END_FUNCTION; -- make_array_of_array

  FUNCTION mixed_loop_type_set(
               l: SET [0:?] OF loop
      ): LOGICAL;

    LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLY_LOOP' 
        IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLY_LOOP' 
          IN TYPEOF(l[i])) <> poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION msb_shells(
               brep: manifold_solid_brep;
               schema_name: STRING
      ): SET [1:?] OF closed_shell;
    IF (schema_name + '.BREP_WITH_VOIDS') IN TYPEOF(brep) THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;

  END_FUNCTION; -- msb_shells

  FUNCTION msf_curve_check(
               cv: curve
      ): BOOLEAN;
    IF SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D'] 
        * TYPEOF(cv)) > 1 THEN
      RETURN(FALSE);
    ELSE
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' 
          IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE)
           THEN
        RETURN(TRUE);
      ELSE
        IF SIZEOF([
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE'] *
             TYPEOF(cv)) = 1 THEN
          RETURN(TRUE);
        ELSE
          IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' 
              IN TYPEOF(cv) THEN
            RETURN(msf_curve_check(cv\curve_replica.parent_curve));
          ELSE
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' 
                IN TYPEOF(cv)) AND (cv\offset_curve_3d.self_intersect = 
                FALSE) THEN
              RETURN(msf_curve_check(cv\offset_curve_3d.basis_curve));
            ELSE
              IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
                  IN TYPEOF(cv) THEN
                RETURN(msf_curve_check(cv\pcurve.reference_to_curve\
                    representation.items[1]) AND msf_surface_check(cv\
                    pcurve.basis_surface));
              ELSE
                IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' 
                    IN TYPEOF(cv) THEN
                  IF msf_curve_check(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                        associated_geometry) BY 1;
                      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' 
                          IN TYPEOF(cv\surface_curve.associated_geometry[i])
                           THEN
                        IF NOT msf_surface_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      ELSE
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' 
                            IN TYPEOF(cv\surface_curve.associated_geometry[
                            i]) THEN
                          IF NOT msf_curve_check(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' 
                      IN TYPEOF(cv) THEN
                    IF SIZEOF(cv\polyline.points) >= 3 THEN
                      RETURN(TRUE);
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- msf_curve_check

  FUNCTION msf_surface_check(
               surf: surface
      ): BOOLEAN;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE' 
        IN TYPEOF(surf) THEN
      RETURN(TRUE);
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' 
          IN TYPEOF(surf) THEN
        RETURN(msf_curve_check(surf\swept_surface.swept_curve));
      ELSE
        IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE' 
            IN TYPEOF(surf)) AND (surf\offset_surface.self_intersect = 
            FALSE) THEN
          RETURN(msf_surface_check(surf\offset_surface.basis_surface));
        ELSE
          IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' 
              IN TYPEOF(surf) THEN
            RETURN(msf_surface_check(surf\surface_replica.parent_surface));
          ELSE
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' 
                IN TYPEOF(surf)) AND (surf\b_spline_surface.self_intersect 
                = FALSE) THEN
              RETURN(TRUE);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- msf_surface_check

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN
           TYPEOF(arg) THEN
        BEGIN
          v := dummy_gri || direction(arg.orientation.direction_ratios);
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec := dummy_gri || vector(v,1);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' 
            IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION open_shell_reversed(
               a_shell: open_shell
      ): oriented_open_shell;

    LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_OPEN_SHELL' 
        IN TYPEOF(a_shell) THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- open_shell_reversed

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(
               a_path: path
      ): LOGICAL;

    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(
               a_path: path
      ): oriented_path;

    LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' 
        IN TYPEOF(a_path) THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- path_reversed

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN
           TYPEOF(vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' 
        IN TYPEOF(a_shell) THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' 
          IN TYPEOF(a_shell) THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;

  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE' IN 
        TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PATH' IN 
        TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_BOUND' 
        IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE' IN 
        TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL' IN 
        TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

  END_FUNCTION; -- topology_reversed

  FUNCTION unique_version_change_order(
               c: action;
               schema_name: STRING
      ): BOOLEAN;

    LOCAL
      ords     : action_directive := c\directed_action.directive;
      assign   : SET OF action_request_assignment := [];
      versions : SET OF product_definition_formation := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ords.requests) BY 1;
      assign := assign + QUERY ( ara <* bag_to_set(USEDIN(ords.requests[i],
          schema_name + '.ACTION_REQUEST_ASSIGNMENT.' + 
          'ASSIGNED_ACTION_REQUEST')) | ((schema_name + '.CHANGE_REQUEST') 
          IN TYPEOF(ara)) );
    END_REPEAT;
    REPEAT k := 1 TO SIZEOF(assign) BY 1;
      versions := versions + assign[k]\change_request.items;
    END_REPEAT;
    RETURN(SIZEOF(QUERY ( vers <* versions | (NOT (SIZEOF(
        QUERY ( other_vers <* (versions - vers) | (vers.of_product :=: 
        other_vers.of_product) )) = 0)) )) = 0);

  END_FUNCTION; -- unique_version_change_order

  FUNCTION using_items(
               item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' 
        IN TYPEOF(z)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FOUNDED_ITEM' 
        IN TYPEOF(z))) );
    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

  END_FUNCTION; -- using_items

  FUNCTION using_representations(
               item: founded_item_select
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_2d_wireframe_edge_curve(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF SIZEOF([schma + '.LINE',schma + '.B_SPLINE_CURVE',schma + '.CIRCLE',
        schma + '.HYPERBOLA',schma + '.ELLIPSE',schma + '.PARABOLA',schma +
         '.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
        RETURN(valid_2d_wireframe_edge_curve(crv\curve_replica.
            parent_curve,schma));
      ELSE
        IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF(crv) THEN
          RETURN(valid_2d_wireframe_edge_curve(crv\offset_curve_2d.
              basis_curve,schma));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_2d_wireframe_edge_curve

  FUNCTION valid_basis_curve_in_2d_wireframe(
               crv: curve
      ): BOOLEAN;
    IF SIZEOF([
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE'] * 
        TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' 
          IN TYPEOF(crv) THEN
        IF SIZEOF([
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARABOLA','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.HYPERBOLA'] 
            * TYPEOF(crv\trimmed_curve.basis_curve)) = 1 THEN
          RETURN(TRUE);
        ELSE
          RETURN(valid_basis_curve_in_2d_wireframe(crv\trimmed_curve.
              basis_curve));
        END_IF;
      ELSE
        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_2D' 
            IN TYPEOF(crv) THEN
          RETURN(valid_basis_curve_in_2d_wireframe(crv\offset_curve_2d.
              basis_curve));
        ELSE
          IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' 
              IN TYPEOF(crv) THEN
            RETURN(valid_basis_curve_in_2d_wireframe(crv\curve_replica.
                parent_curve));
          ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE' 
                IN TYPEOF(crv) THEN
              RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | 
                  (NOT valid_basis_curve_in_2d_wireframe(ccs.parent_curve)) )) 
                  = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_basis_curve_in_2d_wireframe

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    IF NOT ((1 <= date.day_component) AND (date.day_component <= 31))
         THEN
      RETURN(FALSE);
    END_IF;
    CASE date.month_component OF
      4        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      6        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      9        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      11       :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      2        :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      OTHERWISE  :         RETURN(TRUE);
      END_CASE;

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_geometrically_bounded_wf_curve(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF SIZEOF([schma + '.POLYLINE',schma + '.B_SPLINE_CURVE',schma + 
        '.ELLIPSE',schma + '.CIRCLE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.TRIMMED_CURVE') IN TYPEOF(crv) THEN
        IF SIZEOF([schma + '.LINE',schma + '.PARABOLA',schma + 
            '.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1
             THEN
          RETURN(TRUE);
        ELSE
          RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
              basis_curve,schma));
        END_IF;
      ELSE
        IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF(crv) THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
              basis_curve,schma));
        ELSE
          IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
            RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
                parent_curve,schma));
          ELSE
            IF (schma + '.COMPOSITE_CURVE') IN TYPEOF(crv) THEN
              RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | 
                  (NOT valid_geometrically_bounded_wf_curve(ccs.
                  parent_curve,schma)) )) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_curve

  FUNCTION valid_geometrically_bounded_wf_point(
               pnt: point;
               schma: STRING
      ): BOOLEAN;
    IF (schma + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.POINT_ON_CURVE') IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
            basis_curve,schma));
      ELSE
        IF (schma + '.POINT_REPLICA') IN TYPEOF(pnt) THEN
          RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
              parent_pt,schma));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_point

  FUNCTION valid_measure_value(
               m: measure_value
      ): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

  END_FUNCTION; -- valid_measure_value

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MASS_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TIME_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELECTRIC_CURRENT_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LUMINOUS_INTENSITY_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AREA_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VOLUME_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_LENGTH_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION valid_wireframe_edge_curve(
               crv: curve
      ): BOOLEAN;
    IF SIZEOF([
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE'] *
         TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' 
          IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
      ELSE
        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' 
            IN TYPEOF(crv) THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_edge_curve

  FUNCTION valid_wireframe_vertex_point(
               pnt: point
      ): BOOLEAN;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' 
        IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_REPLICA' 
          IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_vertex_point

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' 
            IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' 
            IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(vec1,0);
        END_IF;
      END;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_difference

END_SCHEMA; -- electronic_assembly_interconnect_and_packaging_design
