(*
Created:
Fri Jun 20 11:50:56 EDT 2003

 The object identifier assigned to this schema is:
                { 1 0 10303 210 wd1_35 1 2 }

 Using part 21 of ISO 10303, the file_schema entity will be as follows:

    FILE_SCHEMA (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN { 1 0 10303 210 wd1_35 1 2 }'));

<!DOCTYPE AIM.EXP.SHORT.LISTING.SUBC PUBLIC "-//NIST//DTD Publish - STEP Application Protocols V 2.2//EN">
<AIM.EXP.SHORT.LISTING.SUBC AP.Name="electronic_assembly_interconnect_and_packaging_design">
<AIM.EXP.SHORT.LISTING.INTRO.TEXT>
<EXPRESS.Code>
*)
SCHEMA electronic_assembly_interconnect_and_packaging_design '{ 1 0 10303 210 wd1_35 1 2 }';

REFERENCE FROM support_resource_schema -- ISO 10303-41
 (label);

USE FROM action_schema -- ISO 10303-41
 (action,
  action_directive,
  action_method,
  action_method_relationship,
  action_relationship,
  action_request_solution,
  action_request_status,
  action_status,
  directed_action,
  executed_action,
  versioned_action_request);

USE FROM aic_advanced_brep; -- ISO 10303-514

USE FROM aic_csg; -- ISO 10303-515

USE FROM aic_edge_based_wireframe; -- ISO 10303-501

USE FROM aic_geometrically_bounded_2d_wireframe; -- ISO 10303-503

USE FROM aic_geometrically_bounded_surface; -- ISO 10303-507

USE FROM aic_geometrically_bounded_wireframe; -- ISO 10303-510

USE FROM aic_manifold_surface; -- ISO 10303-509

USE FROM aic_manifold_subsurface; -- ISO 10303-521

USE FROM aic_shell_based_wireframe; -- ISO 10303-502

USE FROM application_context_schema -- ISO 10303-41
 (application_context,
  application_context_element,
  application_protocol_definition,
  product_concept_context,
  product_context,
  product_definition_context);

USE FROM approval_schema -- ISO 10303-41
 (approval,
  approval_date_time,
  approval_person_organization,
  approval_relationship,
  approval_role,
  approval_status);

USE FROM certification_schema  -- ISO 10303-41
 (certification,
  certification_type);
             
USE FROM configuration_management_schema -- ISO 10303-44
 (configuration_design,
  configuration_effectivity,
  configuration_item);

USE FROM contract_schema -- ISO 10303-41
 (contract,
  contract_type);

REFERENCE FROM date_time_schema -- ISO 10303-41
 (leap_year);

USE FROM date_time_schema -- ISO 10303-41
 (calendar_date,
  date_and_time,
  date_time_role,
  date_role,
  date);

USE FROM document_schema -- ISO 10303-41
 (document,
  document_relationship,
  document_type,
  document_usage_constraint,
  document_with_class);

USE FROM effectivity_schema -- ISO 10303-41
 (effectivity,
  dated_effectivity,
  lot_effectivity,
  serial_numbered_effectivity);

USE FROM external_reference_schema -- ISO 10303-41
 (externally_defined_item,
  external_source,
  external_source_relationship,
  pre_defined_item);

USE FROM geometric_model_schema -- ISO 10303-42
 (boolean_operand,
  boolean_operator,
  boolean_result,
  circular_area,
  csg_primitive,
  csg_select,
  elliptic_area,
  extruded_area_solid,
  half_space_2d,
  polygonal_area,
  primitive_2d,
  rectangle_domain,
  rectangled_half_space,
  rectangular_area,
  revolved_area_solid);

REFERENCE FROM geometry_schema -- ISO 10303-42
  (dummy_gri);

USE FROM geometry_schema -- ISO 10303-42
 (axis2_placement_2d,
  axis2_placement_3d,
  bounded_curve,
  b_spline_curve,
  cartesian_point,
  cartesian_transformation_operator,
  cartesian_transformation_operator_2d,
  circle,
  composite_curve,
  composite_curve_segment,
  curve,
  curve_bounded_surface,
  ellipse,
  geometric_representation_context,
  geometric_representation_item,
  hyperbola,
  line,
  outer_boundary_curve,
  parabola,
  placement,
  plane,
  polyline,
  trimmed_curve);

USE FROM group_schema -- ISO 10303-41
 (group,
  group_relationship);

USE FROM management_resources_schema -- ISO 10303-41
 (action_assignment,
  action_request_assignment,
  approval_assignment,
  certification_assignment,
  contract_assignment,
  date_assignment,
  date_and_time_assignment,
  document_reference,
  group_assignment,
  organization_assignment,
  person_assignment,
  person_and_organization_assignment,
  security_classification_assignment);

USE FROM material_property_definition_schema -- ISO 10303-45
 (material_designation,
  material_designation_characterization,
  material_property,
  product_material_composition_relationship,
  property_definition_relationship);

USE FROM material_property_representation_schema -- ISO 10303-45
 (data_environment,
  material_property_representation);

USE FROM measure_schema -- ISO 10303-41
 (amount_of_substance_measure,
  amount_of_substance_measure_with_unit,
  amount_of_substance_unit,
  area_measure,
  area_measure_with_unit,
  area_unit,
  celsius_temperature_measure_with_unit,
  context_dependent_measure,
  context_dependent_unit,
  conversion_based_unit,
  count_measure,
  derived_unit,
  descriptive_measure,
  electric_current_measure,
  electric_current_measure_with_unit,
  electric_current_unit,
  global_unit_assigned_context,
  length_measure_with_unit,
  length_unit,
  luminous_intensity_measure,
  luminous_intensity_measure_with_unit,
  luminous_intensity_unit,
  mass_measure,
  mass_measure_with_unit,
  mass_unit,
  measure_value,
  measure_with_unit,
  named_unit,
  numeric_measure,
  parameter_value,
  plane_angle_measure_with_unit,
  plane_angle_unit,
  positive_plane_angle_measure,
  ratio_measure_with_unit,
  ratio_unit,
  si_unit,
  solid_angle_measure,
  solid_angle_measure_with_unit,
  solid_angle_unit,
  thermodynamic_temperature_measure,
  thermodynamic_temperature_measure_with_unit,
  thermodynamic_temperature_unit,
  time_measure,
  time_measure_with_unit,
  time_unit,
  volume_measure,
  volume_measure_with_unit,
  volume_unit);

USE FROM person_organization_schema -- ISO 10303-41
 (address,
  organization,
  organization_relationship,
  organization_role,
  organizational_address,
  organizational_project,
  person,
  person_and_organization,
  person_and_organization_role,
  person_role,
  personal_address);

USE FROM presentation_appearance_schema -- ISO 10303-46
 (box_height,
  box_rotate_angle,
  box_slant_angle,
  box_width,
  character_glyph_style_outline,
  character_glyph_style_stroke,
  curve_style,
  curve_style_font,
  curve_style_font_and_scaling,
  curve_style_with_ends_and_corners,
  curve_style_with_extension,
  externally_defined_curve_font,
  externally_defined_hatch_style,
  externally_defined_tile,
  externally_defined_tile_style,
  fill_area_style,
  fill_area_style_colour,
  fill_area_style_hatching,
  fill_area_style_tile_coloured_region,
  fill_area_style_tile_curve_with_style,
  fill_area_style_tile_symbol_with_style,
  fill_area_style_tiles,  
  one_direction_repeat_factor,
  pre_defined_curve_font,
  presentation_style_by_context,
  styled_item,
  text_style,
  text_style_for_defined_font,
  two_direction_repeat_factor);

USE FROM presentation_definition_schema -- ISO 10303-46
 (annotation_curve_occurrence,
  annotation_fill_area,
  annotation_fill_area_occurrence,
  annotation_occurrence,
  annotation_symbol,
  annotation_text,
  annotation_text_character,
  annotation_text_occurrence,
  externally_defined_symbol,
  symbol_representation,
  symbol_representation_map,
  symbol_target,
  text_literal,
  text_literal_with_associated_curves,
  text_literal_with_extent,
  text_string_representation);

USE FROM presentation_organization_schema -- ISO 10303-46
 (presentation_representation);

USE FROM presentation_resource_schema -- ISO 10303-46
 (character_glyph_font_usage,
  character_glyph_symbol_outline,
  colour,
  colour_rgb,
  colour_specification,
  externally_defined_text_font,
  text_font_family,
  text_font_in_family);

USE FROM product_concept_schema  -- ISO 10303-44
 (product_concept);
      
USE FROM product_definition_schema -- ISO 10303-41
 (product,
  product_category,
  product_category_relationship,
  product_definition,
  product_definition_formation,
  product_definition_formation_relationship,
  product_definition_formation_with_specified_source,
  product_definition_relationship,
  product_definition_with_associated_documents,
  product_related_product_category);

USE FROM product_property_definition_schema -- ISO 10303-41
 (characterized_object,
  characterized_product_definition,
  product_definition_shape,
  property_definition,
  shape_aspect,
  shape_aspect_relationship);

REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (acyclic_shape_aspect_relationship);

USE FROM product_property_representation_schema -- ISO 10303-41
 (context_dependent_shape_representation,
  property_definition_representation,
  shape_definition_representation,
  shape_representation,
  shape_representation_relationship);

USE FROM product_structure_schema -- ISO 10303-44
 (alternate_product_relationship,
  assembly_component_usage,
  assembly_component_usage_substitute,
  make_from_usage_option,
  next_assembly_usage_occurrence,
  product_definition_usage,
  promissory_usage_occurrence,
  quantified_assembly_component_usage,
  specified_higher_usage_occurrence);

USE FROM qualified_measure_schema -- ISO 10303-45
 (descriptive_representation_item,
  expanded_uncertainty,
  measure_qualification, 
  measure_representation_item,
  precision_qualifier,
  type_qualifier,
  qualitative_uncertainty);

USE FROM representation_schema -- ISO 10303-43
 (compound_item_definition,
  compound_representation_item,
  global_uncertainty_assigned_context,
  item_defined_transformation,
  list_representation_item,
  mapped_item,
  parametric_representation_context,
  representation,
  representation_context,
  representation_item,
  representation_relationship,
  representation_relationship_with_transformation,
  set_representation_item,
  uncertainty_measure_with_unit);

USE FROM security_classification_schema -- ISO 10303-41
 (security_classification,
 security_classification_level);

USE FROM shape_aspect_definition_schema -- ISO 10303-47
      (apex,
       centre_of_symmetry,
       composite_shape_aspect,
       derived_shape_aspect,
       extension,	   
       geometric_alignment,
       geometric_intersection,
       shape_aspect_deriving_relationship,
       symmetric_shape_aspect,
       tangent);

USE FROM shape_dimension_schema -- ISO 10303-47
      (angular_location,
       angular_size,
       dimensional_characteristic_representation,
       dimensional_location,
       dimensional_location_with_path,
       dimensional_size,
       shape_dimension_representation);

USE FROM shape_tolerance_schema -- ISO 10303-47
      (dimension_related_tolerance_zone_element,
       geometric_tolerance,
       geometric_tolerance_relationship,
       modified_geometric_tolerance,
       plus_minus_tolerance,
       projected_zone_definition,
       runout_zone_definition,
       runout_zone_orientation,
       runout_zone_orientation_reference_direction,
       tolerance_value,
       tolerance_zone,
       tolerance_zone_definition,
       tolerance_zone_form);  

REFERENCE FROM topology_schema -- ISO 10303-42
 (dummy_tri);

USE FROM topology_schema -- ISO 10303-42
 (edge_curve,
  edge_loop,
  face,
  face_surface);


(*
</EXPRESS.CODE>

<Schema.Ref.Note>
<Schema.Ref.Note.Intro.Text>
<Schema.External.Reference Schema.Name.Ext.Linkend="action_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="aic_advanced_brep" Step.Part.Number="514">
<Schema.External.Reference Schema.Name.Ext.Linkend="aic_csg" Step.Part.Number="515">
<Schema.External.Reference Schema.Name.Ext.Linkend="aic_edge_based_wireframe" Step.Part.Number="501">
<Schema.External.Reference Schema.Name.Ext.Linkend="aic_geometrically_bounded_2d_wireframe" Step.Part.Number="503">
<Schema.External.Reference Schema.Name.Ext.Linkend="aic_geometrically_bounded_surface" Step.Part.Number="507">
<Schema.External.Reference Schema.Name.Ext.Linkend="aic_shell_based_wireframe" Step.Part.Number="502">
<Schema.External.Reference Schema.Name.Ext.Linkend="application_context_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="approval_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="certification_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="configuration_management_schema" Step.Part.Number="44">
<Schema.External.Reference Schema.Name.Ext.Linkend="contract_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="date_time_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="document_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="effectivity_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="external_reference_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="geometric_model_schema" Step.Part.Number="42">
<Schema.External.Reference Schema.Name.Ext.Linkend="geometry_schema" Step.Part.Number="42">
<Schema.External.Reference Schema.Name.Ext.Linkend="group_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="management_resources_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="material_property_definition_schema" Step.Part.Number="45">
<Schema.External.Reference Schema.Name.Ext.Linkend="material_property_representation_schema" Step.Part.Number="45">
<Schema.External.Reference Schema.Name.Ext.Linkend="measure_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="person_organization_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="presentation_appearance_schema" Step.Part.Number="46">
<Schema.External.Reference Schema.Name.Ext.Linkend="presentation_definition_schema" Step.Part.Number="46">
<Schema.External.Reference Schema.Name.Ext.Linkend="presentation_organization_schema" Step.Part.Number="46">
<Schema.External.Reference Schema.Name.Ext.Linkend="presentation_resource_schema" Step.Part.Number="46">
<Schema.External.Reference Schema.Name.Ext.Linkend="product_concept_schema" Step.Part.Number="44">
<Schema.External.Reference Schema.Name.Ext.Linkend="product_definition_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="product_property_definition_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="product_property_representation_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="product_structure_schema" Step.Part.Number="44">
<Schema.External.Reference Schema.Name.Ext.Linkend="qualified_measure_schema" Step.Part.Number="45">
<Schema.External.Reference Schema.Name.Ext.Linkend="representation_schema" Step.Part.Number="43">
<Schema.External.Reference Schema.Name.Ext.Linkend="security_classification_schema" Step.Part.Number="41">
<Schema.External.Reference Schema.Name.Ext.Linkend="shape_aspect_definition_schema" Step.Part.Number="47">
<Schema.External.Reference Schema.Name.Ext.Linkend="shape_dimension_schema" Step.Part.Number="47">
<Schema.External.Reference Schema.Name.Ext.Linkend="shape_tolerance_schema" Step.Part.Number="47">
<Schema.External.Reference Schema.Name.Ext.Linkend="topology_schema" Step.Part.Number="42">
</Schema.Ref.Note>
<FcandA.CL3>

<FcandA.with.CL4.Clauses>

<intro.text>This part of ISO 10303 is designed to be used in the concurrent engineering of modular electronic 
products.  A fundamental concept of this schema is that the organization controls the configuration 
of product models for these types of product designs.  This schema is not designed to 
control product designs through drawing control.  It is designed to provide a vehicle to control 
the configuration of the design and associated data.  The design in this context includes the 
requirements and constraints exchanged between the design organization, data suppliers (e.g., 
component suppliers, value added suppliers), product suppliers (e.g., piece part vendors, substrate
 vendors), and the customers or marketing representatives for those customers. Several 
engineering disciplines may share data using this schema (e.g., system, mechanical, electrical, 
manufacturing, inspection, logistics) for product definition and product analysis purposes.  This 
schema provides requirements definition using requirements property definition, decomposition 
and operations on property definition.  This schema provides a functional definition using externally 
defined models or the functional decomposition model defined in this schema.  This 
schema provides a physical definition for packages, piece parts, interconnect substrate, bare die, 
mechanical parts, and assemblies.  The physical definition includes a geometric dimensioning and 
tolerancing model that may be applied to any physical model.  This schema provides design and 
usage views for functional and physical models to support design abstraction and intellectual 
property aspects.  This schema provides data suppliers a standard infrastructure with which to 
build explicit product data models for modular electronic products that may be incorporated 
into a piece part or technology library.  The explicit product data models may be standardized 
as instances of this schema.  This schema provides support for a design organization to archive 
data using this schema as a design view in one product category and the marketing organization 
to specify the usage view in a more generic category.  The functional usage view in this schema 
includes an explicit interface definition to allow integration with external simulation environments.  

The support for this includes the capability to define product terminals only in a usage view. 
 The product models in this schema include both abstract functional product model and 
physical product models.  Inclusion of the functional model provides the ability to categorize 
functional models using the product_category entity.  This schema provides support for multiple 
functional definitions to exist in a repository for a particular usage view, but the specific 
definition desired is included in the functional model exchanged.  Parameters  (e.g., resistance) 
whose values are fundamental properties of the materials and their composition and therefore 
independent of the product version may be exchanged using the subtypes of product_category in 
this schema.  Parameters (e.g., timing related) that are dependent on the version of the product 
may be exchanged using characteristics associated with a particular product_definition entity.  
Signal properties and composition may be exchanged using external_definition for the interface to 
industry domain specific name definitions.</intro.text>

<Clause.CL4 NAME="Relating the shape of a product to its configuration data"><Clause.CL4.Bdy>The shape of products in this part of ISO 10303 is represented by the  shape_representation 
entity. This entity and its subtypes define the  geometric or topological entities which make 
up a particular  representation type. Each product or assembly that is of interest  will be given 
by an instance of the product entity. Each product will in  turn have at least one version 
given by an instance of the product_definition_formation entity. Each version may have one 
or more definitions  given by the product_definition entity. Each definition may have its shape 
represented. This is done using the AIM entities by relating the  product_definition instance to 
the appropriate shape_representation instance.  The concept of  the shape of a product_definition 
is given by an instance of  the entity product_definition_shape. That shape of the product is  then 
connected to the shape_representation entity by an instance of shape_definition_representation. 

A shape_definition_representation inherits  attributes from its supertype property_definition_representation 
that reference the shape_representation entity that contains the geometry  or 
topology for the shape of the product and a select type called  characterized_definition. This 
type allows for the representation of a  shape_aspect, shape_aspect_relationship, characterized_object, 
or a characterized_product_definition which is also a select type. To specify that the 
property of  interest is the  shape of the product_definition the product_definition_shape subtype of 
property_definition shall be used. The product_definition_shape entity is constrained to use the 
characterized_product_definition select type. The characterized_product_definition select type 
allows for  the representation of a product_definition or a product_definition_relationship via a 
reference through its select list. This reference  ensures that the product_definition_shape entity 
will be used to define the shape of a product_definition. If the property of interest is an aspect 
of the shape of the product_definition or the relationship between two aspects of the shape of the 
product_definition the property_definition shall be used  and its definition attribute shall 
reference an instance of shape_aspect  or shape_aspect_relationship. In order to specify the shape 
of a product the product_definition entity will be referenced here.</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Relating the shape of a component to the shape of its assembly"><Clause.CL4.Bdy>There are two methods that may be used to relate the shape of a component to the shape of 
the assembly in which it is assembled.  The first method consists of defining the shape for each 
component and assembly, and then relating the two shapes and providing the information that 
defines the orientation of the component with respect to the assembly through a transformation. 
 The second method consists of defining the shape for each component and assembly, and 
then incorporating the shape of the component directly in the shape of the assembly.  The first 
method shall be used to relate the shapes that are represented by different representation types.  

The second method may be used for the incorporation of the representation of a component 
into the representation of an assembly if the two types are the same.  Both methods employ 
the shape_representation and product_definition entities.  The first method also employs the 
product_definition_relationship, shape_representation_relationship AND representation_relationship_with_transformation 
(i.e., an instance of each entity forming a complex entity instance of the 
two entities with an AND relationship) and context_dependent_shape_representation entities.  

The second method employs the mapped_item and representation_map entities. When 
using the first method to relate the shape of the component to the shape of the assembly, 
each of the shape_representation entities that define the shapes of the component and assembly 
product_definitions is related through references in the shape_representation_relationship entity.  
Orientation information, in this case, will be provided by the formation of a complex instance 
of the shape_representation_relationship AND representation_relationship_with_transformation 
entities.  The representation_relationship_with_transformation entity references a transformation 
which is a select type allowing the orientation to be defined using an axis2_placement_3d entity in 
each representation for an item_defined_transformation or a cartesian_transformation_operator 
entity for a functionally_defined_transformation. In addition, an instance of 
the context_dependent_shape_representation must be given to explicitly relate the shape_representation_relationship 
that defines the relationship of the two shapes to the product_definition_relationship that 
defines the assembly-component relationship between the two product_definitions. 

When using the second method to relate the shape of the component to the shape of the assembly, the 
shape_representation entity that defines the geometry or topology for the shape of the component 
product is referenced by an instance of a representation_map entity that is referenced by 
the mapping_source attribute of an instance of the mapped_item entity.  The attribute mapped_representation 
of the representation_map will reference the shape_representation subtype that 
defines the representation of the shape.  The instance of the mapped_item entity is then added 
to the set of items in the shape_representation entity that defines the geometry or topology for 
the assembly product.</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Types of shape representation"><Clause.CL4.Bdy>This part of ISO 10303 defines several types of representation for shapes of items - both 2d and 
3d wireframe representations using edge based and shell based models, 2d wireframe 
representations that are geometrically bounded, surface models that are geometrically bounded, CSG solid 
models, advanced boundary representation solid models, extruded solid models, 2d Curves and 
basic 2d Curves.  Each of the 3d types of representation is self contained meaning that one type 
may not contain another type.  Each of the types is given by a subtype of the shape_representation 
entity.  Each subtypecontains local rules that govern the types of geometric or topological 
entities that can be used in it.  Every shape_representation must be one of the subtypes unless 
it is used as the representation of the shape of an assembly used in method one above. 

In that case, the shape_representation instance will contain only axis2_placement_3d entities in its 
set of items in order to define the orientation of the components' representations in it.  Since the 
rules in each of the subtypes will conflict with each other, any shape_representation that is 
referenced by a representation_map to implement method two above must be of the same type 
as the shape_representation that has the mapped_item that references that representation_map in its set of items.</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Use of global rules"><Clause.CL4.Bdy>Many of the relationships among different entities in the integrated resource parts of ISO 10303 
are specified using the most generic cardinality of zero or more between two related entities.  This 
cardinality means that the relationship is optional or there may be one or more instances of a related 
entity that is related to a single instance of the relating entity.  This part of ISO 10303 uses 
global rules to constrain that cardinality.  In some cases the constraint is made to be one to one, \and in some instances at least one.  
<example>Examples of these rules include contract_requires_person_organization,
approval_requires_approval_date_time, and certification_requires_approval 
for exactly one, and change_request_requires_person_organization and
 product_requires_product_version for one or more.</example> 

 Global rules are also used to restrict the values of STRING type attributes to be 
only those that are applicable within the context of electronic assembly, interconnect and 
packaging design. 

<example> Examples of these rules are restrict_approval_status and 
restrict_person_organization_role.</example>  

Global rules are also used to collect in one location all the constraints required to implement a given ARM concept. 

<example>Examples of these rules include operational_requirement_occurrence_relationship_constraint,
geometric_tolerance_qualifier_constraint, and feature_group_relationship_constraint.</example>
</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Assignment of units"><Clause.CL4.Bdy>Units are assigned to the representation of shape on a global basis.  This is done by the creation 
of an instance of the global_unit_assigned_context.  This entity contains an attribute that allows 
for a set of units to be assigned to a representation_context.  Each of the shape_representation 
entities has a context for its representation.  If units of measure are desired for a particular 
instance of shape_representation then that instance shall have a global_unit_assigned_context in 
its context_of_items attribute. </Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Terminal definition"><Clause.CL4.Bdy>Terminals are defined as aspects of the shape of a product in this schema.  This is true for 
both terminals of functional products and terminals of physical products.  The properties of 
the terminals interconnected in a network defined by the functional_network_definition may 
be evaluated by experimental means to determine suitability of the product_definition. The 
geometric representation of the functional product terminal is the schematic symbol for the 
terminal.  The geometric representation of the functional product shape is the schematic symbol for the functional product.
<note>This edition of this part of ISO 10303 does not standardize the exchange of presentation of 
geometric representations of terminals of functional products or shapes of functional products. In 
this edition of the standard, there is no standardized way to specify the position of the schematic 
terminal symbol in the schematic symbol for the functional product.  This structure is included to 
assure interoperability with other 
parts of ISO 10303. <!-- for future editions of this part --></note>
</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Product instances"><Clause.CL4.Bdy>This schema separates the "part" in the "part-assembly" relationship into two or three entities: one or two instances of product_definition 
and a corresponding component_definition.  If there is only one instance of product_definition, then there is no separate 'design' for the part.  If there are two instances of product definition then one of them is the design and the other is the 'design usage'.  This separation is controlled by a rule 
in component_definition that the product_definition_formation for component_definition and the 
product_definition that corresponds to the "part" concept is the same product_definition_formation.  
The correspondence is established by an instance of product_definition_relationship with a 
name of "instantiated part".  The correspondence between the design and the design usage is established by an instace of product_definition_relationship with a name of 'design usage'.
</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Change management"><Clause.CL4.Bdy>This schema provides action, action_directive, add_design_object_assignment, change, change_request,
 change_from_design_object_assignment, change_to_design_object_assignment, delete_object_assignment,
 and product_definition_relationship entities to support design management processes.  
A data set that incorporates add, change, or delete shall include any required action_assignment 
subtype and the product_definition_relationship that identifies the previous product_definition 
and the current product_definition.  Requests for change and specific change directions are provided.</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Functional network definition"><Clause.CL4.Bdy>This schema 
provides functional_unit, functional_unit_terminal_definition, component_functional_unit, 
component_functional_terminal, and network_node_definition to exchange network 
listings (using a nodal formulation) of functional objects.</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Geometric dimensioning and tolerancing"><Clause.CL4.Bdy>Each instance of physical_unit_geometric_tolerance along with supporting entity instances (e.g., 
property_definition with a description of "datum system property with material conditions") is 
intended to convey the data associated with a geometric tolerance requirement that is included 
in a single segment of a feature control frame of a technical drawing.  Typically, feature control 
frames only have one segment. However, with composite geometric tolerances (i.e., composite 
position tolerance, composite linear profile tolerance, and composite surface profile tolerance) 
the feature control frame consists of an ordered set of segments. Associated with this set 
are certain order-dependent requirements as to the values that may be placed in the various 
compartments of the segments of these composite feature control frames.  
<example>If one or more data are specifiedin a lower segment of a 
composite feature control frame they must also be specified in segments 
that are listed above it.
</example>

To convey the data associated with a composite feature control frame, instances of geometric_tolerance_relationship
 are used to create an ordered set of physical_unit_geometric_tolerance.  Additionally, constraints defined 
within the relevant physical_unit_geometric_tolerance (i.e., position_tolerance, linear_profile_tolerance, 
and surface_profile_tolerance) are used to specify the order-dependent requirements and to 
insure a valid data structure.
</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Physical network definition"><Clause.CL4.Bdy>This schema provides physical_unit_network_definition, physical_connectivity_definition, and component_terminal to exchange network listings (using a nodal formulation) of physical objects.</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Product classification"><Clause.CL4.Bdy>This schema provides predefined product classifications of assembly, bare die, functionality, interconnect, material, package, physical network design, piece part, printed part, requirements model, simulation model, standard part, technology specific model, and template model.  These predefined product classifications may require specific types of product_definition to support them or specific context values.
<example>
It is valid to have a package classification and to have an instance of interconnect_definition associated with it, but
an instance of package will also exist that references that product instance.
</example>
</Clause.CL4.Bdy></Clause.CL4>

<Clause.CL4 NAME="Requirements definition"><Clause.CL4.Bdy>This schema provides group_product_definition, group_shape_aspect, grouped_requirements_property,
 mounting_restriction_area,requirement_allocation_group, requirements_property, and 
requirements_property_group to convey the data associated with technical requirements and the 
allocation of those requirementsto product data.</Clause.CL4.Bdy></Clause.CL4>

</FcandA.with.CL4.Clauses>

</FcandA.CL3>

<TYPE.DEFS.SECTION> 
<MULTI.TYPE.DEFS.CL3>
<TYPE.DEF.CL4> 
<TYPE.DEF NAME="action_assigned_item">
<TYPE.DESCRIPTION> 
An action_assigned_item type specifies those items to
which an action may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE action_assigned_item = SELECT 
     (product_definition_formation);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="approval_assigned_item">
<TYPE.DESCRIPTION>
An approval_assigned_item type specifies those items
to which an approval may be assigned which has more values than approved, unapproved.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE approval_assigned_item = SELECT
     (action,
      action_directive,
      certification,
      change,
      change_request,
      configuration_effectivity,
      configuration_item,
      contract,
      date,
      directed_action,
      document,
      product,
      product_definition,
      product_definition_formation,
      product_definition_formation_with_specified_source,
      representation,
      security_classification,
      start_request,
      start_work,
      versioned_action_request);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="certification_assigned_item">
<TYPE.DESCRIPTION>
A certification_assigned_item type specifies those items
to which a certification may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE certification_assigned_item = SELECT 
     (supplied_part_relationship,
      make_from_usage_option,
      product_definition_formation_with_specified_source);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<!--
type added 4/1/97

-->
<TYPE.DEF.CL4>
<TYPE.DEF NAME="change_request_item">
<TYPE.DESCRIPTION>
A change_request_item type specifies those items
to which a request for change may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE change_request_item = SELECT
     (product_definition_formation,
      representation_relationship);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="classification_assigned_item">
<TYPE.DESCRIPTION>
A classification_assigned_item type specifies those items
to which a classification may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE classification_assigned_item = SELECT
     (material_designation,
      requirements_property,
      signal,
      stratum);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="contract_assigned_item">
<TYPE.DESCRIPTION>
A contract_assigned_item type specifies those objects to which a
contract may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE contract_assigned_item = SELECT
     (alternate_product_relationship,
      directed_action,
      product,
      product_definition_formation);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="date_and_time_assigned_item">
<TYPE.DESCRIPTION>
A date_and_time_assigned_item type specifies those items
to which a date and a time may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE date_and_time_assigned_item = SELECT
     (approval_person_organization,
      certification,
      change,
      contract,
      directed_action,
      document,
      product_definition,
      rule_action,
      security_classification,
      versioned_action_request);
END_TYPE; -- date_and_time_assigned_item
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="date_assigned_item">
<TYPE.DESCRIPTION>
A date_assigned_item type specifies those items to which a date may
be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE date_assigned_item = SELECT
     (product_definition,
      versioned_action_request,
      directed_action,
      approval_person_organization,
      contract,
      security_classification,
      certification);
END_TYPE; -- date_assigned_item
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="document_assigned_item">
<TYPE.DESCRIPTION>
A document_assigned_item type specifies those items
to which a document may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE document_assigned_item = SELECT
     (action_method,
      assembly_component_usage,
      bond_category,
      characterized_object,
      component_definition,
      component_feature,
      component_interface_terminal,
      component_shape_aspect,
      component_terminal,
      coordinated_representation_item,
      configuration_item,
      descriptive_representation_item,
      externally_defined_item,
      functional_unit_terminal_definition,
      inter_stratum_feature,
      interconnect_module_component_surface_feature,
      layer,
      laminate_component_interface_terminal,
      material_designation,
      measure_representation_item,
      package_terminal,
      part_template_definition,
      physical_connectivity_definition,
      physical_connectivity_element,
      product,
      product_definition,
      product_definition_formation,
      product_definition_formation_relationship,
      property_definition,
      representation,
      representation_item,
      requirements_property,
      rule_definition,
      shape_aspect,
      signal,
      stratum,
      stratum_feature);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="document_identifier_assigned_item">
<TYPE.DESCRIPTION>
A document_identifier_assigned_item type specifies those items
to which a document_identifier may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE document_identifier_assigned_item = SELECT
     (document);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<!--
 tt 4/1/97
 TYPE document_reference_assigned_item = SELECT

-->
<TYPE.DEF.CL4>
<TYPE.DEF NAME="frozen_assigned_item">
<TYPE.DESCRIPTION>
An frozen_assigned_item type specifies those items
to which an approval with value of (approved, unapproved) may be assigned to indicate acceptance of a design element.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE frozen_assigned_item = SELECT
     (alternate_product_relationship,
      applied_date_and_time_assignment,
      applied_document_reference,
      applied_group_assignment,
      characterized_object,
      colour,
      component_definition,
      component_shape_aspect,
      composite_curve_segment,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style,
      fill_area_style_colour,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      inter_stratum_feature,
      material_designation,
      measure_with_unit,
      plus_minus_tolerance,
      pre_defined_item,
      product_concept,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
      runout_zone_orientation,
      shape_aspect,
      shape_aspect_relationship,
      stratum_feature,
      tolerance_value,
      tolerance_zone_form);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="group_assigned_item">
<TYPE.DESCRIPTION>
A group_assigned_item type specifies those items to which a group may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE group_assigned_item = SELECT
     (assembly_bond_definition,
      design_object,
      component_definition,
      component_feature,
      component_interface_terminal,
      component_shape_aspect,
      component_terminal,
      compound_representation_item,
      configuration_item,
      inter_stratum_feature,
      laminate_component_interface_terminal,
      printed_part_template_terminal,
      product,
      product_definition_formation,
      property_definition_representation,
      representation,
      representation_item,
      requirements_property,
      rule_definition,
      shape_aspect,
      shape_aspect_relationship,
      stratum,
      stratum_feature,
      stratum_surface);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>
<!--
tt 4/1/97
 TYPE grouped_item = SELECT

-->
<!--
added following type tt 4/2/97

-->
<TYPE.DEF.CL4>
<TYPE.DEF NAME="managed_design_object">
<TYPE.DESCRIPTION>
A managed_design_object type specifies those items
to which design management information may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE managed_design_object = SELECT
     (action,
      alternate_product_relationship,
      applied_approval_assignment,
      applied_date_and_time_assignment,
      applied_document_reference,
      applied_group_assignment,
      approval,
      approval_status,
      certification,
      characterized_object,
      colour,
      composite_curve_segment,
      configuration_effectivity,
      configuration_item,
      contract,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      date,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style,
      fill_area_style_colour,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      layer_connection_point,
      layer_connection_point_link,
      material_designation,
      measure_with_unit,
      organization,
      person,
      person_and_organization,
      plus_minus_tolerance,
      pre_defined_item,
      product,
      product_concept,
      product_definition,
      product_definition_formation,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
      runout_zone_orientation,
      security_classification,
      shape_aspect,
      shape_aspect_relationship,
      tolerance_value,
      tolerance_zone_form,
      versioned_action_request);
END_TYPE; -- managed_design_object
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="organization_assigned_item">
<TYPE.DESCRIPTION>
An organization_assigned_item type specifies those items
to which an organization may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE organization_assigned_item = SELECT
     (configuration_item,
      contract,
      directed_action,
      document,
      versioned_action_request,
      product,
      product_definition,
      product_definition_formation,
      product_definition_formation_with_specified_source,
      rule_definition,
      representation,
      security_classification);
END_TYPE; -- organization_assigned_item
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="owner_assigned_item">
<TYPE.DESCRIPTION>
An owner_assigned_item type specifies those items to which a person_organization may be assigned to indicate direct control of a design element.
<note>
Owner in this usage indicates a single point of design control.
</note>
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE owner_assigned_item = SELECT
     (alternate_product_relationship,
      characterized_object,
      colour,
      component_definition,
      component_shape_aspect,
      composite_curve_segment,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style,
      fill_area_style_colour,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      inter_stratum_feature,
      material_designation,
      measure_with_unit,
      plus_minus_tolerance,
      pre_defined_item,
      product_concept,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
      runout_zone_orientation,
      shape_aspect,
      shape_aspect_relationship,
      stratum_feature,
      tolerance_value,
      tolerance_zone_form);
END_TYPE; -- owner_assigned_item
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="person_and_organization_assigned_item">
<TYPE.DESCRIPTION>
A person_and_organization_assigned_item type specifies those items
to which a person associated with an organization may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE person_and_organization_assigned_item = SELECT
     (change,
      configuration_item,
      contract,
      document,
      product,
      product_definition_formation,
      product_definition,
      directed_action,
      rule_action,
      security_classification,
      versioned_action_request);
END_TYPE; -- person_and_organization_assigned_item
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="person_assigned_item">
<TYPE.DESCRIPTION>
A person_assigned_item type specifies those items
to which a person may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE person_assigned_item = SELECT
     (document);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="promissory_usage_in_product_model_assigned_item">
<TYPE.DESCRIPTION>
A promissory_usage_in_product_model_assigned_item type specifies those items to which a promissory_usage_in_product_model_assignment may be made.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE promissory_usage_in_product_model_assigned_item = SELECT
     (product_concept,
      product_definition);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="replacement_from_item">
<TYPE.DESCRIPTION>
A replacement_from_item type specifies those items for which
a replacement may be specified.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE replacement_from_item = SELECT
     (product_definition_formation);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="replacement_to_item">
<TYPE.DESCRIPTION>
A replacement_to_item type specifies those items which
may be used as a replacement for another item.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE replacement_to_item = SELECT
     (product_definition_formation);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="security_classification_assigned_item">
<TYPE.DESCRIPTION>
A security_classification_assigned_item type specifies those items to which a security classification may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE security_classification_assigned_item = SELECT
     (applied_promissory_usage_in_product_model_assignment,
      assembly_component_usage,
      document,
      make_from_usage_option,
      product_definition_formation,
      product_definition);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="start_request_item">
<TYPE.DESCRIPTION>
A start_request_item type specifies those items
to which a request to start may be assigned.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE start_request_item = SELECT
     (product_definition_formation,
      representation_relationship);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<TYPE.DEF.CL4>
<TYPE.DEF NAME="work_item">
<TYPE.DESCRIPTION>
A work_item type specifies those items
to which work may be performed.
</TYPE.DESCRIPTION>
<EXPRESS.CODE>
*)
TYPE work_item = SELECT
     (product_definition_formation);
END_TYPE;
(*
</EXPRESS.CODE>
</TYPE.DEF>
</TYPE.DEF.CL4>

<!--
following four entities added tt 4/2/97

-->
</MULTI.TYPE.DEFS.CL3>
</TYPE.DEFS.SECTION>
<ENTITY.DEFS.SECTION>
<MULTI.ENT.DEFS.and.Imports.CL3>
<ENTITY.DEFS.CL4>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="absorbed_dose_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An absorbed_dose_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Absorbed_dose_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY absorbed_dose_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\absorbed_dose_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = gray;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- absorbed_dose_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The absorbed_dose_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The absorbed_dose_measure_with_unit shall reference an si_unit with the name of gray.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="activity_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An activity_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Activity_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY activity_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\activity_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = becquerel;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- activity_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The activity_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The activity_measure_with_unit shall reference a becquerel si_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="add_design_object_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An add_design_object_assignment is an action_assignment that implements
the ARM concept of <internal.ref Linkend="Add_design_object_management_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY add_design_object_assignment
   SUBTYPE OF (action_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(it <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))
        AND (it\product_definition_relationship.name = 
                       'design object addition'))) = 1;
END_ENTITY; -- add_design_object_assignment
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The add_design_object_assignment shall have exactly one item
that is a product_definition_relationship with a name of 'design object addition'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
The add_design_object_assignment shall have exactly one item that is a
managed_design_object that is not a product_definition_relationship 
with a name of 'design object addition' and is not referenced by 
another product_definition_relationship with a name of 
'design object addition', 'design object change', or 'design object deletion'
in the same design.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>


</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="add_design_object_request_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An add_design_object_request_assignment is an action_request_assignment that implements
the ARM concepts of <internal.ref Linkend="Add_design_object_management_relationship"> and <internal.ref Linkend="Change_request">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY add_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(it <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))
        AND (it\product_definition_relationship.name = 
                         'design object addition'))) = 1;
END_ENTITY; -- add_design_object_request_assignment
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The add_design_object_request_assignment shall have exactly one item
that is a product_definition_relationship with a name of 'design object addition'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The add_design_object_request_assignment shall have exactly one item that is a
managed_design_object that is not a product_definition_relationship 
with a name of 'design object addition' and is not referenced by 
another product_definition_relationship with a name of 
'design object addition', 'design object change', or 'design object deletion'
in the same design.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>


</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="altered_package_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A altered_package_terminal is a package_terminal that implements the ARM
concept of <Internal.ref Linkend="Altered_package_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY altered_package_terminal
  ABSTRACT SUPERTYPE OF ((shape_formed_terminal ANDOR
      surface_prepped_terminal) ANDOR length_trimmed_terminal)
   SUBTYPE OF (package_terminal);
WHERE
 WR1: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'terminal to be altered' ))
       = 1;
 WR2: (SELF.of_shape.definition\product_definition.description =
       'altered package');
END_ENTITY; -- altered_package_terminal
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The altered_package_terminal shall be referenced by one shape_aspect_relationship with a description of 'terminal to be altered' as the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The altered_package_terminal shall be an aspect of the shape of a product_definition with a description of 'altered package'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="analytical_model">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An analytical_model is a representation that implements the ARM
concept of <internal.ref Linkend="Analytical_model">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY analytical_model
  SUBTYPE OF (representation);
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 2;
  WR2: SIZEOF (QUERY (dr <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       dr.assigned_document.kind\document_type.product_data_type = 
       'language reference manual')) = 1;
  WR3: SIZEOF (QUERY (it <* SELF.items |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MODEL_PARAMETER' IN 
       TYPEOF (it)))) = 0;
  WR4: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       (rr\representation_relationship.name = 'access mechanism') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL_PORT' IN
       TYPEOF (rr.rep_2)))) >= 1;
END_ENTITY; -- analytical_model
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within a population of analytical_model.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.group>

<FORMAL.PROPOSITIONS.group RULE.TYPES="WR">
  
<FORMAL.PROPOSITIONS.RUL>
The analytical_model shall be referenced by exactly two
document_references.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model shall be referenced by exactly one
document_reference where the document_type is 'language reference manual'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model shall have at least one model_parameter in its set
of items.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model shall be referenced as rep_1 in at least one
representation_relationship with a name of 'access mechanism' where the rep_2
references an analytical_model_port.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.group>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="analytical_model_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An analytical_model_definition is a product_definition that implements the ARM concepts of:
<internal.ref Linkend="Analytical_model_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY analytical_model_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\analytical_model_definition))) = 0;
  WR7: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'simulation model')) >= 1;
END_ENTITY; -- analytical_model_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the analytical_model_definition is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_definition shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_definition shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_definition shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_definition shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_definition shall not be any other type of product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_definition shall have a product_category name of 'simulation model'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="analytical_model_make_from_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An analytical_model_make_from_relationship is a representation and a representation_relationship
that implements the ARM concept of <internal.ref Linkend="Analytical_model_make_from">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY analytical_model_make_from_relationship
  SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL'] *
       TYPEOF (SELF.rep_1)) = 1;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL'] *
       TYPEOF (SELF.rep_2)) = 1;
  WR3: SIZEOF( QUERY(rr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |NOT(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2))))) = 0;
  WR4: SIZEOF( QUERY(rr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |NOT(
       (rr\representation_relationship.name = 'associated make from') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2))))) = 0;
  WR5: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL'] *
       TYPEOF (SELF)) = 0;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\analytical_model_make_from_relationship))) = 0;
END_ENTITY; -- analytical_model_make_from_relationship 
(* 
</EXPRESS.CODE> 
<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR"> 
<FORMAL.PROPOSITIONS.RUL>
The combination of rep_1 and rep_2 shall be unique within a population of analytical_model_make_from_relationship.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_make_from_relationship shall reference an analytical_model as its rep_1.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_make_from_relationship shall reference an analytical_model as its rep_2.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_make_from_relationship shall be related to only a make_from_model_port_relationship via a representation_relationship. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The analytical_model_make_from_relationship shall be related to only a make_from_model_port_relationship via a representation_relationship with a name of 'associated make from'. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The analytical_model_make_from_relationship shall not be an analytical_model.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_make_from_relationship shall only be a representation, represetation_item or in addition to itself.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="analytical_model_port">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An analytical_model_port is a representation that describes an interface 
point for an analytical_model.  An 
analytical_model_port implements the ARM constructs of:
<list>
<list.item><internal.ref Linkend="Analytical_model_port"></list.item>
<list.item><internal.ref Linkend="Analytical_model_scalar_port"></list.item>
<list.item><internal.ref Linkend="Analytical_model_vector_port"></list.item>
<list.item><internal.ref Linkend="Digital_analytical_model_port"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY analytical_model_port
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'distributed property') AND
       (it\descriptive_representation_item.description IN 
       ['true', 'false']))) = 1;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'nominal signal flow direction') AND
       (it\descriptive_representation_item.description IN 
       ['input direction',
       'output direction', 'bidirectional', 'unknown direction',
       'not applicable']))) <= 1;
  WR3: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'port type') AND
       (it\descriptive_representation_item.description IN 
       ['string property type',
       'logical property type', 'physical property type',
       'boolean property type']))) = 1;
  WR4: SIZEOF (QUERY (am <* QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') |
       rr\representation_relationship.name = 'access mechanism') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL' IN 
       TYPEOF (am.rep_1))) = 1;
  WR5: SIZEOF (QUERY (aga <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       aga.assigned_group\group.name IN ['scalar port', 'digital scalar port', 
       'vector port', 'digital vector port', 
       'digital analytical model port'])) <= 1;
  WR6: (NOT (SIZEOF (QUERY (aga <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       aga.assigned_group\group.name IN ['vector port', 'digital vector port'])) 
       = 1)) OR
       (SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'size') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COUNT_MEASURE' IN
       TYPEOF (it\measure_with_unit.value_component)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONTEXT_DEPENDENT_UNIT' IN
       TYPEOF (it\measure_with_unit.unit_component)))) = 1);
  WR7: (NOT (SIZEOF (QUERY (aga <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       aga.assigned_group\group.name IN ['digital scalar port', 
       'digital vector port', 'digital analytical model port'])) = 1)) OR
       (SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'nominal signal flow direction') AND
    (it\descriptive_representation_item.description IN ['input direction',
       'output direction', 'bidirectional', 'unknown direction']))) = 1);
END_ENTITY; -- analytical_model_port
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_port shall have exactly one 
descriptive_representation_item with a name of 'distributed property' and a 
description of
'true' or 'false'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_port shall have at most one 
descriptive_representation_item with a name of 'nominal signal flow direction' 
and a
description of 'input direction', 'output direction', 'bidirectional',
'unknown direction', or 'not applicable'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_port shall have exactly one 
descriptive_representation_item with a name 
of 'port type' and a description of 'string property type', 
'logical property type', 'physical property type', or 'boolean property type'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_port shall be related to exactly one analytical_model 
as the 'access mechanism'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_model_port shall be assigned to at most one group with a
name of 'scalar port', 'digital scalar port', 'vector port', 'digital vector
port', or 'digital analytical model port'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the analytical_model_port is assigned to a group with a name of
'vector port' or 'digital vector port', it shall have exactly one
measure_representation_item with a name of 'size', a value_component that is a
count_measure, and a unit_component that is a context_dependent_unit.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the analytical_model_port is assigned to a group with a name of
'digital scalar port', 'digital vector port', or 'digital analytical model
port', it shall have exactly one descriptive_representation_item with a name
of 'nominal signal flow direction' and a description of 'input direction',
'output direction', 'bidirectional', or 'unknown direction'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="analytical_representation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An analytical_representation is a
representation that associates specific properties
with an analytical_model.
An analytical_representation implements the ARM concept of <internal.ref Linkend="Analytical_representation">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY analytical_representation
  SUBTYPE OF (representation);
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN
       TYPEOF (rr.rep_2))) >= 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL' IN TYPEOF (rr.rep_1))) = 1;
END_ENTITY; -- analytical_representation
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within a population of analytical_representation.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The analytical_representation shall have at least one
representation_relationship that references a
parameter_assignment_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The analytical_representation shall have exactly one
representation_relationship that references an analytical_model.
</FORMAL.PROPOSITIONS.RUL>


<!--
 added angular_dimension_with_orientation mm 7/2/97

-->

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="angular_dimension_with_orientation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An angular_dimension_with_orientation is a dimensional_location
that defines the angle between two shape elements.  
An angular_dimension_with_orientation implements the ARM concept of <internal.ref Linkend="Angular_dimension_with_direction_vector">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY angular_dimension_with_orientation
  SUBTYPE OF (dimensional_location);
WHERE
    wr1: SELF\shape_aspect_relationship.description = 'angular';
END_ENTITY; -- angular_dimension_with_orientation
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The description of the angular_dimension_with_orientation shall be 'angular'.
</Formal.propositions.rul>
</Formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The angular_dimension_with_orientation shall have exactly one property_definition with a 
description of 'dimensional location property', and that property_definition either shall be 
represented by a representation that contains a placement with a name of 'orientation' or shall 
relate to a property_definition with a description of 'datum based vector orientation' to specify 
the 'measurement orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the angular_dimension_with_orientation has a property_definition with a description of 
'dimensional location property' and that property_definition relates to a property_definition with 
a description of 'datum based vector orientation' to specify the 'measurement orientation', the 
combination of the shape_aspect specified as the related_shape_aspect, the shape_aspect specified as the relating_shape_aspect, 
and the property_definition with a description of 'datum based vector orientation' shall be unique.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the angular_dimension_with_orientation has a property_definition with a description of 
'dimensional location property' and that property_definition is represented by a representation 
that contains a placement with a name of 'orientation', the combination of the shape_aspect 
specified as the related_shape_aspect, the shape_aspect specified as the relating_shape_aspect, and the placement with a name of 
'orientation' shall be unique.
</Informal.propositions.rul>


</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="angularity_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An angularity_tolerance is a 
geometric_tolerance_with_specified_datum_system.  An angularity_tolerance
implements the ARM concept of <internal.ref Linkend="Angularity_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY angularity_tolerance
  SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
WHERE
  WR1: SELF\geometric_tolerance.name = 'angularity';
END_ENTITY; -- angularity_tolerance
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name for the angularity_tolerance shall be 'angularity'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The toleranced_shape_aspect of the angularity_tolerance shall either lie on the 
boundary of the shape of the product; be a centre_of_symmetry with a description of 
either 'axis' or 'plane'; be a tangent with a description of 'plane'; be a 
part_template_definition; or be a composite_shape_aspect the 'composing' shape_aspects 
of which either are all of type part_template_definition, are all of type 
centre_of_symmetry and have the same description -- either 'axis' or 'plane', or are 
all of type tangent with a description of 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The angularity_tolerance shall have at most two physical_unit_datum in its referenced datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
The angularity_tolerance shall have at least one physical_unit_datum in its referenced datum_system 
that has description of either 'axis' or 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the toleranced_shape_aspect of the angularity_tolerance is neither a 
centre_of_symmetry with a description of 'axis' nor a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'axis', the tolerance_zone_boundary shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_action_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_action_assignment is an action_assignment that specifies
a set of action_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_action_assignment
  SUBTYPE OF (action_assignment);
    items : SET [1:?] OF action_assigned_item;
END_ENTITY; -- applied_action_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_approval_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_approval_assignment is an approval_assignment that specifies
a set of approval_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_approval_assignment 
 SUBTYPE OF (approval_assignment); 
 items : SET [1:?] OF approval_assigned_item; 
END_ENTITY; -- applied_approval_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_certification_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_certification_assignment is a certification_assignment that
specifies a set of certification_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET [1:?] OF certification_assigned_item;
END_ENTITY; -- applied_certification_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_classification_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_classification_assignment is a group_assignment that specifies
a set of classification_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_classification_assignment
   SUBTYPE OF (group_assignment);
     items : SET [1:?] OF classification_assigned_item;
END_ENTITY; -- applied_classification_assignment
(*
</EXPRESS.CODE>


</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_contract_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_contract_assignment is a contract_assignment that specifies
a set of contract_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contract_assigned_item;
END_ENTITY; -- applied_contract_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_date_and_time_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_date_and_time_assignment is a date_and_time_assignment that
specifies a set of date_and_time_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_assigned_item;
WHERE
  WR1: applied_date_time_correlation
       (SELF,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
  WR2: (NOT (SELF.role\date_time_role.name = 'participant date and time')) OR
       (SIZEOF (QUERY (ra <* QUERY (it <* SELF.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_ACTION' IN
       TYPEOF (it)) |
       NOT (SIZEOF (USEDIN (ra,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')) = 1))) = 0);
END_ENTITY; -- applied_date_and_time_assignment
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The role of the applied_date_and_time_assignment shall correlate with the
items of the applied_date_and_time_assignment.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the applied_date_and_time_assignment has a role of 'participant date
and time', each rule_action in the set of items shall have exactly one
applied_person_and_organization_assignment.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_date_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_date_assignment is a date_assignment that specifies a set of
date_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_assigned_item;
WHERE
  WR1: applied_date_correlation (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
END_ENTITY; -- applied_date_assignment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The role of the applied_date_assignment shall correlate with the
items of the applied_date_assignment.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_document_reference">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_document_reference is a document reference that specifies
a set of document_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET [1:?] OF document_assigned_item;
END_ENTITY; -- applied_document_reference
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_group_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_group_assignment is a group_assignment that specifies
a set of group_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_group_assignment
 SUBTYPE OF (group_assignment);
     items : SET [1:?] OF group_assigned_item;
END_ENTITY; -- applied_group_assignment
(*
</EXPRESS.CODE>
<InFormal.propositions rule.types="IP">
<InFormal.propositions.rul>
If the applied_group_assignment has an assigned_group that is a 
functional_terminal_group then it shall only have items that are
functional_unit_terminal_definitions with a description of 
'scalar terminal'.
</InFormal.propositions.rul>
</InFormal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_organization_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_organization_assignment is an organization_assignment that
specifies a set of organization_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_assigned_item;
END_ENTITY; -- applied_organization_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_person_and_organization_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_person_and_organization_assignment is a
person_and_organization_assignment that specifies a set of
person_and_organization_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_assigned_item;
END_ENTITY; -- applied_person_and_organization_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_person_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_person_assignment is a person_assignment that specifies
a set of person_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_person_assignment
 SUBTYPE OF (person_assignment);
     items : SET [1:?] OF person_assigned_item;
END_ENTITY; -- applied_person_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_promissory_usage_in_product_model_assignment">
<ENTITY.DESCRIPTION>
An applied_promissory_usage_in_product_model_assignment is a group_assignment that specifies
a set of promissory_usage_in_product_model_assigned_item. One item shall be a product_concept and the other item shall be a product_definition.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_promissory_usage_in_product_model_assignment
 SUBTYPE OF (group_assignment);
     items : SET [1:?] OF promissory_usage_in_product_model_assigned_item;
WHERE
 WR1: SIZEOF(QUERY(pm <* items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_CONCEPT' IN TYPEOF(pm)
        )) = 1;
 WR2: SIZEOF(QUERY(pd <* items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION' IN TYPEOF(pd)
        )) = 1;
 WR3: SIZEOF(items) = 2;
 WR4: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROMISSORY_USAGE_IN_PRODUCT_MODEL' IN TYPEOF(SELF\group_assignment.assigned_group);
 WR5: SIZEOF(USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) <= 1;
END_ENTITY; -- applied_promissory_usage_in_product_model_assignment
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="applied_security_classification_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An applied_security_classification_assignment is a
security_classification_assignment that specifies a set of
security_classification_assigned_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_assigned_item;
END_ENTITY; -- applied_security_classification_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="array_placement_group_component_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An array_placement_group_component_definition is a assembly_group_component_definition that implements the ARM concept of
<internal.ref Linkend="Array_placement_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY array_placement_group_component_definition
  SUPERTYPE OF (ONEOF(linear_array_placement_group_component_definition,
                      rectangular_array_placement_group_component_definition))
  SUBTYPE OF (assembly_group_component_definition);
END_ENTITY; -- array_placement_group_component_definition
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="array_placement_group_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An array_placement_group_component_shape_aspect is a assembly_group_component_shape_aspect that implements the ARM concepts of
<internal.ref Linkend="Array_placement_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY array_placement_group_component_shape_aspect
  SUPERTYPE OF (ONEOF(linear_array_placement_group_component_shape_aspect,
                      rectangular_array_placement_group_component_shape_aspect))
  SUBTYPE OF (assembly_group_component_shape_aspect);
END_ENTITY; -- array_placement_group_component_shape_aspect
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_bond_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An assembly_bond_definition is a shape_aspect
that defines a joint that uses material to bond together portions
of the assembly.  An assembly_bond_definition implements the ARM concept
of <internal.ref Linkend="Assembly_bond_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_bond_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
  WR2: SIZEOF (QUERY (aga <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BOND_CATEGORY' IN
       TYPEOF (aga.assigned_group))) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 1' ))  = 1;
  WR4: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 2' ))  = 1;
  WR5: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF (SELF.of_shape.definition))
       AND
       (SIZEOF (QUERY (prpc <* USEDIN (SELF.of_shape.definition.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'technology specific model')) >= 1));
END_ENTITY; -- assembly_bond_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name of the assembly_bond_definition shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The assembly_bond_definition shall have exactly one material_designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_bond_definition shall be in exactly one bond_category.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_bond_definition shall be related to exactly one shape_aspect as the 'bonded feature 1'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_bond_definition shall be related to exactly one shape_aspect as the 'bonded feature 2'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_bond_definition shall be an aspect of the shape of the externally_defined_product_definition of a 'technology specific model' product. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_definition">
<ENTITY.DESCRIPTION>
An assembly_definition is a physical_unit.  An assembly_definition implements
the ARM concepts of a <internal.ref Linkend="Pca"> and
a <internal.ref Linkend="Pca_usage_view">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_definition
 SUBTYPE OF (physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR 
        (SELF\product_definition.name = 'assembly module');
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_ASSEMBLY_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name = 'assembly module')
        )) = 1);
  WR4: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
END_ENTITY; -- assembly_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The name shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_definition shall be a definition of a product that has a name of 'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the assembly_definition is a physical design, it shall relate to exactly
one assembly_definition, externally_defined_assembly_definition, or 
library_defined_assembly_definition that is a physical design usage with a 
name of 'assembly module' as the design usage.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the assembly_definition has a frame_of_reference name of 'physical design
usage', it shall have at least two shape_aspects that are 
assembly_module_terminals with a description of 'pca terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_group_component_definition">
<ENTITY.DESCRIPTION>
An assembly_group_component_definition is a component_definition that implements the ARM concept of
<internal.ref Linkend="Assembly_group_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_group_component_definition
  SUBTYPE OF (component_definition);
WHERE
  WR1: (SIZEOF (QUERY (gc <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'group component') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (gc.related_product_definition)))) >= 1)  OR
       (SIZEOF (QUERY(agcsa <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF (agcsa)))) = 0);
  WR2: (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT' IN TYPEOF (aj)) AND
       (SIZEOF (QUERY( acu <* USEDIN (aj\shape_aspect_relationship.relating_shape_aspect,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
       AND (acu\product_definition_relationship.relating_product_definition = SELF)
       )) >= 1))) >= 1);
  WR3: (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj))AND
       (SIZEOF (QUERY( acu <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
        AND (acu\product_definition_relationship.relating_product_definition = SELF)
        )) = 0))) = 0);
  WR4: (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)) AND
       (SIZEOF (QUERY( cl <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect.of_shape.definition,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'REPRESENTATION.ITEMS') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_LOCATION' IN TYPEOF (cl))
        AND (aj IN cl\representation.items))) = 0))) = 0);
END_ENTITY; -- assembly_group_component_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The assembly_group_component_definition shall be related to at least one component_definition by a product_definition_relationship with a name of 'group component' or it shall be a definition for an assembly_component_group_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the assembly_group_component_definition is referenced by an
assembly_joint through the of_shape attribute, at least one of the members
of component_definition that are related by the relating_shape_aspect of that
assembly_joint shall be related by members of assembly_component_usage to
this assembly_group_component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the assembly_group_component_definition is referenced by an
assembly_joint through the of_shape attribute, each member
of component_definition that are related by the related_shape_aspect of that
assembly_joint shall be related by members of assembly_component_usage to
this assembly_group_component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the assembly_group_component_definition is referenced by an assembly_joint through the of_shape.definition attribute, the component_definition that is related by the assembly_joint\shape_aspect_relationship.related_shape_aspect.of_shape.definition attribute of that assembly_joint shall be positioned by a member of component_location which also references that assembly_joint. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_group_component_definition_placement_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A assembly_group_component_definition_placement_link is a product_definition and a product_definition_relationship that implements the ARM concept of<internal.ref Linkend="Assembly_component_placement_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_group_component_definition_placement_link
  SUBTYPE OF (product_definition,product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\assembly_group_component_definition_placement_link)) = 0;
  WR5: SELF\product_definition.name = '';
  WR6: SELF\product_definition_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
END_ENTITY; -- assembly_group_component_definition_placement_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_group_component_definition_placement_link shall relate to only a component_definition in the related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_group_component_definition_placement_link shall relate to only a component_definition in the relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of assembly_group_component_definition_placement_link shall be only assembly_group_component_definition_placement_link, product_definition, and product_definition_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each assembly_group_component_definition_placement_link shall be referenced exactly once by a product_definition_relationship related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_group_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An assembly_group_component_shape_aspect is a component_shape_aspect that implements the ARM concept of
<internal.ref Linkend="Assembly_group_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_group_component_shape_aspect
  SUBTYPE OF (component_shape_aspect);
WHERE
  WR1: (SIZEOF (QUERY (gc <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'group component') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (gc.related_shape_aspect))))
       >= 1);
END_ENTITY; -- assembly_group_component_shape_aspect
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The assembly_group_component_shape_aspect shall be related to at least
one component_shape_aspect by a shape_aspect_relationship with a name of 'group component'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_group_component_shape_aspect_placement_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An assembly_group_component_shape_aspect_placement_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Assembly_component_placement_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_group_component_shape_aspect_placement_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\assembly_group_component_shape_aspect_placement_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
END_ENTITY; -- assembly_group_component_shape_aspect_placement_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_group_component_shape_aspect_placement_link shall relate to only a component_shape_aspect in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_group_component_shape_aspect_placement_link shall relate to only a component_shape_aspect in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of assembly_group_component_shape_aspect_placement_link shall be only assembly_group_component_shape_aspect_placement_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each assembly_group_component_shape_aspect_placement_link shall be referenced exactly once by a shape_aspect_relationship related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_joint">
<ENTITY.DESCRIPTION>
An assembly_joint is a shape_aspect_relationship and
a shape_aspect that is the result of a physical connection between two
components in the assembly.  The order shall be inferred from the
use of relating and related attributes on shape_aspect_relationship.
An assembly_joint implements the ARM
concepts of:
<list>
<list.item><internal.ref Linkend="Assembly_joint"></list.item>
<list.item><internal.ref Linkend="Assembled_with_bonding"></list.item>
<list.item><internal.ref Linkend="Assembled_with_fasteners"></list.item>
</list>

</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_joint
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
  WR1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       (SELF.relating_shape_aspect\shape_aspect.description IN 
       ['assembly module component terminal', 
       'bare die component terminal',
       'interconnect component join terminal', 
       'interconnect module component terminal',  
       'package terminal occurrence', 
       'packaged component join terminal'])) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_MOUNTING_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect));
  WR2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description IN 
       ['assembly module component terminal', 
       'bare die component terminal', 
       'interconnect component join terminal', 
       'interconnect module component terminal',  
       'package terminal occurrence', 
       'packaged component join terminal'])) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_MOUNTING_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect));
  WR3: (NOT (SELF\shape_aspect_relationship.name = 
       'assembled with bonding')) OR
       (SIZEOF (QUERY (ddu <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'default definition usage') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION' IN
       TYPEOF (ddu.relating_shape_aspect))) = 1);
  WR4: (NOT (SELF\shape_aspect_relationship.name = 
       'assembled with bonding')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'bond assembly position') AND
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM' IN TYPEOF (it)) AND
       (it\representation_item.name = 'assembly position'))) = 1))) = 1)) <= 1);
  WR5: (NOT (SELF\shape_aspect_relationship.name = 
       'assembled with fasteners')) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition));
  WR6: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) OR
       is_assembly_module_design(SELF.of_shape.definition); 
  WR7: (NOT (SELF\shape_aspect_relationship.name =
       'assembled with bonding')) OR
       (SIZEOF (QUERY (ddu <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'default definition usage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_BOND_DEFINITION' IN
       TYPEOF (ddu.relating_shape_aspect)) AND
       (SIZEOF (QUERY (sar <* USEDIN (ddu.relating_shape_aspect,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 1' ))  = 1)
       AND (SIZEOF (QUERY (sar <* USEDIN (ddu.relating_shape_aspect,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 1' ))  = 1)
       )) = 1);
  WR8: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'+
       'ASSEMBLY_JOINT');
END_ENTITY; -- assembly_joint
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The assembly_joint shall have a relating_shape_aspect that references
either a component_terminal with a description of 'assembly module component
terminal', 'bare die component terminal', 'interconnect component join
terminal', 'interconnect module component terminal', 
'package terminal occurrence', or  'packaged component join terminal', or a
component_interface_terminal or a component_mounting_feature or an
interconnect_module_component_surface_feature.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_joint shall have a related_shape_aspect that references
either a component_terminal with a description of 'assembly module component
terminal', 'bare die component terminal', 'interconnect component join
terminal', 'interconnect module component terminal', 
'package terminal occurrence', or  'packaged component join terminal', or a
component_interface_terminal or a component_mounting_feature or an
interconnect_module_component_surface_feature.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the name of the shape_aspect_relationship of the assembly_joint is
'assembled with bonding', it shall be related to exactly one  
assembly_bond_definition as the 'default definition usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the name of the shape_aspect_relationship of the assembly_joint is
'assembled with bonding', it shall have at most one property_definition that
is associated with exactly one representation with a name of 'bond assembly
position' that contains exactly one mapped_item with the name 'assembly
position'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the name of the shape_aspect_relationship of the assembly_joint is 
'assembled with fasteners', it shall be an aspect of the shape of an assembly_group_component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_joint is shall be an aspect of the shape of a physical_unit that is an assembly module design or of an assembly_group_component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the name of the shape_aspect_relationship of the assembly_joint is 'assembled with bonding', its bonded features shall be defined by the referenced features.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The members of assembly_joint shall form a directed acyclic graph with the relating_shape_aspect, related_shape_aspect attributes of assembly_joint.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_module_interface_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An assembly_module_interface_terminal is an assembly_module_terminal that implement the
ARM concept of <internal.ref Linkend="Assembly_module_interface_terminal">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_module_interface_terminal
  SUBTYPE OF (assembly_module_terminal);
END_ENTITY; -- assembly_module_interface_terminal
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall be related to at most one shape_aspect with a description of 'interface terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_module_join_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An assembly_module_join_terminal is an assembly_module_terminal that implement the
ARM concept of <internal.ref Linkend="Assembly_module_join_terminal">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_module_join_terminal
  SUBTYPE OF (assembly_module_terminal);
END_ENTITY; -- assembly_module_join_terminal
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall be related to at most one shape_aspect with a description of 'join terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_module_macro_component_join_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An assembly_module_macro_component_join_terminal is a shape_aspect that implements the ARM concept of
<internal.ref Linkend="Assembly_module_macro_component_join_terminal">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_module_macro_component_join_terminal
  SUBTYPE OF (component_terminal);
WHERE
  WR1: NOT (SELF\shape_aspect.description IN 
      ['bare die component terminal', 
       'component termination passage join terminal', 
       'conductive interconnect element terminal', 
       'interconnect component join terminal', 
       'interconnect module component terminal', 'land join terminal', 
       'minimally defined component terminal',
       'non functional land join terminal', 
       'packaged component join terminal', 
       'printed component join terminal', 'package terminal occurrence',
       'via terminal']);
END_ENTITY; -- assembly_module_macro_component_join_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_macro_component_join_terminal shall not have a description of
'bare die component terminal', 'component termination
passage join terminal', 'conductive interconnect element terminal',
'interconnect component join terminal', 'interconnect module component
terminal', 'land join terminal', 'minimally defined component terminal',
'non functional land join terminal', 'packaged component join terminal',
'printed component join terminal', 'package terminal occurrence',
or 'via terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_module_terminal">
<ENTITY.DESCRIPTION>
An assembly_module_terminal is a shape_aspect that implement the ARM concepts of: 
<list>
<list.item><internal.ref Linkend="Assembly_module_terminal"></list.item>
<list.item><internal.ref Linkend="Part_terminal"></list.item>
<list.item><internal.ref Linkend="Pca_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_module_terminal
  SUPERTYPE OF (ONEOF(
           assembly_module_interface_terminal, 
           assembly_module_join_terminal))
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
  WR2: NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR
      (SELF.of_shape.definition\product_definition.name = 'assembly module');
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR4: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
  WR5: (NOT (SELF\shape_aspect.description = 'pca terminal')) OR
       ((SIZEOF(TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_ASSEMBLY_DEFINITION']) >=1)
       AND (SELF.of_shape.definition\product_definition.
       frame_of_reference.name = 'physical design usage'));
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 'connection zone')) = 1;
  WR7: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 'interface terminal')) <= 1;
END_ENTITY; -- assembly_module_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The product_definition name shall exist. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall be the shape_aspect of a product_definition of a product that has a name of 'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall have at least one
shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall be related to at most one 
part_connected_terminals_definition as a 'member connected terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the assembly_module_terminal has a description of 'pca terminal',
it shall be an aspect of the shape of an assembly_definition, 
externally_defined_assembly_definition, or library_defined_assembly_definition 
that has a frame_of_reference name 'physical design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall be related to exactly one shape_aspect with 
a description of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall be related to at most one shape_aspect with a description of 'interface terminal'.
</FORMAL.PROPOSITIONS.RUL>

<!--
 added auxiliary_characteristic_dimension_representation mm 7/2/97

-->
</FORMAL.PROPOSITIONS>
<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The assembly_module_terminal shall be related to at most one assembly_module_usage_view_connector_relationship.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="assembly_module_usage_view_connector_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A assembly_module_usage_view_connector_relationship is a type of mapped_item that implements the
ARM concept of<internal.ref Linkend="assembly_module_usage_view_connector_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY assembly_module_usage_view_connector_relationship
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.mapping_target);
  wr2: SELF\mapped_item.mapping_source.mapped_representation\representation.name =
       '3d bound volume shape';
  wr3:  SIZEOF (QUERY (pdr <* USEDIN 
       ( SELF\mapped_item.mapping_source.mapped_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_CONNECTOR',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_CONNECTOR'] * 
        TYPEOF (pdr.definition.definition) ) = 1) )) = 1;
  wr4:  SIZEOF (QUERY (r <* USEDIN ( SELF\representation_item,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') |
        SIZEOF (QUERY (pdr <* USEDIN (r,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION' IN TYPEOF(pdr.definition.definition))
         AND
        (pdr.definition.definition.
          frame_of_reference\application_context_element.name = 
          'physical design usage')
          AND
          (pdr.definition.definition\product_definition.
          name = 'assembly module')
           )) = 1 )) = 1;
END_ENTITY; -- assembly_module_usage_view_connector_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_usage_view_connector_relationship shall have an axis2_placement_3d as a placement. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_usage_view_connector_relationship shall place a 3d representation. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_usage_view_connector_relationship shall place a 3d representation of a packaged_connector,
externally_defined_packaged_connector, or a library_defined_packaged_connector. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The assembly_module_usage_view_connector_relationship shall place the 3d representation into a representation
of a product_definition that is an 'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="auxiliary_characteristic_dimension_representation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An auxiliary_characteristic_dimension_representation is a
dimensional_characteristic_representation
that implements the ARM concept of 
<internal.ref Linkend="Dimensional_characteristic_representation"> where
the ARM attribute "auxiliary_dimension_representation" has a value of TRUE.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY auxiliary_characteristic_dimension_representation
 SUBTYPE OF (dimensional_characteristic_representation);
END_ENTITY; -- auxiliary_characteristic_dimension_representation
(*
</EXPRESS.CODE>



</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bare_die">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bare_die is a physical_unit that implements the ARM concept
of <internal.ref Linkend="Bare_die">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bare_die
 SUBTYPE OF (physical_unit);
WHERE
  WR1: SIZEOF (QUERY (ifdu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\property_definition_relationship.name = 'implemented function') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifdu.relating_product_definition)) AND
       (ifdu.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'device unit technology') |
       dut.relating_property_definition\property_definition.name = 
       'unit technology')) = 1)) = 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0;
END_ENTITY; -- bare_die
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The bare_die shall be related to exactly one functional_unit with a
frame_of_reference name of 'functional design usage' as the 'implemented
function'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die shall have exactly one property_definition that is related
to exactly one property_definition with a name of 'unit technology' as the
'device unit technology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die shall have at least two shape_aspects that are bare_die_terminals.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The bare_die shall have exactly one representation with the name of material property data
that shall be related to cartesian_points with names of 
'least material condition centroid location' and 'maximum material condition centroid location'.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bare_die_bottom_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bare_die_bottom_surface is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Bare_die_bottom_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bare_die_bottom_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\bare_die_bottom_surface ||
       SELF\part_mounting_feature ||
       SELF\bare_die_surface)) = 0;
END_ENTITY; -- bare_die_bottom_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The bare_die_bottom_surface shall be the aspect of the shape of a bare_die,
externally_defined_bare_die, or library_defined_bare_die.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_bottom_surface shall be on the boundary of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_bottom_surface shall be no other subtype of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bare_die_edge_segment_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bare_die_edge_segment_surface is a shape_aspect and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Bare_die_edge_segment_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bare_die_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  wr1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  wr2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  wr3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE_EDGE_SURFACE' IN TYPEOF
       (ce.relating_shape_aspect) ))) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\bare_die_edge_segment_surface)) = 0;
END_ENTITY; -- bare_die_edge_segment_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The bare_die_edge_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_edge_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship relating attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex instances referenced shall not be the same instance of edge_segment_vertex.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The bare_die_edge_segment_surface shall be related to
exactly one bare_die_edge_surface as the 'composed surface'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_edge_segment_surface shall not be in a complex instance other 
than with it's immediate supertypes. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bare_die_edge_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bare_die_edge_surface is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Bare_die_edge_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bare_die_edge_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\bare_die_edge_surface ||
       SELF\bare_die_surface)) = 0;
END_ENTITY; -- bare_die_edge_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The bare_die_edge_surface shall be the aspect of the shape of a bare_die,
externally_defined_bare_die, or library_defined_bare_die.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_edge_surface shall be on the boundary of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_edge_surface shall be no other subtype of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bare_die_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bare_die_surface is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Bare_die_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bare_die_surface
 ABSTRACT SUPERTYPE OF (ONEOF( bare_die_bottom_surface, 
                         bare_die_top_surface, 
                        bare_die_edge_surface))
 SUBTYPE OF (part_mounting_feature);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
END_ENTITY; -- bare_die_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The bare_die_surface shall be the aspect of the shape of a bare_die,
externally_defined_bare_die, or library_defined_bare_die.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_surface shall be on the boundary of the product.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bare_die_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bare_die_terminal is a minimally_defined_bare_die_terminal that implements
the ARM concept of <internal.ref Linkend="Bare_die_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bare_die_terminal
  SUBTYPE OF (minimally_defined_bare_die_terminal);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE' IN 
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'external connection area') |
       eca.related_shape_aspect\shape_aspect.description = 'connection zone')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
  WR4: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'seating plane zone') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN 
       TYPEOF (eca.related_shape_aspect))) <= 1;
END_ENTITY; -- bare_die_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The bare_die_terminal shall be a terminal of a bare_die.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_terminal shall relate to exactly one shape_aspect that has a
description of 'connection zone' as the 'external connection area'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_terminal shall have exactly one material designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_terminal shall have no more than one 'seating plane zone'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bare_die_top_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bare_die_top_surface is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Bare_die_top_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bare_die_top_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\bare_die_top_surface ||
       SELF\bare_die_surface)) = 0;
END_ENTITY; -- bare_die_top_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The bare_die_top_surface shall be the aspect of the shape of a bare_die,
externally_defined_bare_die, or library_defined_bare_die.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_top_surface shall be on the boundary of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bare_die_top_surface shall be no other subtype of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bond_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bond_category is a group and an external_definition that implements the
ARM concept of <internal.ref Linkend="External_definition"> in the role of
bond category.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bond_category
  SUBTYPE OF (group, external_definition);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
END_ENTITY; -- bond_category
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The bond_category shall be referenced by exactly one document.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bus_element_link">
<ENTITY.DESCRIPTION>
A bus_element_link is a product_definition and a product_definition_relationship that implements the ARM concept of<internal.ref Linkend="Bus_element_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bus_element_link
  SUBTYPE OF (product_definition,product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.related_product_definition,
       SELF\product_definition_relationship.relating_product_definition;
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NETWORK_NODE_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition));
  WR3: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NETWORK_NODE_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition));
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\bus_element_link)) = 0;
  WR5: NOT EXISTS(SELF\product_definition.name) OR 
        (SELF\product_definition.name = '');
  WR6: SELF\product_definition_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) >= 1;
END_ENTITY; -- bus_element_link 
(* 
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The combination of related, relating attributes inherited from product_definition_relationship be unique within a population of bus_element_link.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.group>

<FORMAL.PROPOSITIONS.group RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bus_element_link shall relate to only a bus_structural_definition or a network_node_definition in the related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bus_element_link shall relate to only a bus_structural_definition or a network_node_definition in the relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of bus_element_link shall be only bus_element_link, product_definition, and product_definition_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each bus_element_link shall be referenced at least once by a product_definition_relationship related_product_definition.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.group>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="bus_structural_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A bus_structural_definition is a product_definition that implements the ARM
concept of <internal.ref Linkend="Bus_structural_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY bus_structural_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF (QUERY (bce <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'bus composition') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_ELEMENT_LINK' IN
       TYPEOF (bce.related_product_definition))) >= 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 
       'functional unit network terminal definition bus assignment')) 
       <= 1)) <= 1;
  WR3: consistent_bus_structural_definition(bag_to_set(QUERY( pdr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_ELEMENT_LINK' IN TYPEOF(pdr.related_product_definition))));
END_ENTITY; -- bus_structural_definition
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">

<FORMAL.PROPOSITIONS.RUL>
The bus_structural_definition shall relate to at least one bus_element_link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bus_structural_definition shall have at most one property_definition
that relates to another property_definition to specify the 'functional unit
network terminal definition bus assignment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The bus_structural_definition shall be a connected structure and shall not have any vertex with a degree greater than 2.  The number of vertices shall equal the number of links + 1.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="cable_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A cable_component is a component_definition that implements the ARM concept
of <internal.ref Linkend="Cable_component">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY cable_component
  SUBTYPE OF (component_definition);
WHERE
  WR1: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1;
  WR2: SELF\product_definition.description :<>: 'laminate component';
END_ENTITY; -- cable_component
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The cable_component shall be related, as the 'instantiated part', to exactly one physical_unit that is in the 'physical design usage' product_definition_context.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The cable_component shall not have a description of 'laminate component'. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="capacitance_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A capacitance_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Capacitance_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY capacitance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\capacitance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = farad;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- capacitance_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The capacitance_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The capacitance_measure_with_unit shall reference an si_unit with a name of farad.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="change">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A change is an action_assignment that points to a set 
of <express.construct NAME.Linkend="work_item">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY change
 SUBTYPE OF (action_assignment);
     items : SET [1:?] OF work_item;
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIRECTED_ACTION' 
       IN TYPEOF (SELF.assigned_action);
  WR2: unique_version_change_order (SELF.assigned_action, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');

END_ENTITY; -- change
(*
</EXPRESS.CODE>




<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The change shall assign a directed_action.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A single change shall not change more than one version of a single product,
but may change more than one product_definition_formation if each
product_definition_formation references a different product.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="change_from_design_object_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A change_from_design_object_assignment is an action_assignment that implements
the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Change_design_object_management_relationship"></list.item>
<list.item><internal.ref Linkend="Component_swap_specification"></list.item>
<list.item><internal.ref Linkend="Gate_path_swap_specification"></list.item>
<list.item><internal.ref Linkend="Terminal_swap_specification"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY change_from_design_object_assignment
   SUBTYPE OF (action_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(aa <* USEDIN(SELF\action_assignment.assigned_action,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ACTION_ASSIGNMENT.ASSIGNED_ACTION')
        |'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'CHANGE_TO_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa))) >= 1;
    END_ENTITY; -- change_from_design_object_assignment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
SELF\action_assignment.assigned_action shall also be a 
SELF\action_assignment.assigned_action for a 
change_to_design_object_assignment.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
The change_from_design_object_assignment shall have exactly one item that is a
managed_design_object that is not referenced by
another product_definition_relationship with a name of
'design object addition', 'design object change', or 'design object deletion'
in the same design that is not an item of a action_assignment with the same assigned_action.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="change_from_design_object_request_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A change_from_design_object_request_assignment is an action_request_assignment that implements
the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Change_design_object_management_relationship"></list.item>
<list.item><internal.ref Linkend="Change_request"></list.item>
<list.item><internal.ref Linkend="Component_swap_specification"></list.item>
<list.item><internal.ref Linkend="Gate_path_swap_specification"></list.item>
<list.item><internal.ref Linkend="Terminal_swap_specification"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY change_from_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(aa <*
        USEDIN(SELF\action_request_assignment.assigned_action_request,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')
        |'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'CHANGE_TO_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa))) >= 1;

END_ENTITY; -- change_from_design_object_request_assignment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
SELF\action_request_assignment.assigned_action_request shall also be a 
SELF\action_request_assignment.assigned_action_request for a 
change_to_design_object_request_assignment.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
The change_from_design_object_request_assignment shall have exactly one item that is a
managed_design_object that is not referenced by
another product_definition_relationship with a name of
'design object addition', 'design object change', or 'design object deletion'
in the same design that is not an item of a action_request_assignment with the same assigned_action_request.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="change_request">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A change_request is an action_request_assignment that implements the ARM
concept of <internal.ref Linkend="Change_request">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY change_request
  SUBTYPE OF (action_request_assignment);
  items : SET [1:?] OF change_request_item;
END_ENTITY; -- change_request
(*
</EXPRESS.CODE>



<!--
 changed supertype mm 7/2/97
 removed WR2 & FP mm 7/2/97 

-->
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="change_to_design_object_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A change_to_design_object_assignment is an action_assignment that implements
the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Change_design_object_management_relationship"></list.item>
<list.item><internal.ref Linkend="Component_swap_specification"></list.item>
<list.item><internal.ref Linkend="Gate_path_swap_specification"></list.item>
<list.item><internal.ref Linkend="Terminal_swap_specification"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY change_to_design_object_assignment
   SUBTYPE OF (action_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(aa <* USEDIN(SELF\action_assignment.assigned_action,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ACTION_ASSIGNMENT.ASSIGNED_ACTION')
        |'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'CHANGE_FROM_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa))) >= 1;
   WR2: SIZEOF(QUERY ( pdr <* SELF.items | 
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND
        (pdr\product_definition_relationship.name = 'design object change'))) = 1;
    
END_ENTITY; -- change_to_design_object_assignment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR"> 
<FORMAL.PROPOSITIONS.RUL> 
SELF\action_assignment.assigned_action shall also be a 
SELF\action_assignment.assigned_action for a 
change_from_design_object_assignment.
</FORMAL.PROPOSITIONS.RUL> 

<FORMAL.PROPOSITIONS.RUL>
The change_to_design_object_assignment shall have exactly one item
that is a product_definition_relationship with a name of 'design object change'.</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP"> 
<INFORMAL.PROPOSITIONS.RUL>
The change_to_design_object_assignment shall have exactly one item that is a
managed_design_object that is not a product_definition_relationship 
with a name of 'design object change' and is not referenced by 
another product_definition_relationship with a name of 
'design object addition', 'design object change', or 'design object deletion'
in the same design that is not an item of a action_assignment with the same assigned_action.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="change_to_design_object_request_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A change_to_design_object_request_assignment is an action_request_assignment that implements
the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Change_design_object_management_relationship"></list.item>
<list.item><internal.ref Linkend="Component_swap_specification"></list.item>
<list.item><internal.ref Linkend="Change_request"></list.item>
<list.item><internal.ref Linkend="Gate_path_swap_specification"></list.item>
<list.item><internal.ref Linkend="Terminal_swap_specification"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY change_to_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(aa <* 
        USEDIN(SELF\action_request_assignment.assigned_action_request,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')
        |'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'CHANGE_FROM_DESIGN_OBJECT_REQUEST_ASSIGNMENT' 
         IN TYPEOF(aa))) >= 1;
   WR2: SIZEOF(QUERY ( pdr <* SELF.items | 
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND
        (pdr\product_definition_relationship.name = 'design object change'))) = 1;
END_ENTITY; -- change_to_design_object_request_assignment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR"> 
<FORMAL.PROPOSITIONS.RUL> 
SELF\action_request_assignment.assigned_action_request shall also be a 
SELF\action_request_assignment.assigned_action_request for a 
change_from_design_object_request_assignment.
</FORMAL.PROPOSITIONS.RUL> 

<FORMAL.PROPOSITIONS.RUL>
The change_to_design_object_request_assignment shall have exactly one item
that is a product_definition_relationship with a name of 'design object change'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP"> 
<INFORMAL.PROPOSITIONS.RUL>
The change_to_design_object_request_assignment shall have exactly one item that is a
managed_design_object that is not a product_definition_relationship 
with a name of 'design object change' and is not referenced by 
another product_definition_relationship with a name of 
'design object addition', 'design object change', or 'design object deletion'
in the same design that is not an item of a action_request_assignment with the same assigned_action_request.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="characteristic_type">
<ENTITY.DESCRIPTION>
A characteristic_type is a group that specifies a boolean property, a numeric property whose units are in accordance with ISO 10303-41, a compound characteristic, a
logical property, a string property, or an externally defined property for a characteristic.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY characteristic_type
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN [
       'string property',
       'logical property',
       'boolean property',
       'numeric property',
       'externally defined property',
       'compound characteristic'
        ];
END_ENTITY; -- characteristic_type
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
A characteristic_type shall have a name that is 
'string property', 
'logical property', 
'boolean property',
'numeric property',
'externally defined property' or
'compound characteristic'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="characterized_product_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A characterized_product_category is a characterized_object and a 
product_category that implements the ARM concept
of <internal.ref Linkend="Ee_product_category">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY characterized_product_category
  SUBTYPE OF (characterized_object,product_category);
WHERE
  WR1:  SIZEOF (QUERY (pd <* USEDIN (SELF,
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'PROPERTY_DEFINITION.DEFINITION') | 
   (pd\property_definition.description = 'product category values') AND
   (SIZEOF (QUERY (pdr <* USEDIN (pd,
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
   'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'PARAMETER_ASSIGNMENT_REPRESENTATION'
   IN TYPEOF (pdr.used_representation)))) >= 1 ))) <= 1;

  WR2:  SIZEOF (QUERY (pd <* USEDIN (SELF,
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
   'PROPERTY_DEFINITION.DEFINITION') | 
   ((pd\property_definition.description = 'product category parameters') AND
   (SIZEOF (QUERY (pdr <* USEDIN (pd,
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
   (SIZEOF (QUERY (ri <* pdr.used_representation.items
   | (NOT (SIZEOF (TYPEOF (ri) *
   ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MODEL_PARAMETER']) =1)) )) =0))) >= 1 )))) <= 1;

  WR3: SELF\characterized_object.name = SELF\product_category.name;

  WR4:  SIZEOF (USEDIN (SELF,
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1; 

END_ENTITY; -- characterized_product_category
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The characterized_product_category shall be referenced by no more than one
property_definition that has a description of 'product category values' that
shall reference one or more parameter_assignment_representation.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The characterized_product_category shall be referenced by no more than one
property_definition that has a description of 'product category parameters' that
shall reference one or more model_parameter.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The name attribute inherited from product_category shall be the same value as the name attribute inherited from characterized_object. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The characterized_product_category shall be referenced by exactly one applied_document_reference.
</FORMAL.PROPOSITIONS.RUL>

<note>
The RULE characterized_product_category_unique_constraint also constrains this entity.
</note>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="circular_runout_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A circular_runout_tolerance is a 
geometric_tolerance_with_specified_datum_system that implements the ARM
concept of <internal.ref Linkend="Circular_runout_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY circular_runout_tolerance
  SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
WHERE
  WR1: SELF\geometric_tolerance.name = 'circular runout';
  WR2: NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
  WR3: SIZEOF (QUERY (pdr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'referenced datum system definition')  AND  
       (pdr.related_property_definition\property_definition.description =
       'datum system property without material conditions'))) = 1;
END_ENTITY; -- circular_runout_tolerance
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name for the circular_runout_tolerance shall be 'circular runout'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.propositions.rul>
The circular_runout_tolerance shall not be a modified_geometric_tolerance.
</FORMAL.propositions.rul>

<FORMAL.propositions.rul>
The circular_runout_tolerance shall relate to exactly one property_definition that has the description of 'datum 
system property without material conditions' to specify the 'referenced datum system definition'.
</FORMAL.propositions.rul>
</FORMAL.PROPOSITIONS>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The toleranced_shape_aspect of the circular_runout_tolerance shall either be a 
part_template_definition, lie on the boundary of the shape of the product, or be 
a composite_shape_aspect the 'composing' shape_aspects of which are all of type part_template_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
The circular_runout_tolerance shall have at most two physical_unit_datum in its referenced 
datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
The circular_runout_tolerance shall have at least one physical_unit_datum in its referenced 
datum_system that has description of 'axis'.
</Informal.propositions.rul>


<Informal.propositions.rul>
The tolerance_zone_boundary of the circular_runout_tolerance shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_definition">
<ENTITY.DESCRIPTION>
A component_definition is a product_definition that represents a product
that is used in an assembly.  The component_definition entity implements
the ARM concepts of:
<list>
<list.item><Internal.ref Linkend="Array_placement_group"></list.item>
<list.item><Internal.ref Linkend="Assembly_component"></list.item>
<list.item><Internal.ref Linkend="Assembly_group_component"></list.item>
<list.item><Internal.ref Linkend="Assembly_module_component"></list.item>
<list.item><Internal.ref Linkend="Assembly_module_macro_component"></list.item>
<list.item><Internal.ref Linkend="Bare_die_component"></list.item>
<list.item><Internal.ref Linkend="Cable_component"></list.item>
<list.item><Internal.ref Linkend="Interconnect_module_component"></list.item>
<list.item><Internal.ref Linkend="Interconnect_module_macro_component"></list.item>
<list.item><Internal.ref Linkend="Interface_component"></list.item>
<list.item><Internal.ref Linkend="Interfaced_group_component"></list.item>
<list.item><Internal.ref Linkend="Mating_connector_component"></list.item>
<list.item><Internal.ref Linkend="Physical_component"></list.item>
<list.item><Internal.ref Linkend="Physical_laminate_component"></list.item>
<list.item><Internal.ref Linkend="Routed_interconnect_component"></list.item>
<list.item><Internal.ref Linkend="Routed_physical_component"></list.item>
<list.item><Internal.ref Linkend="Thermal_component"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_definition
  SUPERTYPE OF (ONEOF (printed_component, packaged_component, routed_physical_component)
                ANDOR (thermal_component) ANDOR (cable_component))
  SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = 'planar projected shape')) 
       <= 1))) = 0;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = '3d bound volume shape')) 
       <= 1))) = 0;
  WR3: (NOT (SELF\product_definition.description = 
                                         'bare die component')) OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_BARE_DIE'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1);
  WR4: NOT(is_assembly_module_occurrence(SELF))
       OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage') AND
       (ip.relating_product_definition\product_definition.name = 
          'assembly module')
       )) = 1);
  WR5: NOT(is_assembly_module_occurrence(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN 
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'assembly module component terminal'))) 
       >= 2)) >= 1);
  WR6: NOT(is_interconnect_module_occurrence(SELF))
       OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage') AND
        (SELF\product_definition.name = 'interconnect module')
       )) = 1);
  WR7: (NOT (SELF\product_definition.description = 'mating connector')) OR
       ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF)) AND
       (SIZEOF (QUERY (doc <* 
   SELF\product_definition_with_associated_documents.documentation_ids |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EE_SPECIFICATION' IN 
       TYPEOF (doc))) = 1)) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'part template occurrence') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |  
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description = 
       'printed connector template'))) = 1)) = 1))) = 0) OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition\product_definition.description =
       'packaged connector'))) = 1));
  WR8: (NOT (SELF\product_definition.description = 'mating connector')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name  = 
       'mating connector placement')) = 1)) = 1);
 WR9: (NOT (SELF\product_definition.description = 'mating connector')) OR
       ((SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr))) = 0) AND
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr))) = 0));
 WR10: SIZEOF(QUERY(pdr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        NOT(NOT(pdr\product_definition_relationship.name = 'instantiated part')
        OR 
        (SELF.formation :=: 
        pdr.relating_product_definition.formation))))
        = 0;
 WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       (sr_pdr.used_representation\representation.name = 
        'part template non planar 2d shape')
       OR
       (sr_pdr.used_representation\representation.name = 'non planar 2d shape')
       OR
       (sr_pdr.used_representation\representation.name = 
        'open shell based surface'))) 
       <= 1))) = 0;
 WR12: NOT(SELF.frame_of_reference.name = 'layout occurrence') OR
       ((SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF)));
 WR13: NOT((SELF.frame_of_reference.name = 'layout occurrence') 
          AND
       NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_COMPONENT' IN TYPEOF(SELF))) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ((SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (sa)) >= 1)) 
        )) = 1))) = 0);

 WR14: NOT(is_assembly_module_macro_occurrence(SELF))
       OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design definition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design') AND
       (ip.relating_product_definition\product_definition.name = 
           'assembly module')
       )) = 1);
 WR15: NOT(is_interconnect_module_macro_occurrence(SELF))
        OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design definition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design') AND
       (ip.relating_product_definition\product_definition.name = 
             'interconnect module')
        )) = 1);
 WR16: SIZEOF(QUERY(pdr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        ((pdr\product_definition_relationship.name = 'instantiated definition')
        AND
        (NOT(SELF.formation :=:
        pdr.relating_product_definition.formation)))))
        = 0;
 WR17: (NOT (SELF\product_definition.description =
                                         'routed interconnect component')) OR
       ((SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1) AND
       (SELF.frame_of_reference.name = 'physical occurrence'));
END_ENTITY; -- component_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_definition shall have at most one shape_representation with a name of 'planar projected shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_definition shall have at most one shape_representation
with a name of '3d bound volume shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a description of 'bare die component',
the component_definition shall be related, as the 'instantiated part', to
exactly one bare_die, externally_defined_bare_die, or
library_defined_bare_die; that is in the 'physical design usage'
product_definition_context.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition is in the 'physical occurrence'
product_definition_context and has a name of 
'assembly module', the component_definition shall be
related, as the 'instantiated part', to exactly one physical_unit that is
in the 'physical design usage' product_definition_context and has a name of 
'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a frame_of_reference name of 'physical
occurrence' and it is associated with a product that is categorized as an
'assembly module', it shall have at least two shape_aspects that are
component_terminals with a description of 'assembly module component
terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition is in the 'physical occurrence'
product_definition_context and has a name of 
'interconnect module', the component_definition shall be
related, as the 'instantiated part', to exactly one physical_unit that is
in the 'physical design usage' product_definition_context and has a
name that is 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a description of 'mating connector', it
shall be of type product_definition_with_associated_documents that contains
exactly one ee_specification, or it shall have exactly one shape_aspect with a
description of 'part template occurrence' and is related to exactly one 
part_template_definition with a description of 'printed connector template' 
as the
'instantiated template', or it shall be related to exactly one packaged_part,
externally_defined_packaged_part, or library_defined_packaged_part with a
description of 'packaged connector' as the 'instantiated part'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a description of 'mating connector',
it shall have exactly one shape_representation with a name of
'mating connector placement'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a description of 'mating connector',
it shall not participate in a next_assembly_usage_occurance.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition is the related_product_definition of a
product_definition_relationship that has a name of 'instantiated part',
it shall have the same formation as the relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_definition shall have at most one shape_representation with a name of 'part template non planar 2d shape' or of 'open shell based surface'
or of 'non planar 2d shape'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a frame_of_reference with a name of 'layout occurrence',
the component_definition shall be a definition of a product that is categorized as a 'template model'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a frame_of_reference with a name of 'layout occurrence',
and if the component_definition is not a printed_component, 
the component_definition shall have exactly one component_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
If the component_definition is in the 'macro occurrence'
product_definition_context and has a name of 
'assembly module', the component_definition shall be
related, by the 'design definition' relationship, to exactly one physical_unit that is
in the 'physical design ' product_definition_context and has a
name of 'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition is in the 'macro occurrence'
product_definition_context and has a name of 
'interconnect module', the component_definition shall be
related, by the 'design definition' relationship, to exactly one physical_unit that is
in the 'physical design ' product_definition_context and has a name of 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition is the related_product_definition of a
product_definition_relationship that has a name of 'instantiated definition',
it shall have the same formation as the relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_definition has a description of 'routed interconnect component', it shall be related to a physical_unit as an 'instantiated part' and shall be in the 'physical occurrence' context. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<Informal.Propositions Rule.Types="IP">

<INFORMAL.PROPOSITIONS.RUL>
The assembly referenced by the assembly composition relationship that references this component definition shall be the same assembly as that referenced by the shape that is referenced by the component position that references that assembly_composition_relationship.
</INFORMAL.PROPOSITIONS.RUL>
<INFORMAL.PROPOSITIONS.RUL>
If the component_definition has a description of 'routed interconnect component', it shall have exactly one property_definition that is associated to exactly one representation.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_feature">
<ENTITY.DESCRIPTION>
A component_feature is a shape_aspect.  A component_feature
implements the ARM concept of<Internal.ref Linkend="Component_feature"> when no ARM subtype is
implemented.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_feature
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
END_ENTITY; -- component_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_feature shall be an aspect of the shape of a component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_feature shall be related to at most one shape_aspect as an 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_feature_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A component_feature_relationship is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Component_feature_relationship">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_feature_relationship
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\component_feature_relationship)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
END_ENTITY; -- component_feature_relationship 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of component_feature_relationship shall be only component_feature_relationship, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_functional_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A component_function_terminal is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Functional_unit_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_functional_terminal
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_UNIT' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated terminal') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'
       IN TYPEOF (it.relating_shape_aspect))) = 1;
  WR3: SIZEOF (QUERY (futba <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'functional unit terminal bus assignment') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION' IN 
       TYPEOF (futba.relating_property_definition.definition))) <= 1;
  WR4: SIZEOF (QUERY (futna <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'functional unit terminal node assignment') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NETWORK_NODE_DEFINITION' IN 
       TYPEOF (futna.relating_property_definition.definition))) <= 1;
END_ENTITY; -- component_functional_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_functional_terminal shall be an aspect of the shape of a
component_functional_unit.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_functional_terminal shall be related to exactly one
functional_unit_terminal_definition as the 'instantiated terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_functional_terminal shall be related to at most one
property of a bus_structural_definition as the 
'functional unit terminal bus assignment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_functional_terminal shall be related to at most one 
property of a network_node_definition as the
'functional unit terminal node assignment'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_functional_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A component_functional_unit is a product_definition that implements the ARM
concept of <internal.ref Linkend="Functional_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_functional_unit
  SUBTYPE OF (product_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'functional occurrence';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL' IN
       TYPEOF (sa))) >= 1)) >= 1;
  WR3: SIZEOF (QUERY (ifu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated functional unit') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifu.relating_product_definition))) = 1;
  WR4: SIZEOF (QUERY (nc <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'network composition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (nc.relating_product_definition)) AND
       (nc.relating_product_definition.frame_of_reference.name =
       'functional network design'))) = 1;
END_ENTITY; -- component_functional_unit
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_functional_unit shall have the context element named
'functional occurrence'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_functional_unit shall have at least one
component_functional_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_functional_unit shall be related to exactly one
functional_unit as the 'instantiated functional unit'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_functional_unit shall be related to exactly one
functional_unit that has a context element with a name of 'functional network
design' as the 'network composition'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_interface_terminal">
<ENTITY.DESCRIPTION>
A component_interface_terminal is a shape_aspect that implements the ARM
concepts of:
<list>
<list.item><internal.ref Linkend="Component_interface_terminal"></list.item>
<list.item><internal.ref Linkend="Interconnect_component_interface_terminal"></list.item>
<list.item><internal.ref Linkend="Packaged_connector_component_interface_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_interface_terminal
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN [
       'interconnect component interface terminal',
       'packaged connector component interface terminal'];
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN 
       TYPEOF (SELF.of_shape.definition);
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
  WR4: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design usage')) <= 1;
  WR5: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_COMPONENT_DEFINITION' IN 
       TYPEOF (SELF.of_shape.definition));
  WR6: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (SELF.of_shape.definition\product_definition.
        frame_of_reference.name = 
       'physical occurrence');
  WR7: (NOT (SELF\shape_aspect.description = 
       'interconnect component interface terminal')) OR
       ((SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1)
       AND 
       NOT(SELF.of_shape.definition\product_definition.description 
       IN ['assembly module component', 'bare die component',
       'interconnect module component', 'laminate component',
       'packaged component']));
  WR8: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (SELF.product_definitional);
  WR9: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_COMPONENT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.description = 
       'packaged connector component') AND
       (SELF.of_shape.definition\product_definition.
       frame_of_reference.name = 
       'physical occurrence'));
 WR10: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'interface terminal'))) = 1);
END_ENTITY; -- component_interface_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_interface_terminal shall have a description of
'interconnect component interface terminal' or 'packaged connector component
interface terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_interface_terminal shall be an aspect of the shape of a
component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_interface_terminal shall be related to at most
one shape_aspect as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_interface_terminal shall relate to at most one
shape_aspect to specify the 'design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the name of the component_interface_terminal is 'interconnect
component interface terminal', it shall be an aspect of the shape of an
interface_component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the name of the component_interface_terminal is 'interconnect
component interface terminal', it shall be an aspect of the shape of a
product_definition with a frame_of_reference name of 'physical occurrence'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_interface_terminal has a description of
'interconnect component interface terminal', the
component_interface_terminal shall relate to exactly one shape_aspect that
has a description of 'connection zone' and that is associated with a
product that is categorized as an 'interconnect module' and does not
have a description of 'assembly module component', 'bare die component',
'interconnect module component', 'laminate component', or 'packaged component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the name of the component_interface_terminal is 'packaged connector
component interface terminal', it shall lie on the boundary of the shape of
the component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_interface_terminal has a description of 'packaged
connector component interface terminal', it shall be an aspect of the shape of
a packaged_component that has a description of 'packaged connector component'
and a frame_of_reference name of 'physical occurrence'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_interface_terminal has a description of 'packaged
connector component interface terminal', the component_interface_terminal
shall be related to exactly one packaged_part_terminal with a description
of 'interface terminal' as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_location">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A component_location is a representation that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Component_2d_edge_location"></list.item>
<list.item><internal.ref Linkend="Component_2d_location"></list.item>
<list.item><internal.ref Linkend="Component_2d_stacked_location"></list.item>
<list.item><internal.ref Linkend="Component_3d_location"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_location
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'placement fixed') AND 
       ((it\descriptive_representation_item.description = 'true') OR
       (it\descriptive_representation_item.description = 'false')))) = 1;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)))) = 1;
  WR3: (NOT 
       (SELF.context_of_items\geometric_representation_context.
       coordinate_space_dimension
       = 2)) OR (SIZEOF (QUERY (it <* SELF.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (it))) = 1);
  WR4: (NOT 
       (SELF.context_of_items\geometric_representation_context.
       coordinate_space_dimension
        = 3)) OR (SIZEOF (QUERY (it <* SELF.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (it))) = 1);
  WR5: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM'
       IN TYPEOF (it)) 
       )) = 1;
  WR6: NOT (SIZEOF (QUERY (it <* SELF.items |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (it))) = 1)
        OR
        (SIZEOF (QUERY (cto2d <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D'
        IN TYPEOF (cto2d)) AND
        (SIZEOF (QUERY (mi <* USEDIN (cto2d,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM.MAPPING_TARGET') | (
       (SIZEOF (QUERY (cl <* USEDIN (mi,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') |(cl = SELF))) = 1)))) >= 1)
        )) = 1);
  WR7: NOT (SIZEOF (QUERY (it <* SELF.items |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (it))) = 1)
      OR
       (SIZEOF (QUERY (cto2d <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'AXIS2_PLACEMENT_3D'
        IN TYPEOF (cto2d)) AND
        (SIZEOF (QUERY (mi <* USEDIN (cto2d,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM.MAPPING_TARGET') | (
       (SIZEOF (QUERY (cl <* USEDIN (mi,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') |(cl = SELF))) = 1)))) = 1)
        )) = 1);
  WR8:NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2) AND 
          (SELF.context_of_items.context_type = 'component surface') AND
        (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'mounting surface assembly joint') AND
       (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
         'interconnect module component surface feature') AND
       (SIZEOF(QUERY ( sar <* USEDIN (pdr.definition.definition.relating_shape_aspect,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        ((sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module primary surface') OR
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge surface') OR
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge segment surface')))) = 1)
       )
       )) = 1)))
       OR
       (SIZEOF(QUERY (cto2d <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);
  WR9:NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2) AND 
          (SELF.context_of_items.context_type = 'component surface') AND
         (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'mounting surface assembly joint') AND
       (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
         'interconnect module component surface feature') AND
       (SIZEOF(QUERY ( sar <* USEDIN (pdr.definition.definition.relating_shape_aspect,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module secondary surface')) = 1)
       ))) = 1)))
       OR
    (SIZEOF(QUERY( cto2d <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,-1.0,0.001 )))) = 1);
  WR10: (NOT(is_laminate_component_location(SELF))) OR
      (SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
      (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
        'interconnect module component surface feature'))) = 0);
  WR11: (NOT(is_laminate_component_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);
  WR12: SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.definition.definition\shape_aspect.description =
        'interconnect module component surface feature'))) = 0;
  WR13: (NOT((SELF.context_of_items\geometric_representation_context.
        coordinate_space_dimension = 2) AND
        (SELF.context_of_items.context_type = 'component stacked')))
        OR 
      (SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
      (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
        'interconnect module component surface feature'))) = 0);
 WR14: NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)
          AND
         (SELF.context_of_items.context_type = 'component edge'))
       OR
        ((NOT(is_laminate_component_location(SELF)))
          AND
       (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'reference terminal assembly joint') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_TERMINAL' IN 
                      TYPEOF (pdr.definition.definition.related_shape_aspect)) 
         AND
       (pdr.definition.definition.related_shape_aspect\shape_aspect.description IN
       ['packaged component join terminal',
       'package terminal occurrence'])
         AND
       (SIZEOF(QUERY ( sar <* USEDIN 
                          (pdr.definition.definition.related_shape_aspect,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name = 'instantiated feature')
           AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF (sar.relating_shape_aspect))
         )) = 1)
         AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_DEFINITION' IN
         TYPEOF (pdr.definition.definition.related_shape_aspect.of_shape.definition))
         AND
       (component_definition_located_by_component_location(SELF) =
                 pdr.definition.definition.related_shape_aspect.of_shape.definition) 
       ))) = 1))
         AND
       (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'mounting surface assembly joint') AND
       (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
         'interconnect module component surface feature') AND
       (SIZEOF(QUERY ( sar <* USEDIN (pdr.definition.definition.relating_shape_aspect,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge surface') OR
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge segment surface'))) = 1)
         AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_MOUNTING_FEATURE' IN 
                      TYPEOF (pdr.definition.definition.related_shape_aspect)) 
         AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_DEFINITION' IN
         TYPEOF (pdr.definition.definition.related_shape_aspect.of_shape.definition))
         AND
       (component_definition_located_by_component_location(SELF) =
                 pdr.definition.definition.related_shape_aspect.of_shape.definition) 
       ))) = 1))
      );
 WR15: NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)
          AND
         (SELF.context_of_items.context_type = 'component stacked'))
       OR
        ((NOT(is_laminate_component_location(SELF)))
          AND
       (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition))
         AND
       ('mounting joint' = pdr.name)
         AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_MOUNTING_FEATURE' IN
                      TYPEOF (pdr.definition.definition.related_shape_aspect))
         AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_DEFINITION' IN
         TYPEOF (pdr.definition.definition.related_shape_aspect.of_shape.definition))
         AND
       (component_definition_located_by_component_location(SELF) :=:
                 pdr.definition.definition.related_shape_aspect.of_shape.definition)    
         AND
       (component_definition_located_by_component_location(SELF) :<>: 
                 pdr.definition.definition.relating_shape_aspect.of_shape.definition)    
       )
      )) = 1))
        );
 WR16: (NOT(is_interconnect_module_component_location(SELF))) OR
      (SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
      (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
        'interconnect module component surface feature'))) = 0);
 WR17: NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)
          AND
         (SELF.context_of_items.context_type = 'component stacked'))
       OR
       (SIZEOF(QUERY (cto2d <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      ((cto2d_determinant_test(cto2d,1.0,0.001 )) OR
      (cto2d_determinant_test(cto2d,-1.0,0.001 )))
      )) = 1);
 WR18 : SIZEOF (QUERY (it <* SELF\representation.items| NOT
     (SIZEOF(
    ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'CARTESIAN_TRANSFORMATION_OPERATOR_2D', 
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'MAPPED_ITEM', 
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'DESCRIPTIVE_REPRESENTATION_ITEM', 
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'AXIS2_PLACEMENT_3D'] 
     * TYPEOF(it)) = 1 ))) = 0;
 WR19: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_3D'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'origin') 
       )) = 0;
 WR20: SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM'
       IN TYPEOF (it))
       AND NOT
       (((it\representation_item.name = 'component assembly 2d position')
        OR
       (it\representation_item.name = 'component assembly 3d position'))
       AND
       (it.mapping_source.mapping_origin\representation_item.name = 'origin')
       AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_2D' IN TYPEOF (it.mapping_source.mapping_origin))
        OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (it.mapping_source.mapping_origin))))
       )) = 0;
 WR21: SIZEOF(QUERY(pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN 
            TYPEOF(pdr.definition.definition))
       )) = 1;
END_ENTITY; -- component_location
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<!-- 1 -->
<FORMAL.PROPOSITIONS.RUL>
The component_location shall contain exactly one descriptive_representation_item with a name 'placement fixed' and the description of that descriptive_representation_item shall be either 'true' or 'false'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_location shall contain exactly one descriptive_representation_item.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2, it shall contain exactly one cartesian_transformation_operator_2d.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 3, it shall contain exactly one axis2_placement_3d.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_location shall contain exactly one mapped_item.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_location that contains a cto2d shall contain exactly one mapped_item that specifies the cto2d.
</FORMAL.PROPOSITIONS.RUL>

<!-- 7 -->
<FORMAL.PROPOSITIONS.RUL>
The component_location that contains an a2p3d shall contain exactly one mapped_item that specifies the a2p3d.
</FORMAL.PROPOSITIONS.RUL>

<!-- 8 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2 and if the component_location references a primary surface, edge surface, or edge segment surface, the determinant of the cto2d shall be +1.0 within a delta of 0.001.
</FORMAL.PROPOSITIONS.RUL>

<!-- 9 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2 and if the component_location references a secondary surface, the determinant of the cto2d shall be -1.0 within a delta of 0.001.
</FORMAL.PROPOSITIONS.RUL>

<!-- 10 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location is the location of the implementation of the ARM concept of Laminate_component, it shall not be associated with a component_shape_aspect where the description is 'interconnect module component surface feature'.
</FORMAL.PROPOSITIONS.RUL>

<!-- 11 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2 and is the location of the implementation of the ARM concept of Laminate_component, the determinant of the cto2d shall be +1.0 within a delta of 0.001.
</FORMAL.PROPOSITIONS.RUL>

<!-- 12 -->
<FORMAL.PROPOSITIONS.RUL>
The component_location shall not directly reference any component_shape_aspect where the description is 'interconnect module component surface feature'.
</FORMAL.PROPOSITIONS.RUL>

<!-- 13 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2 and a context_type of 'component stacked', it shall not reference a component_shape_aspect where the description is 'interconnect module component surface feature'.
</FORMAL.PROPOSITIONS.RUL>

<!-- 14 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2 and a context_type of 'component edge', it shall be associated with exactly one assembly_joint where the assembly_joint shall specify with the related_shape_aspect a component_terminal that is defined by a primary_reference_terminal.  
The component_location shall be associated with a component_shape_aspect where the description is 'interconnect module component surface feature' that is defined by an edge or edge_segment of an interconnect module.
The component_terminal specified by the related_shape_aspect of the assembly_joint shall be a component_terminal of the component_definition being located by this component_location.
</FORMAL.PROPOSITIONS.RUL>

<!-- 15 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2 and a context_type of 'component stacked', it shall be associated with exactly one assembly_joint where the assembly_joint shall specify with the related_shape_aspect a component_mounting_feature.
The component_mounting_feature referenced by the assembly_joint related_shape_aspect shall be a component_mounting_feature of the component_definition being located by this component_location.  The relating_shape_aspect of the assembly_joint shall specify a component_feature of a component_definition that is not being located by this component_location.
<note>
The base component of the stack is not considered to be stacked.  The assembly_joint referenced to support stacking are directed for stack traversal.
</note>
<example>
In this example, three bare die are vertically mounted on top of a substrate.
The substrate is not considered to be part of the stack.
The first bare die is not considered to be 'stacked'.  The component_location references the substrate.
The second bare die is considered to be 'stacked'.  The component_location references an assembly_joint. 
The related_shape_aspect of the assembly_joint references the second bare die, and the relating_shape_aspect of the assembly_joint references the first bare die.
The third bare die is considered to be 'stacked'.  The component_location references a different assembly_joint.
The related_shape_aspect of the assembly_joint references the third bare die, and the relating_shape_aspect of the assembly_joint references the second bare die.
</example>
</FORMAL.PROPOSITIONS.RUL>

<!-- 16 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location is the location of the implementation of the ARM concept of Interconnect_module_component, it shall not be associated with a component_shape_aspect where the description is 'interconnect module component surface feature'.
</FORMAL.PROPOSITIONS.RUL>

<!-- 17 -->
<FORMAL.PROPOSITIONS.RUL>
If the component_location has a geometric_representation_context with a coordinate_space_dimension value of 2 and a context_type of 'component stacked', the determinant of the cto2d shall be +1.0 or -1.0, in either case within a delta of 0.001. 
</FORMAL.PROPOSITIONS.RUL>

<!-- 18 -->
<FORMAL.PROPOSITIONS.RUL>
The items in a component_location shall be a mapped_item, a descriptive_representation_item, a cartesian_transformation_operator_2d, or an axis2_placement_3d.
</FORMAL.PROPOSITIONS.RUL>

<!-- 19 -->
<FORMAL.PROPOSITIONS.RUL>
The axis2_placement_3d shall not have a name of 'origin'.
<note>
This does not prohibit placing the component at the origin.  It prohibits an axis2_placement_3d that is in the role of 'origin' from serving as the location.
</note>
</FORMAL.PROPOSITIONS.RUL>

<!-- 20 -->
<FORMAL.PROPOSITIONS.RUL>
The representation_item used as a mapping_source shall be either an axis2_placement_2d or shall be an axis2_placement_3d and it shall have a name of 'origin'.
</FORMAL.PROPOSITIONS.RUL>

<!-- 21 -->
<FORMAL.PROPOSITIONS.RUL>
The component_location shall be used by exactly one next_assembly_usage_occurrence.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_mating_constraint_condition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A component_mating_constraint_condition is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Component_mating_constraint_condition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_mating_constraint_condition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
END_ENTITY; -- component_mating_constraint_condition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within the context of the product_definition_shape referenced as of_shape inherited from the shape_aspect supertype.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_mating_constraint_condition shall relate to at least one and no more than three assembly_joint
to specify the 'constraining_joint'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_mating_constraint_condition shall be related to at least one and no more than five representation_items to describe the 'degree of freedom' constrained. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_mating_constraint_condition shall not be any other type of shape_aspect. 
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_mounting_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A component_mounting_feature is a shape_aspect.  A component_mounting_feature
implements the ARM concept of<Internal.ref Linkend="Component_mounting_feature">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_mounting_feature
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROBE_ACCESS_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND'] * 
       TYPEOF (SELF)) = 0);
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = 
       'planar projected shape')) 
       <= 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = '3d bound volume shape')) 
       <= 1))) = 0;
  WR5: (NOT (SELF\shape_aspect.description IN ['component feature'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design usage')) <= 1);
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
END_ENTITY; -- component_mounting_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_mounting_feature shall be an aspect of the shape of a component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_mounting_feature shall not be any of the following: inter_stratum_feature,
probe_access_area, land.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_mounting_feature shall have at most one shape_representation
with a name of 'planar projected shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_mounting_feature shall have at most one shape_representation
with a name of '3d bound volume shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_mounting_feature has a description of 'component feature',
it shall relate to at most one shape_aspect to specify the
'design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_mounting_feature shall be related to at most one shape_aspect as an 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_shape_aspect">
<ENTITY.DESCRIPTION>
A component_shape_aspect is a shape_aspect.  A component_shape_aspect
implements the ARM concepts of:
<list>
<list.item><Internal.ref Linkend="Conductive_interconnect_element"></list.item>
<list.item><Internal.ref Linkend="Conductive_interconnect_element_with_pre_defined_transitions"></list.item>
<list.item><Internal.ref Linkend="Conductive_interconnect_element_with_user_defined_single_transition"></list.item>
<list.item><Internal.ref Linkend="Join_two_physical_connectivity_definition_supporting_printed_component"></list.item>
<list.item><Internal.ref Linkend="Laminate_component"></list.item>
<list.item><Internal.ref Linkend="Laminate_text_component"></list.item>
<list.item><Internal.ref Linkend="Laminate_text_string_component"></list.item>
<list.item><Internal.ref Linkend="Primary_stratum_indicator_symbol"></list.item>
<list.item><Internal.ref Linkend="Special_symbol_laminate_component"></list.item>
<list.item><Internal.ref Linkend="Stratum_feature_template_component"></list.item>
<list.item><Internal.ref Linkend="Thermal_component"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_shape_aspect
  SUPERTYPE OF (ONEOF (land, connected_area_component, inter_stratum_feature)
                ANDOR (thermal_component_shape_aspect))
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FIDUCIAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONNECTED_AREA_COMPONENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'THERMAL_COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTEGRAL_SHIELD',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROBE_ACCESS_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND'] * 
       TYPEOF (SELF)) >= 1) OR
       (SELF\shape_aspect.description IN [
       'part template occurrence', 
       'laminate component', 
       'laminate text component', 
       'laminate text string component', 
       'conductive interconnect element with pre defined transitions', 
       'join 2 physical connectivity definition supporting',
     'conductive interconnect element with user defined single transition',
      'special symbol laminate component', 
       'primary stratum indicator symbol', 
       'stratum feature template component']);
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = 'planar projected shape')) 
       <= 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = '3d bound volume shape')) 
       <= 1))) = 0;
  WR5: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description IN ['laminate text component', 
       'laminate text string component', 
       'special symbol laminate component', 
       'primary stratum indicator symbol',  
       'stratum feature template component']) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.description = 
                  'laminate component')
       ));
  WR6: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description = 
       'laminate text component') OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEXT_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)))) = 1));
  WR7: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description IN
       ['stratum feature template component']) OR
       (SIZEOF (QUERY (sfi <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'stratum feature implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (sfi.relating_shape_aspect)))) = 1));
  WR8: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description IN
       ['conductive interconnect element with pre defined transitions', 
       'join 2 physical connectivity definition supporting',
       'conductive interconnect element with ' +
       'user defined single transition']) OR
       (SIZEOF (QUERY (cc <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed conductor') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (cc.related_shape_aspect)))) = 1));
(*
  WR9: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description IN
       ['conductive interconnect element with pre defined transitions', 
       'join 2 physical connectivity definition supporting',
       'conductive interconnect element with user ' +
       'defined single transition']) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF)|
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'conductive interconnect element terminal')))) >= 2));
*)
 WR10: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description IN
       ['special symbol laminate component',
       'primary stratum indicator symbol']) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.related_shape_aspect\shape_aspect.description =
       'special symbol part template')))) = 1));
 WR11: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description = 
       'stratum feature template component') OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'stratum feature template')) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)))) <= 1));
 WR12: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description IN
       ['laminate text component']) OR
       (SIZEOF (QUERY (sfi <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'stratum feature implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (sfi.relating_shape_aspect)))) >= 1));
 WR13: NOT ((SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FIDUCIAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONNECTED_AREA_COMPONENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'THERMAL_COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTEGRAL_SHIELD',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROBE_ACCESS_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND'] *
       TYPEOF (SELF)) >= 1) OR
       (SELF\shape_aspect.description IN [
       'laminate component',
       'laminate text component',
       'laminate text string component',
       'conductive interconnect element with pre defined transitions', 
       'join 2 physical connectivity definition supporting',
     'conductive interconnect element with user defined single transition',
      'special symbol laminate component',
       'primary stratum indicator symbol',
       'stratum feature template component'])) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\
        product_definition.frame_of_reference\
        application_context_element.name = 'layout occurrence'));
 WR14: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template')) <= 1;
 WR15: NOT(EXISTS(SELF\shape_aspect.description)) OR 
       (NOT (SELF\shape_aspect.description =
       'join 2 physical connectivity definition supporting') OR
       (SIZEOF ( QUERY (propd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (ri <* QUERY (propdr <* USEDIN (propd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       propdr\property_definition_relationship.name = 'requirement implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP' IN
       TYPEOF (ri.relating_property_definition.definition)) AND
       (ri.relating_property_definition.definition\shape_aspect_relationship.name =
       'ordered physical connectivity definition') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION'
       IN TYPEOF (ri.relating_property_definition.definition.
       related_shape_aspect)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF
       (ri.relating_property_definition.definition.
       relating_shape_aspect)))) = 1))) = 1));
END_ENTITY; -- component_shape_aspect
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_shape_aspect shall be an aspect of the shape of a component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_shape_aspect shall be an inter_stratum_feature, probe_access_area, or land, or fiducial, or assembly_group_component_shape_aspect, or material_removal_component_shape_aspect,
or integral_shield, or thermal_component_shape_aspect or connected_area_component, or it shall have a
description of 
'laminate component',
'laminate text component', 'laminate text string component', 'part template occurrence',
'conductive interconnect element with pre defined transitions', 
'join 2 physical connectivity definition supporting',
'conductive interconnect element with user defined single transition', 
'special symbol laminate component', 'primary stratum
indicator symbol', or 'stratum feature template component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_shape_aspect shall have at most one shape_representation
with a name of 'planar projected shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_shape_aspect shall have at most one shape_representation
with a name of '3d bound volume shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 'laminate text
component', 'laminate text string component',
'special symbol laminate component', 'primary stratum indicator
symbol', or 'stratum feature template component', it shall be an aspect of the
shape of a component_definition that is the definition of a product that is
categorized as an 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 'laminate text
component', the component_shape_aspect shall be related to exactly one
part_text_template_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 
'stratum feature template component', the
component_shape_aspect shall be related to exactly one stratum_feature as
the 'stratum feature implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of either
'conductive interconnect element with pre defined transitions',
'join 2 physical connectivity definition supporting' or 'conductive
interconnect element with user defined single transition', the
component_shape_aspect shall relate to exactly one stratum_feature to
specify the 'composed conductor'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of either
'conductive interconnect element with pre defined transitions',
'join 2 physical connectivity definition supporting' or 'conductive
interconnect element with user defined single transition', the
component_shape_aspect shall relate to at least two component_terminal that
have a description of 'conductive interconnect element terminal' to specify
the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of either 'special
symbol laminate component' or 'primary stratum indicator symbol', the
component_shape_aspect shall be related to exactly one part_template_definition with a
description of 'special symbol part template' as an 'instantiated
template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 'stratum feature
template component', the component_shape_aspect shall be related, as an
'instantiated template', to not more than one part_template_definition that has a
description of 'stratum feature template' or to not more than one land_physical_template.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 'laminate text component', the
component_shape_aspect shall be related to at least one stratum_feature as
the 'stratum feature implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect is an inter_stratum_feature, probe_access_area, or land, or fiducial, or assembly_group_component_shape_aspect, or material_removal_component_shape_aspect,
or integral_shield, or thermal_component_shape_aspect, or connected_area_component, or if it has a
description of 'laminate component',
'laminate text component', 'laminate text string component',
'conductive interconnect element with pre defined transitions',
'join 2 physical connectivity definition supporting',
'conductive interconnect element with user defined single transition',
'special symbol laminate component', 'primary stratum
indicator symbol', or 'stratum feature template component', 
it shall be a shape_aspect for a component_definition
with a frame_of_reference of 'layout occurrence'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_shape_aspect shall be related to at most one shape_aspect as an 'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 'join 2 physical connectivity definition supporting', the component_shape_aspect shall have exactly one property_definition that is related, as the 'requirement implementation', 
to exactly one property_definition that is the property of a shape_aspect_relationship that relates one physical_connectivity_definition to another physical_connectivity_definition as an 'ordered physical connectivity definition'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<Informal.Propositions Rule.Types="IP">

<INFORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 'conductive interconnect
element with pre defined transitions', there shall be at least one
shape_aspect_relationship with name of 'connected points' that relates the
component_shape_aspect (as relating_shape_aspect) to one layer_connection_point_link
(as related_shape_aspect). 
</INFORMAL.PROPOSITIONS.RUL>

<INFORMAL.PROPOSITIONS.RUL>
If the component_shape_aspect has a description of 'conductive interconnect 
element with pre defined transitions' or 'conductive interconnect element 
with user defined single transition', each shape_aspect_relationship that
uses the component_shape_aspect as its relating_shape_aspect and has a
name of 'connected points' shall have a unique description.
</INFORMAL.PROPOSITIONS.RUL>

<INFORMAL.PROPOSITIONS.RUL>
The aggregation of design views referenced by the path in the ARM of stratum_feature_implementation.resident_stratum.assembly.assembly shall be the same aggregation of design views as that reference by the path in the ARM of assembly.assembly when the component_shape_aspect is an implementation of the ARM concept of Stratum_feature_template_component
</INFORMAL.PROPOSITIONS.RUL>

</Informal.Propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="component_terminal">
<ENTITY.DESCRIPTION>
A component_terminal is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Assembly_module_component_terminal"></list.item>
<list.item><internal.ref Linkend="Assembly_module_macro_component_join_terminal"></list.item>
<list.item><internal.ref Linkend="Bare_die_component_terminal"></list.item>
<list.item><internal.ref Linkend="Component_terminal"></list.item>
<list.item><internal.ref Linkend="Component_termination_passage_join_terminal"></list.item>
<list.item><internal.ref Linkend="Conductive_interconnect_element_terminal"></list.item>
<list.item><internal.ref Linkend="Interconnect_component_join_terminal"></list.item>
<list.item><internal.ref Linkend="Interconnect_module_component_terminal"></list.item>
<list.item><internal.ref Linkend="Interconnect_module_macro_component_join_terminal"></list.item>
<list.item><internal.ref Linkend="Land_join_terminal"></list.item>
<list.item><internal.ref Linkend="Minimally_defined_component_terminal"></list.item>
<list.item><internal.ref Linkend="Non_functional_land_join_terminal"></list.item>
<list.item><internal.ref Linkend="Package_terminal_occurrence"></list.item>
<list.item><internal.ref Linkend="Packaged_component_join_terminal"></list.item>
<list.item><internal.ref Linkend="Printed_component_join_terminal"></list.item>
<list.item><internal.ref Linkend="Via_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY component_terminal
  SUPERTYPE OF (ONEOF(assembly_module_macro_component_join_terminal,
        interconnect_module_macro_component_join_terminal))
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: (SELF\shape_aspect.description IN 
      ['assembly module component terminal', 
       'bare die component terminal', 
       'component termination passage join terminal', 
       'conductive interconnect element terminal', 
       'interconnect component join terminal', 
       'interconnect module component terminal', 'land join terminal', 
       'minimally defined component terminal',
       'non functional land join terminal', 
       'packaged component join terminal', 
       'printed component join terminal', 'package terminal occurrence',
       'via terminal']) OR
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN
       TYPEOF  (SELF)) OR
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN
       TYPEOF  (SELF));
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF  (SELF.of_shape.definition);
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
  WR4: SIZEOF (QUERY (at <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated terminals') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF (at.relating_shape_aspect))) <= 1;
  WR5: SIZEOF (QUERY (cr <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connectivity requirement') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK' IN
       TYPEOF (cr.relating_shape_aspect))) <= 1;
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design usage')) <= 1;
  WR7: (NOT (SELF\shape_aspect.description IN 
       ['assembly module component terminal', 
       'bare die component terminal', 'package terminal occurrence', 
       'packaged component join terminal', 
       'printed component join terminal'])) OR
       (SELF.product_definitional);
  WR8: (NOT (SELF\shape_aspect.description = 
       'assembly module component terminal')) OR
       ((SELF.of_shape.definition.frame_of_reference.name =
       'physical occurrence') AND
       (EXISTS(SELF.of_shape.definition\product_definition.name)) AND
       (NOT(EXISTS(SELF.of_shape.definition\product_definition.name)) OR
       (SELF.of_shape.definition\product_definition.name =
       'assembly module'))
       );
  WR9: (NOT (SELF\shape_aspect.description = 
       'assembly module component terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)))) = 1);
 WR10: (NOT (SELF\shape_aspect.description = 
       'bare die component terminal')) OR
       (SELF.of_shape.definition\product_definition.description = 
       'bare die component');
 WR11: (NOT (SELF\shape_aspect.description = 
       'bare die component terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)))) = 1);
(*
 WR12: (NOT (SELF\shape_aspect.description = 
       'component termination passage join terminal')) OR
       (
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_PASSAGE' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description =
       'component termination passage'));
*)
 WR13: (NOT (SELF\shape_aspect.description = 
       'component termination passage join terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description =
       'component termination passage template join terminal')) = 1);
(*
  WR14: (NOT (SELF\shape_aspect.description = 
        'conductive interconnect element terminal')) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (associated_component(SELF)) AND
       ((associated_component(SELF).description =
       'conductive interconnect element with pre defined transitions') OR
       (associated_component(SELF).description =
   'conductive interconnect element with user defined single transition')
       ));
*)
 WR15: (NOT (SELF\shape_aspect.description IN
       ['conductive interconnect element terminal',
       'interconnect component join terminal',
       'printed component join terminal'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description =
       'connection zone')) <= 1);
 WR16: (NOT (SELF\shape_aspect.description =
       'interconnect module component terminal')) OR
   ((SELF.of_shape.definition\product_definition.frame_of_reference.name =
       'physical occurrence') AND
       (EXISTS(SELF.of_shape.definition\product_definition.name)) AND
       (NOT(EXISTS(SELF.of_shape.definition\product_definition.name)) OR
       (SELF.of_shape.definition\product_definition.name =
       'interconnect module'))
       );

 WR17: (NOT (SELF\shape_aspect.description =
       'interconnect module component terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)
       )) = 1);
 WR18: (NOT (SELF\shape_aspect.description IN
       ['land join terminal', 'non functional land join terminal'])) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (TRUE)))) = 1);
(*
 WR19: (NOT (SELF\shape_aspect.description = 'land join terminal')) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND' IN
       TYPEOF (associated_component(SELF)));
*)
 WR20: (NOT (SELF\shape_aspect.description = 
       'minimally defined terminal')) OR
       (SIZEOF (QUERY (pdr<* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'part terminal external reference')) = 1);
(*
 WR21: (NOT (SELF\shape_aspect.description = 
       'non functional land join terminal')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description IN
       ['non functional land',
       'via dependent non functional land',
       'via and contact size dependent non functional land',
       'component termination passage dependent non functional land',
       'contact size dependent non functional land',
       'component termination passage and contact size ' +
       'dependent non functional land',
       'unsupported passage dependent non functional land'])))) = 1);
*)
 WR22: (NOT (SELF\shape_aspect.description = 
       'package terminal occurrence')) OR
       (SIZEOF (QUERY (ud <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'usage definition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL' IN
       TYPEOF (ud.relating_shape_aspect)))) = 1);
 WR23: (NOT (SELF\shape_aspect.description IN 
       ['package terminal occurrence',
       'packaged component join terminal'])) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_COMPONENT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.
        frame_of_reference.name = 
       'physical occurrence'));
 WR24: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'join terminal'))) = 1);
 WR25: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2)) <= 2)) <= 1)) <= 1); 
 WR26: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'maximum wire length')) <= 1)) <= 1)) <= 1);
 WR27: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'minimum wire length')) <= 1)) <= 1)) <= 1); 
 WR28: (NOT (SELF\shape_aspect.description = 
       'printed component join terminal')) OR
       ((SELF.of_shape.definition\product_definition.
       frame_of_reference.name =
       'layout occurrence') AND
       (SELF.of_shape.definition\product_definition.
       name = 'interconnect module')
       );
 WR29: (NOT (SELF\shape_aspect.description = 
       'printed component join terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'join terminal'))) = 1);
 WR30: (NOT (SELF\shape_aspect.description = 
       'printed component join terminal')) OR
       (SIZEOF (QUERY (i <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       pdr\shape_aspect_relationship.name = 'implementation') |
       ((SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (i.relating_shape_aspect)) >= 1) AND
       (i.relating_shape_aspect\shape_aspect.description = 
                        'stratum feature template component'))
       )) = 1);
(*
 WR31: (NOT (SELF\shape_aspect.description = 'via terminal')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_PASSAGE' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description IN
       ['buried via', 'interfacial connection',
       'bonded conductive base blind via',
       'non conductive base blind via',
       'plated conductive base blind via'])))) = 1);
*)
 WR32: (NOT (SELF\shape_aspect.description = 'via terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description =
       'via template terminal')) = 1);
 WR33: (NOT (SELF\shape_aspect.description =
       'interconnect component join terminal')) OR
       ((SELF.of_shape.definition\product_definition.
       frame_of_reference.name =
       'physical occurrence') AND
       NOT(SELF.of_shape.definition\product_definition.description 
       IN ['assembly module component', 'bare die component', 
       'interconnect module component', 'laminate component',
       'packaged component']));
 WR34: SIZEOF(QUERY(pd <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') | SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       SIZEOF(QUERY(dri <* pdr.used_representation.items |
       (dri\representation_item.name = 'global swappable') AND 
       (dri\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1)) <= 1;
 WR35: SIZEOF(QUERY(pd <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') | SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       SIZEOF(QUERY(dri <* pdr.used_representation.items |
       (dri\representation_item.name = 'local swappable') AND 
       (dri\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1)) <= 1;
 WR36: SIZEOF(QUERY(pd <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') | SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       SIZEOF(QUERY(dri <* pdr.used_representation.items | dri\representation_item.name = 
       'swap code'
       )) = 1)) = 1)) <= 1;
END_ENTITY; -- component_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall have a description of 'assembly module
component terminal', 'bare die component terminal', 'component termination
passage join terminal', 'conductive interconnect element terminal',
'interconnect component join terminal', 'interconnect module component
terminal', 'land join terminal', 'minimally defined component terminal',
'non functional land join terminal', 'packaged component join terminal',
'printed component join terminal', 'package terminal occurrence',
or 'via terminal' or shall be an assembly_module_macro_component_join_terminal
or shall be an interconnect_module_macro_component_join_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall be an aspect of the shape of a 
component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall be related to at most one
shape_aspect as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall be related to at most one
physical_connectivity_definition as 'associated terminals'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall be related to at most one
physical_network as the 'connectivity requirement'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall relate to at most one shape_aspect to
specify the 'design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'assembly module
component terminal', 'bare die component terminal', 'package terminal
occurrence', 'packaged component join terminal', or 'printed component join
terminal', it shall lie on the boundary of the shape.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'assembly module
component terminal', it shall be an aspect of the shape of a 
component_definition that has a frame_of_reference name of 
'physical occurrence' or it shall be an assembly_module_macro_component_join_terminal
and it shall be an aspect of the shape of a component_definition
that is associated with a product that is a 'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'assembly module
component terminal', the component_terminal shall be related to exactly one
assembly_module_terminal as an 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'bare die component
terminal', it shall be an aspect of the shape of a product_definition that has
a description of 'bare die component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'bare die component
terminal', the component_terminal shall be related to exactly one
bare_die_terminal as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'component
termination passage join terminal', the component_terminal shall be related
to exactly one plated_passage with a description of 'component termination
passage' as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'component
termination passage join terminal', the component_terminal shall be related
to exactly one shape_aspect with a description of 'component termination
passage template join terminal' as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'conductive
interconnect element terminal', the component_terminal shall be related to
exactly one component_shape_aspect with a description of either 'conductive
interconnect element with pre defined transitions' or 'conductive interconnect
element with user defined single transition' as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'conductive
interconnect element terminal', 'interconnect component join terminal' or
'printed component join terminal', the component_terminal shall relate to
zero or one shape_aspect that has a name of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'interconnect module
component terminal', it shall be an aspect of the shape of a 
component_definition that has a frame_of_reference name of 
'physical occurrence' or it shall be an interconnect_module_macro_component_join_terminal
and it shall be an aspect of the shape of a component_definition
that is associated with a product that is a 'interconnect
module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'interconnect module
component terminal', the component_terminal shall be related to exactly one
interconnect_module_terminal as the 'instantiated feature' where the
interconnect_module_terminal is on a product_definition of a product that
is an 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of either 'land join
terminal' or 'non functional land join terminal', the component_terminal
shall be related to exactly one land_template_terminal as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'land join terminal',
the component_terminal shall be related to exactly one land as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 
'minimally defined component terminal' the component_terminal
shall be the definition of exactly one property_definition_representation
with a used_representation.name of 'part terminal external reference'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'non functional land
join terminal', the component_terminal shall be related to exactly one land
that has a description of 'non functional land', 'via dependent non
functional land', 'via and contact size dependent non functional land',
'component termination passage dependent non functional land', 'contact
size dependent non functional land', 'component termination passage and
contact size dependent non functional land', or 'unsupported passage
dependent non functional land' as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'package terminal
occurrence', the component_terminal shall be related to exactly one
package_terminal as the 'usage definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'package terminal
occurrence', or 'packaged component join terminal' it shall be an aspect of
the shape of a packaged_component that has a frame_of_reference name of
'physical occurrence'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'packaged component
join terminal', the component_terminal shall be related to exactly one
packaged_part_terminal with a description of 'join terminal' as the
'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'packaged component join
terminal', it shall have at most one property_definition that has at most one
representation that contains at most two length_measure_with_units.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'packaged component join
terminal', it shall have at most one property_definition that has at most one
representation that contains at most one length_measure_with_unit with a name
of 'maximum wire length'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'packaged component join
terminal', it shall have at most one property_definition that has at most one
representation that contains at most one length_measure_with_unit with a name
of 'minimum wire length'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'printed component join
terminal', it shall be an aspect of the shape of a component_definition that
has a frame_of_reference name of 'layout occurrence' and that is associated
with a product that is an 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'printed component
join terminal', the component_terminal shall be related to exactly one
printed_part_template_terminal with a description of 'join terminal' as the
'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'printed component
join terminal', the component_terminal shall be related, as an
'implementation', to exactly one component_shape_aspect with a description
of stratum_feature_template_component. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'via terminal', the
component_terminal shall be related to exactly one plated_passage that has
a description of 'buried via', 'interfacial connection', 'bonded conductive
base blind via', 'non conductive base blind via', or 'plated conductive
base blind via' as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'via terminal', the
component_terminal shall be related to exactly one shape_aspect with a
description of 'via template terminal' as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>


<FORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of 'interconnect 
component join terminal', it shall be an aspect of the shape of a 
component_definition that has a frame_of_reference name of 
'physical occurrence' and that is associated with a product that 
does not have a description of 'assembly module component',
'bare die component', 'interconnect module component', 'laminate component',
or 'packaged component'.
</FORMAL.PROPOSITIONS.RUL>

<!--
 added composite_group_shape_aspect mm 7/2/97 

-->

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall be the definition for at most one
property_definition that is the definition of a 
property_definition_representation that has a used representation 
that has an item that is a descriptive_representation_item with a 
name of 'global swappable' and a description of 'true' or 'false'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall be the definition for at most one
property_definition that is the definition of a 
property_definition_representation that has a used representation 
that has an item that is a descriptive_representation_item with a 
name of 'local swappable' and a description of 'true' or 'false'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The component_terminal shall be the definition for at most one
property_definition that is the definition of a 
property_definition_representation that has a used representation 
that has an item that is a descriptive_representation_item with a 
name of 'swap code'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
If the component_terminal has a description of either 'land join
terminal' or 'non functional land join terminal', the component_terminal
shall be associated with the stratum referenced by the stratum_surface.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="composite_array_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A composite_array_shape_aspect is a composite_shape_aspect that implements the ARM concept of
<internal.ref Linkend="Part_array_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY composite_array_shape_aspect
  SUPERTYPE OF (ONEOF( linear_composite_array_shape_aspect,
                 rectangular_composite_array_shape_aspect))
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_array_shape_aspect
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="composite_array_shape_aspect_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An composite_array_shape_aspect_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Part_feature_placement_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY composite_array_shape_aspect_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\composite_array_shape_aspect_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
END_ENTITY; -- composite_array_shape_aspect_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The composite_array_shape_aspect_link shall relate to a shape_aspect in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The composite_array_shape_aspect_link shall relate to a shape_aspect in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of composite_array_shape_aspect_link shall be only composite_array_shape_aspect_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each composite_array_shape_aspect_link shall be referenced exactly once by a shape_aspect_relationship related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="composite_group_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A composite_group_shape_aspect is a composite_shape_aspect that implements the
ARM concept of <internal.ref Linkend="Composite_group_shape_element">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY composite_group_shape_aspect
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_group_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="composite_signal_property_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A composite_signal_property_relationship is a property_definition_relationship that implements the ARM
concept of<internal.ref Linkend="Composite_signal_property_relationship">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY composite_signal_property_relationship
  SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
  WR1: SELF\property_definition_relationship.related_property_definition.definition :<>:
       SELF\property_definition_relationship.relating_property_definition.definition;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship ||
       SELF\composite_signal_property_relationship || SELF\property_definition)) = 0;
  WR3: SELF\property_definition_relationship.related_property_definition.name =
       'signal property';
  WR4: SELF\property_definition_relationship.relating_property_definition.name =
       'composite signal property';
  WR5: SELF\property_definition.name = '';
  WR6: SELF\property_definition.description = '';
  WR7: SELF\property_definition_relationship.name = '';
  WR8: SELF\property_definition_relationship.description = '';
  WR9: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) AND
       (SELF\property_definition.definition.description = 'aggregate operation');
 WR10: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNAL_DEFINITION' IN TYPEOF(SELF\property_definition.definition);
END_ENTITY; -- composite_signal_property_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship shall not relate to the same property_definition definition through the related and relating
attributes.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship shall not be any other subtype of property_definition_relationship or property_definition. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship shall reference only a 'signal property' through the related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship shall reference only a 'composite signal property' through the relating attribute.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship name inherited from property_definition shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship description inherited from property_definition shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship name inherited from property_definition_relationship shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship description inherited from property_definition_relationship shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship shall reference exactly one characterized_object that has a description of 'aggregate opertion'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The composite_signal_property_relationship shall reference exactly one characterized_object that is also an external_definition.
</FORMAL.PROPOSITIONS.RUL>
</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="composite_unit_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A composite_unit_shape_aspect is a composite_shape_aspect that implements the
ARM concept of <internal.ref Linkend="Composite_unit_shape_element">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY composite_unit_shape_aspect
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_unit_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="concentricity_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A concentricity_tolerance is a geometric_tolerance_with_specified_datum_system
that implements the ARM concept
of <internal.ref Linkend="Concentricity_and_coaxiality_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY concentricity_tolerance
  SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
WHERE
  WR1: SELF\geometric_tolerance.name = 'concentricity';
END_ENTITY; -- concentricity_tolerance
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name for the concentricity_tolerance shall be 'concentricity'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The toleranced_shape_aspect of the concentricity_tolerance shall either be a 
centre_of_symmetry with a description of either 'axis' or 'point'; or a 
composite_shape_aspect in which the 'composing' shape_aspects are all of type 
centre_of_symmetry and have the same description, either 'axis' or 'point'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The concentricity_tolerance shall have exactly one physical_unit_datum in its referenced 
datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the toleranced_shape_aspect of the concentricity_tolerance is either a 
centre_of_symmetry with a description of 'point', or a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'point'; the physical_unit_datum of the datum_system shall have a description of 
'point'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the toleranced_shape_aspect of the concentricity_tolerance is either a 
centre_of_symmetry with a description of 'axis', or a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'axis'; the physical_unit_datum of the datum_system shall have a description of 
'axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The tolerance_zone_boundary of the concentricity_tolerance shall have a description of 'circular or 
cylindrical or spherical'.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="conductance_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A conductance_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Conductance_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY conductance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\conductance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = siemens;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- conductance_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The conductance_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The conductance_measure_with_unit shall reference an si_unit with the name of siemens.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="conductive_interconnect_element_terminal_link">
<ENTITY.DESCRIPTION>
A conductive_interconnect_element_terminal_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Conductive_interconnect_element_terminal_link">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY conductive_interconnect_element_terminal_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\conductive_interconnect_element_terminal_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\shape_aspect.of_shape.definition);
  WR8: SELF\shape_aspect_relationship.related_shape_aspect.description = 'conductive interconnect element terminal';
  WR9: SELF\shape_aspect_relationship.relating_shape_aspect.description = 'conductive interconnect element terminal';
  WR10: SELF\shape_aspect.of_shape.definition\product_definition.description = 'laminate component';
END_ENTITY; -- conductive_interconnect_element_terminal_link 
(* 
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related point shall not be the relating point. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The conductive_interconnect_element_terminal_link shall relate to only a  conductive_interconnect_element_terminal in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The conductive_interconnect_element_terminal_link shall relate to only a conductive_interconnect_element_terminal in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of conductive_interconnect_element_terminal_link shall be only conductive_interconnect_element_terminal_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The shape_aspect supertype shall reference a component_definition
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The related shape_aspect description shall be a 'conductive interconnect element terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The relating shape_aspect description shall be a 'conductive interconnect element terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The associated product_definition description shall be a 'laminate component'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="connected_area_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A connected_area_component is a component_shape_aspect that implements the ARM concept of
<internal.ref Linkend="Connected_area_component">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY connected_area_component
 SUBTYPE OF (component_shape_aspect);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN  
       TYPEOF (SELF.of_shape.definition)) AND 
       (SIZEOF (QUERY (prpc <* 
       USEDIN (SELF.of_shape.definition.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1);
  WR2: SIZEOF (QUERY (sfi <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'stratum feature implementation') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (sfi.relating_shape_aspect))) = 1;
 WR3: SIZEOF (QUERY (sfi <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated layer connection point') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (sfi.relating_shape_aspect))) >= 1;
 WR4: SELF\shape_aspect.description = 'stratum feature template component';
 WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\component_shape_aspect||
       SELF\connected_area_component)) = 0;
END_ENTITY; -- connected_area_component
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The connected_area_component shall be an aspect of the shape of a component_definition that
is the definition of a product that is categorized as an 'template
module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connected_area_component shall be related to exactly one stratum_feature as a 'stratum feature implementation'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The connected_area_component shall be related to at least one layer_connection_point as an 'associated layer connection point'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connected_area_component shall have a description of 'stratum feature template component'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connected_area_component shall not be a complex instance other than with its direct supertypes. 
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="connection_zone_based_assembly_joint">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A connection_zone_based_assembly_joint is an assembly_joint that includes the
identification of the connection zones that are to be mated in addition to the specific
features that are to be mated.  A connection_zone_based_assembly_joint implements the ARM
concept of<internal.ref Linkend="Connection_zone_based_assembly_joint">.

</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY connection_zone_based_assembly_joint
  SUBTYPE OF (assembly_joint);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 1')) = 1;
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 2')) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar.relating_shape_aspect\shape_aspect.description = 'connection zone')) = 2;

END_ENTITY; -- connection_zone_based_assembly_joint
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_based_assembly_joint shall be related to exactly one shape_aspect as 'zone 1' by
a shape_aspect_relationship.related_shape_aspect. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_based_assembly_joint shall be related to exactly one shape_aspect as 'zone 2' by
a shape_aspect_relationship.relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_based_assembly_joint shall be related to only shape_aspects with a description of 'connection_zone'. 
</FORMAL.PROPOSITIONS.RUL>



</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="connection_zone_based_fabrication_joint">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A connection_zone_based_fabrication_joint is an fabrication_joint that includes the
identification of the connection zones that are to be mated in addition to the specific
features that are to be mated.  A connection_zone_based_fabrication_joint implements the ARM
concept of<internal.ref Linkend="Connection_zone_based_fabrication_joint">.

</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY connection_zone_based_fabrication_joint
  SUBTYPE OF (fabrication_joint);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 1')) = 1;
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 2')) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar.relating_shape_aspect\shape_aspect.description = 'connection zone')) = 2;

END_ENTITY; -- connection_zone_based_fabrication_joint
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_based_fabrication_joint shall be related to exactly one shape_aspect as 'zone 1' by
a shape_aspect_relationship.related_shape_aspect. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_based_fabrication_joint shall be related to exactly one shape_aspect as 'zone 2' by
a shape_aspect_relationship.relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_based_fabrication_joint shall be related to only shape_aspects with a description of 'connection_zone'. 
</FORMAL.PROPOSITIONS.RUL>



</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="connection_zone_interface_plane_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A connection_zone_interface_plane_relationship is a shape_aspect and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Connection_zone_interface_plane_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY connection_zone_interface_plane_relationship
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.name;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
       SELF\connection_zone_interface_plane_relationship ||
       SELF\shape_aspect)) = 0;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SEATING_PLANE' IN 
       TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 
      'plane';
  WR4: SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 
      'connection zone';
  WR5: SELF\shape_aspect_relationship.description IN ['area', 'edge']; 
  WR6: SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
  WR7: SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
  WR8: SIZEOF (QUERY (dz <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'derived zone') |
       dz.related_shape_aspect\shape_aspect.description = 'connection zone')) = 1;
END_ENTITY; -- connection_zone_interface_plane_relationship
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall not be any other type of shape_aspect_relationship or any other type of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall relate to a seating_plane.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall relate to a seating_plane, with a name of 'plane'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall relate to a shape_aspect with a description of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall have a description of 'area' or 'edge'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall have the same of_shape through the shape_aspect supertype and through the related_shape_aspect in the shape_aspect_relationship supertype. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall have the same of_shape through the shape_aspect supertype and through the relating_shape_aspect in the shape_aspect_relationship supertype. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A connection_zone_interface_plane_relationship shall be related to one shape_aspect with a description of 'connection zone' as the 'derived zone'. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="connection_zone_map_identification">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A connection_zone_map_identification is a shape_aspect and a representation_relationship that implements the ARM concept of<internal.ref Linkend="Connection_zone_map_identification">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY connection_zone_map_identification
  SUBTYPE OF (shape_aspect,representation_relationship);
WHERE
  WR1: SELF\representation_relationship.rep_2 :<>:
       SELF\representation_relationship.rep_1;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN 
	TYPEOF(SELF\representation_relationship.rep_1);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN 
	TYPEOF(SELF\representation_relationship.rep_2);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\representation_relationship ||
       SELF\connection_zone_map_identification)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\representation_relationship.name = '';
  WR7: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FOOTPRINT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
END_ENTITY; -- connection_zone_map_identification 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related zone shall not be the relating zone. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_map_identification shall relate to only a usage_view_connection_zone_terminal_shape_relationship in the rep_1.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The connection_zone_map_identification shall relate to only a usage_view_connection_zone_terminal_shape_relationship in the rep_2.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of connection_zone_map_identification shall be only connection_zone_map_identification, shape_aspect, and representation_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the representation_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each connection_zone_map_identification shall be a shape_aspect for a footprint_definition.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="coordinated_representation_item">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A coordinated_representation_item is a representation and a representation_item
that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Plus_minus_tolerance_characteristic"></list.item>
<list.item><internal.ref Linkend="Statistical_tolerance_characteristic"></list.item>
<list.item><internal.ref Linkend="Symmetrical_tolerance_characteristic"></list.item>
<list.item><internal.ref Linkend="Tolerance_characteristic"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY coordinated_representation_item
  SUBTYPE OF (representation, representation_item);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       SIZEOF (USEDIN (pdr, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATA_ENVIRONMENT.ELEMENTS')) <= 1)) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
  WR3: (NOT (SELF\representation_item.name = 'tolerance')) OR
       (SIZEOF (QUERY (it <* SELF.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) >= 1); 
  WR4: (NOT (SELF\representation_item.name = 'plus minus tolerance')) OR
       (SIZEOF (QUERY (it <* SELF.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) = 3); 
  WR5: (NOT (SELF\representation_item.name = 'symmetrical tolerance')) OR
       (SIZEOF (QUERY (it <* SELF.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) = 2); 
  WR6: (NOT (SELF\representation_item.name = 'plus minus tolerance'))
       OR
       (
        (SIZEOF (QUERY (it <* SELF.items
         | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
            'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) 
           AND 
            (it\representation_item.name = 'basic value'))
        ) = 1)
       AND
        (SIZEOF (QUERY (it <* SELF.items
         | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
            'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) 
           AND 
            (it\representation_item.name = 'plus value'))
        ) = 1)
       AND
        (SIZEOF (QUERY (it <* SELF.items 
         | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
            'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) 
           AND 
            (it\representation_item.name = 'minus value'))
        ) = 1)
       );

  WR7: (NOT (SELF\representation_item.name = 'symmetrical tolerance')) OR
       ((SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it)) AND (it\representation_item.name = 'basic value'))
                        ) = 1)
       AND
       (SIZEOF (QUERY (it <* SELF.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it)) AND ( it\representation_item.name = 'deviation value'))
                        ) = 1)
       ); 
END_ENTITY; -- coordinated_representation_item
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The coordinated_representation_item shall represent at most one property
that is an element of at most one data_environment.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The coordinated_representation_item shall be referenced by exactly one
document.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the coordinated_representation_item has a representation_item name of
'tolerance', it shall contain at least one measure_representation_item.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
<!-- Done, MTK 3/19/97 -->
If the coordinated_representation_item has a representation_item name of
'plus minus tolerance', it shall contain exactly three 
measure_representation_items.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the coordinated_representation_item has a representation_item name of
'symmetrical tolerance', it shall contain exactly two 
measure_representation_items.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
<!-- Done, MTK 3/23/97 -->
If the coordinated_representation_item has a representation_item name
of 'plus minus tolerance', the three contained measure_representation_items
shall have their name attribute satisfied by 'basic value', 'plus value',
and 'minus value'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
<!-- Done, MTK 3/23/97 -->
If the coordinated_representation_item has a representation_item name of
'symmetrical tolerance', the two contained measure_representation_items
shall have their name attribute satisfied by 'basic value' and
'deviation value'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
If the coordinated_representation_item has a representation_item name
of 'plus minus tolerance', each contained measure_representation_items
shall have the same unit_components for the dimensions attribute.
</INFORMAL.PROPOSITIONS.RUL>

<INFORMAL.PROPOSITIONS.RUL>
If the coordinated_representation_item has a representation_item name
of 'plus minus tolerance', the measure_representation_item
with a name attribute of 'minus value' shall have a value_component 
less then that of the measure_representation_item with a name attribute 
of 'basic value' which shall have a value_component less then that of 
the measure_representation_item with a name attribute of 'plus_value'.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="csg_2d_shape_representation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A csg_2d_shape_representation is a shape_representation that
implements the ARM concept of <internal.ref Linkend="Area_2d_shape_definition">.
A csg_2d_shape_representation is a two-dimensional shape_representation that represents the shape of a product using constructive solid geometry operations and techniques. The solid objects may be either 2D primitives, or half-space 2D solids. 
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY csg_2d_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE 
 WR1: SELF.context_of_items\
  geometric_representation_context.coordinate_space_dimension = 2;

 WR2 : SIZEOF (QUERY (it <* SELF.items| NOT
     (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID', 
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM', 
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D'] 
     * TYPEOF(it)) = 1 ))) = 0;

 WR3: SIZEOF(QUERY ( it <* SELF.items | 
    (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID']
	* TYPEOF(it)) = 1) 
	OR 
	(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
	IN TYPEOF(it)) AND
	('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
	'CSG_2D_SHAPE_REPRESENTATION' 
	  IN TYPEOF(it\mapped_item.mapping_source.mapped_representation))) 
       )) >= 1;

 WR4: SIZEOF(QUERY ( it <* SELF.items | 
     (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
     IN TYPEOF(it)) AND (NOT (( 
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'CSG_2D_SHAPE_REPRESENTATION') 
      IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))) )) = 0;
 WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_representation ||
      SELF\csg_2d_shape_representation || SELF\representation)) = 0;
END_ENTITY; -- csg_2d_shape_representation 
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The geometric_representation_context of the csg_2d_shape_representation shall have a coordinate_space_dimension equal to two.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The items in a csg_2d_shape_representation shall be a csg_solid, mapped_item, or an axis2_placement_2d. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At least one of the items in a csg_2d_shape_representation shall be a csg_solid, or a mapped_item with a mapped_representation of the mapping_source attribute of the type csg_2d_shape_representation. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If a mapped_item is in the items set then the mapped_representation of the mapping_source attribute shall be a csg_2d_shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The csg_2d_shape_representation shall not be another type of shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<!--
added entity 4/30/2001 tt

-->
</FORMAL.PROPOSITIONS>
<note>
Since WR1 requires a coordinate_space_dimension equal to two, the leaves of the tree_root_expression in csg_solid can be built by only half_space_2d or primitive_2d elements.
</note>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="curve_dimension">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A curve_dimension is a dimensional_size that implements the ARM concept
of <internal.ref Linkend="Curve_dimension">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY curve_dimension
  SUBTYPE OF (dimensional_size);
WHERE
  WR1: SELF\dimensional_size.name <> 'angular' ;
END_ENTITY; -- curve_dimension
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The name of the curve_dimension shall not be 'angular'.
</Formal.propositions.rul>

</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="cutout_edge_segment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A cutout_edge_segment is an inter_stratum_feature and a shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Cutout_edge_segment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY cutout_edge_segment
  SUPERTYPE OF (plated_cutout_edge_segment)
  SUBTYPE OF (inter_stratum_feature,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect.description IN [
       'plated cutout edge segment',
       'cutout edge segment'];
  WR2: SIZEOF (QUERY (cc <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed cutout') |(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (cc.relating_shape_aspect)) AND 
	(cc.relating_shape_aspect\shape_aspect.description  IN ['cutout',
         'physical connectivity interrupting cutout', 'plated cutout']))
       )) = 1;
  WR3: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect));
  WR4: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect));
  WR5: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
END_ENTITY; -- cutout_edge_segment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The cutout_edge_segment shall have a name of 'cutout edge segment' and a relating_shape_aspect_description of 'cutout', 'physical connectivity interrupting cutout', or 'plated cutout'.
'plated cutout edge segment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The cutout_edge_segment shall relate to an edge_segment_vertex in the relating role.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The cutout_edge_segment shall relate to an edge_segment_vertex in the related role.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The relating_shape_aspectand the related_shape_aspect shall not be the same instance of shatp_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
The associated passage_technology shall have descriptive_representation_item with a description of 'true'.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="data_set_representation_item">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A data_set_representation_item is a compound_representation_item
that implements the ARM concept of <internal.ref Linkend="Characteristic_data_set">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY data_set_representation_item
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS')) > 0;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SET_REPRESENTATION_ITEM'
       IN TYPEOF(SELF\compound_representation_item.item_element);
END_ENTITY; -- data_set_representation_item
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The data_set_representation_item shall be referenced by exactly
one applied_document_reference.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The item_element attribute shall be a list_representation_item.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_difference">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_difference is a subtype of shape_aspect and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Datum_difference">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_difference
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM' IN TYPEOF
       (SELF\shape_aspect_relationship.relating_shape_aspect)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM' IN TYPEOF
       (SELF\shape_aspect_relationship.related_shape_aspect));
  WR2: SELF\shape_aspect.name = SELF\shape_aspect_relationship.name;
  WR3: SELF\shape_aspect.description = SELF\shape_aspect_relationship.
       description;
  WR4: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR5: SIZEOF (TYPEOF(SELF) - (TYPEOF(SELF\shape_aspect || 
       SELF\shape_aspect_relationship || SELF\datum_difference))) = 0;
END_ENTITY; -- datum_difference
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The datum_difference shall be applied to only physical_unit_datum. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The datum_difference name attribute inherited shall be identical in each supertypes.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The datum_difference description attribute inherited shall be identical in each supertypes.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The datum_difference shall be applied to only different physical_unit_datum.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The datum_difference shall not be in a complex instance of other types of shape_aspect or shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_difference_analytical_model_port_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_difference_analytical_model_port_assignment is a subtype of property_definition_representation that implements the
ARM concept of<internal.ref Linkend="Datum_difference_analytical_model_port_assignment">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_difference_analytical_model_port_assignment
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL_PORT' IN TYPEOF
       (SELF\property_definition_representation.used_representation)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_DIFFERENCE' IN TYPEOF
       (SELF\property_definition_representation.definition));
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_representation ||
       SELF\datum_difference_analytical_model_port_assignment)) = 0;
END_ENTITY; -- datum_difference_analytical_model_port_assignment
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The datum_difference_analytical_model_port_assignment shall be related to only datum_difference and analytical_model_port. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The datum_difference_analytical_model_port_assignment shall not be in a complex instance of other types of property_definition_representation.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_difference_based_characteristic">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_difference_based_characteristic is a representation_item that implements the
ARM concept of<internal.ref Linkend="Datum_difference_based_characteristic">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_difference_based_characteristic
  SUBTYPE OF (representation_item);
WHERE
  WR1: SIZEOF(QUERY ( r <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'REPRESENTATION.ITEMS') | (SIZEOF(QUERY (prd2 <*
        QUERY ( prd <* USEDIN(r,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
       ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
       + 'PROPERTY_DEFINITION_REPRESENTATION') IN TYPEOF(prd)) AND 
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PROPERTY_DEFINITION') IN TYPEOF(prd\
       property_definition_representation.definition))) ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_DIFFERENCE' IN
      TYPEOF(prd2\property_definition_representation.definition\
                               property_definition.definition))))
            = 1) )) 
               = 1;
END_ENTITY; -- datum_difference_based_characteristic
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The datum_difference_based_characteristic shall be related to exactly one datum_difference.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_difference_based_model_parameter">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_difference_based_model_parameter is a model_parameter that implements the
ARM concept of<internal.ref Linkend="Datum_difference_based_model_parameter">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_difference_based_model_parameter
  SUBTYPE OF (model_parameter);
WHERE
      wr1: SIZEOF(QUERY ( r <* USEDIN(SELF,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'REPRESENTATION.ITEMS') | (SIZEOF(QUERY (prd2 <*
                QUERY ( prd <* USEDIN(r,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
               ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' 
               + 'PROPERTY_DEFINITION_REPRESENTATION') IN TYPEOF(prd)) AND 
               (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'PROPERTY_DEFINITION') IN TYPEOF(prd\
               property_definition_representation.definition))) ) |
               ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'DATUM_DIFFERENCE' IN
               TYPEOF(prd2\property_definition_representation.definition\
                                        property_definition.definition))))
                = 1) )) 
               = 1;
END_ENTITY; -- datum_difference_based_model_parameter
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The datum_difference_based_model_parameter shall be related to exactly one datum_difference.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_difference_functional_unit_usage_view_terminal_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_difference_functional_unit_usage_view_terminal_assignment is a shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Datum_difference_functional_unit_usage_view_terminal_assignment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_difference_functional_unit_usage_view_terminal_assignment
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
SELF\datum_difference_functional_unit_usage_view_terminal_assignment)) 
                                                              = 0;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF 
        (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_DIFFERENCE' IN TYPEOF 
        (SELF\shape_aspect_relationship.relating_shape_aspect);
END_ENTITY; -- datum_difference_functional_unit_-
--             usage_view_terminal_assignment
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The datum_difference_functional_unit_usage_view_terminal_assignment shall not
participate in a complex instance with other than the shape_aspect_relationship supertype.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The datum_difference_functional_unit_usage_view_terminal_assignment shall be related to exactly one
functional_unit_terminal_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The datum_difference_functional_unit_usage_view_terminal_assignment shall be related to exactly one
datum_difference.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_reference_frame">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_reference_frame is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Datum_reference_frame">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_reference_frame
  SUBTYPE OF (shape_aspect);
WHERE
 WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
      SELF\datum_reference_frame)) = 0;
 WR2: SELF\shape_aspect.product_definitional = False;
 WR3: (SIZEOF (QUERY (pud <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'reference axis') | 
      (pud.related_shape_aspect\shape_aspect.description = 'axis') AND
      ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'PHYSICAL_UNIT_DATUM' IN TYPEOF (pud.related_shape_aspect)))) <= 3);
 WR4: (SIZEOF (QUERY (pud <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'reference plane') | 
      (pud.related_shape_aspect\shape_aspect.description = 'plane') AND
      ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'PHYSICAL_UNIT_DATUM' IN TYPEOF (pud.related_shape_aspect)))) <= 3);
 WR5: (SIZEOF (QUERY (pud <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'reference origin') | 
      (pud.related_shape_aspect\shape_aspect.description = 'point') AND
      ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'PHYSICAL_UNIT_DATUM' IN TYPEOF (pud.related_shape_aspect)))) <= 1);
 WR6: (SIZEOF (QUERY (ds <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'established datum reference frame') | 
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'DATUM_SYSTEM' IN TYPEOF (ds.related_shape_aspect))) >= 1);

 WR7: (SIZEOF (QUERY (pud <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'reference axis') | 
      (pud.related_shape_aspect\shape_aspect.description = 'axis') AND
      ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'PHYSICAL_UNIT_DATUM' IN TYPEOF (pud.related_shape_aspect))))
      + SIZEOF (QUERY (pud <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'reference plane') | 
      (pud.related_shape_aspect\shape_aspect.description = 'plane') AND
      ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'PHYSICAL_UNIT_DATUM' IN TYPEOF (pud.related_shape_aspect))))
      + SIZEOF (QUERY (pud <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'reference origin') | 
      (pud.related_shape_aspect\shape_aspect.description = 'point') AND
      ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'PHYSICAL_UNIT_DATUM' IN TYPEOF (pud.related_shape_aspect)))) >= 1);
 WR8: (SIZEOF (QUERY (pud <* QUERY ( sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'reference origin') | 
      (pud.related_shape_aspect\shape_aspect.description <> 'point') OR 
      (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'DERIVED_SHAPE_ASPECT' IN TYPEOF (pud.related_shape_aspect)))
       )) = 0);
END_ENTITY; -- datum_reference_frame
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The datum_reference_frame shall not be a complex instance, except with the supertype shape_aspect.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_reference_frame shall not lie on the boundary of the shape of the product.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_reference_frame shall relate to at most three physical_unit_datum that have a description 
of 'axis' to specify the 'reference axis'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_reference_frame shall relate to at most three physical_unit_datum that have a description 
of 'plane' to specify the 'reference plane'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_reference_frame shall relate to at most one physical_unit_datum that has a description of 'point' to specify the 'reference origin'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_reference_frame shall be related to at least one datum_system as the 'established datum 
reference frame'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_reference_frame shall relate to at least one physical_unit_datum that has a 
description of 'axis' or 'plane' or 'point' to specify the 'reference axis' or 'reference 
plane' or 'reference origin', respectively.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each 'reference origin' related to the datum_reference_frame shall also be a derived_shape_aspect that has a description of 'point'.
</Formal.propositions.rul>

</Formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each reference_axis shall be specified to be either a constituent of, or normal to each of the 
reference_planes and this specification shall be consistent with the mutually perpendicular 
reference_planes.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_system">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_system is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Datum_system">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_system
  SUBTYPE OF (shape_aspect);
WHERE
 WR1: SELF\shape_aspect.product_definitional = False;
 WR2: (SIZEOF (QUERY (sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 
                  'established datum reference frame')) = 1);
 WR3: (SIZEOF (QUERY (sar <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 
                       'datum usage in datum system')) >= 1);
 WR4: (SIZEOF (QUERY (pd <* USEDIN(SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
      'PROPERTY_DEFINITION.DEFINITION') |
      (pd\property_definition.description = 
               'datum system property with material conditions')
      OR (pd\property_definition.description = 
      'datum system property without material conditions'))) = 1);
END_ENTITY; -- datum_system
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The datum_system shall not lie on the boundary of the shape of the product.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_system shall relate to at exactly one shape_aspect to specify the 'established datum 
reference frame'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_system shall relate to at least one shape_aspect to specify the 'datum usage in datum 
system'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The datum_system shall have exactly one property_definition that has the description of either 'datum system 
property with material conditions' or 'datum system property without material conditions'.
</Formal.propositions.rul>

</Formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Any particular physical_unit_datum_feature shall be used no more than one time to establish the 
datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Any particular physical_unit_datum_target shall be used no more than one time to establish the 
datum_system.
</Informal.propositions.rul>

</Informal.propositions>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="datum_system_based_dimensional_location">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A datum_system_based_dimensional_location is a dimensional_location that
implements the ARM concept
of <internal.ref Linkend="Dimension_location_with_specified_datum_system">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY datum_system_based_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY; -- datum_system_based_dimensional_location
(*
</EXPRESS.CODE>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The datum_system_based_dimensional_location shall have exactly one property_definition with a 
description of 'dimensional location property', and that property_definition shall relate to a 
property_definition with a description of 'datum system property without material conditions' to 
specify the 'referenced datum system property'.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="delete_design_object_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A delete_design_object_assignment is an action_assignment that implements the
ARM concept
of <internal.ref Linkend="Delete_design_object_management_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY delete_design_object_assignment
   SUBTYPE OF (action_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(it <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))
        AND (it\product_definition_relationship.name = 'design object deletion'))) = 1;
END_ENTITY; -- delete_design_object_assignment
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The delete_design_object_assignment shall have exactly one item
that is a product_definition_relationship with a name of 'design object deletion'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The delete_design_object_assignment shall have exactly one item that is a
managed_design_object that is not a product_definition_relationship
with a name of 'design object deletion' and that is not
referenced by another product_definition_relationship with a name
of 'design object addition', 'design object change', or 'design object deletion'
in the same design.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>


</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="delete_design_object_request_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A delete_design_object_request_assignment is an action_request_assignment that implements the
ARM concepts
of <internal.ref Linkend="Change_request"> and
<internal.ref Linkend="Delete_design_object_management_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY delete_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
     items : SET [1:?] OF managed_design_object;
WHERE
   WR1: SIZEOF(QUERY(it <* SELF.items |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))
        AND (it\product_definition_relationship.name = 'design object deletion'))) = 1;
END_ENTITY; -- delete_design_object_request_assignment
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The delete_design_object_request_assignment shall have exactly one item
that is a product_definition_relationship with a name of 'design object deletion'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
The delete_design_object_request_assignment shall have exactly one item that is a
managed_design_object that is not a product_definition_relationship
with a name of 'design object deletion' and that is not
referenced by another product_definition_relationship with a name
of 'design object addition', 'design object change', or 'design object deletion'
in the same design.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>


</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="dependent_material_removal_feature_template">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A dependent_material_removal_feature_template is a part_template_definition that implements the
ARM concept of
<internal.ref Linkend="Dependent_material_removal_feature_template">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY dependent_material_removal_feature_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: SELF\shape_aspect.description = 'material removal feature template';
  WR2: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (am.relating_shape_aspect)) AND
       (am.relating_shape_aspect.description IN
       ['default attachment size and component termination passage based',
       'default attachment size based',
       'default attachment size and via based',
       'default component termination passage based',
       'default via based',
       'default unsupported passage based']))
        )) = 1;
END_ENTITY; -- dependent_material_removal_feature_template
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The dependent_material_removal_feature_template shall have a description that is 'material removal feature template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The dependent_material_removal_feature_template shall be related to exactly one land_physical_template with a description of
'default attachment size and component termination passage based', or 'default attachment size based', or 'default attachment size and via based', or 'default component termination passage based', or 'default via based', or 'default unsupported passage based'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="design_layer_type_specific_padstack_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A design_layer_type_specific_padstack_definition is a product_definition that implements the ARM concepts of:
<internal.ref Linkend="Design_layer_type_specific_padstack_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY design_layer_type_specific_padstack_definition 
 SUBTYPE OF (padstack_definition);
END_ENTITY; -- design_layer_type_specific_padstack_definition 
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have a frame_of_reference with a name of 'layout design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall be associated with a product that is a template model.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="design_make_from_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A design_make_from_relationship is a product_definition_relationship that
implements the ARM concept of <internal.ref Linkend="Engineering_make_from">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY design_make_from_relationship
  SUBTYPE OF (product_definition_relationship);
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT'] *
       TYPEOF (SELF.relating_product_definition)) = 1;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT'] *
       TYPEOF (SELF.related_product_definition)) = 1;
  WR3: SIZEOF( QUERY(pds <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pds)))) = 0;
END_ENTITY; -- design_make_from_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The design_make_from_relationship shall reference a physical_unit or a
functional_unit as its relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The design_make_from_relationship shall reference a physical_unit or a
functional_unit as its related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The design_make_from_relationship shall not be the definition of a
product_definition_shape.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="design_object">
<ENTITY.DESCRIPTION>
A design_object is a characterized_object that implements the ARM concept
of <internal.ref linkend="Layout_spacing_requirement_occurrence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY design_object
  SUBTYPE OF (characterized_object);
END_ENTITY; -- design_object
(*
</EXPRESS.CODE>
<!--
comment this out until needed, hopefully never
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The design_object shall be referenced by exactly one document.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="device_terminal_map">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A device_terminal_map is a shape_aspect and a shape_aspect_relationship that
implements the ARM concept of <internal.ref Linkend="Device_terminal_map">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY device_terminal_map
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.related_shape_aspect,
       SELF\shape_aspect_relationship.relating_shape_aspect;
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL'
       IN TYPEOF (SELF.relating_shape_aspect);
END_ENTITY; -- device_terminal_map
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS>

<formal.propositions.group rule.types="UR">
<formal.propositions.rul>
The combination of related_shape_aspect and relating_shape_aspect of
shape_aspect_relationship shall be unique within a population of device_terminal_map.
</formal.propositions.rul>
</formal.propositions.group>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The relating_shape_aspect shall be a packaged_part_terminal.
</FORMAL.PROPOSITIONS.RUL>

</formal.propositions.group>

<!--
 added dimensional_location_with_direction mm 7/2/97 

-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="dimensional_location_with_direction">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A dimensional_location_with_direction is a dimensional_location that
implements the ARM concept
of <internal.ref Linkend="Dimension_location_with_direction_vector">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY dimensional_location_with_direction
  SUBTYPE OF (dimensional_location);
WHERE
    wr1: SELF\shape_aspect_relationship.description = 'linear';
END_ENTITY; -- dimensional_location_with_direction
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The description of the dimensional_location_with_direction shall be 'linear'.
</Formal.propositions.rul>

</Formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The dimensional_location_with_direction shall have exactly one property_definition with a 
description of 'dimensional location property', and that property_definition either shall be 
represented by a representation that contains a placement with a name of 'orientation' or shall 
relate to a property_definition with a description of 'datum based vector orientation' to specify 
the 'measurement orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the dimensional_location_with_direction has a property_definition with a description of 
'dimensional location property' and that property_definition relates to a property_definition with 
a description of 'datum based vector orientation' to specify the 'measurement orientation', the 
combination of the shape_aspect specified as the related_shape_aspect, the shape_aspect specified as the relating_shape_aspect, and 
the property_definition with a description of 'datum based vector orientation' shall be unique.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the dimensional_location_with_direction has a property_definition with a description of 
'dimensional location property' and that property_definition is represented by a representation 
that contains a placement with a name of 'orientation', the combination of the shape_aspect 
specified as the related_shape_aspect, the shape_aspect 
specified as the relating_shape_aspect, and the placement with a name of 
'orientation' shall be unique.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="dimensional_size_property">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A dimensional_size_property is a dimensional_size and a property_definition.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY dimensional_size_property
  SUBTYPE OF (dimensional_size, property_definition);
END_ENTITY; -- dimensional_size_property
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="directed_dimensional_location">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A directed_dimensional_location is a dimensional_location that implements
the ARM concept of <internal.ref Linkend="Dimensional_location"> where
the ARM attribute "directed" of that concept has a value of TRUE.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY; -- directed_dimensional_location
(*
</EXPRESS.CODE>



</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="discrete_shield">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A discrete_shield is a component_definition that implements the ARM concept of
<internal.ref Linkend="Shield"> when the shield is comprised of a component or
components that are manufactured separately from the interconnect component.  
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY discrete_shield
  SUBTYPE OF (component_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical occurrence';
  WR2: SIZEOF (QUERY (si <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'shielded item') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (si.relating_product_definition))) >= 1;
END_ENTITY; -- discrete_shield
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The discrete_shield shall have a frame_of_reference name of 'physical
occurrence'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The discrete_shield shall be related to at least one component_definition or
at least one component_shape_aspect as the 'shielded item'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="document_identifier">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A document_identifier is a group that specifies an identifier qualified by a name for a document.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY document_identifier
  SUBTYPE OF (group);
UNIQUE
  UR1: SELF\group.name, SELF\group.description;
WHERE
  WR1: SIZEOF (USEDIN(SELF,'')) = 1;
END_ENTITY; -- document_identifier
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">

<FORMAL.PROPOSITIONS.RUL>
The combination of name and description inherited from group shall be unique.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
A document_identifier shall be referenced exactly once.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>
</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="document_identifier_assignment">
<ENTITY.DESCRIPTION>
A document_identifier_assignment is a group_assignment that specifies one or more of document_identifier_assigned_item.  If there are more than one, then the items are all revisions of the same drawing.
<example>
A schematic diagram may have a base identifier and each revision identification of that diagram differs from other revisions identification only in the document.description.
</example>
<note>
Due to a constraint on document_identifier, no member of document_identifier may be referenced more than once, guaranteeing uniqueness of assigned_group.
</note>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY document_identifier_assignment
 SUBTYPE OF (group_assignment);
   SELF\group_assignment.assigned_group : document_identifier;
     items : SET [1:?] OF document_identifier_assigned_item;
END_ENTITY; -- document_identifier_assignment
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="dose_equivalent_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A dose_equivalent_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Dose_equivalent_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY dose_equivalent_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\dose_equivalent_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = sievert;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- dose_equivalent_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The dose_equivalent_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The dose_equivalent_measure_with_unit shall reference an si_unit with the name of sievert.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="edge_based_2d_wireframe_shape_representation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An edge_based_2d_wireframe_shape_representation is a shape_representation that
implements the ARM concepts of
<internal.ref Linkend="Edge_based_2d_wireframe">
and <internal.ref Linkend="Edge_based_wireframe">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY edge_based_2d_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF\representation.items |
       NOT (SIZEOF (   
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_2D'] *
       TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF\representation.items |
       SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM'] * 
       TYPEOF (it)) = 1)) >= 1;
  WR3: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL' IN 
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (eb <* 
       ebwm\edge_based_wireframe_model.ebwm_boundary |
       NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_CURVE'
       IN TYPEOF (edges)))) = 0))) = 0))) = 0;
  WR4: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL' IN 
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (eb <* 
       ebwm\edge_based_wireframe_model.ebwm_boundary |
       NOT (SIZEOF (QUERY (pline_edges <* QUERY (edges <* eb.ces_edges |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POLYLINE' IN
       TYPEOF (edges\edge_curve.edge_geometry)) |
       NOT (SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points) 
       > 2))) = 0))) = 0))) = 0;
  WR5: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL' IN 
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (eb <* 
       ebwm\edge_based_wireframe_model.ebwm_boundary |
       NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
       NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_POINT' IN 
       TYPEOF (edges.edge_start)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_POINT' IN 
       TYPEOF (edges.edge_end))))) = 0))) = 0))) = 0;
  WR6: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL' IN 
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (eb <*
       ebwm\edge_based_wireframe_model.ebwm_boundary |
       NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
       NOT (valid_2d_wireframe_edge_curve
       (edges\edge_curve.edge_geometry,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')))) 
       = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF\representation.items|
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL' IN 
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (eb <* 
       ebwm\edge_based_wireframe_model.ebwm_boundary |
       NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
       NOT ((valid_wireframe_vertex_point
       (edges.edge_start\vertex_point.vertex_geometry)) AND
       (valid_wireframe_vertex_point
       (edges.edge_end\vertex_point.vertex_geometry))))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_WIREFRAME_MODEL' IN 
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (eb <* 
       ebwm\edge_based_wireframe_model.ebwm_boundary |
       NOT (SIZEOF (QUERY (con_edges <* QUERY (edges <* eb.ces_edges |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONIC'
       IN TYPEOF (edges\edge_curve.edge_geometry)) |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_2D' IN
       TYPEOF (con_edges\edge_curve.edge_geometry\conic.position)))) 
       = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (mi <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM' IN 
       TYPEOF (it)) |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION' IN
       TYPEOF (mi\mapped_item.mapping_source.mapped_representation)))) = 0;
  WR10: SELF\representation.
        context_of_items\geometric_representation_context.
        coordinate_space_dimension = 2;
END_ENTITY; -- edge_based_2d_wireframe_shape_representation
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The items in an edge_based_2d_wireframe_shape_representation shall be an
edge_based_wireframe_model, a mapped_item, or an axis2_placement_2d.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At least one of the items in an edge_based_2d_wireframe_shape_representation 
shall be either an edge_based_wireframe_model or a mapped_item.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Every edge in an edge_based_wireframe_model shall be an edge_curve.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Every polyline that underlies an edge of an edge_based_wireframe_model
shall be defined by more than two distinct points.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Every vertex defined for an edge_based_wireframe_model shall be a
vertex_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_geometry that underlies an edge for an edge_based_wireframe_model 
shall be a line, circle, ellipse, parabola, hyperbola, b_spline_curve,
offset_curve_2d, polyline, or a curve_replica.  For each curve that has a basis
defined by another curve, the basis curve shall be one of these types also.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The vertex_geometry that underlies the edges for an edge_based_wireframe_model 
shall be a cartesian_point or point_replica and the point_replica shall 
replicate either another point_replica or a cartesian_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
All conics shall be positioned by an axis2_placement_2d.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If there is a mapped_item in an edge_based_2d_wireframe_shape_representation, 
the source of the mapped_item shall be an 
edge_based_2d_wireframe_shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The  edge_based_2d_wireframe_shape_representation  shall  have  a 
coordinate_space_dimension equal to two.
</FORMAL.PROPOSITIONS.RUL>

<!--
added entity 4/2/97 tt

-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="edge_segment_cross_section">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An edge_segment_cross_section is a volume_shape_intersection 
that implements the ARM concept of <internal.ref Linkend="Edge_segment_cross_section">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY edge_segment_cross_section
  SUBTYPE OF (volume_shape_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\volume_shape_intersection || 
       SELF\edge_segment_cross_section))) = 0;
END_ENTITY; -- edge_segment_cross_section 
(* 
</EXPRESS.CODE> 

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_cross_section shall not be a complex subtype of other than its direct supertypes.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="edge_segment_vertex">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An edge_segment_vertex is a physical_unit_datum that implements the
ARM concept of<internal.ref Linkend="Edge_segment_vertex">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY edge_segment_vertex
  SUBTYPE OF (physical_unit_datum);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\physical_unit_datum ||
       SELF\edge_segment_vertex)) = 0;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
        pd\property_definition.description = 'shape element characterization'
       )) = 1;
  WR3: SELF\shape_aspect.of_shape\property_definition.definition.
       frame_of_reference\application_context_element.name
       IN ['physical design occurrence', 'physical design usage'];
  WR4: SELF\shape_aspect.name = 'single datum';
END_ENTITY; -- edge_segment_vertex
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex shall not participate in a complex instance of
shape_aspect other than with the physical_unit_datum supertype.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex shall be related to one representation
with a name of 'shape element characterization'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex shall be in the 'physical design occurrence' or 'physical design usage' context. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex shall be a single datum. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="ee_specification">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An ee_specification is a document which implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Assembly_technology_specification"></list.item>
<list.item><internal.ref Linkend="Design_specification"></list.item>
<list.item><internal.ref Linkend="Ee_specification"></list.item>
<list.item><internal.ref Linkend="Fabrication_technology_specification"></list.item>
<list.item><internal.ref Linkend="Interface_specification"></list.item>
<list.item><internal.ref Linkend="Language_reference_manual"></list.item>
<list.item><internal.ref Linkend="Lead_form_specification"></list.item>
<list.item><internal.ref Linkend="Material_specification"></list.item>
<list.item><internal.ref Linkend="Process_specification"></list.item>
<list.item><internal.ref Linkend="Surface_finish_specification"></list.item>
<list.item><internal.ref Linkend="Test_specification"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY ee_specification 
 SUBTYPE OF (document);
WHERE
  WR1: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'document source')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'document source')) >= 1;
  WR2: SELF\document.kind\document_type.product_data_type IN 
       ['assembly technology specification',
       'design specification', 'fabrication technology specification',
       'interface specification', 'language reference manual',
       'lead form specification', 'material specification',
       'reference document', 'source code',
       'process specification', 'surface finish specification',
       'test specification'];
END_ENTITY; -- ee_specification
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The ee_specification shall have at least one organization or 
person_and_organization specified as its 'document source'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The ee_specification shall be a assembly_technology_specification, design_specification,
fabrication_technology_specification, interface_specification,
language_reference_manual, lead_form_specification, material_specification,
reference document, source code, process_specification, surface_finish_specification, or a test_specification.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="electric_charge_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An electric_charge_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Electric_charge_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY electric_charge_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\electric_charge_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = coulomb;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- electric_charge_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The electric_charge_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The electric_charge_measure_with_unit shall reference an si_unit with the name of coulomb.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="electrical_isolation_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An electrical_isolation_component_shape_aspect is a filled_area_material_removal_component_shape_aspect
that implements the ARM concept of <Internal.ref Linkend="Electrical_isolation_laminate_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY electrical_isolation_component_shape_aspect
  SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
END_ENTITY; -- electrical_isolation_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="electrical_isolation_removal_template_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An electrical_isolation_removal_template_definition is a part_template_definition that implements the ARM concept of
<internal.ref Linkend="Electrical_isolation_removal_template">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY electrical_isolation_removal_template_definition
  SUBTYPE OF (part_template_definition);
(*
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL' IN
       TYPEOF (it))) = 1)) = 1))) = 0);
  WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font vertical extent'))) = 1
       )) = 1))) = 0);
  WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font horizontal extent'))) = 1
       )) = 1))) = 0);
*)
END_ENTITY; -- electrical_isolation_removal_template_definition
(*
</EXPRESS.CODE>
<!--

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The electrical_isolation_removal_template_definition shall have a representation that has exactly one text_literal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The electrical_isolation_removal_template_definition shall have a representation that has exactly one
measure_representation_item that is a length_measure_with_unit with a name of
'maximum font vertical extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The electrical_isolation_removal_template_definition shall have a representation that has exactly one
measure_representation_item that is a length_measure_with_unit with a name of
'maximum font horizontal extent'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>
-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="electrical_network">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An electrical_network is a functional_unit that implements the ARM concept
of <Internal.ref Linkend="Electrical_network_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY electrical_network
  SUBTYPE OF (functional_unit);
END_ENTITY; -- electrical_network
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="electromotive_force_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An electromotive_force_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Electromotive_force_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY electromotive_force_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\electromotive_force_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = volt ;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- electromotive_force_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The electromotive_force_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The electromotive_force_measure_with_unit shall reference an si_unit with a name of volt. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="energy_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An energy_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Energy_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY energy_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\energy_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = joule;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- energy_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The energy_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The energy_measure_with_unit shall reference an si_unit with a name of joule.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="evaluated_characteristic">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An evaluated_characteristic is a representation and a representation_relationship that implements the ARM concept of <internal.ref Linkend="Evaluated_characteristic">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY evaluated_characteristic
  SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\representation_relationship_with_transformation || 
       SELF\evaluated_characteristic))) = 0;
  WR2: SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
  WR3: SELF\representation_relationship.name = '';
  WR4: SELF\representation.name = '';
  WR5: SELF\representation_relationship.rep_1.name = 'planned characteristic';
END_ENTITY; -- evaluated_characteristic 
(* 
</EXPRESS.CODE> 
<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR"> 
<FORMAL.PROPOSITIONS.RUL>
The combination of rep_1 and rep_2 shall be unique within a population of evaluated_characteristic.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The evaluated_characteristic shall only be a representation, representation_relationship, or representation_relationship_with_transformation in addition to itself.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The evaluated_characteristic rep_1 shall not be the rep_2.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute inherited from representation_relationship shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute inherited from representation shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of representation_relationship.rep_1 shall be 'planned characteristic'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="evaluation_product_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An evaluation_product_definition is a product_definition that implements the ARM concept of:
<internal.ref Linkend="Evaluation_ee_product_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY evaluation_product_definition
 SUBTYPE OF (product_definition);
END_ENTITY; -- evaluation_product_definition
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="external_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An external_definition is a characterized_object and an externally_defined_representation_item
and a descriptive_representation_item that implements the ARM concept of <internal.ref Linkend="External_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY external_definition
  SUPERTYPE OF(ONEOF(bond_category))
  SUBTYPE OF (characterized_object, descriptive_representation_item,
              externally_defined_representation_item);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
END_ENTITY; -- external_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The external_definition shall be referenced by exactly one document.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_assembly_definition">
<ENTITY.DESCRIPTION>
An externally_defined_assembly_definition is an externally_defined_physical_unit that implements the ARM concept of <internal.ref Linkend="Pca_usage_view">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_assembly_definition
 SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR
       (SELF\product_definition.name = 'assembly module');
  WR3: (NOT (SELF.frame_of_reference\application_context_element.name = 'physical design usage')) 
        OR (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
END_ENTITY; -- externally_defined_assembly_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The name shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_assembly_definition shall be a definition of a product that has a name of 'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_assembly_definition has a frame_of_reference name
of 'physical design usage', it shall have at least two shape_aspects that are
assembly_module_terminals with a description of 'pca terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_bare_die">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_bare_die is an externally_defined_physical_unit that
implements the ARM concept of <internal.ref Linkend="Bare_die">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_bare_die
  SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: SIZEOF (QUERY (ifdu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifdu.relating_product_definition)) AND
       (ifdu.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'device unit technology') |
       dut.relating_property_definition\property_definition.name = 
       'unit technology')) = 1)) = 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0;
END_ENTITY; -- externally_defined_bare_die
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_bare_die shall be related to exactly one
functional_unit with a frame_of_reference name of 'functional design usage' as
the 'implemented function'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_bare_die shall have exactly one property_definition 
that is related to exactly one property_definition with a name of
'unit technology' as the 'device unit technology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_bare_die shall have at least two shape_aspects
that are bare_die_terminals.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_functional_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_functional_unit is a functional_unit and an
externally_defined_product_definition that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Externally_defined_ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Functional_unit_definition"></list.item>
<list.item><internal.ref Linkend="Functional_unit_usage_view"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_functional_unit
  SUBTYPE OF (functional_unit, externally_defined_product_definition);
END_ENTITY; -- externally_defined_functional_unit
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_interconnect_definition">
<ENTITY.DESCRIPTION>
An externally_defined_interconnect_definition is an 
externally_defined_physical_unit that implements the ARM concept
of <internal.ref Linkend="Pcb_usage_view">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_interconnect_definition
 SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR
       (SELF\product_definition.name = 'interconnect module');
END_ENTITY; -- externally_defined_interconnect_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_interconnect_definition shall be a definition with a name of 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_package">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_package is an externally_defined_physical_unit that
implements the ARM concepts of
<internal.ref Linkend="Altered_package">
and <internal.ref Linkend="Package">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_package
 SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical design usage';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
                           'registered case style')) >= 1))) = 0;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr)) |
       sr_pdr.used_representation\representation.name = 'seating plane')) = 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY' IN 
       TYPEOF (sa))) <= 1))) = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL' IN 
       TYPEOF (sa))) >= 1))) = 0;
  WR6: (NOT (SELF\product_definition.description = 'altered package')) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'package preparation') AND
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (pdr.relating_product_definition)) = 1))) = 1); 
END_ENTITY; -- externally_defined_package
(*
</EXPRESS.CODE>
      

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_package shall have a frame_of_reference name of
'physical design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_package shall have at least one representation
with the name of 'registered case style'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_package shall have exactly one
shape_representation with the name of 'seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_package shall have at most one package_body.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_package shall have at least one package_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_package has a description of 'altered
package', it shall be related to exactly one package,
externally_defined_package, or library_defined_package as the
'package preparation'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
Each three-dimensional shape representation of the externally_defined_package shall have exactly one 
geometric_representation_item that is an axis2_placement_3d and that 
axis2_placement_3d shall define the location and orientation of the
seating plane in that representation.  The normal of the seating plane
in that representation shall be congruent with and the same direction as the Z axis of the
axis2_placement_3d.  The plane of the seating plane in that representation shall be congruent
with the plane established by the X and Y axes of the axis2_placement_3d.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_packaged_connector">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_packaged_connector is an externally_defined_packaged_part
that implements the ARM concept of <internal.ref Linkend="Packaged_connector">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_packaged_connector
 SUBTYPE OF (externally_defined_packaged_part);
END_ENTITY; -- externally_defined_packaged_connector
(*
</EXPRESS.CODE>


<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
There shall be at least one shape_aspect that is a 
packaged_connector_terminal_relationship for the externally_defined_packaged_connector.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_packaged_part">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_packaged_part is an externally_defined_physical_unit
that implements the ARM concepts of
<internal.ref Linkend="Altered_packaged_part">
and <internal.ref Linkend="Packaged_part">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_packaged_part
 SUPERTYPE OF (externally_defined_packaged_connector)
 SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0);
  WR2: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (ifu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN
       TYPEOF (ifu.relating_product_definition)) AND
       (ifu.relating_product_definition.frame_of_reference.name =
       'functional design usage'))) = 1);
  WR4: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (upkg <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'used package') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE' IN
       TYPEOF (upkg.related_product_definition))) = 1);
  WR5: (NOT (SELF\product_definition.description = 
       'altered packaged part')) OR
       (SIZEOF (QUERY (bpp <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'base packaged part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] * 
       TYPEOF (bpp.relating_product_definition)) = 1) AND
       (bpp.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) >= 1);
  WR6: (NOT (SELF\product_definition.description = 
       'altered packaged part')) OR
       (SIZEOF (QUERY (upkg <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'used package') |
       SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] * 
       TYPEOF (upkg.relating_product_definition)) = 1)) >= 1);
END_ENTITY; -- externally_defined_packaged_part
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall have at least one shape_aspect that is a
packaged_part_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall have exactly one material_designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall be related to exactly one functional_unit
with a frame_of_reference name of 'functional design usage' as the
'implemented function'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall relate to exactly one package to specify the
'used package'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_packaged_part has a description of 'altered
packaged part', it shall be related to at least one packaged_part,
externally_defined_packaged_part, or library_defined_packaged_part with a
frame_of_reference name of 'physical design usage' as the 'base packaged
part'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the externally_defined_packaged_part has a description of 'altered
packaged part', it shall be related to at least one package, 
externally_defined_package, or library_defined_package as the 'used package'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_physical_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_physical_unit is a physical_unit and an
externally_defined_product_definition that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Assembly_module_usage_view"></list.item>
<list.item><internal.ref Linkend="Ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Externally_defined_ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Interconnect_module_usage_view"></list.item>
<list.item><internal.ref Linkend="Physical_unit"></list.item>
<list.item><internal.ref Linkend="Physical_unit_usage_view"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_physical_unit
 SUPERTYPE OF (ONEOF  (externally_defined_package, externally_defined_packaged_part,   
  externally_defined_bare_die, externally_defined_assembly_definition, 
  externally_defined_interconnect_definition))
 SUBTYPE OF (physical_unit, externally_defined_product_definition);
END_ENTITY; -- externally_defined_physical_unit
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_product_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_product_definition is a product_definition and an
externally_defined_item that implements the ARM concept of:
<internal.ref Linkend="Externally_defined_ee_product_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_product_definition
 SUPERTYPE OF (library_defined_product_definition)
 SUBTYPE OF (product_definition, externally_defined_item);
END_ENTITY; -- externally_defined_product_definition
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="externally_defined_representation_item">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An externally_defined_representation_item is an externally_defined_item and
a representation_item that implements the ARM concept
of <internal.ref Linkend="External_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY externally_defined_representation_item
  SUBTYPE OF (externally_defined_item, representation_item);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
END_ENTITY; -- externally_defined_representation_item
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The externally_defined_representation_item shall be referenced by exactly
one applied_document_reference.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="fabrication_joint">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A fabrication_joint is a shape_aspect and a shape_aspect_relationship that implements the ARM concept
of <internal.ref Linkend="Fabrication_joint">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY fabrication_joint
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description IN
       ['via terminal', 'printed component join terminal',
       'non functional land join terminal',
       'land join terminal', 'conductive interconnect element terminal',
       'component termination passage join terminal']));
  WR2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       (SELF.relating_shape_aspect\shape_aspect.description IN
       ['via terminal', 'printed component join terminal',
       'non functional land join terminal',
       'land join terminal', 'conductive interconnect element terminal',
       'component termination passage join terminal']));
  WR3: SIZEOF (QUERY (ajm <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'auxiliary joint material') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND' IN
       TYPEOF (ajm.related_shape_aspect)) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (ajm.related_shape_aspect)) AND
       (ajm.related_shape_aspect\shape_aspect.description =
       'stratum feature template component')))) <= 1;
  WR4: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'+
       'FABRICATION_JOINT');
END_ENTITY; -- fabrication_joint
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The fabrication_joint relating_shape_aspect attribute shall relate to exactly one component_terminals that have a description of 'via terminal', 'printed component join terminal', 'non functional land join terminal', 'land join terminal', 'conductive interconnect element terminal', or 'component termination passage join terminal' to specify the 'fabrication features'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The fabrication_joint related_shape_aspect attribute shall relate to exactly one component_terminals that have a description of 'via terminal', 'printed component join terminal', 'non functional land join terminal', 'land join terminal', 'conductive interconnect element terminal', or 'component termination passage join terminal' to specify the 'fabrication features'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The fabrication_joint shall relate to either at most one land or to at most one component_shape_aspect that has a description of 'stratum feature template component', to specify the 'auxiliary joint material'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The fabrication_joint shall not participate in a cyclic relationship.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="feature_shape_occurrence_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A feature_shape_occurrence_relationship is a representation and a shape_representation_relationship
that implements the ARM concept of <internal.ref Linkend="Feature_shape_occurrence_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY feature_shape_occurrence_relationship
  SUBTYPE OF (representation, shape_representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
  WR2: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\feature_shape_occurrence_relationship))) = 0;
END_ENTITY; -- feature_shape_occurrence_relationship 
(* 
</EXPRESS.CODE> 
<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR"> 
<FORMAL.PROPOSITIONS.RUL>
The combination of rep_1 and rep_2 shall be unique within a population of feature_shape_occurrence_relationship.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The feature_shape_occurrence_relationship rep_1 shall not be rep_2. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The feature_shape_occurrence_relationship shall not be a complex subtype of other than its direct supertypes.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="fiducial">
<ENTITY.DESCRIPTION>
A fiducial is a component_shape_aspect that implements the ARM concept of <internal.ref Linkend="Fiducial">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY fiducial
  SUBTYPE OF (component_shape_aspect);
WHERE
  wr1: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'COMPONENT_DEFINITION') IN TYPEOF(SELF.of_shape.definition))
            AND (SELF.of_shape.definition\product_definition.description = 
                    'laminate component');
END_ENTITY; -- fiducial
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The fiducial shall be an aspect of a definition with a name of 'interconnect module'. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="fiducial_part_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A fiducial_part_feature is a part_tooling_feature that implements the ARM
concept of <internal.ref Linkend="Fiducial_part_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY fiducial_part_feature
 SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- fiducial_part_feature
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="fiducial_stratum_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A fiducial_stratum_feature is a stratum_feature that implements the ARM
concept of <internal.ref Linkend="Fiducial_stratum_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY fiducial_stratum_feature
 SUBTYPE OF (stratum_feature);
END_ENTITY; -- fiducial_stratum_feature
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="filled_area_material_removal_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A filled_area_material_removal_component_shape_aspect is a material_removal_component_shape_aspect
that implements the ARM concept of <Internal.ref Linkend="Filled_area_material_removal_laminate_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY filled_area_material_removal_component_shape_aspect
  SUBTYPE OF (material_removal_component_shape_aspect);
END_ENTITY; -- filled_area_material_removal_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="footprint_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An footprint_definition is a product_definition that implements the ARM concepts of:
<internal.ref Linkend="Footprint_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY footprint_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\footprint_definition))) = 0;
  WR7: SELF.frame_of_reference.name IN ['layout design usage' ];
  WR8: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'template model')) = 1;
END_ENTITY; -- footprint_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the footprint_definition is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_definition shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_definition shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_definition shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_definition shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_definition shall not be any other type of product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_definition shall have a frame_of_reference with a name of 'layout design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_definition shall be associated with a product that is a template model.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="footprint_occurrence">
<ENTITY.DESCRIPTION>
A footprint_occurrence is an assembly_group_component_shape_aspect that implements the ARM concept of<internal.ref Linkend="Footprint_occurrence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY footprint_occurrence
  SUBTYPE OF (assembly_group_component_shape_aspect);
END_ENTITY; -- footprint_occurrence
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="footprint_occurrence_shape_aspect_relationship">
<ENTITY.DESCRIPTION>
A footprint_occurrence_shape_aspect_relationship is a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Footprint_occurrence_sub_assembly_relationship">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY footprint_occurrence_shape_aspect_relationship
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: SELF\shape_aspect_relationship.name = 'footprint occurrence sub assembly relationship';
END_ENTITY; -- footprint_occurrence_shape_aspect_relationship 
(* 
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related shape_aspect shall not be the relating shape_aspect. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The footprint_occurrence_shape_aspect_relationship name shall be 'footprint occurrence sub assembly relationship'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="force_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A force_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Force_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY force_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\force_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = newton;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- force_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The force_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The force_measure_with_unit shall reference an si_unit with a name of newton. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="frequency_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A frequency_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Frequency_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY frequency_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\frequency_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = hertz;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- frequency_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The frequency_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The frequency_measure_with_unit shall reference an si_unit with a name of hertz. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="frozen_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An frozen_assignment is an approval_assignment that specifies
a set of frozen_assigned_item.  An item that is 'approved' is frozen.  An item that is 'not yet approved' is not frozen.
<example>
A component placement is considered frozen (i.e., the component cannot 
be moved) if its next_assembly_usage_occurrence is a member of the set of 
frozen_assigned_item and the approval_status is "approved".
</example>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY frozen_assignment 
 SUBTYPE OF (approval_assignment); 
 items : SET [1:?] OF frozen_assigned_item; 
WHERE
 WR1: SELF\approval_assignment.assigned_approval.status.name in ['approved', 'not yet approved'];
END_ENTITY; -- frozen_assignment
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The approval status shall either be 'approved' or 'not yet approved'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="functional_specification">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An functional_specification is a representation that implements the ARM
concept of <internal.ref Linkend="Functional_specification">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY functional_specification
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
       (rr\representation_relationship.name = 'functional characteristic category') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNAL_DEFINITION' IN
       TYPEOF (rr.rep_1.items[1])))) = 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       (rr\representation_relationship.name = 'characterizing signal' +
       'for functional specification')
       )) = 1;
  WR3: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       (rr\representation_relationship.name = 'reference signal for' +
        'functional specification') 
       )) = 1;
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\functional_specification)) = 0;
  WR5: SELF\representation.name = '';
  WR6: SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF (pdr.definition.definition)) 
        )) = 0;
END_ENTITY; -- functional_specification
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
  
<FORMAL.PROPOSITIONS.RUL>
The functional_specification shall be in exactly one 'functional characteristic category'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_specification shall reference exactly one 'characterizing signal for functional specification'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_specification shall reference exactly one 'reference signal for functional specification'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_specification shall be no other type of representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_specification name shall be blank.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_specification shall reference exactly one component_functional_unit.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="functional_specification_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A functional_specification_definition is a functional_unit that implements the ARM concept
of <Internal.ref Linkend="Functional_specification_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY functional_specification_definition
  SUBTYPE OF (functional_unit);
WHERE
  WR1: SELF.frame_of_reference\application_context_element.name =
             'functional network design';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_SPECIFICATION' IN TYPEOF (pdr.used_representation))
       )) > 0))) > 0;
END_ENTITY; -- functional_specification_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The functional_specification_definition context shall be 'functional network design'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The functional_specification_definition shall be related to at least one functional_specification.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="functional_terminal_group">
<ENTITY.DESCRIPTION>
A functional_terminal_group is a group that specifies a type for the terminals assigned to the group.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY functional_terminal_group
 SUBTYPE OF (group);
UNIQUE
   UR1: SELF\group.name;
END_ENTITY; -- functional_terminal_group
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="functional_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A functional_unit is the characterization of the functionality of an occurrence of an electrical device or of an abstract component.
A functional_unit implements the ARM concepts of:
<list>
<list.item><Internal.ref Linkend="Ee_product_definition"></list.item>
<list.item><Internal.ref Linkend="Electrical_network_definition"></list.item>
<list.item><Internal.ref Linkend="Functional_specification_definition"></list.item>
<list.item><Internal.ref Linkend="Functional_unit_definition"></list.item>
<list.item><Internal.ref Linkend="Functional_unit_network_definition"></list.item>
<list.item><Internal.ref Linkend="Functional_unit_usage_view"></list.item>
<list.item><Internal.ref Linkend="Thermal_network_definition"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY functional_unit
 SUPERTYPE OF ((electrical_network)
              ANDOR (thermal_network) 
	      ANDOR (functional_specification_definition))
 SUBTYPE OF (product_definition);
WHERE
  WR1: SELF.frame_of_reference.name IN ['functional design usage', 
       'functional network design'];
  WR2: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
   SELF\product_definition_with_associated_documents.documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR3: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) = 1; 
  WR4: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR5: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR6: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR7: (NOT (SELF.frame_of_reference.name = 
                                 'functional network design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       du.relating_product_definition.frame_of_reference.name = 
       'functional design usage')) = 1);
  WR8: (NOT (SIZEOF([
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
            'THERMAL_NETWORK',
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
            'ELECTRICAL_NETWORK'] * TYPEOF(SELF)) = 1))
        OR (SELF.frame_of_reference.name = 'functional network design');
END_ENTITY; -- functional_unit
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The functional_unit shall have a frame_of_reference with a name of
'functional design usage' or 'functional network design'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the functional_unit is a product_definition_with_associated_documents, 
there shall be at most one document in the set of documentation_ids
that has a product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_unit shall have exactly one creation date and time.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_unit shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_unit shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_unit shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the functional_unit is a functional network design it shall be related to exactly one functional_unit that is a functional design usage as the design usage.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the functional_unit is a thermal_network or an electrical_network
the frame_of_reference attribute shall be satisfied by an entity with
a name equal to 'functional network design'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="functional_unit_terminal_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A functional_unit_terminal_definition is a shape_aspect that implements the
ARM concepts of 
<internal.ref Linkend="Functional_unit_usage_view_terminal_definition">
and <internal.ref Linkend="Scalar_terminal_definition">. 
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY functional_unit_terminal_definition
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN
       TYPEOF (SELF.of_shape.definition)) AND
   (SELF.of_shape.definition\product_definition.frame_of_reference.name =
       'functional design usage');
  WR2: SIZEOF (QUERY (pd2 <* QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION' IN
       TYPEOF (pd)) |
       SIZEOF (QUERY (funtdba <* QUERY (pdr <* USEDIN (pd2,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 
       'functional unit network terminal definition bus assignment') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION' IN 
       TYPEOF 
       (funtdba.relating_property_definition.definition))) <= 1)) <= 1;
  WR3: SIZEOF (QUERY (pd2 <* QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION' IN
       TYPEOF (pd)) |
       SIZEOF (QUERY (funtdna <* QUERY (pdr <* USEDIN (pd2,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 
       'functional unit network terminal definition node assignment') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NETWORK_NODE_DEFINITION' IN 
       TYPEOF 
       (funtdna.relating_property_definition.definition))) <= 1)) <= 1;
END_ENTITY; -- functional_unit_terminal_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The functional_unit_terminal_definition shall be an aspect of the shape
of a functional_unit that has a context element with a name of 'functional design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_unit_terminal_definition shall have no more than one 
property definition that is related to at most one property of a 
bus_structural_definition as the 'functional unit network terminal definition 
bus assignment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The functional_unit_terminal_definition shall have no more than one 
property definition that is related to at most one property of a 
network_node_definition as the 'functional unit network terminal definition 
node assignment'.
</FORMAL.PROPOSITIONS.RUL>

<!--
 added changed supertype mm 7/2/97
 commented out WR1 mm 7/2/97

-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="geometric_tolerance_group">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A geometric_tolerance_group is a property_definition that implements the ARM
concepts of <internal.ref Linkend="Separate_geometric_tolerance_requirement">
and <internal.ref Linkend="Simultaneous_geometric_tolerance_requirement">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY geometric_tolerance_group
  SUBTYPE OF (property_definition);
WHERE
    WR1: SELF\property_definition.description
         IN ['separate requirement', 'simultaneous requirement'];
    WR2: (NOT (SELF\property_definition.description = 
          'separate requirement'))
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' 
         IN TYPEOF(pdr.related_property_definition)) AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance')
         )) >=1);
    WR3: (NOT (SELF\property_definition.description = 
        'simultaneous requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' 
         IN TYPEOF(pdr.related_property_definition)) AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance'))
         )) >=2);
    WR4: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'LINEAR_PROFILE_TOLERANCE' IN 
          TYPEOF(pdr.related_property_definition)) AND
         (pdr.related_property_definition\property_definition.name = 
         'linear profile refinement') AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance') )
         )) =0);
    WR5: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'SURFACE_PROFILE_TOLERANCE' IN 
         TYPEOF(pdr.related_property_definition)) AND
         (pdr.related_property_definition\property_definition.name = 
         'surface profile refinement') AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance') )
         )) =0);
    WR6: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'POSITION_TOLERANCE' IN 
         TYPEOF(pdr.related_property_definition)) AND
         (pdr.related_property_definition\property_definition.name = 
         'feature relating position') AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance') )
         )) =0);
    WR7: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (pdr\property_definition_relationship.name = 'group geometric tolerance') AND
      (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'LINEAR_PROFILE_TOLERANCE',
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'SURFACE_PROFILE_TOLERANCE',
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'POSITION_TOLERANCE'] * TYPEOF(pdr.related_property_definition)) > 0)
         )) =0);
END_ENTITY; -- geometric_tolerance_group
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The geometric_tolerance_group shall have a description of either 'separate requirement' or 
'simultaneous requirement'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the geometric_tolerance_group has a description of 'separate requirement', the 
geometric_tolerance_group shall relate to at least one 
geometric_tolerance_with_specified_datum_system to specify the 'group geometric tolerance'.
</Formal.propositions.rul>

<formal.propositions.rul>
If the geometric_tolerance_group has a description of 'simultaneous requirement', the 
geometric_tolerance_group shall relate to at least two physical_unit_geometric_tolerances to specify 
the 'group geometric tolerance'.
</formal.propositions.rul>

<formal.propositions.rul>
If the geometric_tolerance_group has a description of 'separate requirement', the 
geometric_tolerance_group shall relate to exactly zero linear_profile_tolerance with a name of 
'linear profile refinement' to specify the 'group geometric tolerance'.
</formal.propositions.rul>

<formal.propositions.rul>
If the geometric_tolerance_group has a description of 'separate requirement', the 
geometric_tolerance_group shall relate to exactly zero surface_profile_tolerance with a name of 
'surface profile refinement' to specify the 'group geometric tolerance'.
</formal.propositions.rul>

<formal.propositions.rul>
If the geometric_tolerance_group has a description of 'separate requirement', the 
geometric_tolerance_group shall relate to exactly zero position_tolerance with a name of 'feature 
relating position' to specify the 'group geometric tolerance'.
</formal.propositions.rul>

<formal.propositions.rul>
If the geometric_tolerance_group has a description of 'separate requirement', the 
geometric_tolerance_group shall relate to exactly zero physical_unit_geometric_tolerance, to 
specify the 'group geometric tolerance', that are not either linear_profile_tolerance, 
surface_profile_tolerance, or position_tolerance.
</formal.propositions.rul>

</Formal.propositions>

<Informal.propositions rule.types="IP">

<Informal.propositions.rul>
If the geometric_tolerance_group has a description of 'separate requirement' and the 
geometric_tolerance_group relates to at least two geometric_tolerance_with_specified_datum_systems 
to specify the 'group geometric tolerance', all of the 
geometric_tolerance_with_specified_datum_system shall relate to the same property_definition to 
specify the 'referenced datum system definition', and that property_definition shall have a 
description of either 'datum system property with material conditions' or 'datum system property 
without material conditions'.
</Informal.propositions.rul>


<Informal.propositions.rul>
If the geometric_tolerance_group has a description of 'simultaneous requirement' and the 
geometric_tolerance_group relates to at least two physical_unit_geometric_tolerances to specify the 
'group geometric tolerance', all of the physical_unit_geometric_tolerance either shall not relate 
to a property_definition to specify the 'referenced datum system definition' or shall relate to the 
same property_definition to specify the 'referenced datum system definition', and that 
property_definition shall have a description of either 'datum system property with material 
conditions' or 'datum system property without material conditions'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the geometric_tolerance_group has a description of 'simultaneous requirement', the 
geometric_tolerance_group shall relate to exactly zero physical_unit_geometric_tolerance, to 
specify the 'group geometric tolerance', that are not either a linear_profile_tolerance with a 
description of 'linear profile refinement', a surface_profile_tolerance with a description of 
'surface profile refinement', or a position_tolerance with a description of 'feature relating 
position'.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="geometric_tolerance_with_specified_datum_system">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A geometric_tolerance_with_specified_datum_system is a
physical_unit_geometric_tolerance that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Boundary_based_position_tolerance"></list.item>
<list.item><internal.ref Linkend="Composite_feature_locating_position_tolerance"></list.item>
<list.item><internal.ref Linkend="Composite_linear_profile_locating_tolerance"></list.item>
<list.item><internal.ref Linkend="Composite_surface_profile_locating_tolerance"></list.item>
<list.item><internal.ref Linkend="Geometric_tolerance_with_referenced_datum_system"></list.item>
<list.item><internal.ref Linkend="Position_tolerance_with_referenced_datum_system"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_line_tolerance_with_referenced_datum_system"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_surface_tolerance_with_referenced_datum_system"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY geometric_tolerance_with_specified_datum_system
  SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
   WR1: SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'ANGULARITY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'POSITION_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'CIRCULAR_RUNOUT_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'LINEAR_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'SURFACE_PROFILE_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'CONCENTRICITY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'PARALLELISM_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'PERPENDICULARITY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'SYMMETRY_TOLERANCE',
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'TOTAL_RUNOUT_TOLERANCE'] * TYPEOF(SELF)) = 1;

   WR2: SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         ((pdr.related_property_definition\property_definition.description =
           'datum system property with material conditions')
          OR (pdr.related_property_definition\property_definition.description =
              'datum system property without material conditions'))
         AND (pdr\property_definition_relationship.name = 'referenced datum system definition')
         )) = 1;

   WR3: SIZEOF (QUERY(pdr <* USEDIN(SELF,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
           + 'GEOMETRIC_TOLERANCE_GROUP' IN 
             TYPEOF(pdr.related_property_definition))
          AND (pdr.related_property_definition\property_definition.description = 
              'separate requirement')
          AND (pdr\property_definition_relationship.name = 'group geometric tolerance')
         )) <= 1;
END_ENTITY; -- geometric_tolerance_with_specified_datum_system
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">
<formal.propositions.rul>
The geometric_tolerance_with_specified_datum_system shall be one of the following types: 
angularity_tolerance, position_tolerance, circular_runout_tolerance, linear_profile_tolerance, 
surface_profile_tolerance, concentricity_tolerance, parallelism_tolerance, 
perpendicularity_tolerance, symmetry_tolerance, or total_runout_tolerance.
</formal.propositions.rul>

<formal.propositions.rul>
The geometric_tolerance_with_specified_datum_system shall relate to exactly one property_definition that has 
the description of either 'datum system property with material conditions' or 'datum system 
property without material conditions' to specify the 'referenced datum system definition'.
</formal.propositions.rul>

<formal.propositions.rul>
The geometric_tolerance_with_specified_datum_system shall be related to at most one 
geometric_tolerance_group with a description of 'separate requirement' as the 'group geometric 
tolerance'.
</formal.propositions.rul>

</formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="group_product_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A group_product_definition is a component_definition that implements the ARM
concept of <internal.ref Linkend="Placement_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY group_product_definition
  SUBTYPE OF (component_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'design requirement';
  WR2: (NOT (SELF\product_definition.description = 
                                      'placement group')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF (pd))) >= 1);
END_ENTITY; -- group_product_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The group_product_definition shall have a frame_of_reference name of
'design requirement'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_product_definition has a description of 'placement group',
it shall have at least one requirements_property. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="group_shape_aspect">
<ENTITY.DESCRIPTION>
A group_shape_aspect is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Interconnect_module_constraint_region"></list.item>
<list.item><internal.ref Linkend="Placement_group"></list.item>
<list.item><internal.ref Linkend="Termination_constraint"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY group_shape_aspect
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION' IN
       TYPEOF (SELF\shape_aspect.of_shape.definition);
  WR2: NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region']) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (SELF\shape_aspect.of_shape.definition)) AND
       (EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name)) AND
       (NOT EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name) OR 
       (SELF\shape_aspect.of_shape.definition\product_definition.name = 'interconnect module')));
 WR3: ((NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'constrained object')
     AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                    'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY') IN
                  TYPEOF(pdr.related_property_definition.definition)))
                        )) = 1)
                )) = 1));
 WR4: (NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'design specific purpose'))) = 1)) = 1))) = 0);
  WR5: (NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'keepout') AND
       (it\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1))) = 0);
  WR6: (NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) = 1)) = 1);
  WR7: (NOT(SELF\shape_aspect.description IN
       ['interconnect module constraint region'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'requirement')
     AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                    'REQUIREMENTS_PROPERTY') IN
                  TYPEOF(pdr.relating_property_definition)))
                        )) = 1)
                )) = 1);
  WR8: (NOT(SELF\shape_aspect.description = 
       'termination constraint')) OR
       (SIZEOF (QUERY (ctm <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'constrained termination member') |
       ctm.related_shape_aspect\shape_aspect.description = 
       'mating connector termination')) >= 2);
  WR9: EXISTS(SELF\shape_aspect.description);
  WR10: (NOT(SELF\shape_aspect.description IN
       ['placement group'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'requirement')
     AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                    'REQUIREMENTS_PROPERTY') IN
                  TYPEOF(pdr.relating_property_definition))
               AND
           (pdr.relating_property_definition\property_definition.name = 'requirement')))
                   ) = 1)
                )) = 1);
  WR11: (NOT(SELF\shape_aspect.description IN
       ['termination constraint'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'termination usage constraint')
     AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                    'REQUIREMENTS_PROPERTY') IN
                  TYPEOF(pdr.relating_property_definition))
                           AND
    (pdr.relating_property_definition\property_definition.name = 'termination usage constraint')))
                        ) = 1) 
                )) = 1);
END_ENTITY; -- group_shape_aspect
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The group_shape_aspect shall be an aspect of the shape of a product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'interconnect module
constraint region', it shall be an aspect of the shape of a 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'interconnect module
constraint region', it shall relate to exactly one 
interconnect_module_design_object_category to specify the 'constrained object'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'interconnect module
constraint region', it shall have exactly one representation that contains
exactly one descriptive_representation_item with a name of 'design specific
purpose'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'interconnect module
constraint region', it shall have exactly one representation that contains
exactly one descriptive_representation_item with a name of 'keepout' and a
description of either 'true' or 'false'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'interconnect module
constraint region', it shall have exactly one property that has exactly one
shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'interconnect module constraint region', or 'termination constraint', or 'placement group' it shall have exactly one requirements_property.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect  has a description of 'termination constraint', it shall relate to at least two shape_aspects with a description of 'mating connector termination' to specify a 'constrained termination member'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The attribute description inherited from shape_aspect shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'placement group' it shall have exactly one requirements_property.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the group_shape_aspect has a description of 'termination constraint' it shall have exactly one requirements_property.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="grouped_requirements_property">
<ENTITY.DESCRIPTION>
A grouped_requirements_property is a group and a requirements_property that 
implements the ARM concepts of
<internal.ref Linkend="Item_restricted_requirement_occurrence">
and <internal.ref Linkend="Layout_spacing_requirement_occurrence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY grouped_requirements_property
  SUBTYPE OF (group, requirements_property);
WHERE
  WR1: (NOT (SELF\group.name = 
        'item restricted requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       SIZEOF (aga.items) = 1)) = 1);
  WR2: (NOT (SELF\group.name = 
        'layout spacing requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (aga.items) = 2) AND
       (SIZEOF (QUERY (rp <* QUERY (it <* aga.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (it)) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (rp)) AND
       (rp\characterized_object.name IN [
       'assembly module assembly component',
       'assembly module component terminal',
       'assembly module component',
       'assembly module macro component join terminal',
       'assembly module macro component',
       'assembly module',
       'bare die component terminal',
       'bare die component',
       'bonded conductive base blind via',
       'buried via',
       'cable component',
       'component feature',
       'component mounting feature',
       'component termination passage and contact size dependent land',
       'component termination passage and contact size dependent non functional land',
       'component termination passage dependent land',
       'component termination passage dependent non functional land',
       'component termination passage interface terminal',
       'component termination passage join terminal',
       'component termination passage',
       'conductive interconnect element terminal',
       'conductive interconnect element with pre defined transitions',
       'conductive interconnect element with user defined single transition',
       'connected area component',
       'contact size dependent land',
       'contact size dependent non functional land',
       'cutout edge segment',
       'cutout',
       'dielectric material passage',
       'electrical isolation laminate component',
       'embedded component terminal',
       'fiducial',
       'fill area',
       'filled area material removal laminate component',
       'inter stratum feature',
       'interconnect component interface terminal',
       'interconnect component join terminal',
       'interconnect module assembly component',
       'interconnect module component stratum based terminal',
       'interconnect module component surface feature',
       'interconnect module component terminal',
       'interconnect module component',
       'interconnect module edge segment',
       'interconnect module edge',
       'interconnect module macro component join terminal',
       'interconnect module macro component',
       'interface access material removal laminate component',
       'interface access stratum feature template component',
       'interface component',
       'interfacial connection',
       'internal probe access area',
       'join two physical connectivity definition supporting inter stratum feature',
       'join two physical connectivity definition supporting printed component',
       'laminate component',
       'laminate text component',
       'laminate text string component',
       'land interface terminal',
       'land join terminal',
       'land',
       'material removal laminate component',
       'minimally defined component terminal',
       'movable packaged component join terminal',
       'multi layer material removal laminate component',
       'multi layer stratum feature template component',
       'non conductive base blind via',
       'non functional land interface terminal',
       'non functional land join terminal',
       'non functional land',
       'packaged component join terminal',
       'packaged component',
       'packaged connector component interface terminal',
       'packaged connector component',
       'partially plated cutout',
       'partially plated interconnect module edge',
       'physical component',
       'physical connectivity interrupting cutout',
       'physical laminate component',
       'physical network supporting inter stratum feature',
       'plated conductive base blind via',
       'plated cutout edge segment',
       'plated cutout',
       'plated interconnect module edge segment',
       'plated interconnect module edge',
       'plated passage or unsupported passage',
       'plated passage',
       'primary stratum indicator symbol',
       'printed component join terminal',
       'printed connector component interface terminal',
       'probe access area',
       'routed interconnect component',
       'routed physical component',
       'special symbol laminate component',
       'stratum feature template component',
       'stratum feature',
       'thermal isolation laminate component',
       'unrouted conductive interconnect element',
       'unsupported passage dependent non functional land',
       'unsupported passage',
       'via and contact size dependent land',
       'via and contact size dependent non functional land',
       'via dependent land',
       'via dependent non functional land',
       'via terminal',
       'via']))) = 2))) = 1);
  WR3: (NOT (SELF\group.name = 
       'layout spacing requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (QUERY (rp <* QUERY (it <* aga.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (it)) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (rp)) AND
       (rp\characterized_object.description = 
       'dependent design object category'))) = 1))) = 1);
  WR4: (NOT (SELF\group.name = 
       'layout spacing requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (QUERY (rp <* QUERY (it <* aga.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (it)) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (rp)) AND
       (rp\characterized_object.description = 
       'reference design object category'))) = 1))) = 1);
END_ENTITY; -- grouped_requirements_property
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the grouped_requirements_property has a group name of 'item
restricted requirements property', it shall be assigned to exactly one item.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the grouped_requirements_property has a group name of 'layout spacing
requirements property', it shall be assigned to exactly
two <express.construct NAME.Linkend="design_object">s 
with a name of 
'assembly module assembly component',
'assembly module component terminal',
'assembly module component',
'assembly module macro component join terminal',
'assembly module macro component',
'assembly module',
'bare die component terminal',
'bare die component',
'bonded conductive base blind via',
'buried via',
'cable component',
'component feature',
'component mounting feature',
'component termination passage and contact size dependent land',
'component termination passage and contact size dependent non functional land',
'component termination passage dependent land',
'component termination passage dependent non functional land',
'component termination passage interface terminal',
'component termination passage join terminal',
'component termination passage',
'conductive interconnect element terminal',
'conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition',
'connected area component',
'contact size dependent land',
'contact size dependent non functional land',
'cutout edge segment',
'cutout',
'dielectric material passage',
'electrical isolation laminate component',
'embedded component terminal',
'fiducial',
'fill area',
'filled area material removal laminate component',
'inter stratum feature',
'interconnect component interface terminal',
'interconnect component join terminal',
'interconnect module assembly component',
'interconnect module component stratum based terminal',
'interconnect module component surface feature',
'interconnect module component terminal',
'interconnect module component',
'interconnect module edge segment',
'interconnect module edge',
'interconnect module macro component join terminal',
'interconnect module macro component',
'interface access material removal laminate component',
'interface access stratum feature template component',
'interface component',
'interfacial connection',
'internal probe access area',
'join two physical connectivity definition supporting inter stratum feature',
'join two physical connectivity definition supporting printed component',
'laminate component',
'laminate text component',
'laminate text string component',
'land interface terminal',
'land join terminal',
'land',
'material removal laminate component',
'minimally defined component terminal',
'movable packaged component join terminal',
'multi layer material removal laminate component',
'multi layer stratum feature template component',
'non conductive base blind via',
'non functional land interface terminal',
'non functional land join terminal',
'non functional land',
'packaged component join terminal',
'packaged component',
'packaged connector component interface terminal',
'packaged connector component',
'partially plated cutout',
'partially plated interconnect module edge',
'physical component',
'physical connectivity interrupting cutout',
'physical laminate component',
'physical network supporting inter stratum feature',
'plated conductive base blind via',
'plated cutout edge segment',
'plated cutout',
'plated interconnect module edge segment',
'plated interconnect module edge',
'plated passage or unsupported passage',
'plated passage',
'primary stratum indicator symbol',
'printed component join terminal',
'printed connector component interface terminal',
'probe access area',
'routed interconnect component',
'routed physical component',
'special symbol laminate component',
'stratum feature template component',
'stratum feature',
'thermal isolation laminate component',
'unrouted conductive interconnect element',
'unsupported passage dependent non functional land',
'unsupported passage',
'via and contact size dependent land',
'via and contact size dependent non functional land',
'via dependent land',
'via dependent non functional land',
'via terminal' or
'via'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the grouped_requirements_property has a group name of 'layout spacing
requirements property', it shall be assigned to exactly one 
design_object with a description of 
'dependent design object category'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the grouped_requirements_property has a group name of 'layout spacing
requirements property', it shall be assigned to exactly one 
design_object with a description of 
'reference design object category'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="guided_wave_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A guided_wave_terminal is a package_terminal that implements the ARM
concept of <Internal.ref Linkend="Guided_wave_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY guided_wave_terminal
   SUBTYPE OF (package_terminal);
END_ENTITY; -- guided_wave_terminal
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="illuminance_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An illuminance_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Illuminance_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY illuminance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\illuminance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = lux;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- illuminance_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The illuminance_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The illuminance_measure_with_unit shall reference an si_unit with a name of lux.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="inductance_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An inductance_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Inductance_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY inductance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\inductance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = henry;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- inductance_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The inductance_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The inductance_measure_with_unit shall reference an si_unit with a name of henry.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="integral_shield">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An integral_shield is a component_shape_aspect that implements the ARM concept
of <internal.ref Linkend="Shield">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY integral_shield
  SUBTYPE OF (component_shape_aspect);
WHERE
  WR1: SIZEOF (QUERY(pdr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_property_definition))
       OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'COMPONENT_SHAPE_ASPECT' IN TYPEOF(pdr.relating_property_definition)))
       AND (pdr\property_definition_relationship.name = 'shielded item'))) >=1;
END_ENTITY; -- integral_shield
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The integral_shield shall be related to at least one component_definition or to
at least one component_shape_aspect as the 'shielded item'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="inter_stratum_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An inter_stratum_feature is a component_shape_aspect that implements the ARM
concepts of:
<list>
<list.item><internal.ref Linkend="Cutout"></list.item>
<list.item><internal.ref Linkend="Cutout_edge_segment"></list.item>
<list.item><internal.ref Linkend="Dielectric_material_passage"></list.item>
<list.item><internal.ref Linkend="Inter_stratum_feature"></list.item>
<list.item><internal.ref Linkend="Interconnect_module_edge"></list.item>
<list.item><internal.ref Linkend="Interconnect_module_edge_segment"></list.item>
<list.item><internal.ref Linkend="Partially_plated_cutout"></list.item>
<list.item><internal.ref Linkend="Partially_plated_interconnect_module_edge"></list.item>
<list.item><internal.ref Linkend="Physical_connectivity_interrupting_cutout"></list.item>
<list.item><internal.ref Linkend="Unsupported_passage"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY inter_stratum_feature
 SUBTYPE OF (component_shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN ['bonded conductive base blind via', 
       'buried via', 'component termination passage', 
       'interfacial connection', 'non conductive base blind via', 
       'plated conductive base blind via', 'plated cutout', 
       'partially plated cutout', 
       'plated cutout edge segment', 
       'partially plated interconnect module edge', 
       'plated interconnect module edge segment', 
       'plated interconnect module edge', 'unsupported passage', 'cutout', 
       'physical connectivity interrupting cutout', 
       'dielectric material passage', 'cutout edge segment', 
       'interconnect module edge segment', 'interconnect module edge'];
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'feature of size') AND
       (it\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1))) = 1;
  WR3: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description IN
       ['inter stratum feature template',
       'via template',
       'component termination passage template',
       'unsupported passage template']))) = 1;
  WR4: (NOT (SELF\shape_aspect.description = 'cutout edge segment')) OR
       (SIZEOF (QUERY (cc <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed cutout') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (cc.relating_shape_aspect)) AND
       ((cc.relating_shape_aspect\shape_aspect.description =
       'cutout') OR
       (cc.relating_shape_aspect\shape_aspect.description =
       'physical connectivity interrupting cutout') OR
       (cc.relating_shape_aspect\shape_aspect.description =
       'partially plated cutout')))) = 1);
  WR5: (NOT (SELF\shape_aspect.description = 'interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed edge') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_shape_aspect)) AND
       ((ce.relating_shape_aspect\shape_aspect.description =
       'interconnect module edge') OR
       (ce.relating_shape_aspect\shape_aspect.description =
       'interconnect module edge')
        ))) = 1);
  WR6: (NOT (SELF\shape_aspect.description = 'dielectric material passage')) OR
       (SIZEOF (QUERY (pp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent passage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (pp.relating_shape_aspect)) AND
       ((pp.relating_shape_aspect\shape_aspect.description =
       'cutout') OR
       (pp.relating_shape_aspect\shape_aspect.description =
       'physical connectivity interrupting cutout') OR
       (pp.relating_shape_aspect\shape_aspect.description =
       'partially plated cutout')))) = 1);
  WR7: (NOT (SELF\shape_aspect.description = 'dielectric material passage')) OR
       ((SIZEOF (QUERY (rp <* QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF (pd)) |
       rp\property_definition.name = 'feature material')) <= 1) OR
       (SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1));
  WR8: (NOT (SELF\shape_aspect.description = 
       'physical connectivity interrupting cutout')) OR
       (SIZEOF (QUERY (ice <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'interrupted connectivity elements') |
       ice.relating_shape_aspect\shape_aspect.name =
       'conductive interconnect element')) >= 1);
  WR9: (NOT (SELF\shape_aspect.description = 'unsupported passage')) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'unsupported passage template'))) = 1);
  WR10: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SIZEOF (QUERY (prpc <*
       USEDIN (SELF.of_shape.definition.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1);
 WR11: (NOT (SELF\shape_aspect.description = 'cutout edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)))) = 1);
 WR12: (NOT (SELF\shape_aspect.description = 
       'plated cutout edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)))) = 1);
 WR13: (NOT (SELF\shape_aspect.description = 
       'interconnect module edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)))) = 1);
 WR14: (NOT (SELF\shape_aspect.description = 
       'plated interconnect module edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)))) = 1);
END_ENTITY; -- inter_stratum_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature shall have a description of 'bonded conductive
base blind via', 'buried via', 'component termination passage', 'interfacial
connection', 'non conductive base blind via', 'plated conductive base blind
via', 'partially plated cutout', 'plated cutout', 
'plated cutout edge segment', 'plated interconnect
module edge segment', 'partially plated interconnect module edge', 
'plated interconnect module edge', 'unsupported
passage', 'cutout', 'physical connectivity interrupting cutout', 'dielectric
material passage', 'cutout edge segment', 'interconnect module edge segment',
or 'interconnect module edge'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature shall have exactly one 
descriptive_representation_item with a name of 'feature
of size' and a description of 'true' or 'false'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature shall be related, as an instantiated
template, to exactly one part_template_definition that has a description of 'inter
stratum feature template', 'via template', 'component termination passage
template', or 'unsupported passage template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'cutout edge
segment', the inter_stratum_feature shall be related to exactly one
inter_stratum_feature with a description of either 'cutout' or 'physical
connectivity interrupting cutout' or 'partially plated cutout' as the 'composed cutout'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'interconnect
module edge segment', the inter_stratum_feature shall be related to exactly
one inter_stratum_feature with a description of 'interconnect module edge'
or of 'partially plated interconnect module edge' as a 'composed edge'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'dielectric
material passage', the inter_stratum_feature shall be related to exactly
one inter_stratum_feature with a description of either 'cutout' or 'physical
connectivity interrupting cutout' or 'partially plated cutout' as the 'precedent passage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'dielectric material
passage', it shall have at most one requirements_property with a name of
'feature material' or be the definition for at most one material_designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'physical
connectivity interrupting cutout', the inter_stratum_feature shall be
related to at least one shape_aspect with a name of 'conductive
interconnect element' as 'interrupted connectivity elements'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'unsupported
passage', the inter_stratum_feature shall be related to exactly one
part_template_definition with a description of 'unsupported passage template' as an
'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature shall be an aspect of the shape of a component_definition that is the definition of a product that is categorized as an 'interconnect
module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'cutout edge segment ',
the inter_stratum_feature shall be related, as an
'instantiated template', to exactly one
inter_stratum_feature_edge_segment_template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'plated cutout edge segment ',
the inter_stratum_feature shall be related, as an
'instantiated template', to exactly one
'inter_stratum_feature_edge_segment_template'.
</FORMAL.PROPOSITIONS.RUL>
 
<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'interconnect module edge segment ',
the inter_stratum_feature shall be related, as an
'instantiated template', to exactly one
inter_stratum_feature_edge_segment_template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the inter_stratum_feature has a description of 'plated interconnect module edge segment ',
the inter_stratum_feature shall be related, as an
'instantiated template', to exactly one
'inter_stratum_feature_edge_segment_template'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="inter_stratum_feature_edge_segment_template">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An inter_stratum_feature_edge_segment_template is an inter_stratum_feature and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Interconnect_module_edge_segment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY inter_stratum_feature_edge_segment_template
  SUBTYPE OF (part_template_definition,shape_aspect_relationship);
WHERE
  wr1: (SIZEOF (QUERY (ce <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE_EDGE_TEMPLATE' IN
       TYPEOF (ce.relating_shape_aspect)) 
       )) = 1);
  wr2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  wr3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  wr4: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  wr5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition ||
       SELF\shape_aspect_relationship ||
       SELF\inter_stratum_feature_edge_segment_template)) = 0;
END_ENTITY; -- inter_stratum_feature_edge_segment_template
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature_edge_segment_template shall be related to exactly one
inter_stratum_feature_edge_template. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature_edge_segment_template shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship relating attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature_edge_segment_template shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The two edge_segment_vertex instances referenced shall not be the same instance of edge_segment_vertex.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature_edge_segment_template shall not participate in complex instances
other than those of its immediate supertypes.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="inter_stratum_feature_edge_template">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A inter_stratum_feature_edge_template is a part_template_definition that implements the
ARM concept of<internal.ref Linkend="inter_stratum_feature_edge_template">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY inter_stratum_feature_edge_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition ||
       SELF\inter_stratum_feature_edge_template)) = 0;
  WR2: SELF\shape_aspect.description = 
       'inter stratum feature edge template';
END_ENTITY; -- inter_stratum_feature_edge_template
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature_edge_template shall not participate in a complex instance of other
than it's direct supertypes.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The inter_stratum_feature_edge_template shall have a description of 'inter stratum feature edge template'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_definition">
<ENTITY.DESCRIPTION>
An interconnect_definition is a physical_unit that implements the ARM concepts
of <internal.ref Linkend="Pcb">
and <internal.ref Linkend="Pcb_usage_view">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_definition
 SUBTYPE OF (physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR
       (SELF\product_definition.name = 'interconnect module');
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_INTERCONNECT_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name = 
       'interconnect module')
)) = 1);
END_ENTITY; -- interconnect_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interconnect_definition shall have a name that is 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the interconnect_definition is a physical design, it shall relate to exactly
one interconnect_definition, externally_defined_interconnect_definition, or 
library_defined_interconnect_definition that is a physical design usage with a 
name of 'interconnect module' as the design usage.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_component_surface_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interconnect_module_component_surface_feature is a shape_aspect.  An interconnect_module_component_surface_feature
implements the ARM concept of:
<Internal.ref Linkend="Interconnect_module_component_surface_feature">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_component_surface_feature
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: (SELF\shape_aspect.description IN [
       'interconnect module component surface feature']);
  WR3: SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description IN
       ['interconnect module secondary surface',
        'interconnect module primary surface',
        'interconnect module cavity surface',
        'interconnect module cutout surface',
        'interconnect module edge surface',
        'interconnect module edge segment surface'])) = 1;
END_ENTITY; -- interconnect_module_component_surface_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_component_surface_feature shall be an aspect of the shape of a component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_component_surface_feature shall have a description of 'interconnect module component surface feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_component_surface_feature shall be related to exactly one 
shape_aspect with a description of 'interconnect module secondary surface',
'interconnect module primary surface', 'interconnect module edge surface',
'interconnect module cavity surface', 'interconnect module cavity surface',
or 'interconnect module edge segment surface' as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_design_object_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interconnect_module_design_object_category is a characterized_object
that specifies a design object category for
the implementation of the ARM concept of<internal.ref Linkend="Interconnect_module_constraint_region">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_design_object_category
  SUBTYPE OF (characterized_object);
WHERE
  WR1: SELF\characterized_object.description IN 
       ['cutout category', 
       'fill area category', 
       'inter stratum feature category', 
       'stratum feature category', 
       'via category'];
END_ENTITY; -- interconnect_module_design_object_category
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_design_object_category shall have a description of 
'cutout category', 
'fill area category', 
'inter stratum feature category', 
'stratum feature category', 
or 'via category'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_cutout_segment_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A interconnect_module_cutout_segment_surface is a shape_aspect and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Interconnect_module_cutout_segment_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_cutout_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  wr1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  wr2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  wr3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('interconnect module cutout surface' = 
       ce.relating_shape_aspect\shape_aspect.description) )) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\interconnect_module_cutout_segment_surface)) = 0;
END_ENTITY; -- interconnect_module_cutout_segment_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_cutout_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_cutout_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship relating attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex instances referenced shall not be the same instance of edge_segment_vertex.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_cutout_segment_surface shall be related to
exactly one shape_aspect with a description of 'interconnect module cutout surface' as the 'composed surface'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_cutout_segment_surface shall not be in a complex instance other 
than with it's immediate supertypes. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_edge_segment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A interconnect_module_edge_segment is an inter_stratum_feature and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Interconnect_module_edge_segment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_edge_segment
  SUBTYPE OF (inter_stratum_feature,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect.description IN [
       'plated interconnect module edge segment', 
       'interconnect module edge segment'];
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1;
  WR3: (NOT (SELF\shape_aspect.description = 
       'plated interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed edge') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_shape_aspect)) AND
       (ce.relating_shape_aspect\shape_aspect.description =
       'plated interconnect module edge'))) = 1);
  WR4: (NOT (SELF\shape_aspect.description = 'interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed edge') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_shape_aspect)) AND
       (ce.relating_shape_aspect\shape_aspect.description =
       'interconnect module edge'))) = 1);
  wr5: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  wr6: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  wr7: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY; -- interconnect_module_edge_segment
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment shall have a description of either
'plated interconnect module edge segment', or 'interconnect module
edge segment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment shall be related to at most one
join_shape_aspect with a name of 'inter stratum join' as a 'join
implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment shall be related to
exactly one plated_inter_stratum_feature as the 'composed edge' if
the description of the interconnect_module_edge_segment is
'plated interconnect module edge segment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment shall be related to
exactly one inter_stratum_feature as the 'composed edge'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship relating attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex instances referenced shall not be the same instance of edge_segment_vertex.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_edge_segment_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A interconnect_module_edge_segment_surface is a shape_aspect and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Interconnect_module_edge_segment_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  wr1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  wr2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  wr3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('interconnect module edge surface' = 
       ce.relating_shape_aspect\shape_aspect.description) )) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\interconnect_module_edge_segment_surface)) = 0;
END_ENTITY; -- interconnect_module_edge_segment_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship relating attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex instances referenced shall not be the same instance of edge_segment_vertex.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment_surface shall be related to
exactly one shape_aspect with a description of 'interconnect module edge surface' as the 'composed surface'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_edge_segment_surface shall not be in a complex instance other 
than with it's immediate supertypes. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_interface_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interconnect_module_interface_terminal is an interconnect_module_terminal that implement the
ARM concept of <internal.ref Linkend="Interconnect_module_interface_terminal">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_interface_terminal
  SUBTYPE OF (interconnect_module_terminal);
END_ENTITY; -- interconnect_module_interface_terminal
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_join_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interconnect_module_join_terminal is an interconnect_module_terminal that implement the
ARM concept of <internal.ref Linkend="Interconnect_module_join_terminal">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_join_terminal
  SUBTYPE OF (interconnect_module_terminal);
END_ENTITY; -- interconnect_module_join_terminal
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_terminal shall be related to at most one shape_aspect with a description of 'join terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_macro_component_join_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interconnect_module_macro_component_join_terminal is a shape_aspect that implements the ARM concept of
internal.ref Linkend="Interconnect_module_macro_component_join_terminal">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_macro_component_join_terminal
  SUBTYPE OF (component_terminal);
WHERE
  WR1: NOT (SELF\shape_aspect.description IN 
       ['assembly module component terminal', 
        'bare die component terminal', 
       'component termination passage join terminal', 
       'conductive interconnect element terminal', 
       'interconnect component join terminal', 
       'land join terminal', 
       'minimally defined component terminal',
       'non functional land join terminal', 
       'packaged component join terminal', 
       'printed component join terminal', 'package terminal occurrence',
       'via terminal']);
END_ENTITY; -- interconnect_module_macro_component_join_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_macro_component_join_terminal shall not have a description of
'bare die component terminal', 'component termination
passage join terminal', 'conductive interconnect element terminal',
'interconnect component join terminal', 'assembly module component
terminal', 'land join terminal', 'minimally defined component terminal',
'non functional land join terminal', 'packaged component join terminal',
'printed component join terminal', 'package terminal occurrence',
or 'via terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_stratum_based_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interconnect_module_stratum_based_terminal is an 
interconnect_module_terminal that implements the ARM concept
of <internal.ref Linkend="Interconnect_module_stratum_based_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_stratum_based_terminal
  SUBTYPE OF (interconnect_module_terminal);
END_ENTITY; -- interconnect_module_stratum_based_terminal
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interconnect_module_terminal">
<ENTITY.DESCRIPTION>
An interconnect_module_terminal is a shape_aspect that implements the ARM 
concepts of <internal.ref Linkend="Interconnect_module_terminal">
and <internal.ref Linkend="Part_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interconnect_module_terminal
  SUPERTYPE OF (ONEOF(interconnect_module_interface_terminal,
                      interconnect_module_join_terminal))
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
  WR2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.
       frame_of_reference.name = 
       'physical design usage') AND
       (SELF.of_shape.definition\product_definition.name = 
       'interconnect module');
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1)) >= 1; 
  WR4: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
  WR5: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 
       'connection zone')) <= 1;
END_ENTITY; -- interconnect_module_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The physical_unit name shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_terminal shall be an aspect of the shape of a physical_unit that is an 'interconnect module' and that is a 'physical design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_terminal shall have at least one
property_definition that is represented by a shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_terminal shall be related to at most one 
part_connected_terminals_definition as a 'member connected terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interconnect_module_terminal shall be related to no more than one shape_aspect with 
a description of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interface_access_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interface_access_component_shape_aspect is a component_shape_aspect that implements
the ARM concept of <Internal.ref Linkend="Interface_access_laminate_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interface_access_component_shape_aspect
  SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- interface_access_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interface_access_material_removal_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interface_access_material_removal_component_shape_aspect is a material_removal_component_shape_aspect
that implements the ARM concept of <Internal.ref Linkend="Interface_access_material_removal_laminate_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interface_access_material_removal_component_shape_aspect
  SUBTYPE OF (material_removal_component_shape_aspect);
END_ENTITY; -- interface_access_material_removal_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interface_component_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interface_component_definition is a component_definition that implements the ARM concept of
<internal.ref Linkend="interface_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interface_component_definition
  SUBTYPE OF (component_definition);
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL' IN 
       TYPEOF (sa)) AND
       (sa\shape_aspect.description IN ['interconnect component interface terminal',
       'packaged connector component interface terminal']))) >= 1)) >= 1);
END_ENTITY; -- interface_component_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interface_component_definition shall have at least one shape_aspect that is a  component_interface_terminal
with a description of 'interconnect component interface terminal' or
'packaged connector component interface terminal'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interface_mounted_join">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interface_mounted_join is a shape_aspect and a
shape_aspect_relationship that relates a component_terminal to a 
component_interface_terminal.  An interface_mounted_join implements the
ARM concept of an <internal.ref Linkend="Interface_mounted_join">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interface_mounted_join
 SUBTYPE OF (shape_aspect_relationship,shape_aspect);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal');
  WR2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       ((SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal'));
END_ENTITY; -- interface_mounted_join
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The interface_mounted_join shall have a 'packaged connector component interface terminal' as
the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The interface_mounted_join shall have a component_terminal with the listed description as the
relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>


</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="interfaced_group_component_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An interfaced_group_component_definition is a assembly_group_component_definition that implements the ARM concept of
<internal.ref Linkend="Interfaced_group_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY interfaced_group_component_definition
  SUBTYPE OF (assembly_group_component_definition);
WHERE
  WR1: (SIZEOF (QUERY (gc <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'group component') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_COMPONENT_DEFINITION' IN 
       TYPEOF (gc.related_product_definition))))
       >= 1);
END_ENTITY; -- interfaced_group_component_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The interfaced_group_component_definition shall relate to at least
one interface_component_definition to
specify a 'group component'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="join_shape_aspect">
<ENTITY.DESCRIPTION>
A join_shape_aspect is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Inter_stratum_join_relationship"></list.item>
<list.item><internal.ref Linkend="Intra_stratum_join_relationship"></list.item>
<list.item><internal.ref Linkend="Join_relationship"></list.item>
<list.item><internal.ref Linkend="Unrouted_join_relationship"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY join_shape_aspect
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: NOT(SELF\shape_aspect.name IN ['constrained intra layer join',
       'inter stratum join', 'intra stratum join']) OR 
       (SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (cp.related_shape_aspect))) >= 2);
  WR2: SIZEOF (QUERY (nt <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'network topology') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK' IN
       TYPEOF (nt.relating_shape_aspect))) = 1;
  WR3: (NOT (SELF\shape_aspect.name = 'intra stratum join')) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (ji.related_shape_aspect)) AND
       (ji.related_shape_aspect\shape_aspect.description = 'conductor'))) <= 1);
  WR4: (NOT (SELF\shape_aspect.name = 'intra stratum join')) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (ji.related_shape_aspect)) AND
       (ji.related_shape_aspect\shape_aspect.description = 'connected filled area'))) 
       <= 1);
  WR5: (NOT (SELF\shape_aspect.name = 'inter stratum join')) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP' IN
       TYPEOF (ji.related_shape_aspect)) AND
       (ji.related_shape_aspect\shape_aspect.description = 
       'physical network supporting stratum feature conductive join')) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (ji.related_shape_aspect)))) <= 1);
  WR6: NOT(SELF\shape_aspect.name = 'unrouted join') OR
       (SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'unrouted terminals') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (cp.related_shape_aspect))) >= 2);
END_ENTITY; -- join_shape_aspect
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The join_shape_aspect with a name of 'constrained intra layer join', 'inter stratum join', or 'intra stratum join' shall be used to relate at least two layer_connection_points to specify a 'connected point'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The join_shape_aspect shall be related to exactly one physical_network as
the 'network topology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the join_shape_aspect has a name of 'intra stratum join', it
shall relate to at most one stratum_feature with a description of 'conductor'
as a 'join implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the join_shape_aspect has a name of 'intra stratum join', it
shall relate to at most one stratum_feature with a description of 'connected
filled area' as a 'join implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the join_shape_aspect has a name of 'inter stratum join', it
shall relate to at most one stratum_concept_relationship with a description of 
'physical network supporting stratum feature conductive join' or 
plated_inter_stratum_feature as a 'join implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The join_shape_aspect with a name of 'unrouted join', shall be used to relate at least two component_terminal to specify 'unrouted terminals'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="keepout_design_object_category">
<ENTITY.DESCRIPTION>
A keepout_design_object_category is a characterized_object
that specifies a design object category for
the implementation of the ARM concepts of
<internal.ref Linkend="Part_template_3d_keepout_shape">,
<internal.ref Linkend="Part_template_planar_keepout_shape">,
<internal.ref Linkend="Physical_unit_3d_keepout_shape">, and
<internal.ref Linkend="Physical_unit_planar_keepout_shape">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY keepout_design_object_category
  SUBTYPE OF (characterized_object);
WHERE
  WR1: SELF\characterized_object.description IN 
       ['assembly module assembly component category',
        'component feature category',
        'assembly ee material category',
        'interconnect ee material category',
        'interconnect module assembly component category',
        'via category',
        'inter stratum feature category',
        'cutout category',
        'fill area category',
        'laminate component category',
        'stratum feature category'];
END_ENTITY; -- keepout_design_object_category
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The keepout_design_object_category shall have a description of 
'assembly module assembly component category',
'component feature category',
'assembly ee material category',
'interconnect ee material category',
'interconnect module assembly component category',
'via category',
'inter stratum feature category',
'cutout category',
'fill area category',
'laminate component category',
or 'stratum feature category'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="laminate_component_interface_terminal">
<ENTITY.DESCRIPTION>
A laminate_component_interface_terminal is a shape_aspect.  A laminate_component_interface_terminal
implements the ARM concepts of:
<list>
<list.item><Internal.ref Linkend="Component_termination_passage_interface_terminal"></list.item>
<list.item><Internal.ref Linkend="Land_interface_terminal"></list.item>
<list.item><Internal.ref Linkend="Non_functional_land_interface_terminal"></list.item> 
<list.item><Internal.ref Linkend="Printed_connector_component_interface_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY laminate_component_interface_terminal
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: (NOT (SELF\shape_aspect.description IN 
       ['component termination passage interface terminal', 
       'land interface terminal', 
       'printed connector component interface terminal',
       'non functional land interface terminal'])) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition));
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) = 1;
(*
  WR3: (NOT (SELF\shape_aspect.description = 
       'component termination passage interface terminal')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_PASSAGE' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description =
       'component termination passage'));
*)
  WR4: (NOT (SELF\shape_aspect.description = 
       'component termination passage interface terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description =
       'component termination passage template interface terminal')) = 1);
 WR5: (NOT (SELF\shape_aspect.description IN
       ['land interface terminal',
       'non functional land interface terminal'])) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (TRUE)))) = 1);
(*
 WR6: NOT(SELF\shape_aspect.description = 'land interface terminal') OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND' IN
       TYPEOF (associated_component(SELF))) AND
(associated_component(SELF).description IN
       ['via and contact size dependent land',
       'contact size dependent land',
    'component termination passage and contact size dependent land']));
 WR7: NOT(SELF\shape_aspect.description =
       'non functional land interface terminal') OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND' IN
       TYPEOF (associated_component(SELF))) AND
(associated_component(SELF).description IN
       ['via and contact size dependent non functional land',
       'contact size dependent non functional land',
    'component termination passage and contact size dependent non functional land']));
*)
 WR8: (NOT (SELF\shape_aspect.description = 
       'printed connector component interface terminal')) OR
       (SELF.product_definitional);
 WR9: (NOT (SELF\shape_aspect.description = 
       'printed connector component interface terminal')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_COMPONENT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.description = 
       'printed connector component'));
 WR10: (NOT (SELF\shape_aspect.description = 
       'printed connector component interface terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'interface terminal'))) = 1);
 WR11: (NOT (SELF\shape_aspect.description =
       'printed connector component interface terminal')) OR
       (SIZEOF (QUERY (i <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       pdr\shape_aspect_relationship.name = 'implementation') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE'] *
       TYPEOF (i.relating_shape_aspect)) = 1)
       )) = 1);
 WR12: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\
        product_definition.frame_of_reference\
        application_context_element.name = 'layout occurrence');
END_ENTITY; -- laminate_component_interface_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The laminate_component_interface_terminal shall be an aspect of the shape of a component_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The laminate_component_interface_terminal shall be related to exactly one shape_aspect as an 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'component
termination passage interface terminal', the laminate_component_interface_terminal shall
be related to exactly one plated_passage with a description of 'component
termination passage' as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'component
termination passage interface terminal', the laminate_component_interface_terminal shall
be related to exactly one shape_aspect with a description of 'component
termination passage template interface terminal' as the 'instantiated
feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of either 'land
interface terminal' or 'non functional land interface terminal', the
laminate_component_interface_terminal shall be related to exactly one
land_template_terminal as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'land interface
terminal', the laminate_component_interface_terminal shall be related to exactly one land
with the appropriate description as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'non functional
land interface terminal', the laminate_component_interface_terminal shall be related to
exactly one land with the appropriate description as the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'printed connector
component interface terminal', it shall lie on the boundary of a product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'printed connector
component interface terminal', it shall be an aspect of the shape of a
printed_component that has a description of 'printed connector component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'printed connector component interface terminal', the laminate_component_interface_terminal shall be related to exactly one printed_part_template_terminal with a description of 'interface terminal' as the 'instantiated feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the laminate_component_interface_terminal has a description of 'printed connector component interface terminal', the laminate_component_interface_terminal shall be related to exactly one stratum_feature as the 'implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The laminate_component_interface_terminal shall be a shape_aspect for a component_definition
with a frame_of_reference of 'layout occurrence'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="laminate_group_component_make_from_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A laminate_group_component_make_from_relationship is a make_from_usage_option that implements the ARM concept of <internal.ref Linkend="Laminate_group_component_make_from_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY laminate_group_component_make_from_relationship
  SUBTYPE OF (make_from_usage_option);
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION'] *
       TYPEOF (SELF.relating_product_definition)) = 1;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION'] *
       TYPEOF (SELF.related_product_definition)) = 1;
  WR3: SIZEOF( QUERY(pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
        (SIZEOF( QUERY(pdr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ((pdr.name = 'stratum mapping') AND
       (pdr.related_property_definition\property_definition.
         definition\product_definition_relationship.name = 'stratum make from')
        AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'MAKE_FROM_USAGE_OPTION' IN 
         TYPEOF(pdr.related_property_definition\property_definition.definition)))
          )) > 0) 
        )) > 0;
END_ENTITY; -- laminate_group_component_make_from_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The laminate_group_component_make_from_relationship shall reference an assembly_group_component_definition as its relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The laminate_group_component_make_from_relationship shall reference an assembly_group_component_definition as its related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The laminate_group_component_make_from_relationship shall reference at least one make_from_usage_option with a name of 'stratum make from' as the 'stratum mapping'. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="land">
<ENTITY.DESCRIPTION>
A land is a component_shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Component_termination_passage_and_contact_size_dependent_land"></list.item>
<list.item><internal.ref Linkend="Component_termination_passage_and_contact_size_dependent_non_functional_land"></list.item>
<list.item><internal.ref Linkend="Component_termination_passage_dependent_land"></list.item>
<list.item><internal.ref Linkend="Contact_size_dependent_land"></list.item>
<list.item><internal.ref Linkend="Contact_size_dependent_non_functional_land"></list.item>
<list.item><internal.ref Linkend="Non_functional_land"></list.item>
<list.item><internal.ref Linkend="Land"></list.item>
<list.item><internal.ref Linkend="Unsupported_passage_dependent_non_functional_land"></list.item>
<list.item><internal.ref Linkend="Via_and_contact_size_dependent_land"></list.item>
<list.item><internal.ref Linkend="Via_and_contact_size_dependent_non_functional_land"></list.item>
<list.item><internal.ref Linkend="Via_dependent_land"></list.item>
<list.item><internal.ref Linkend="Via_dependent_non_functional_land"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY land
 SUBTYPE OF (component_shape_aspect);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN  
       TYPEOF (SELF.of_shape.definition)) AND 
       (SIZEOF (QUERY (prpc <* 
       USEDIN (SELF.of_shape.definition.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1);
  WR2: SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (i_f.relating_shape_aspect))) = 1;
  WR3: SIZEOF (QUERY (aud <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'alternate usage definition') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (aud.relating_shape_aspect))) <= 1;
  WR4: SIZEOF (QUERY (sfi <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'stratum feature implementation') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (sfi.relating_shape_aspect))) = 1;
(*
  WR5: (NOT (SELF\shape_aspect.description IN
       ['via and contact size dependent land',
    'component termination passage and contact size dependent land'])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'land interface terminal')))) >= 0);
  WR6: (NOT (SELF\shape_aspect.description IN
       ['functional land', 'via dependent land',
       'via and contact size dependent land',
       'component termination passage dependent land',
       'contact size dependent land',
   'component termination passage and contact size dependent land'])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'land join terminal')))) >= 1);
  WR7: (NOT (SELF\shape_aspect.description IN
       ['via and contact size dependent non functional land',
       'component termination passage and contact size '])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'non functional land interface terminal')))) = 1);
  WR8: (NOT (SELF\shape_aspect.description IN
       ['non functional land', 'via dependent non functional land',
       'via and contact size dependent non functional land',
       'component termination passage dependent non functional land',
       'contact size dependent non functional land',
       'component termination passage and contact size ' + 
       'dependent non functional land',
       'unsupported passage dependent non functional land'])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF)|
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'non functional land join terminal')))) >= 1);
*)
  WR9: (NOT (SELF\shape_aspect.description IN
       ['component termination passage and contact size dependent land',
       'component termination passage and contact size dependent' + 
       'non functional land',
       'component termination passage dependent land',
       'component termination passage dependent non functional land'])) OR
       (SIZEOF (QUERY (rp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'reference passage') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_PASSAGE' IN
       TYPEOF (rp.relating_shape_aspect)) AND
       (rp.relating_shape_aspect\shape_aspect.description =
       'component termination passage')))) = 1);
 WR10: (NOT (SELF\shape_aspect.description IN
       ['via and contact size dependent land',
       'via and contact size dependent non functional land',
       'via dependent land', 'via dependent non functional land'])) OR
       (SIZEOF (QUERY (rv <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'reference via') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_PASSAGE' IN
       TYPEOF (rv.relating_shape_aspect)) AND
       (rv.relating_shape_aspect\shape_aspect.description IN
       ['buried via', 'interfacial connection', 
       'bonded conductive base blind via', 'non conductive base blind via',
       'plated conductive base blind via'])))) = 1);
 WR11: (NOT (SELF\shape_aspect.description = 
       'unsupported passage dependent non functional land')) OR
       (SIZEOF (QUERY (rp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'reference passage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (rp.relating_shape_aspect)) AND
       (rp.relating_shape_aspect\shape_aspect.description =
       'unsupported passage'))) = 1);
 WR12: (NOT (SELF\shape_aspect.description IN
       ['component termination passage dependent land',
       'component termination passage dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'default component termination passage based')))) = 1);
 WR13: (NOT (SELF\shape_aspect.description IN
       ['component termination passage and contact size dependent land',
       'component termination passage and contact size dependent ' +
       'non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'default attachment size and component termination ' +
       'passage based')))) = 1);
 WR14: (NOT (SELF\shape_aspect.description IN
       ['contact size dependent land',
       'contact size dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'default attachment size based')))) = 1);
 WR15: (NOT (SELF\shape_aspect.description IN
       ['via and contact size dependent land',
       'via and contact size dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'default attachment size and via based')))) = 1);
 WR16: (NOT (SELF\shape_aspect.description IN
       ['via dependent land',
       'via dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'default via based')))) = 1);
 WR17: (NOT (SELF\shape_aspect.description = 
       'unsupported passage dependent ' +
       'non functional land')) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'default unsupported passage based'))) = 1);
END_ENTITY; -- land
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The land shall be an aspect of the shape of a component_definition that
is the definition of a product that is categorized as an 'template
module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The land shall be related to exactly one land_physical_template as the
'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The land shall be related to at most one land_physical_template
as the 'alternate usage definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The land shall be related to exactly one stratum_feature as a
'stratum feature implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'via and contact size dependent land', 
or 'component termination passage and contact size dependent land', the land may relate
to zero or more component_shape_aspect that has a description of 'land
interface terminal' to specify the 'associated component'.
<note>
A contact size dependent land may have more than one interface terminal.
</note>
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'functional land', 'via dependent
land', 'via and contact size dependent land', 'component termination
passage dependent land', 'contact size dependent land',  or 'component
termination passage and contact size dependent land', the land shall relate
to at least one component_terminal that has a description of 'land join
terminal' to specify the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'via and contact size dependent non functional land', 'component termination passage and contact size dependent non functional land', the land shall relate to exactly one component_shape_aspect that has a description of 'non functional land interface terminal' to specify the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'non functional land', 'via
dependent non functional land', 'via and contact size dependent non
functional land', 'component termination passage dependent non functional
land', 'contact size dependent non functional land', 'component termination
passage and contact size dependent non functional land', or 'unsupported
passage dependent non functional land', the land shall relate to at least
one component_terminal that has a description of 'non functional land join
terminal' to specify the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'component termination passage and
contact size dependent land', 'component termination passage and contact
size dependent non functional land', 'component termination passage
dependent land', or 'component termination passage dependent non functional
land', the land shall be related to exactly one plated_passage with a
description of 'component termination passage' as a 'reference passage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'via and contact size dependent
land', 'via and contact size dependent non functional land', 'via dependent
land', or 'via dependent non functional land', the land shall be related to
exactly one plated_passage that has a description of 'buried via',
'interfacial connection', 'bonded conductive base blind via', 'non
conductive base blind via', or 'plated conductive base blind via' as a
'reference via'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'unsupported passage dependent non
functional land', the land shall be related to exactly one
inter_stratum_feature with a description of 'unsupported passage' as a
'reference passage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of either 'component termination
passage dependent land' or 'component termination passage dependent non
functional land', the land shall be related to exactly one
land_physical_template with a description of 'default component termination
passage based' as an 'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of either 'component termination
passage and contact size dependent land' or 'component termination passage
and contact size dependent non functional land', the land shall be related
to exactly one land_physical_template with a description of 'default
attachment size and component termination passage based' as an
'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of either 'contact size dependent
land' or 'contact size dependent non functional land', the land shall be
related to exactly one land_physical_template with a description of
'default attachment size based' as an 'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of either 'via and contact size
dependent land' or 'via and contact size dependent non functional land',
the land shall be related to exactly one land_physical_template with a
description of 'default attachment size and via based' as an 'instantiated
template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of either 'via dependent land' or 'via
dependent non functional land', the land shall be related to exactly one
land_physical_template with a description of 'default via based' as an
'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land has a description of 'unsupported passage dependent non
functional land', the land shall be related to exactly one
land_physical_template with a description of 'default unsupported passage
based' as an 'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="land_physical_template">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A land_physical_template is a part_template_definition that implements the
ARM concepts of:
<list> 
<list.item><internal.ref Linkend="Default_attachment_size_and_component_termination_passage_based_land_physical_template"></list.item>
<list.item><internal.ref Linkend="Default_attachment_size_and_via_based_land_physical_template"></list.item>
<list.item><internal.ref Linkend="Default_attachment_size_based_land_physical_template"></list.item>
<list.item><internal.ref Linkend="Default_component_termination_passage_based_land_physical_template"></list.item>
<list.item><internal.ref Linkend="Default_land_physical_template"></list.item>
<list.item><internal.ref Linkend="Default_passage_based_land_physical_template"></list.item>
<list.item><internal.ref Linkend="Default_via_based_land_physical_template"></list.item>
<list.item><internal.ref Linkend="Land_physical_template"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY land_physical_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
    duc\document_usage_constraint.subject_element = 
                 'pre defined classification code')) = 1)) <= 1;
  WR2: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated definition') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL' IN
       TYPEOF (am.related_shape_aspect))) >= 1;
 WR3:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN ['default attachment size based',
       'default attachment size and component termination passage based', 
       'default attachment size and via based'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'minimum attachment region size') AND 
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone')))) <= 1));
 WR4:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN ['default attachment size based',
       'default attachment size and component termination passage based', 
       'default attachment size and via based'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'maximum attachment region size') AND 
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone')))) <= 1));
 WR5:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default component termination passage based',
   'default attachment size and component termination passage based'])) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect)) AND
       (tu.related_shape_aspect\shape_aspect.description = 
       'default component termination passage definition'))) = 1));
 WR6:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default attachment size and component termination passage based',
       'default attachment size based', 
       'default attachment size and via based', 
       'default component termination passage based',
       'default via based',
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (ost <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'of stratum technology') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (ost.relating_shape_aspect.of_shape.definition)
       )) = 1));
 WR7:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2)) = 2)) = 1))) = 0));
 WR8:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND 
       (it\representation_item.name = 'minimum fabrication allowance'))) 
       = 1)) = 1))) = 0));
 WR9:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'minimum annular ring'))) = 1
       )) = 1))) = 0));
 WR10: NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect))) = 1));
 WR11: NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN ['default via based',
       'default attachment size and via based'])) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect)) AND
       (tu.related_shape_aspect\shape_aspect.description = 'default via definition'))) 
       = 1));
 WR12: NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description = 'default unsupported passage')) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect)) AND
       (tu.related_shape_aspect\shape_aspect.description = 
       'default unsupported passage definition'))) = 1));
END_ENTITY; -- land_physical_template
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The land_physical_template shall have a reference of at most one
document that is constrained by a 'pre defined classification code'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The land_physical_template shall be used to relate at least one 
land_template_terminal to specify the 'access mechanism'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of 'default attachment
size based', 'default attachment size and component termination passage
based', or 'default attachment size and via based', it shall be to relate
no more than one shape_aspect with a name of 'connection zone' as the  
'minimum attachment region size'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of 'default attachment
size based', 'default attachment size and component termination passage
based', or 'default attachment size and via based', it shall be to relate
no more than one shape_aspect with a name of 'connection zone' as the  
'maximum attachment region size'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of  'default component
termination passage based' or 'default attachment size and component
termination passage based', it shall relate to a passage_technology with a
description of 'default component termination passage definition' to specify
the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of 'default attachment
size and component termination passage based', 'default attachment size
based', 'default attachment size and via based', 'default component
termination passage based', 'default via based', or 'default unsupported
passage based', it shall relate to a stratum_technology as the 'of stratum technology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of 'default attachment
size and component termination passage based', 'default attachment size and
via based', 'default component termination passage based', 'default via
based', or 'default unsupported passage based', it shall have a representation
that contains exactly two length_measure_with_units.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of 'default attachment
size and component termination passage based', 'default attachment size and
via based', 'default component termination passage based', 'default via
based', or 'default unsupported passage based', it shall have a representation
that contains exactly one length_measure_with_unit with a name of 'minimum
fabrication allowance'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of 'default attachment
size and component termination passage based', 'default attachment size and
via based', 'default component termination passage based', 'default via
based', or 'default unsupported passage based', it shall have a representation
that contains exactly one length_measure_with_unit with a name of 'minimum
annular ring'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of  'default attachment
size and component termination passage based', 'default attachment size and
via based', 'default component termination passage based', 'default via
based', or 'default unsupported passage based', it shall relate a
passage_technology to specify the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of  'default via based'
or 'default attachment size and via based', it shall relate to a 
passage_technology with a description of 'default via definition' to specify 
the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the land_physical_template has a description of  'default
unsupported passage', it shall relate to a passage_technology with a
description of 'default unsupported passage definition' to specify the
'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="land_template_terminal">
<ENTITY.DESCRIPTION>
A land_template_terminal is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Land_template_interface_terminal"></list.item>
<list.item><internal.ref Linkend="Land_template_join_terminal"></list.item>
<list.item><internal.ref Linkend="Land_template_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY land_template_terminal
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN ['interface terminal', 'join terminal'];
  WR2: SIZEOF (QUERY (tcz <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'terminal connection zone') AND
       (sar\shape_aspect_relationship.description IN ['edge curve', 'edge point', 
       'surface area', 'surface point'])) |
       tcz.related_shape_aspect\shape_aspect.description = 'connection zone')) >= 0;
END_ENTITY; -- land_template_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The land_template_terminal shall have a description of either 'interface
terminal' or 'land terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The land_template_terminal shall relate to zero or more shape_aspect
with a name of 'connection zone' to specify the 'terminal connection zone'
which may be described as a 'edge curve', 'edge point', 'surface_area', or
'surface point'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="layer">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A layer is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Layer">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY layer
 SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
       duc\document_usage_constraint.subject_element = 'layer definition')) = 1)) <= 1;       
  WR2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP'
       IN TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition_relationship.name = 
                                    'inter stratum extent');
END_ENTITY; -- layer
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within a population of layer.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The layer shall be referenced by at most one document that has a usage
constraint which specifies the 'layer definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer shall be an aspect of the shape of a product_definition_relationship 
with a name of 'inter stratum extent'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The same geometric representation shall be attached to each of the stratum
specified by the layer.
</INFORMAL.PROPOSITIONS.RUL>

<INFORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="layer_connection_point">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A layer_connection_point is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Dependently_located_layer_connection_point"></list.item>
<list.item><internal.ref Linkend="Explicitly_located_layer_connection_point"></list.item>
<list.item><internal.ref Linkend="Layer_connection_point"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY layer_connection_point
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
WHERE
  WR1: SELF\shape_aspect.of_shape.definition\product_definition.
       name = 'design layer';
  WR2: SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'inter stratum join')))) <= 1;
  WR3: SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'intra stratum join')))) = 1;
  WR4: NOT(
       SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'inter stratum join')))) = 1)
       OR
       (SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'intra stratum join')))) = 1);
  WR5: (NOT (SELF\shape_aspect.description = 'dependently located')) OR
       (SIZEOF (QUERY (ado <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated design object') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTER_STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) OR
       ((SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) AND
       (ado.relating_shape_aspect.description IN ['printed component join terminal',
        'embedded component terminal']))
       )) = 1);
  WR6: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'connection point location 2d') AND
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CARTESIAN_POINT' IN
       TYPEOF (it)) AND (it\geometric_representation_item.dim = 2 )
       )) = 1))) <= 1))) = 0);
  WR7: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'connection point location 3d') AND
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CARTESIAN_POINT' IN
       TYPEOF (it)) AND (it\geometric_representation_item.dim = 3 )
       )) = 1))) <= 1))) = 0);
  WR8: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       ((pdr.used_representation\representation.name = 'connection point location 2d')
       OR
       (pdr.used_representation\representation.name = 'connection point location 3d'))
       )) >= 1))) = 0);
  WR9: (NOT (SELF\shape_aspect.description = 'dependently located')) OR
       (SIZEOF (QUERY (ado <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'reference zone') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) OR
       ((SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) AND
       (ado.relating_shape_aspect.description IN ['connection zone']))
       )) <= 1);
END_ENTITY; -- layer_connection_point
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within the stratum that is the product_definition for this layer_connection_point.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point shall be an aspect of the shape of a product_definition with a name of 'design layer'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point shall be related to no more than one join_shape_aspect with a name of 'inter stratum join' as a 'connected point'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point shall be related to one join_shape_aspect with a name of 'intra stratum join' as a 'connected point'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the layer_connection_point is related to a join_shape_aspect with a name of 'inter stratum join' as a 'connected point',
the layer_connection_point shall be related to a join_shape_aspect with a name of 'intra stratum join' as a 'connected point'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the layer_connection_point has a description of 'dependently located', it shall be related to exactly one inter_stratum_feature or interconnect_module_terminal or component_terminal that has a description of 'embedded component terminal' or 'printed component join terminal' as the 'associated design object'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point shall have no more than one shape_representation as the 'connection point location 2d' that contains exactly one cartesian_point with a dimensionality of 2.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point shall have no more than one shape_representation as the 'connection point location 3d' that contains exactly one cartesian_point with a dimensionality of 3.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point shall have no less than one shape_representation as either the 'connection point location 2d' or the 'connection point location 3d'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the layer_connection_point has a description of 'dependently located', it shall be related to no more than one shape_aspect that has a description of 'connection zone' as the 'reference zone'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

<informal.propositions rule.types="IP">
<informal.propositions.rul>
Each layer_connection_point shall be within the resolved areal extent of not more than one stratum_feature.
</informal.propositions.rul>

<informal.propositions.rul>
Each layer_connection_point shall be specified by not more than one physical_network.
</informal.propositions.rul>

</informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="layer_connection_point_link">
<ENTITY.DESCRIPTION>
A layer_connection_point_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Layer_connection_point_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY layer_connection_point_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\layer_connection_point_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SIZEOF(QUERY( cp <* USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
              cp\shape_aspect_relationship.name = 'connected points')) = 1;
END_ENTITY; -- layer_connection_point_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related point shall not be the relating point. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point_link shall relate to only a  layer_connection_point in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layer_connection_point_link shall relate to only a layer_connection_point in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of layer_connection_point_link shall be only layer_connection_point_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each layer_connection_point_link shall be referenced exactly once by a shape_aspect_relationship with a name of 'connected points' by the related_shape_aspect attribute.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="layout_macro_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A layout_macro_component is a printed_component that implements the ARM concept of
<internal.ref Linkend="Layout_macro_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY layout_macro_component
  SUBTYPE OF (printed_component);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'layout macro component shape aspect') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect))
       )) = 1)) = 1))) = 0;
  WR2: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design definition') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYOUT_MACRO_DEFINITION'] *
       TYPEOF (ip.relating_product_definition)) = 1)
       )) = 1;
  WR3: SELF\product_definition.description <> 'printed connector component';
END_ENTITY; -- layout_macro_component
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_component shall have exactly one shape_aspect with a name of
'layout macro component shape aspect' that is related to a layout_macro_floor_plan_template_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_component shall be associated to exactly one layout_macro_definition as a 'design definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_component shall not have a description of 'printed connector component'. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="layout_macro_definition">
<ENTITY.DESCRIPTION>
An layout_macro_definition is an interconnect_definition that implements the ARM concept
of<internal.ref Linkend="Layout_macro_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY layout_macro_definition
 SUBTYPE OF (interconnect_definition);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_INTERCONNECT_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name = 'interconnect module')
       )) = 0;
 WR3: SELF.frame_of_reference\application_context_element.name = 'physical design';
 WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'layout macro definition shape aspect') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'floor layout view') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect))
       )) = 1)) = 1))) = 0;
END_ENTITY; -- layout_macro_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_definition shall relate to exactly zero interconnect_definition, externally_defined_interconnect_definition, or library_defined_interconnect_definition that is a physical design usage with a name of 'interconnect module' as the design usage.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_definition shall be a physical design.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_definition shall be related to exactly one layout_macro_floor_plan_template.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="layout_macro_definition_terminal_to_usage_terminal_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A layout_macro_definition_terminal_to_usage_terminal_assignment is a shape_aspect and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Layout_macro_definition_terminal_to_usage_terminal_assignment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY layout_macro_definition_terminal_to_usage_terminal_assignment
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.name;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
       SELF\layout_macro_definition_terminal_to_usage_terminal_assignment ||
       SELF\shape_aspect)) = 0;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description
       IN ['component termination passage join terminal',
           'conductive interconnect element terminal',
           'land join terminal',
           'non functional land join terminal',
           'printed component join terminal',
           'via terminal'];
  WR4: SIZEOF(USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')) <= 1;

END_ENTITY; -- layout_macro_definition_terminal_to_usage_terminal_assignment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
A layout_macro_definition_terminal_to_usage_terminal_assignment shall not be any other type of shape_aspect_relationship or any other type of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A layout_macro_definition_terminal_to_usage_terminal_assignment shall relate to a shape_aspect with a description of 'printed part template terminal'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
A layout_macro_definition_terminal_to_usage_terminal_assignment shall relate to a shape_aspect with a description listed. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A layout_macro_definition_terminal_to_usage_terminal_assignment shall be referenced no more than once. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="layout_macro_floor_plan_template">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A layout_macro_floor_plan_template is a part_template_plan_template 
that implements the ARM concepts of<internal.ref Linkend="Layout_macro_floor_plan_template">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY layout_macro_floor_plan_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: NOT(SELF\shape_aspect.description IN
      ['component termination passage template',
       'component termination passage template',
       'default trace template',
       'inter stratum feature template',
       'printed connector template',
       'printed part cross section template',
       'printed part template',
       'trace template',
       'unsupported passage template',
       'via template',
       'non conductive cross section template']);
  WR2: SIZEOF(QUERY( sar <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'access maps') AND
      ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYOUT_MACRO_DEFINITION_TERMINAL_TO_USAGE_TERMINAL_ASSIGNMENT' IN
       TYPEOF (sar.relating_shape_aspect)))
       )) >=1;
END_ENTITY; -- layout_macro_floor_plan_template
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_floor_plan_template description shall not be any of:
'component termination passage template'
'component termination passage template',
'default trace template',
'inter stratum feature template',
'printed connector template',
'printed part cross section template',
'printed part template',
'trace template',
'unsupported passage template',
'via template',
'non conductive cross section template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The layout_macro_floor_plan_template shall be related to at least one layout_macro_definition_terminal_to_usage_terminal_assignment.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="length_trimmed_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A length_trimmed_terminal is an altered_package_terminal that implements the ARM
concept of <Internal.ref Linkend="Length_trimmed_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY length_trimmed_terminal
   SUBTYPE OF (altered_package_terminal);
WHERE
 WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2)) = 2)) = 1))) = 0);
 WR2:  (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
                   'maximum trimmed length'))) = 1)) = 1))) = 0);
 WR3:  (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND 
        (it\representation_item.name = 
                  'minimum trimmed length'))) = 1
       )) = 1))) = 0);

END_ENTITY;
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The length_trimmed_terminal shall have a representation that contains exactly two
length_measure_with_units.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The length_trimmed_terminal shall have a representation that contains exactly one
length_measure_with_unit with a name of 'maximum trimmed length'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The length_trimmed_terminal shall have a representation that contains exactly one
length_measure_with_unit with a name of 'minimum trimmed length'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_assembly_definition">
<ENTITY.DESCRIPTION>
A library_defined_assembly_definition is a library_defined_physical_unit that
implements the ARM concept of <internal.ref Linkend="Pca_usage_view">
in conjunction with <internal.ref Linkend="Library_item">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_assembly_definition
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SELF\product_definition.name = 'assembly module';
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
END_ENTITY; -- library_defined_assembly_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The name shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The library_defined_assembly_definition shall be a definition of a product that has a name of 'assembly module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_assembly_definition has a frame_of_reference name of
'physical design usage', it shall have at least two shape_aspects that are
assembly_module_terminals with a description of 'pca terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_bare_die">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A library_defined_bare_die is a library_defined_physical_unit that implements
the ARM concept of <internal.ref Linkend="Bare_die">
in conjunction with <internal.ref Linkend="Library_item">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_bare_die
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: SIZEOF (QUERY (ifdu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifdu.relating_product_definition)) AND
       (ifdu.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'device unit technology') |
       dut.relating_property_definition\property_definition.name = 
       'unit technology')) = 1)) = 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0;
END_ENTITY; -- library_defined_bare_die
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The library_defined_bare_die shall be related to exactly one
functional_unit with a frame_of_reference name of 'functional design usage' as
the 'implemented function'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The library_defined_bare_die shall have exactly one property_definition
that is related to exactly one property_definition with a name of 'unit
technology' as the 'device unit technology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The library_defined_bare_die shall have at least two shape_aspects that
are bare_die_terminals.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_functional_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A library_defined_functional_unit is an externally_defined_functional_unit that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Functional_unit_definition"></list.item>
<list.item><internal.ref Linkend="Functional_unit_usage_view"></list.item>
<list.item><internal.ref Linkend="Library_ee_product_definition"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_functional_unit
 SUBTYPE OF (externally_defined_functional_unit);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY; -- library_defined_functional_unit
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_interconnect_definition">
<ENTITY.DESCRIPTION>
A library_defined_interconnect_definition is a library_defined_physical_unit
that implements the ARM concept of <internal.ref Linkend="Pcb_usage_view">
in conjunction with <internal.ref Linkend="Library_item">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_interconnect_definition
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SELF\product_definition.name = 'interconnect module';
END_ENTITY; -- library_defined_interconnect_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The library_defined_interconnect_definition shall be a definition with a name of 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_package">
<ENTITY.DESCRIPTION>
A library_defined_package is a library_defined_physical_unit that implements
the ARM concepts of 
<internal.ref Linkend="Altered_package"> and
<internal.ref Linkend="Package">
in conjunction with <internal.ref Linkend="Library_item">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_package
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical design usage';
  WR2: SIZEOF(USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION')) > 0;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY(sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SEATING_PLANE' IN
       TYPEOF (sa))) = 1))) = 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY' IN 
       TYPEOF (sa))) = 1))) <= 1;
  WR5: NOT(EXISTS(SELF\product_definition.description) AND
        (SELF\product_definition.description = 'altered package')) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'package preparation') AND
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (pdr.relating_product_definition)) = 1))) = 1); 
END_ENTITY; -- library_defined_package
(*
</EXPRESS.CODE>
      

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The library_defined_package shall have a frame_of_reference name of
'physical design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The library_defined_package shall have at least one property_definition. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The library_defined_package shall have one seating_plane. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The library_defined_package shall have at most one package_body.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_package has a description of 'altered package',
it shall be related to exactly one package, externally_defined_package, or
library_defined_package as the 'package preparation'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
Each three-dimensional shape representation of the library_defined_package shall have exactly one 
geometric_representation_item that is an axis2_placement_3d and that 
axis2_placement_3d shall define the location and orientation of the
seating plane in that representation.  The normal of the seating plane
in that representation shall be congruent with and the same direction as the Z axis of the
axis2_placement_3d.  The plane of the seating plane in that representation shall be congruent
with the plane established by the X and Y axes of the axis2_placement_3d.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_packaged_connector">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A library_defined_packaged_connector is a library_defined_packaged_part that
implements the ARM concept of <internal.ref Linkend="Packaged_connector">
in conjunction with <internal.ref Linkend="Library_item">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_packaged_connector
 SUBTYPE OF (library_defined_packaged_part);
END_ENTITY; -- library_defined_packaged_connector
(*
</EXPRESS.CODE>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
There shall be at least one shape_aspect that is a 
packaged_connector_terminal_relationship for the library_defined_packaged_part.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_packaged_part">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A library_defined_packaged_part is a library_defined_physical_unit that
implements the ARM concepts of
<internal.ref Linkend="Altered_packaged_part">
and <internal.ref Linkend="Packaged_part">
in conjunction with <internal.ref Linkend="Library_item">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_packaged_part
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0);
  WR2: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (ifu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN
       TYPEOF (ifu.relating_product_definition)) AND
       (ifu.relating_product_definition.frame_of_reference.name =
       'functional design usage'))) = 1);
  WR4: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (upkg <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'used package') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE' IN
       TYPEOF (upkg.related_product_definition))) = 1);
  WR5: (NOT (SELF\product_definition.description = 'altered packaged part')) OR
       (SIZEOF (QUERY (bpp <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'base packaged part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] * 
       TYPEOF (bpp.relating_product_definition)) = 1) AND
       (bpp.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) >= 1);
  WR6: (NOT (SELF\product_definition.description = 'altered packaged part')) OR
       (SIZEOF (QUERY (upkg <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'used package') |
       SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] * 
       TYPEOF (upkg.relating_product_definition)) = 1)) >= 1);
END_ENTITY; -- library_defined_packaged_part
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall have at least one shape_aspect that is a
packaged_part_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall have exactly one material_designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall be related to exactly one functional_unit
with a frame_of_reference name of 'functional design usage' as the
'implemented function'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_packaged_part has a frame_of_reference name of
'physical design usage', it shall relate to exactly one package to specify the
'used package'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_packaged_part has a description of 'altered
packaged part', it shall be related to at least one packaged_part,
externally_defined_packaged_part, or library_defined_packaged_part with a
frame_of_reference name of 'physical design usage' as the 'base packaged
part'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the library_defined_packaged_part has a description of 'altered
packaged part', it shall be related to at least one package, 
externally_defined_package, or library_defined_package as the 'used package'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_physical_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A library_defined_physical_unit is an externally_defined_physical_unit that
implements the ARM concepts of:
<list> 
<list.item><internal.ref Linkend="Assembly_module_usage_view"></list.item>
<list.item><internal.ref Linkend="Ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Interconnect_module_usage_view"></list.item>
<list.item><internal.ref Linkend="Library_ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Physical_unit"></list.item>
<list.item><internal.ref Linkend="Physical_unit_usage_view"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_physical_unit
 SUPERTYPE OF (ONEOF (library_defined_package,
                      library_defined_assembly_definition,
                      library_defined_interconnect_definition,
                      library_defined_packaged_part, 
                      library_defined_bare_die))
 SUBTYPE OF (externally_defined_physical_unit);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY; -- library_defined_physical_unit
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="library_defined_product_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A library_defined_product_definition is an externally_defined_product_definition
that implements the ARM concept of:
<internal.ref Linkend="Library_defined_ee_product_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY library_defined_product_definition
 SUBTYPE OF (externally_defined_product_definition);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY; -- library_defined_product_definition
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="linear_array_component_definition_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A linear_array_component_definition_link is a product_definition and a product_definition_relationship that implements the ARM concept of<internal.ref Linkend="Linear_array_placement_group_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY linear_array_component_definition_link
  SUBTYPE OF (product_definition,product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\linear_array_component_definition_link)) = 0;
  WR5: SELF\product_definition.name = '';
  WR6: SELF\product_definition_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
END_ENTITY; -- linear_array_component_definition_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The linear_array_component_definition_link shall relate to only a linear_array_placement_group_component_definition in the related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The linear_array_component_definition_link shall relate to only a linear_array_placement_group_component_definition in the relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of linear_array_component_definition_link shall be only linear_array_component_definition_link, product_definition, and product_definition_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each linear_array_component_definition_link shall be referenced exactly once by a product_definition_relationship related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="linear_array_component_shape_aspect_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A linear_array_component_shape_aspect_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Linear_array_placement_group_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY linear_array_component_shape_aspect_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\linear_array_component_shape_aspect_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
END_ENTITY; -- linear_array_component_shape_aspect_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The linear_array_component_shape_aspect_link shall relate to only a linear_array_placement_group_component_shape_aspect in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The linear_array_component_shape_aspect_link shall relate to only a linear_array_placement_group_component_shape_aspect in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of linear_array_component_shape_aspect_link shall be only linear_array_component_shape_aspect_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each linear_array_component_shape_aspect_link shall be referenced exactly once by a shape_aspect_relationship related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="linear_array_placement_group_component_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An linear_array_placement_group_component_definition is a array_placement_group_component_definition that implements the ARM concept of
<internal.ref Linkend="Linear_array_placement_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY linear_array_placement_group_component_definition
  SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY; -- linear_array_placement_group_component_definition
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="linear_array_placement_group_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An linear_array_placement_group_component_shape_aspect is a array_placement_group_component_shape_aspect that implements the ARM concepts of
<internal.ref Linkend="Linear_array_placement_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY linear_array_placement_group_component_shape_aspect
  SUBTYPE OF (array_placement_group_component_shape_aspect);
END_ENTITY; -- linear_array_placement_group_component_shape_aspect
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="linear_composite_array_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A linear_composite_array_shape_aspect is a composite_shape_aspect that implements the ARM concept of
<internal.ref Linkend="Part_linear_array_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY linear_composite_array_shape_aspect
  SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY; -- linear_composite_array_shape_aspect
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="linear_composite_array_shape_aspect_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A linear_composite_array_shape_aspect_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Part_linear_array_feature_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY linear_composite_array_shape_aspect_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\linear_composite_array_shape_aspect_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
END_ENTITY; -- linear_composite_array_shape_aspect_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The linear_composite_array_shape_aspect_link shall relate to only a linear_composite_array_shape_aspect_shape_aspect in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The linear_composite_array_shape_aspect_link shall relate to only a linear_composite_array_shape_aspect_shape_aspect in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of linear_composite_array_shape_aspect_link shall be only linear_composite_array_shape_aspect_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each linear_composite_array_shape_aspect_link shall be referenced exactly once by a shape_aspect_relationship related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="linear_profile_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A linear_profile_tolerance is a physical_unit_geometric_tolerance that 
implements the ARM concept of:
<list>
<list.item><internal.ref Linkend="Composite_linear_profile_locating_tolerance"></list.item>
<list.item><internal.ref Linkend="Composite_linear_profile_refinement_tolerance"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_line_tolerance"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_line_tolerance_with_referenced_datum_system"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_line_tolerance_without_referenced_datum_system"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY linear_profile_tolerance
  SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
  WR1: ( NOT( SELF\geometric_tolerance.name = 
        'linear profile refinement')) OR
       ( SIZEOF (QUERY( gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
        TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control')
       AND ((gtr.relating_geometric_tolerance\geometric_tolerance.name = 
       'linear profile locating')
       OR (gtr.relating_geometric_tolerance\geometric_tolerance.name = 
       'linear profile refinement')))
       )) = 1);
  WR2: ( NOT(SELF\geometric_tolerance.name = 'linear profile locating')) OR
       ( SIZEOF( QUERY( gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
       TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 
       'linear profile refinement'))
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) = 1);
  WR3: ( NOT( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(SELF))
       AND ( SELF\geometric_tolerance.name = 
       'linear profile refinement'))) OR
       ( SIZEOF( QUERY( gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
       TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 
      'linear profile refinement')
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control')
       )) = 0);
  WR4: ( NOT( SELF\geometric_tolerance.name = 
       'linear profile refinement')) OR
       ( SIZEOF (QUERY( gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
       TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 
       'linear profile refinement')
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))
       )) <= 1);
  WR5: NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
END_ENTITY; -- linear_profile_tolerance
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement', it shall be related as 
the 'linear profile refining control' to exactly one linear_profile_tolerance with a name of either 
'linear profile locating' or 'linear profile refinement'.
</formal.propositions.rul>

<formal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile locating', it shall relate to exactly 
one linear_profile_tolerance with a name of 'linear profile refinement' to specify the 'linear 
profile refining control'.
</formal.propositions.rul>

<formal.propositions.rul>
If the linear_profile_tolerance is not a geometric_tolerance_with_specified_datum_system and has a 
name of 'linear profile refinement', it shall relate to exactly zero linear_profile_tolerance with 
a name of 'linear profile refinement' to specify the 'linear profile refining control'.
</formal.propositions.rul>

<formal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement', it shall relate to at 
most one linear_profile_tolerance with a name of 'linear profile refinement' to specify the 'linear 
profile refining control'.
</formal.propositions.rul>

<formal.propositions.rul>
The linear_profile_tolerance shall not be a modified_geometric_tolerance.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
If linear_profile_tolerance is a geometric_tolerance_with_specified_datum_system it shall have a 
name of either 'linear profile', 'linear profile refinement', or 'linear profile locating'; 
otherwise, it shall have the name of either 'linear profile' or 'linear profile refinement.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement', it shall be related as 
the 'linear profile refining control' to exactly one linear_profile_tolerance with a name of either 
'linear profile locating' or 'linear profile refinement'. Both of these linear_profile_tolerances 
shall specify the same shape_aspect as the toleranced_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement' and it is related as the 
'linear profile refining control' to exactly one linear_profile_tolerance with a name of 'linear 
profile refinement', it shall either not reference a datum_system or it shall have less 
physical_unit_datum in its referenced datum_system than the datum_system referenced by the 
linear_profile_tolerance to which it is related as the 'linear profile refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement' and it is related as the 
'linear profile refining control' to exactly one linear_profile_tolerance with a name of 'linear 
profile locating', it shall either not reference a datum_system or it shall have less than or an 
equal number of physical_unit_datum in its referenced datum_system than the datum_system referenced 
by the linear_profile_tolerance to which it is related as the 'linear profile refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement' and it is a 
geometric_tolerance_with_specified_datum_system, the physical_unit_datum of its referenced 
datum_system shall be physical_unit_datum of the datum_system of the linear_profile_tolerance to 
which it is related as the 'linear profile refining control' and shall be assigned the same 
precedence.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement' and it is a 
geometric_tolerance_with_specified_datum_system that relates to a property_definition of a datum_system that 
has the description of 'datum system property without material conditions' to specify its 
'referenced datum system definition', the linear_profile_tolerance to which it is related as the 
'linear profile refining control' shall also be a geometric_tolerance_with_specified_datum_system 
that relates to a property_definition of a datum_system that has the description of 'datum system property 
without material conditions' to specify its 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement' and it is a 
geometric_tolerance_with_specified_datum_system that relates to a property_definition of a datum_system that 
has the description of 'datum system property with material conditions' to specify its 'referenced 
datum system definition', the linear_profile_tolerance to which it is related as the 'linear 
profile refining control' shall also be a geometric_tolerance_with_specified_datum_system that 
relates to a property_definition of a datum_system that has the description of 'datum system property with 
material conditions' to specify its 'referenced datum system definition', and each of these 
property_definition shall relate to property_definition with a description of 'datum feature material condition 
property' to specify their 'applied material condition property'. These property_definition shall be applied 
to physical_unit_datum_features in the context of the datum_systems referenced by each of the 
linear_profile_tolerance. The name of the property_definition applied to each of the 
physical_unit_datum_feature in the context of the datum_system referenced by this 
linear_profile_tolerance shall be the same as the name of the property_definition applied to the same 
physical_unit_datum_feature in the context of the datum_system referenced by the 
linear_profile_tolerance to which this linear_profile_tolerance is related as the 'linear profile 
refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement', it shall specify a 
measure_with_unit as its magnitude that is less than the measure_with_unit specified as the 
magnitude of the linear_profile_tolerance to which it is related as the 'linear profile refining 
control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement', there shall exist a 
property_definition that has a description of 'true profile' that is related as the 'basic profile' to a 
property_definition of the tolerance_zone_boundary of this linear_profile_tolerance and to a property_definition of the 
tolerance_zone_boundary of the linear_profile_tolerance that this linear_profile_tolerance is 
related to as the 'linear profile refining control', and these property_definition shall have the description 
of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 
'profile boundary with offsets'.
</Informal.propositions.rul>


<Informal.propositions.rul>
If the linear_profile_tolerance has a name of 'linear profile refinement' and its tolerance_zone 
has a property_definition that has a description of 'tolerance zone orientation' that relates to a property_definition 
with a description of 'viewing plane based orientation' to specify the 'zone orientation', it shall 
be related to a linear_profile_tolerance as the 'linear profile refining control' the 
tolerance_zone of which has a property_definition that has a description of 'tolerance zone orientation' that 
relates to the same property_definition with a description of 'viewing plane based orientation' to specify its 
'zone orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The toleranced_shape_aspect of the linear_profile_tolerance shall either be a 
part_template_definition, lie on the boundary of the shape of the product, or be 
a composite_shape_aspect the 'composing' shape_aspects of which are all of type part_template_definition.
</Informal.propositions.rul>


<Informal.propositions.rul>
The tolerance_zone_boundary of the linear_profile_tolerance shall have a property_definition with a 
description of 'boundary zone definition with specified size' and a name of either 'profile 
boundary' or 'profile boundary with offsets'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the linear_profile_tolerance is not a geometric_tolerance_with_specified_datum_system, its 
tolerance_zone shall have a property_definition that has a description of 'tolerance zone orientation' that 
relates to a property_definition with a description of 'viewing plane based orientation' to specify the 'zone 
orientation'.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="luminous_flux_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An luminous_flux_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Luminous_flux_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY luminous_flux_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\luminous_flux_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = lumen;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- luminous_flux_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The luminous_flux_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The luminous_flux_measure_with_unit shall reference an si_unit with a name of lumen.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="magnetic_flux_density_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A magnetic_flux_density_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Magnetic_flux_density_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY magnetic_flux_density_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\magnetic_flux_density_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = tesla;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- magnetic_flux_density_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The magnetic_flux_density_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The magnetic_flux_density_measure_with_unit shall reference an si_unit with a name of tesla.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="magnetic_flux_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A magnetic_flux_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Magnetic_flux_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY magnetic_flux_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\magnetic_flux_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = weber;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- magnetic_flux_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The magnetic_flux_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The magnetic_flux_measure_with_unit shall reference an si_unit with a name of weber.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="make_from_connectivity_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A make_from_connectivity_relationship is a shape_aspect_relationship that
implements the ARM concept
of <internal.ref Linkend="Physical_connectivity_make_from_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY make_from_connectivity_relationship
 SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION'
       IN TYPEOF (SELF.relating_shape_aspect);
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION'
       IN TYPEOF (SELF.related_shape_aspect);
END_ENTITY; -- make_from_connectivity_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The make_from_connectivity_relationship shall have a relating_shape_aspect 
that references a physical_connectivity_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_connectivity_relationship shall have a related_shape_aspect 
that references a physical_connectivity_definition.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="make_from_feature_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A make_from_feature_relationship is a shape_aspect_relationship that implements
the ARM concept
of <internal.ref Linkend="Component_feature_make_from_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY make_from_feature_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (SELF.relating_shape_aspect)) = 1;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (SELF.related_shape_aspect)) = 1;
  WR3: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.relating_shape_aspect))) OR
       (SELF.relating_shape_aspect\shape_aspect.description IN ['component feature',
       'component termination passage interface terminal', 
       'land or non functional land interface terminal',  
       'printed connector component interface terminal']);
  WR4: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.related_shape_aspect))) OR
       (SELF.related_shape_aspect\shape_aspect.description IN ['component feature',
       'component termination passage interface terminal', 
       'land or non functional land interface terminal',  
       'printed connector component interface terminal']);
END_ENTITY; -- make_from_feature_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The make_from_feature_relationship shall have a relating_shape_aspect
that is a component_definition, component_interface_terminal, or 
component_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_feature_relationship shall have a related_shape_aspect
that is a component_definition, component_interface_terminal, or 
component_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the make_from_feature_relationship has a relating_shape_aspect of
type component_shape_aspect, the description shall be either 'component
feature', 'component termination passage interface terminal', 'land or non
functional land interface terminal', or 'printed connector component interface
terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the make_from_feature_relationship has a related_shape_aspect of
type component_shape_aspect, the description shall be either 'component
feature', 'component termination passage interface terminal', 'land or non
functional land interface terminal', or 'printed connector component interface
terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="make_from_functional_unit_terminal_definition_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A make_from_functional_unit_terminal_definition_relationship is a shape_aspect and shape_aspect_relationship that implements the ARM concept
of <internal.ref Linkend="Functional_unit_terminal_definition_make_from_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY make_from_functional_unit_terminal_definition_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.relating_shape_aspect, 
       SELF\shape_aspect_relationship.related_shape_aspect;
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'] *
       TYPEOF (SELF.relating_shape_aspect)) = 1;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'] *
       TYPEOF (SELF.related_shape_aspect)) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
    SELF\make_from_functional_unit_terminal_definition_relationship)) = 0;
  WR4: relating_shape_aspect.of_shape :<>: 
       related_shape_aspect.of_shape;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect.description = '';
  WR7: SELF\shape_aspect.product_definitional = FALSE;
  WR8: SIZEOF (USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION')) = 0;
  WR9: SIZEOF (QUERY( sar <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_MAKE_FROM_RELATIONSHIP') IN TYPEOF
       (sar.of_shape\property_definition.definition))
       )) = 1;


END_ENTITY; -- make_from_functional_unit_terminal_definition_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shall have a relating_shape_aspect and related_shape_aspect combination that is unique.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shall have a relating_shape_aspect
that is a functional_unit_terminal_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shall have a related_shape_aspect
that is a functional_unit_terminal_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shall not be a complex instance.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship relating_shape_aspect and
related_shape_aspect shall not reference the same product_definition_shape.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shape_aspect supertype name shall be blank.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shape_aspect supertype description shall be blank.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shall not be product definitional.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shall not be referenced by a property_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_functional_unit_terminal_definition_relationship shall be related to one design_make_from_relationship.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="make_from_model_port_relationship">
<ENTITY.DESCRIPTION>
A make_from_model_port_relationship is a representation and a representation_relationship that implements the ARM concept of <internal.ref Linkend="Analytical_model_port_make_from_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY make_from_model_port_relationship
 SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, 
       SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL_PORT'] *
       TYPEOF (SELF.rep_1)) = 1;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL_PORT'] *
       TYPEOF (SELF.rep_2)) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\representation_relationship ||
       SELF\make_from_model_port_relationship)) = 0;
  WR4: rep_1 :<>: rep_2;
  WR5: SIZEOF(QUERY( rr1 <* USEDIN(SELF.rep_1,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
        (SIZEOF(QUERY(rr2 <* USEDIN(SELF.rep_2,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
        (rr1.rep_1 :=: rr2.rep_1)
        )) = 0))) = 1;
  WR6: SIZEOF (QUERY( rr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL_MAKE_FROM_RELATIONSHIP') IN TYPEOF (rr.rep_1))
       )) = 1; 
       
END_ENTITY; -- make_from_model_port_relationship
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">

<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall have a unique combination of rep_1 and rep_2.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall have a rep_1 that is an analytical_model_port.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall have a rep_2 that is an analytical_model_port.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall not be a complex instance.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall not reference the same port.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall not reference the same analytical_model.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall be related to one analytical_model_make_from_relationship.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="make_from_part_feature_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A make_from_part_feature_relationship is a shape_aspect and a shape_aspect_relationship that implements the ARM concept
of <internal.ref Linkend="Part_feature_make_from_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY make_from_part_feature_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.relating_shape_aspect, 
       SELF\shape_aspect_relationship.related_shape_aspect;
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (SELF.relating_shape_aspect)) = 0;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (SELF.related_shape_aspect)) = 0;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\make_from_part_feature_relationship)) = 0;
  WR4: SELF.related_shape_aspect.product_definitional = TRUE;
  WR5: SELF.relating_shape_aspect.product_definitional = TRUE;
  WR6: SELF\shape_aspect.name = '';
  WR7: SELF\shape_aspect.description = '';
  WR8: SELF\shape_aspect.product_definitional = FALSE;
  WR9: SIZEOF (USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION')) = 0;
 WR10: SIZEOF (QUERY( sar <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESIGN_MAKE_FROM_RELATIONSHIP') IN TYPEOF
       (sar.of_shape\property_definition.definition))
       )) = 1;
END_ENTITY; -- make_from_part_feature_relationship 
(* 
</EXPRESS.CODE> 
<FORMAL.PROPOSITIONS> 
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR"> 
<FORMAL.PROPOSITIONS.RUL>
The make_from_model_port_relationship shall have a unique combination of related_shape_aspect and relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall have a relating_shape_aspect that is not a Non_feature_shape_element and that is not a Component_feature.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall have a related_shape_aspect that is not a Non_feature_shape_element and that is not a Component_feature.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall not be a complex instance.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship related_shape_aspect shall be on the boundary of the part or template. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship relating_shape_aspect shall be on the boundary of the part or template. 
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall have a name inherited from the shape_aspect that is blank.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall have a description inherited from the shape_aspect that is blank.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall not be on the boundary of the part or template. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall not be referenced by a property_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The make_from_part_feature_relationship shall be related to exactly one design_make_from_relationship.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="manifold_constraining_context_dependent_shape_representation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A manifold_constraining_context_dependent_shape_representation is a context_dependent_shape_representation
and a representation_relationship
that implements the ARM concept of <internal.ref Linkend="An_unknown_arm_type">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY manifold_constraining_context_dependent_shape_representation
  SUBTYPE OF (context_dependent_shape_representation, representation_relationship);
END_ENTITY; -- manifold_constraining_context_dependent_shape_representation 
(* 
</EXPRESS.CODE> 

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="material_electrical_conductivity_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A material_electrical_conductivity_category is a group that specifies
the attribute electrical_conductivity_characteristic for the ARM
concept of <internal.ref Linkend="Material_electrical_conductivity_requirement_occurrence">
and the electrical conductivity_characteristic for the ARM concept of <internal.ref Linkend="Material_electrical_conductivity_requirement_occurrence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY material_electrical_conductivity_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN ['conductive', 'non conductive', 'resistive',  
       'semi conductive'];
END_ENTITY; -- material_electrical_conductivity_category
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The material_electrical_conductivity_category shall have a name of
'conductive', 'non conductive', 'resistive', or 'semi conductive'
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="material_functional_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A material_functional_category is a group that specifies
the role of material for the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Marking"></list.item>
<list.item><internal.ref Linkend="Packaged_part"></list.item>
<list.item><internal.ref Linkend="Part_device"></list.item>
</list>.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY material_functional_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN 
     ['bonding agent', 'potting compound', 'marking material'];
END_ENTITY; -- material_functional_category
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The material_functional_category shall have a name of
'bonding agent', 'potting compound', or 'marking material'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="material_optical_conductivity_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A material_optical_conductivity_category is a group that specifies
the optical conductivity characteristic for the ARM
concept
of <internal.ref Linkend="Ee_material">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY material_optical_conductivity_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN ['conductive', 'non conductive', 'resistive',  
       'semi conductive'];
END_ENTITY; -- material_optical_conductivity_category
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The material_optical_conductivity_category shall have a name of
'conductive', 'non conductive', 'resistive', or 'semi conductive'
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="material_removal_component_shape_aspect">
<ENTITY.DESCRIPTION>
A material_removal_component_shape_aspect is a component_shape_aspect that implements
the ARM concept of <Internal.ref Linkend="Material_removal_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY material_removal_component_shape_aspect
  SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- material_removal_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="material_thermal_conductivity_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A material_thermal_conductivity_category is a group that specifies
the thermal conductivity characteristic for the ARM
concept
of <internal.ref Linkend="Ee_material">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY material_thermal_conductivity_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN ['conductive', 'non conductive', 'resistive',  
       'semi conductive'];
END_ENTITY; -- material_thermal_conductivity_category
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The material_thermal_conductivity_category shall have a name of
'conductive', 'non conductive', 'resistive', or 'semi conductive'
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="minimally_defined_bare_die_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A minimally_defined_bare_die_terminal is a shape_aspect that implements the ARM
concepts of <internal.ref Linkend="Guided_wave_bare_die_terminal">
or <internal.ref Linkend="Minimally_defined_bare_die_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY minimally_defined_bare_die_terminal
  SUPERTYPE OF (bare_die_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE' IN 
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'external connection area') |
       eca.related_shape_aspect\shape_aspect.description = 'connection zone')) <= 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
  WR4: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
END_ENTITY; -- minimally_defined_bare_die_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The minimally_defined_bare_die_terminal shall be a terminal of a bare_die.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The minimally_defined_bare_die_terminal shall relate to at most one
shape_aspect that has a description of 'connection zone' as the
'external connection area'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The minimally_defined_bare_die_terminal shall have at most one material
designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The minimally_defined_bare_die_terminal shall be related to at most one 
part_connected_terminals_definition as a 'member connected terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="model_parameter">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A model_parameter is a representation_item that implements the ARM concept
of <internal.ref Linkend="Model_parameter">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY model_parameter 
 SUBTYPE OF (representation_item);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
  WR2: SIZEOF (QUERY (cri <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COORDINATED_REPRESENTATION_ITEM' IN TYPEOF(cri)) AND 
       (cri\representation.name = 
       'model parameter with valid range value'))) <= 1;
  WR3: SIZEOF (QUERY (aga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETER_TYPE' IN 
       TYPEOF (aga.assigned_group)) AND
       (aga.assigned_group\group.name IN ['string property type', 
       'logical property type', 'physical property type', 
       'boolean property type']))) = 1;
END_ENTITY; -- model_parameter
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The model_parameter shall be referenced by exactly one document.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The model_parameter shall be an item in at most one 
coordinated_representation_item that has a representation name of 
'model parameter with valid range value'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The model_parameter shall be assigned to exactly one parameter_type with
a name of 'string property type', 'logical property type', 'physical property
type', or 'boolean property type'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="mounting_restriction_area">
<ENTITY.DESCRIPTION>
A mounting_restriction_area is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Mounting_restriction_area">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY mounting_restriction_area
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
  WR2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN TYPEOF (SELF.of_shape.definition));

  WR3: SELF.of_shape.definition.frame_of_reference.name IN ['physical design'];

  WR4: SELF.of_shape.definition\product_definition.name = 'assembly module';

  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CSG_2D_SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)))) = 1))) = 0;
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'mounting surface') AND 
       (sar.related_shape_aspect\shape_aspect.description =
       'interconnect module component surface feature')))) = 1;
  WR7: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\shape_aspect ||
       SELF\mounting_restriction_area))) = 0;

END_ENTITY; -- mounting_restriction_area
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name of the physical_unit shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_area shall be an aspect of the shape of a physical_unit.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_area shall be an aspect of a product_definition that is in the physical design context.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_area shall be an aspect of the shape of an assembly module.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_area shall have exactly one shape_representation that shall be a csg_2d_shape_representation. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_area shall be related to exactly one component_shape_aspect with a description of 'interconnect module component surface feature' as the 'mounting surface'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_area shall not be any other type of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="mounting_restriction_volume">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A mounting_restriction_volume is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Mounting_restriction_volume">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY mounting_restriction_volume
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN TYPEOF (SELF.of_shape.definition));

  WR2: SELF.of_shape.definition.frame_of_reference.name IN ['physical design'];

  WR3: SELF.of_shape.definition.name = 'assembly module';

  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
        (pdr.used_representation\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3)
       )) = 1))) = 0;

  WR5: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (sar.related_shape_aspect)) AND
       (sar\shape_aspect_relationship.name = 'mounting surface') AND 
       (sar.related_shape_aspect\shape_aspect.description =
       'interconnect module component surface feature'))) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\shape_aspect ||
       SELF\mounting_restriction_volume))) = 0;
END_ENTITY; -- mounting_restriction_volume
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_volume shall be an aspect of the shape of a physical_unit.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_volume shall be an aspect of a product_definition that is in the physical design context.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_volume shall be an aspect of the shape of an assembly module.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_volume shall have exactly one shape_representation that shall be a 3 dimensional shape representation. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_volume shall be related to exactly one component_shape_aspect with 
a description of 'interconnect module component surface feature' as the 'mounting surface'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The mounting_restriction_volume shall not be any other type of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="multi_layer_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A multi_layer_component_shape_aspect is a component_shape_aspect that implements
the ARM concept of <Internal.ref Linkend="Multi_layer_stratum_feature_template_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY multi_layer_component_shape_aspect
  SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- multi_layer_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="multi_layer_material_removal_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A multi_layer_material_removal_component_shape_aspect is a material_removal_component_shape_aspect
that implements the ARM concept of <Internal.ref Linkend="Multi_layer_material_removal_laminate_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY multi_layer_material_removal_component_shape_aspect
  SUBTYPE OF (material_removal_component_shape_aspect);
END_ENTITY; -- multi_layer_material_removal_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="multi_layer_stratum_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A multi_layer_stratum_feature is a stratum_feature that implements the ARM
concept of <internal.ref Linkend="Multi_layer_stratum_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY multi_layer_stratum_feature
 SUBTYPE OF (stratum_feature);
END_ENTITY; -- multi_layer_stratum_feature
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="network_node_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A network_node_definition is a product_definition that implements the ARM
concept of <internal.ref Linkend="Functional_unit_network_node_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY network_node_definition
  SUBTYPE OF (product_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'functional network design';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (funtdna <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name =
       'functional unit network terminal definition node assignment') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE' IN 
       TYPEOF (funtdna.related_property_definition)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN 
       TYPEOF 
       (funtdna.related_property_definition.definition)))) <= 1)) <= 1;
  WR3: SIZEOF (QUERY (funn <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (funn.relating_product_definition)) AND
       (funn.relating_product_definition.frame_of_reference.name =
       'functional network design'))) = 1;
END_ENTITY; -- network_node_definition
(*
</EXPRESS.CODE>


<formal.propositions rule.types="WR">

<FORMAL.PROPOSITIONS.RUL>
The network_node_definition shall have its context element with a name
of 'functional network design'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The network_node_definition shall have at most one property that relates
to at most one  product_definition_shape of a 
functional_unit_terminal_definition to specify the 
'functional unit network terminal definition node assignment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The network_node_definition shall be related to exactly one
functional_unit that has a context element with a name of 'functional network
design' as the 'functional unit network node'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<informal.propositions rule.types="IP">
<INFORMAL.PROPOSITIONS.RUL>
This is an IP for now, as it obviously uses arm constructs.  It will be converted to DERIVE and then
the electrical and thermal network structural validity can be exchanged based on
approval.  Probably need something like "valid structure".
<note Verbatim = "Y">
<!--
DERIVE
   valid_conservative_node : BOOLEAN := ((SIZEOF(QUERY( vc <* USEDIN (SELF,
      'AP210_WD1_12.BUS_ELEMENT_LINK.PRECEDENT_ELEMENT')|
      vc <> [])) +
   SIZEOF(QUERY( vc <* USEDIN (SELF,
      'AP210_WD1_12.BUS_ELEMENT_LINK.SUBSEQUENT_ELEMENT')|
      vc <> [])) +
   SIZEOF(QUERY( vc <* USEDIN (SELF, 
      'AP210_WD1_12.FUNCTIONAL_UNIT_TERMINAL_NODE_ASSIGNMENT.COMPOSED_NODE') |
      vc <> [])) +
   SIZEOF(external_node_access)) > 1);
-->
</note>   
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="opposing_boundary_dimensional_size">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An opposing_boundary_dimensional_size is a dimensional_size that implements
the ARM concept
of <internal.ref Linkend="Dimensional_size_based_on_opposing_boundaries">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY opposing_boundary_dimensional_size
  SUBTYPE OF (dimensional_size);
WHERE
    wr1: SELF\dimensional_size.name  IN ['angular', 'linear'];
END_ENTITY; -- opposing_boundary_dimensional_size
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The name of the opposing_boundary_dimensional_size shall be either 'angular' or 'linear'.
</Formal.propositions.rul>
</Formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The opposing_boundary_dimensional_size applies_to a composite_unit_shape_aspect.
</Informal.propositions.rul>


</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="owner_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An owner_assignment is an person_and_organization_assignment that specifies
a set of owner_assigned_item.  An item that is owned cannot be changed without the permission of the owner.
<example>
A component position may be owned by the mechanical design department, in which case movement of the component
is to be negotiated with that department.
</example>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY owner_assignment 
 SUBTYPE OF (person_and_organization_assignment); 
 items : SET [1:?] OF owner_assigned_item; 
END_ENTITY; -- owner_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A package is a physical_unit that implements the ARM concepts of 
<internal.ref Linkend="Altered_package">
and <internal.ref Linkend="Package">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package
 SUBTYPE OF (physical_unit);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical design usage';
  -- WR2 deleleted
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY' IN 
       TYPEOF (sa))) = 1))) <= 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL' IN 
       TYPEOF (sa))) >= 1))) >= 1;
  WR5: (NOT (SELF\product_definition.description = 'altered package')) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'package alteration') AND
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (pdr.relating_product_definition)) = 1))) = 1); 
  WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 'package mounting data')) = 1))) = 1;

  WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body height above seating plane')) = 1)
       )) = 1))) = 1;

  WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body height below seating plane')) = 1)
       )) = 1))) <= 1;

  WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body clearance above seating plane')) = 1)
       )) = 1))) <= 1;

  WR10: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body clearance below seating plane')) = 1)
       )) = 1))) <= 1;

  WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'minimum body clearance above seating plane')) = 1)
       )) = 1))) <= 1;

  WR12: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'minimum body clearance below seating plane')) = 1)
       )) = 1))) <= 1;

  WR13: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum lead length below seating plane')) = 1)
       )) = 1))) <= 1;

  WR14: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'least lead length below seating plane')) = 1)
       )) = 1))) <= 1;
  WR15: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT' IN TYPEOF(sa)) AND
       (SIZEOF (QUERY ( sar <* USEDIN(sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        ((sar\shape_aspect_relationship.name = 'package seating plane') AND
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SEATING_PLANE' IN TYPEOF(sar.related_shape_aspect))) )) = 1))
       )) = 1)
       )
       ) = 1;

  WR16: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SEATING_PLANE' IN
       TYPEOF (sa)))) = 1))) = 1;

  WR17: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT' IN TYPEOF(sa)) AND
       (SIZEOF (QUERY ( sar <* USEDIN(sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        ((sar\shape_aspect_relationship.name = 'of datum reference plane') AND
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME' IN TYPEOF(sar.related_shape_aspect))) )) = 1))
       )) = 1)
       )
       ) <= 1;
 WR18: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sa))
       )) = 1)
       )
       ) <= 1;
END_ENTITY; -- package
(*
</EXPRESS.CODE>
      

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The package shall have a frame_of_reference name of 'physical design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have at most one package_body.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have at least one package_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the package has a description of 'altered package', it shall be
related to exactly one package, externally_defined_package, or 
library_defined_package as the 'package alteration'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have exactly one representation with the name of 'package mounting data'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have one item in its representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'maximum body height above seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have no more than one item in the representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'maximum body height below seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have no more than one item in the representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'maximum body clearance above seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have no more than one item in the representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'maximum body clearance below seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have no more than one item in the representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'minimum body clearance above seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have no more than one item in the representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'minimum body clearance below seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have no more than one item in the representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'maximum lead length below seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have no more than one item in the representation with the name of 'package mounting data' that shall be a length_measure_with_unit and that shall have a
name of 'least lead length below seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The seating_plane for this package shall be related to a shape_aspect of this package through a shape_aspect_relationshipt with the name of 'package seating plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have exactly one seating plane.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have at most one datum_reference_frame.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package shall have at most one primary_reference_terminal.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
Each three-dimensional shape representation of the package shall have exactly two 
geometric_representation_item that are axis2_placement_3d and one
axis2_placement_3d shall define the location and orientation of the
seating plane in that representation.  The normal of the seating plane
in that representation shall be congruent with and the same direction as the Z axis of the 
axis2_placement_3d.  The plane of the seating plane in that representation shall be congruent
with the plane established by the X and Y axes of the axis2_placement_3d.
</INFORMAL.PROPOSITIONS.RUL>

<INFORMAL.PROPOSITIONS.RUL>
Each two-dimensional shape representation of the package shall have exactly one
geometric_representation_item that is an axis2_placement_2d that shall define the
origin of the geometric model, and the location and orientation of the seating plane.
</INFORMAL.PROPOSITIONS.RUL>

<INFORMAL.PROPOSITIONS.RUL>
The package shall have no more than one representation with the name of 'material property data' that shall be related to cartesian_points with names of 'least material condition centroid location' and 'maximum material condition centroid location'.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package_body">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A package_body is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Package_body">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package_body
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE']) = 1;
  WR2: SIZEOF (USEDIN (SELF, 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
END_ENTITY; -- package_body
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The package_body shall be the aspect of the shape of a package,
externally_defined_package, or library_defined_package.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_body shall have exactly one material_designation.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package_body_bottom_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A package_body_bottom_surface is a package_body_surface that implements the ARM concept
of <internal.ref Linkend="Package_body_bottom_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package_body_bottom_surface
 SUBTYPE OF (package_body_surface);
END_ENTITY; -- package_body_bottom_surface
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package_body_edge_segment_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A package_body_edge_segment_surface is a shape_aspect and shape_aspect_relationship that implements the
ARM concept of<internal.ref Linkend="Package_body_edge_segment_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package_body_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  wr1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  wr2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  wr3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_EDGE_SURFACE' IN TYPEOF
       (ce.relating_shape_aspect) ))) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\package_body_edge_segment_surface)) = 0;
END_ENTITY; -- package_body_edge_segment_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The package_body_edge_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_body_edge_segment_surface shall be related to exactly one
edge_segment_vertex through a shape_aspect_relationship relating attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_segment_vertex instances referenced shall not be the same instance of edge_segment_vertex.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The package_body_edge_segment_surface shall be related to
exactly one package_body_edge_surface as the 'composed surface'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_body_edge_segment_surface shall not be in a complex instance other 
than with it's immediate supertypes. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package_body_edge_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A package_body_edge_surface is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Package_body_edge_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package_body_edge_surface
 SUBTYPE OF (package_body_surface);
WHERE
  WR1: SELF\shape_aspect.product_definitional;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\package_body_edge_surface ||
       SELF\package_body_surface)) = 0;
END_ENTITY; -- package_body_edge_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The package_body_edge_surface shall be on the boundary of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_body_edge_surface shall be no other subtype of shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package_body_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A package_body_surface is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Package_body_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package_body_surface
ABSTRACT SUPERTYPE OF (ONEOF(package_body_top_surface,
                         package_body_edge_surface,
                         package_body_bottom_surface))
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (TYPEOF(sar\shape_aspect_relationship.relating_shape_aspect) = 
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY']))) = 1;
END_ENTITY; -- package_body_surface
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The package_body_surface shall be the aspect of the shape of a package,
externally_defined_package, or library_defined_package.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_body_surface shall be on the boundary of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_body_surface shall be related to exactly one package_body.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package_body_top_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A package_body_top_surface is a package_body_surface that implements the ARM concept
of <internal.ref Linkend="Package_body_top_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package_body_top_surface
 SUBTYPE OF (package_body_surface);
END_ENTITY; -- package_body_top_surface
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="package_terminal">
<ENTITY.DESCRIPTION>
A package_terminal is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Altered_package_terminal"></list.item>
<list.item><internal.ref Linkend="Guided_wave_terminal"></list.item>
<list.item><internal.ref Linkend="Length_trimmed_terminal"></list.item>
<list.item><internal.ref Linkend="Package_terminal"></list.item>
<list.item><internal.ref Linkend="Shape_formed_terminal"></list.item>
<list.item><internal.ref Linkend="Surface_prepped_terminal"></list.item>
<list.item><internal.ref Linkend="Wire_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY package_terminal
 SUPERTYPE OF (((altered_package_terminal ANDOR guided_wave_terminal)
      ANDOR wire_terminal) ANDOR primary_reference_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR2: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE']) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |(
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION' IN TYPEOF (sar.relating_shape_aspect.of_shape.definition)) AND
       (sar\shape_aspect_relationship.name = 'terminal core material') AND
       (sar.relating_shape_aspect.of_shape.definition.
        frame_of_reference\application_context_element.name = 'material definition') 
       )) <= 1;
  WR4: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |(
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION' IN TYPEOF (sar.relating_shape_aspect.of_shape.definition)) AND
       (sar\shape_aspect_relationship.name = 'terminal surface material') AND
       (sar.relating_shape_aspect.of_shape.definition.
        frame_of_reference\application_context_element.name = 'material definition') 
       )) = 1;
  WR5: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
 WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'external connection zone') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 0;
 WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'maximum terminal diametrical extent')) 
        <= 1)) <= 1)) <= 1;
 WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'minimum terminal diametrical extent')) 
         <= 1)) <= 1)) <= 1;
 WR9: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       <= 1;
 WR10: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       <= 1;
 WR11: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'seating plane zone') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN
       TYPEOF (eca.related_shape_aspect))) <= 1;
END_ENTITY; -- package_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall have at least one shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall be the aspect of the shape of a package,
externally_defined_package, or library_defined_package.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall have no more than one shape_aspect_relationship with a name of 'terminal core material' that relates to a product_definition with a frame of reference of 'material definiton'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall have no more than one shape_aspect_relationship with a name of 'terminal core material' that relates to a product_definition with a frame of reference of 'material definiton'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall be related to at most one part_connected_terminals_definition as a 'member connected terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall be related to zero or more shape_aspect with a description of 'connection zone' as the 'external connection zone'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall have at most one property_definition that
has at most one representation that contains at most one
length_measure_with_unit with a name
of 'maximum terminal diametrical extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall have at most one property_definition that
has at most one representation that contains at most one
length_measure_with_unit with a name
of 'minimum terminal diametrical extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall be referenced by no more than one shape_aspect_relationship with a description of 'precedent feature' as the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall be referenced by no more than one shape_aspect_relationship with a description of 'precedent feature' as the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The package_terminal shall be related to no more than one connection_zone_interface_plane_relationship. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="packaged_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A packaged_component is a component_definition that implements the ARM concepts
of:
<list> 
<list.item><internal.ref Linkend="Packaged_component"></list.item>
<list.item><internal.ref Linkend="Packaged_connector_component"></list.item>
<list.item><internal.ref Linkend="Routed_packaged_component"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY packaged_component
  SUBTYPE OF (component_definition);
WHERE
  WR1: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1;
  WR2: SIZEOF (QUERY (pa <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'package alternate') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE'] *
       TYPEOF (pa.relating_product_definition)) = 1) AND
       (pa.relating_product_definition\product_definition.description =
       'altered package'))) <= 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'packaged component join terminal'))) >= 1))) = 0;
  WR4: (NOT (SELF\product_definition.description = 'packaged connector component')) OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (TRUE))) = 1);
  WR5: (NOT (SELF\product_definition.description = 'packaged connector component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'packaged component join terminal'))) 
        >= 1))) = 0);
  WR6: (NOT (SELF\product_definition.description = 'routed packaged component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       SIZEOF (QUERY (pd <* USEDIN (sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (USEDIN (pd, 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) 
       = 1)) = 1)) = 1))) = 0);
END_ENTITY; -- packaged_component
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The packaged_component shall be related, as the 'instantiated part',
to exactly one packaged_part, externally_defined_packaged_part, or
library_defined_packaged_part that is in the 'physical design usage'
product_definition_context.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_component shall be related, as the 'package alternate',
to at most one package, externally_defined_package, or
library_defined_package that has a description of 'altered package'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_component shall have at least one shape_aspect that is a
component_terminal with a description of 'packaged component join terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the packaged_component has description of 'packaged connector
component', the packaged_component shall be related, as the 'instantiated
part', to exactly one packaged_part, externally_defined_packaged_part, or
library_defined_packaged_part that is in the 'packaged connector'
product_definition_context.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the packaged_component has a description of 'packaged connector
component', it shall have at least one shape_aspect that is a 
component_interface_terminal with a description of 
'packaged component join terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the packaged_component has a description of 'routed packaged
component', it shall have exactly one shape_aspect that has exactly one
property_definition that is associated to exactly one representation.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="packaged_connector">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A packaged_connector is a packaged_part that implements the ARM concept
of <internal.ref Linkend="Packaged_connector">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY packaged_connector
  SUBTYPE OF (packaged_part);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN
       TYPEOF (sa)))) = 1))) >= 1;

  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (SIZEOF (QUERY ( sar <* USEDIN(sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        sar\shape_aspect_relationship.name = 'interface plane')) = 1)
       )) = 1)
       )
       ) <= 1;

  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SEATING_PLANE' IN
       TYPEOF (sa)))) = 1))) <= 1;

END_ENTITY; -- packaged_connector
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The packaged_connector shall have at least one shape_aspect that is a packaged_connector_terminal_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_connector shall have at most one shape_aspect that is a seating plane in the role of 'interface plane'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
No more than one seating plane shall reference this packaged_connector through the of_shape attribute.
<note>
Normally the seating_plane that is related through the shape_aspect_relationshipt will also reference this packaged_connector.
</note>
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="packaged_connector_terminal_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A packaged_connector_terminal_relationship is a shape_aspect and a
shape_aspect_relationship that implements the ARM concept
of <internal.ref Linkend="Packaged_connector_terminal_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY packaged_connector_terminal_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: (SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART']) 
       = 1) AND
       (SELF.of_shape.definition\product_definition.description =
       'packaged connector');
  WR2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect)) AND
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description 
        = 'interface terminal'));
  WR3: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect)) AND
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description 
        = 'join terminal'));
END_ENTITY; -- packaged_connector_terminal_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The packaged_connector_terminal_relationship shall be an aspect of the
shape of a packaged_part, externally_defined_packaged_part, or
library_defined_packaged_part with a description of 'packaged connector'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_connector_terminal_relationship shall have a relating_shape_aspect
that is a packaged_part_terminal with a description of 'interface terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_connector_terminal_relationship shall have a related_shape_aspect
that is a packaged_part_terminal with a description of 'join terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="packaged_part">
<ENTITY.DESCRIPTION>
A packaged_part is a physical_unit that implements the ARM concepts of
<internal.ref Linkend="Altered_packaged_part">
and <internal.ref Linkend="Packaged_part">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY packaged_part
 SUPERTYPE OF (packaged_connector)
 SUBTYPE OF (physical_unit);
WHERE 
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (sa))) >= 0))) = 0;
  WR2: SIZEOF (USEDIN (SELF, 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
  WR3: SIZEOF (QUERY (ifu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN
       TYPEOF (ifu.relating_product_definition)) AND
       (ifu.relating_product_definition.frame_of_reference.name =
       'functional design usage'))) <= 1;
  WR4: NOT(EXISTS(SELF\product_definition.description)) OR
       ((NOT (SELF\product_definition.description = 'altered packaged part')) OR
       (SIZEOF (QUERY (bpp <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'base packaged part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] * 
       TYPEOF (bpp.relating_product_definition)) = 1) AND
       (bpp.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) >= 1));
  WR5: SIZEOF (QUERY (upkg <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'used package') |
       SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (upkg.relating_product_definition)) = 1)) >= 1;
  WR6: SELF.frame_of_reference.name = 'physical design usage';
END_ENTITY; -- packaged_part
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The packaged_part may have zero or more shape_aspect that is a packaged_part_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_part shall have no more than one material_designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_part shall be related to exactly one functional_unit with a 
frame_of_reference name of 'functional design usage' as the 
'implemented function'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the packaged_part has a description of 'altered packaged part', it
shall be related to at least one packaged_part, 
externally_defined_packaged_part, or library_defined_packaged_part with a 
frame_of_reference name of
'physical design usage' as the 'member connected terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_part shall be related to at least one package, externally_defined_package, or library_defined_package as the 'used package'.
<note>
The global rule Packaged_part_unique_constraint ensures that all packages so referenced are for the same product_definition_formation.
</note>
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="packaged_part_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A packaged_part_terminal is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Packaged_part_interface_terminal"></list.item>
<list.item><internal.ref Linkend="Packaged_part_join_terminal"></list.item>
<list.item><internal.ref Linkend="Packaged_part_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY packaged_part_terminal
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN ['interface terminal', 
       'join terminal'];
  WR2: (SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PACKAGED_PART']) 
       = 1) AND
  (SELF.of_shape.definition\product_definition.frame_of_reference.name = 
       'physical design usage');
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR4: SIZEOF (QUERY (top <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'terminal of package') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL' IN
       TYPEOF (top.related_shape_aspect))) >= 1;
  WR5: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
  WR6: (NOT(SELF\shape_aspect.description = 'interface terminal')) OR
       (SIZEOF(QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))
       AND (sar.relating_shape_aspect\shape_aspect.description = 
       'join terminal'))) >= 1);
  WR7: (NOT(SELF\shape_aspect.description = 'join terminal')) OR
       (SIZEOF(QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))
       AND (sar.relating_shape_aspect\shape_aspect.description = 
        'interface terminal'))) <= 1);
END_ENTITY; -- packaged_part_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The packaged_part_terminal shall have a description of either 'interface
terminal' or 'join terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_part_terminal shall be an aspect of the shape of a
packaged_part, externally_defined_packaged_part, or 
library_defined_packaged_part that has a frame_of_reference name of 
'physical design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_part_terminal shall have a property that is represented by
at least one shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_part_terminal shall relate to at least one package_terminal
to specify the 'terminal of package'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The packaged_part_terminal shall be related to at most one 
part_connected_terminals_definition as a member connected terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the packaged_part_terminal has a description of 'interface terminal',
it shall be related to at least one packaged_part_terminal with a
description of 'join terminal' by a packaged_connector_terminal_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the packaged_part_terminal has a description of 'join terminal', it
shall be related to at most one packaged_part_terminal with a description of
'interface terminal' by a packaged_connector_terminal_relationship.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<NOTE>
Part_connected_terminals_definition provides a capability to state that
multiple interface terminals are connected internally in the connector.
</NOTE>

<!--
 changed supertype mm 7/2/97
 removed WR2 mm 7/2/97 

-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="padstack_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A padstack_definition is a product_definition that implements the ARM concept<internal.ref Linkend="Padstack_definition"> and its subtypes.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY padstack_definition
 SUPERTYPE OF (ONEOF( design_layer_type_specific_padstack_definition,
               stratum_occurrence_specific_padstack_definition,
               stratum_type_independent_padstack_definition))
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\padstack_definition))) = 0;
  WR7: SELF.frame_of_reference.name IN ['layout design usage' ];
  WR9: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'template model')) = 1;
END_ENTITY; -- padstack_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the padstack_definition is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall not be any other type of product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have a frame_of_reference with a name of 'layout design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall be associated with a product that is a template model.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="padstack_occurrence">
<ENTITY.DESCRIPTION>
A padstack_occurrence is an assembly_group_component_shape_aspect that implements the ARM concept of<internal.ref Linkend="Padstack_occurrence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY padstack_occurrence
  SUBTYPE OF (assembly_group_component_shape_aspect);
END_ENTITY; -- padstack_occurrence
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="padstack_occurrence_shape_aspect_relationship">
<ENTITY.DESCRIPTION>
A padstack_occurrence_shape_aspect_relationship is a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Padstack_occurrence_sub_assembly_relationship">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY padstack_occurrence_shape_aspect_relationship
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\padstack_occurrence_shape_aspect_relationship)) = 0;
  WR3: SELF\shape_aspect_relationship.name = 'padstack occurrence sub assembly relationship';
END_ENTITY; -- padstack_occurrence_shape_aspect_relationship 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related shape_aspect shall not be the relating shape_aspect. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of padstack_occurrence_shape_aspect_relationship shall be only padstack_occurrence_shape_aspect_relationship, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be 'padstack occurrence sub assembly relationship'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="parallelism_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A parallelism_tolerance is a geometric_tolerance_with_specified_datum_source
that implements the ARM concept
of <internal.ref Linkend="Parallelism_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY parallelism_tolerance
  SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
WHERE
  WR1: SELF\geometric_tolerance.name = 'parallelism';
END_ENTITY; -- parallelism_tolerance
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name for the parallelism_tolerance shall be 'parallelism'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The toleranced_shape_aspect of the parallelism_tolerance shall either lie on the 
boundary of the shape of the product; be a centre_of_symmetry with a description of 
either 'axis' or 'plane'; be a tangent with a description of 'plane'; be a 
part_template_definition; or be a composite_shape_aspect the 'composing' shape_aspects 
of which either are all of type part_template_definition, are all of type 
centre_of_symmetry and have the same description -- either 'axis' or 'plane', or are 
all of type tangent with a description of 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The parallelism_tolerance shall have at most two physical_unit_datum in its referenced datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
The parallelism_tolerance shall have at least one physical_unit_datum in its referenced 
datum_system that has description of either 'axis' or 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the toleranced_shape_aspect of the parallelism_tolerance is neither a 
centre_of_symmetry with a description of 'axis' nor a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'axis', the tolerance_zone_boundary shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="parameter_assignment_representation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A parameter_assignment_representation is a representation that implements the
ARM concept of <internal.ref Linkend="Parameter_assignment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY parameter_assignment_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (SELF.items) = 2;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       (SIZEOF (TYPEOF (it) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MODEL_PARAMETER']) 
       = 1))) = 1;
  WR3: SIZEOF (QUERY (it <* SELF.items |
       (SIZEOF (TYPEOF (it) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COORDINATED_REPRESENTATION_ITEM']) 
       = 1))) <= 1;
  WR4: SIZEOF (QUERY (it <* SELF.items |
        (SIZEOF (QUERY(aga <* USEDIN (it,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
             (SIZEOF (TYPEOF ( aga\group_assignment.assigned_group) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHARACTERISTIC_TYPE']) = 1))) 
       = 1))) <= 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\parameter_assignment_representation)) = 0; 
END_ENTITY; -- parameter_assignment_representation
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The parameter_assignment_representation shall have exactly two
representation_items.
</FORMAL.PROPOSITIONS.RUL>


<FORMAL.PROPOSITIONS.RUL>
The parameter_assignment_representation shall have exactly one item that is a model_parameter.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The parameter_assignment_representation shall have no more than one item that is a coordinated_characteristic.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The parameter_assignment_representation shall have no more than one item that is a characteristic.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The parameter_assignment_representation shall not be any other type other than a representation.
</FORMAL.PROPOSITIONS.RUL>



<!--
added entity tt 4/2/297

-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="parameter_type">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A parameter_type is a group that specifies a boolean_property_type, a
logical_property_type, a physical_property_type or a string_property_type
for a model_parameter.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY parameter_type
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN ['string property type','logical property type',
       'physical property type','boolean property type'];
END_ENTITY; -- parameter_type
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
A parameter_type shall have a name that is 'string property type', 'logical
property type', 'physical property type', or 'boolean property type'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="part_connected_terminals_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A part_connected_terminals_definition is a shape_aspect that implements the
ARM concept of <internal.ref Linkend="Part_connected_terminals_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY part_connected_terminals_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BARE_DIE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL'] *
       TYPEOF (mct.related_shape_aspect)) = 1)) >= 2;
END_ENTITY; -- part_connected_terminals_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>
 
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The part_connected_terminals_definition shall relate to at least two instances of
assembly_module_terminal, bare_die_terminal, interconnect_module_terminal,
package_terminal, or packaged_part_terminal to specify a 'member connected
terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
Each terminal related by this part_connected_terminals_definition shall be a
terminal of the same product version.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="part_interface_access_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A part_interface_access_feature is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Part_interface_access_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY part_interface_access_feature
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'interface_access area') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
END_ENTITY; -- part_interface_access_feature
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The part_interface_access_feature shall be related as the 'interface_access area' 
to exactly one shape_aspect with a description of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="part_mating_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A part_mating_feature is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Part_mating_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY part_mating_feature
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'mating area') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
END_ENTITY; -- part_mating_feature
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The part_mating_feature shall be related as the 'mating area' 
to exactly one shape_aspect with a description of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="part_mounting_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A part_mounting_feature is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Part_mounting_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY part_mounting_feature
 SUPERTYPE OF (bare_die_surface)
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'mounting area') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
END_ENTITY; -- part_mounting_feature
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The part_mounting_feature shall be related as the 'mounting area' 
to exactly one shape_aspect with a description of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="part_template_definition">
<ENTITY.DESCRIPTION>
A part_template_definition is a shape_aspect that implements the ARM concepts of:
<list> 
<list.item><internal.ref Linkend="Blind_passage_template"></list.item>
<list.item><internal.ref Linkend="Component_termination_passage_template"></list.item>
<list.item><internal.ref Linkend="Counterbore_passage_template"></list.item>
<list.item><internal.ref Linkend="Countersunk_passage_template"></list.item>
<list.item><internal.ref Linkend="Default_trace_template"></list.item>
<list.item><internal.ref Linkend="Dependent_material_removal_feature_template"></list.item>
<list.item><internal.ref Linkend="Inter_stratum_feature_template"></list.item>
<list.item><internal.ref Linkend="Material_addition_feature_template"></list.item>
<list.item><internal.ref Linkend="Material_removal_feature_template"></list.item>
<list.item><internal.ref Linkend="Non_conductive_cross_section_template"></list.item>
<list.item><internal.ref Linkend="Part_template"></list.item>
<list.item><internal.ref Linkend="Part_text_template"></list.item>
<list.item><internal.ref Linkend="Physical_feature_or_part_template"></list.item>
<list.item><internal.ref Linkend="Printed_connector_template"></list.item>
<list.item><internal.ref Linkend="Printed_part_cross_section_template"></list.item>
<list.item><internal.ref Linkend="Printed_part_template"></list.item>
<list.item><internal.ref Linkend="Special_symbol_part_template"></list.item>
<list.item><internal.ref Linkend="Stratum_feature_template"></list.item>
<list.item><internal.ref Linkend="Trace_template"></list.item>
<list.item><internal.ref Linkend="Unsupported_passage_template"></list.item>
<list.item><internal.ref Linkend="Via_template"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY part_template_definition
  SUPERTYPE OF (dependent_material_removal_feature_template)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\
       shape_aspect.of_shape\
       property_definition.definition.frame_of_reference\
       application_context_element.name = 'template definition';

  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'part template analytical model'))) 
       <= 1))) = 0;       

  WR3: (NOT (SELF\shape_aspect.description = 
         'component termination passage template')) OR
       (SIZEOF (QUERY (ctpt <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'inter stratum feature passage technology') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (ctpt.relating_shape_aspect)) AND
       (ctpt.relating_shape_aspect\shape_aspect.description = 
       'default component termination passage definition'))) = 1);

  WR4: (NOT (SELF\shape_aspect.description = 
        'component termination passage template')) OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'access mechanism') |
       am.related_shape_aspect\shape_aspect.description IN 
       ['component termination passage template interface terminal',
       'component termination passage template join terminal'])) >= 2);

  WR5: (NOT (SELF\shape_aspect.description = 'default trace template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition))) = 1)) = 1);

  WR6: (NOT (SELF\shape_aspect.description = 'inter stratum feature template')) OR
       (SIZEOF (QUERY (isfpt <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'inter stratum feature passage technology') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (isfpt.relating_shape_aspect)))) = 1);

  WR7: (NOT (SELF\shape_aspect.description = 'printed connector template')) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name IN 
       ['connector'])) >= 1);

  WR8: (NOT (SELF\shape_aspect.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANALYTICAL_MODEL' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'transmission line model'))) 
       = 1))) = 0);

  WR9: (NOT (SELF\shape_aspect.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2)) = 2)) = 1))) = 0);

 WR10: (NOT (SELF\shape_aspect.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'maximum width'))) = 1
       )) = 1))) = 0);

 WR11: (NOT (SELF\shape_aspect.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'minimum width'))) = 1
       )) = 1))) = 0);

 WR12: (NOT (SELF\shape_aspect.description = 'printed part template')) OR
       (SIZEOF (QUERY (impl_func <* QUERY (pdr <* 
       USEDIN (SELF.of_shape.definition,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (impl_func.relating_product_definition)) AND
       (impl_func.relating_product_definition.frame_of_reference.name =
       'functional design usage'))) = 1);
 
 WR13: (NOT (SELF\shape_aspect.description = 'printed part template')) OR
       (SIZEOF (QUERY (ad <* QUERY (sar <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated definition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF (ad.related_shape_aspect)) AND
       (ad.related_shape_aspect\shape_aspect.description IN 
       ['interface terminal', 'join terminal']))) >= 2);

 WR14: (NOT (SELF\shape_aspect.description = 'trace template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 'curve style parameters'
       )) = 1 ) )) = 1 );  

 WR15: (NOT (SELF\shape_aspect.description = 'unsupported passage template')) OR
       (SIZEOF (QUERY (upt <* QUERY (sar <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'inter stratum feature passage technology') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN 
       TYPEOF (upt.relating_shape_aspect)) AND
       (upt.relating_shape_aspect\shape_aspect.description = 
       'default unsupported passage definition'))) = 1);

 WR16: (NOT (SELF\shape_aspect.description = 'via template')) OR
       (SIZEOF (QUERY (vpt <* QUERY (sar <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'inter stratum feature passage technology') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY' IN 
       TYPEOF (vpt.relating_shape_aspect)) AND
       (vpt.relating_shape_aspect\shape_aspect.description = 
       'default via definition'))) = 1);

 WR17: (NOT (SELF\shape_aspect.description = 'via template')) OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'access mechanism') |
       am.related_shape_aspect\shape_aspect.description =
                                 'via template terminal')) >= 2);

 WR18: EXISTS(SELF\shape_aspect.name);

 WR19: (NOT (SELF\shape_aspect.description = 'non conductive cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN
       TYPEOF (tu.relating_property_definition.definition)))) = 1)) = 1);

 WR20: (NOT (SELF\shape_aspect.description = 'non conductive cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'nominal width'))) = 1
       )) = 1))) = 0);

 WR21: (NOT (SELF\shape_aspect.description = 'printed connector template')) OR
       (SIZEOF (QUERY (ad <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated definition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (ad.related_shape_aspect)) AND
       (ad.relating_shape_aspect\shape_aspect.description IN
       ['interface terminal', 'join terminal']))) >= 2);

 WR22: (NOT (SELF\shape_aspect.description = 
                         'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'horizontal material link') |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_shape_aspect)) AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_shape_aspect\shape_aspect_relationship.
                                                   related_shape_aspect)) AND
       (ad.relating_shape_aspect\shape_aspect_relationship.
                 related_shape_aspect\shape_aspect.description = 'left'))))) = 0); 

 WR27: (NOT (SELF\shape_aspect.description = 
                        'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'horizontal material link') |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_shape_aspect)) AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_shape_aspect\shape_aspect_relationship.
                                                 relating_shape_aspect)) AND
       (ad.relating_shape_aspect\shape_aspect_relationship.
              relating_shape_aspect\shape_aspect.description = 'right'))))) = 0); 

 WR28: (NOT (SELF\shape_aspect.description = 
                                'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'vertical material link') |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_shape_aspect)) AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_shape_aspect\shape_aspect_relationship.
                                              related_shape_aspect)) AND
       (ad.relating_shape_aspect\shape_aspect_relationship.
          related_shape_aspect\shape_aspect.description = 'bottom'))))) = 0); 

 WR29: (NOT (SELF\shape_aspect.description = 
                                 'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'vertical material link') |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_shape_aspect)) AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_shape_aspect\shape_aspect_relationship.
                                          relating_shape_aspect)) AND
       (ad.relating_shape_aspect\shape_aspect_relationship.
          relating_shape_aspect\shape_aspect.description = 'top'))))) = 0); 
 WR30: SELF\shape_aspect.name = 'NULL';
END_ENTITY; -- part_template_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The part_template_definition shall be an aspect of the shape of a
product_definition that has an application_context_element with a name of 'template definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The part_template_definition shall have at most one representation that
is an analytical_model and has a name of 'part template analytical model'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'component
termination passage template', it shall be related to a passage_technology
with a description of 'default component termination passage definition' as a
'inter stratum feature passage technology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'component
termination passage template', it shall be used to relate at least two
shape_aspects with a description of either 'component termination passage
template interface terminal' or 'component termination passage template join
terminal' to specify the 'access mechanism'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'default trace
template' it shall have a property that is related to a property of a
stratum_technology as the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'inter stratum
feature template', it shall be related to a passage_technology  as an 'inter
stratum feature passage technology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed connector
template', it shall be used to relate at least one shape_aspect to specify a
'connector'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part
cross section template', it shall be represented by exactly one 
analytical_model with a name of 'transmission line model'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part
cross section template', it shall have a representation that contains exactly
two length_measure_with_units.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part
cross section template', it shall have a representation that contains exactly
one length_measure_with_unit with a name of 'maximum width'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part cross section template', it shall have a representation that contains exactly one length_measure_with_unit with a name of 'minimum width'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part
template', it shall be an aspect of the shape of a product_definition that is
the 'implemented function' for exactly one functional_unit with a
frame_of_reference name of 'functional design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part
template', it shall be used to relate two or more
printed_part_template_terminals with a description of either
'interface terminal' or 'join terminal' to specify an 'associated definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'trace template',
it shall have a representation that contains exactly one styled_item with a
name of 'trace style' that specifies a curve_style.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'unsupported
passage template', it shall be related to exactly one passage_technology with
a description of 'default unsupported passage definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'via template', it
shall be related to exactly one passage_technology with a description of
'default via definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'via template', it
shall relate at least two shape_aspects with a description of 'via template
terminal' as the 'access mechanism'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The part_template_definition name shall exist.
<note>
This is a placeholder rule.
</note>
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'non conductive cross section
template' it shall have a property that is related to a property of a
stratum_technology as the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'non conductive
cross section template', it shall have a representation that contains exactly
one length_measure_with_unit with a name of 'nominal width'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed connector 
template', it shall be used to relate two or more
printed_part_template_terminals with a description of either
'interface terminal' or 'join terminal' to specify an 'associated definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part cross section template', and if there are horizontallly adjacent disjoint materials, the subsequent boundary shall be the 'right' boundary for each material link between two materials.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part cross section template', and if there are horizontally adjacent disjoint materials, the precedent boundary shall be the 'left' boundary for each material link between two materials.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part cross section template', and if there are verticallly adjacent disjoint materials, the subsequent boundary shall be the 'top' boundary for each material link between two materials.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the part_template_definition has a description of 'printed part cross section template', and if there are vertically adjacent disjoint materials, the precedent boundary shall be the 'bottom' boundary for each material link between two materials.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name inherited from shape_aspect shall be 'NULL'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="part_text_template_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A part_text_template_definition is a part_template_definition that implements the ARM concept of
<internal.ref Linkend="Part_text_template">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY part_text_template_definition
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL' IN
       TYPEOF (it))) = 1)) = 1))) = 0);
  WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font vertical extent'))) = 1
       )) = 1))) = 0);
  WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font horizontal extent'))) = 1
       )) = 1))) = 0);
END_ENTITY; -- part_text_template_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The part_text_template_definition shall have a representation that has exactly one text_literal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The part_text_template_definition shall have a representation that has exactly one
measure_representation_item that is a length_measure_with_unit with a name of
'maximum font vertical extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The part_text_template_definition shall have a representation that has exactly one
measure_representation_item that is a length_measure_with_unit with a name of
'maximum font horizontal extent'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="part_tooling_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A part_tooling_feature is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Part_tooling_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY part_tooling_feature
 SUPERTYPE OF (fiducial_part_feature ANDOR 
               test_point_part_feature)
 SUBTYPE OF (shape_aspect);
END_ENTITY; -- part_tooling_feature
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="passage_technology">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A passage_technology is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Default_component_termination_passage_definition"></list.item>
<list.item><internal.ref Linkend="Default_unsupported_passage_definition"></list.item>
<list.item><internal.ref Linkend="Passage_technology"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY passage_technology
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION' IN 
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation')) = 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (
          {1 <= SIZEOF (pcr.used_representation.items) <= 8}
                                             ))) = 0))) = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items | 
       NOT (it\representation_item.name IN ['maximum aspect ratio', 'plated passage', 
       'maximum allowed component terminal extent', 
       'minimum allowed component terminal extent', 
       'maximum as finished deposition thickness',  
       'minimum as finished deposition thickness',  
       'maximum as finished passage extent', 
       'minimum as finished passage extent']))) = 0))) = 0))) = 0;
  WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RATIO_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'maximum aspect ratio') AND
       (it\measure_with_unit.value_component > 1.0))) <= 1))) = 0))) = 0;
  WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'plated passage') AND
       (it\descriptive_representation_item.description IN ['true', 'false']))) = 1))) = 0))) = 0;
  WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum as finished passage extent')
       )) <= 1))) = 0))) = 0;
  WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'maximum as finished deposition thickness'))) <= 1))) = 0))) = 0;
 WR10: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum as finished deposition thickness'))) <= 1))) = 0))) = 0;
 WR11: (NOT (SELF\shape_aspect.description IN 
       ['default component termination passage definition',
       'default via definition'])) OR 
       (SIZEOF (USEDIN (SELF, 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
 WR12: (NOT (SELF\shape_aspect.description IN  
       ['default component termination passage definition',
       'default unsupported passage definition',
       'default via definition'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum as finished passage extent'))) 
        = 1))) = 0))) = 0);
 WR13: (NOT (SELF\shape_aspect.description =
       'default component termination passage definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum as finished deposition thickness'))) 
         = 1))) = 0))) = 0);
 WR14: (NOT (SELF\shape_aspect.description =
       'default component termination passage definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum allowed component terminal extent'))) = 1))) = 0))) = 0);
 WR15: (NOT (SELF\shape_aspect.description =
       'default component termination passage definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'maximum allowed component terminal extent'))) = 1))) = 0))) = 0);
 WR16: (NOT (SELF\shape_aspect.description = 'default via definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum as finished deposition thickness'))) = 1))) = 0))) = 0);
 WR17: SIZEOF (QUERY (rpt <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'as finished inter stratum extent') |
       (rpt.related_shape_aspect.of_shape\property_definition.description =
       'finished stratum extent') AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP' 
       IN 
        TYPEOF (rpt.related_shape_aspect.of_shape\property_definition.
       definition)) 
       AND    
       (rpt.related_shape_aspect.of_shape\property_definition.
        definition\product_definition_relationship.name =
       'inter stratum extent')))) = 1;
END_ENTITY; -- passage_technology
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within the scope of the referenced shape.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The passage_technology shall be an aspect of the shape of a product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The passage_technology shall have at most one material designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The passage_technology shall have exactly one representation with a name
of 'physical characteristics representation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The passage_technology shall have at least one and at most eight items
in its representation with a name of 'physical characteristics
representation'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The items in the representation with a name of 'physical
characteristics representation' of a passage_technology shall have a name of
either 'maximum aspect ratio', 'plated passage',  'maximum allowed component
terminal extent', 'minimum allowed component terminal extent', 'maximum as
finished deposition thickness', 'minimum as finished deposition thickness',
'maximum as finished passage extent', or 'minimum as finished passage extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At most one item in the representation with a name of 'physical
characteristics representation' of a passage_technology shall be a 
measure_representation_item and a ratio_measure_with_unit with a name of 
'maximum aspect ratio' and a value greater than 1.0.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Exactly one item in the representation with a name of 'physical
characteristics representation' of a passage_technology shall be a
descriptive_representation_item with a name of 'plated passage' and a
description of 'true' or 'false'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At most one item in the representation with a name of 'physical
characteristics representation' of a passage_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'minimum as finished passage extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At most one item in the representation with a name of 'physical
characteristics representation' of a passage_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'maximum as finished deposition thickness'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At most one item in the representation with a name of 'physical
characteristics representation' of a passage_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'minimum as finished deposition thickness'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the passage_technology has a description of 'default via definition'
or 'default component termination passage definition', it shall have exactly
one material_designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the passage_technology has a description of 'default component
termination passage definition', 'default unsuported passage definition'
or 'default via definition', exactly one item in the representation with a
name of 'physical characteristics representation' of a passage_technology
shall be a measure_representation_item and a length_measure_with_unit with a
name of 'minimum as finished passage extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the passage_technology has a description of 'default component
termination passage definition', exactly one item in the representation with a
name of 'physical characteristics representation' of a passage_technology
shall be a measure_representation_item and a length_measure_with_unit with a
name of 'minimum as finished deposition thickness'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the passage_technology has a description of 'default component
termination passage definition', exactly one item in the representation with a
name of 'physical characteristics representation' of a passage_technology
shall be a measure_representation_item and a length_measure_with_unit with a
name of 'minimum allowed component terminal extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the passage_technology has a description of 'default component
termination passage definition', exactly one item in the representation with a
name of 'physical characteristics representation' of a passage_technology
shall be a measure_representation_item and a length_measure_with_unit with a
name of 'maximum allowed component terminal extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the passage_technology has a description of 'default via
definition', exactly one item in the representation with a name of 'physical
characteristics representation' of a passage_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'minimum as finished deposition thickness'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The passage_technology shall relate to exactly one shape_aspect of a
shape with a description of 'finished stratum extent' of a 
product_definition_relationship with a name of 'inter stratum extent' to 
specify the 'as finished inter stratum extent'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
If the passage_technology is related to a inter_stratum_feature with a
description of 'interconnect module edge' or 'interconnect module edge segment'
it, shall not be related to a representation_item with a name of 
'maximum as finished passage extent'
</INFORMAL.PROPOSITIONS.RUL>

<INFORMAL.PROPOSITIONS.RUL>
If the item in the representation with a name of 'physical
characteristics representation' of a passage_technology has a 
descriptive_representation_item with a name of 'plated passage'
and a description of 'true' then the material designation
shall have be the designation for a
material_designation_characterization with a property that is a
material_property_representation that has a definition that is a
material_property and a used_representation with a name of
'conductivity classification representation' that has an item that
is a descriptive_representation_item with a name of
'electrical conductivity classification' and a description of
'conductive'.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="perpendicularity_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A perpendicularity_tolerance is a
geometric_tolerance_with_specified_datum_source that implements the ARM concept
of <internal.ref Linkend="Perpendicularity_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY perpendicularity_tolerance
  SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
WHERE
  WR1: SELF\geometric_tolerance.name = 'perpendicularity';
END_ENTITY; -- perpendicularity_tolerance
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name for the perpendicularity_tolerance shall be 'perpendicularity'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The toleranced_shape_aspect of the perpendicularity_tolerance shall either lie on the 
boundary of the shape of the product; be a centre_of_symmetry with a description of 
either 'axis' or 'plane'; be a tangent with a description of 'plane'; be a 
part_template_definition; or be a composite_shape_aspect the 'composing' shape_aspects 
of which either are all of type part_template_definition, are all of type 
centre_of_symmetry and have the same description -- either 'axis' or 'plane', or are 
all of type tangent with a description of 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The perpendicularity_tolerance shall have at most two physical_unit_datum in its referenced 
datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
The perpendicularity_tolerance shall have at least one physical_unit_datum in its referenced 
datum_system that has description of either 'axis' or 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the toleranced_shape_aspect of the perpendicularity_tolerance is neither a 
centre_of_symmetry with a description of 'axis' nor a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'axis', the tolerance_zone_boundary shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_connectivity_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_connectivity_definition is a shape_aspect that implements the ARM
concepts of <internal.ref Linkend="Physical_connectivity_definition">
and <internal.ref Linkend="Physical_connectivity_structure_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_connectivity_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name,SELF\shape_aspect.of_shape;
WHERE
  WR1: SIZEOF (QUERY (at <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated terminals') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at.related_shape_aspect)) AND
((at.related_shape_aspect\shape_aspect.description = 
                 'assembly module component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
                        'bare die component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
               'interconnect component join terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
             'interconnect module component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
              'minimally defined component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
                     'packaged component join terminal'))
       )) > 1;
  WR2: SIZEOF (QUERY( pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
        (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'connectivity allocation')) = 1)
       ))
       <= 1;
END_ENTITY; -- physical_connectivity_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within the context of the product_definition_shape in the role of of_shape for the shape_aspect supertype.
<note>
Since there may be only one product_definition for a product_definition_shape, this guarantees uniqueness within the context of the product_definition.
</note>
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The physical_connectivity_definition shall relate to two or more
physical_component_terminal to specify the 'associated terminals'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_connectivity_definition shall be related by at most one property_definition_relationshp as a
'connectivity allocation'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
All component_terminals related to a physical_connectivity_definition shall be in the same design view.
</INFORMAL.PROPOSITIONS.RUL>
<INFORMAL.PROPOSITIONS.RUL>
All component_terminals related to a physical_connectivity_definition shall not be in the set of terminals of the components that implement the connectivity defined by the physical_connectivity_definition.
<note>
The terminals identified by the physical_connectivity_definition are a subset of the terminals referenced by the members of assembly_joint or by the members of the implementation of the ARM concept of Interface_mounted_join.
</note>
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_connectivity_element">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_connectivity_element is a shape_aspect_relationship and a 
shape aspect that implement the ARM concept
of <internal.ref Linkend="Physical_connectivity_element">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_connectivity_element
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
  WR1: (SELF.relating_shape_aspect\shape_aspect.description = 
                          'topological junction') XOR
       (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL'] *
       TYPEOF (SELF.relating_shape_aspect)) = 1);
  WR2: (SELF.related_shape_aspect\shape_aspect.description = 'topological junction') XOR
       (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL'] *
       TYPEOF (SELF.related_shape_aspect)) = 1);
  WR3: SIZEOF (QUERY (se <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'structure element') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF (se.relating_shape_aspect))) = 1;
  WR4: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN 
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.
         frame_of_reference.name = 
       'physical design');
END_ENTITY; -- physical_connectivity_element
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The physical_connectivity_element shall have a relating_shape_aspect that
either has a description of 'topological junction', or is a component_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_connectivity_element shall have a related_shape_aspect that
either has a description of 'topological junction', or is a component_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_connectivity_element shall be related to exactly one
physical_connectivity_definition as a 'structure element'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_connectivity_element shall be an aspect of the shape of  a
physical_unit that has a frame_of_reference name of 'physical design'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_network">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_network is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Physical_network">.
<note>
A physical_network should not be confused with the like sounding term physical_unit_network_definition.
</note>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_network
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (cr <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connectivity requirement') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (cr.related_shape_aspect)) AND
((cr.related_shape_aspect\shape_aspect.description = 
     'component termination passage join terminal') OR
(cr.related_shape_aspect\shape_aspect.description = 
                              'land join terminal') OR
(cr.related_shape_aspect\shape_aspect.description = 
               'non functional land join terminal') OR
(cr.related_shape_aspect\shape_aspect.description = 
                 'printed component join terminal'))
)) >= 2;
  WR2: SIZEOF (QUERY (nt <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'network topology') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (nt.related_shape_aspect))) >= 1;
  WR3: SIZEOF (QUERY (nt <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'reference connected terminals') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_CONNECTED_TERMINALS_DEFINITION' IN
       TYPEOF (nt.relating_shape_aspect))) <= 1;
END_ENTITY; -- physical_network
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The physical_network shall relate to at least two component_terminals with the specified descriptions to
specify a 'connectivity requirement'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_network shall relate to at least one join_shape_aspect to specify a 'network topology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_network shall relate to no more than one part_connected_terminals_definition to specify 'reference connected terminals'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<informal.propositions rule.types="IP">
<informal.propositions.rul>
All component_terminals related to a physical_network in the role of
connectivity_requirement_element shall be in the same design view
as the physical_network (interconnect_module.)
</informal.propositions.rul>

<informal.propositions.rul>
All join_relationships related to a physical_network in the role of
interconnect_module_net_topology_element shall be in the same design view
as the physical_network (interconnect_module.)
</informal.propositions.rul>

<informal.propositions.rul>
All interconnect_module_net_topology_element and connectivity_requirement_element
related to physical_network shall be in the same design view (interconnect_module.)
</informal.propositions.rul>

<informal.propositions.rul>
The material_electrical_conductivity_category shall be the same for all materials that participate in the physical_network.
</informal.propositions.rul>

<informal.propositions.rul>
The physical_network shall not be referenced by more than one property_definition_relationship that relates the physical_network to an aggregate connectivity requirement implementation.
</informal.propositions.rul>

</informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_node_requirement_to_implementing_component_allocation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_node_requirement_to_implementing_component_allocation is a shape_aspect_relationship and
a shape_aspect that is the allocation of a physical node to the component that is partially or wholly responsible
for implementing that node in the assembly.  The relating and related shape_aspects are the node and a shape_aspect
of the component respectively.  
A physical_node_requirement_to_implementing_component_allocation implements the ARM
concept of<internal.ref Linkend="Physical_node_requirement_to_implementing_component_allocation">.

</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_node_requirement_to_implementing_component_allocation
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
  WR1: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.related_shape_aspect.of_shape\property_definition.definition)) AND
       (NOT (SELF.related_shape_aspect.of_shape\property_definition.definition\product_definition.description IN 
       ['laminate component']));
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF (SELF.relating_shape_aspect);
  WR3: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'+
       'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION');
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\physical_node_requirement_to_implementing_component_allocation)) = 0;
(*
  WR5: SIZEOF(terminal_of_implementing_component(SELF,SELF.relating_shape_aspect)) = 0;
*)
END_ENTITY; -- physical_node_requirement_to_implementing_component_allocation
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The physical_node_requirement_to_implementing_component_allocation shall have a related_shape_aspect that references a component_definition that is not a laminate component.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_node_requirement_to_implementing_component_allocation shall have a relating_shape_aspect that references a physical_connectivity_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The members of physical_node_requirement_to_implementing_component_allocation shall form a directed acyclic graph with the relating_shape_aspect, related_shape_aspect attributes of physical_node_requirement_to_implementing_component_allocation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A member of physical_node_requirement_to_implementing_component_allocation shall not be any other subtype of shape_aspect or shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
in arm terms:
SIZEOF(QUERY (pct <* physical_node_requirement.associated_terminals |
          pct\component_feature.associated_component = implementation_component )) = 0;

</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_unit">
<ENTITY.DESCRIPTION>
A physical_unit is a product_definition that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Assembly_module"></list.item>
<list.item><internal.ref Linkend="Assembly_module_usage_view"></list.item>
<list.item><internal.ref Linkend="Externally_defined_ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Interconnect_module"></list.item>
<list.item><internal.ref Linkend="Interconnect_module_usage_view"></list.item>
<list.item><internal.ref Linkend="Library_defined_ee_product_definition"></list.item>
<list.item><internal.ref Linkend="Physical_unit"></list.item>
<list.item><internal.ref Linkend="Physical_unit_design_view"></list.item>
<list.item><internal.ref Linkend="Physical_unit_usage_view"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_unit
 SUPERTYPE OF (ONEOF (bare_die, 
                      package, 
                      packaged_part, 
                      assembly_definition, 
                      interconnect_definition,
                      reference_packaged_part_assembly_implementation,
                      reference_packaged_part_interconnect_implementation))
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SELF.frame_of_reference.name IN ['physical design', 
       'physical design usage'];
  WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'physical unit technology') |
       dut.relating_property_definition\property_definition.name =
       'unit technology')) = 1)) <= 1;
  WR8: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa))) >= 1))) = 0);
  WR9: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
               'maximum negative component height')) <= 1))) = 0);
 WR10: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
                 'maximum positive component height')) <= 1))) = 0);
 WR11: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'implemented function') AND
       (pdr.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1);
 WR12: NOT(is_assembly_module_design(SELF)) 
       OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATING_PRODUCT_DEFINITION') |
       (is_laminate_component(pdr.related_product_definition)
       ))) = 0);
 WR14: NOT(is_interconnect_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'implemented function') AND
       (pdr.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) <= 1);
 WR15: NOT(is_interconnect_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd1 <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd1)) 
       AND (SIZEOF(QUERY(cd <* USEDIN(pd1,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHARACTERIZED_DEFINITION' IN TYPEOF (cd))
       AND (SIZEOF(QUERY(pd2 <* USEDIN(cd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd2\property_definition.name = 'located interconnect module thickness')
       AND (SIZEOF(USEDIN(pd2,        
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) > 1)
       )) = 1))) = 1))) <=1 );
 WR16: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
       'interconnect module usage view physical characteristics'))) <= 1);
 WR17: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
          'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
          'minimum thickness over metal requirement')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR18: NOT(is_interconnect_module_usage(SELF))
        OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
         'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
         'maximum thickness over metal requirement')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR19: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
          'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
         'minimum thickness over dielectric requirement')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR20: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
          'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
           'maximum thickness over dielectric requirement')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR21: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ((pd\property_definition.name = 'restraint') OR
       (pd\property_definition.name = 'tolerance specific restraint')))) <= 1);
 WR22: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (sa\shape_aspect.description = 
                                 'interconnect module primary surface')
       )) <= 1))) = 0);
WR23: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (sa\shape_aspect.description = 
                              'interconnect module secondary surface')
       )) <= 1))) = 0);
WR24: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (sa\shape_aspect.description =
                                 'interconnect module edge surface')
       )) <= 1))) = 0);
WR25: NOT(is_assembly_module_design(SELF)) OR
((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'assembly module')      
       AND (SIZEOF (QUERY(pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY(sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (sa)))) > 0 ))) = 0)))
       OR (SIZEOF (QUERY(pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY(sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT' IN TYPEOF (sa)) AND
       (SIZEOF (QUERY( acu <* USEDIN (
       sa\shape_aspect_relationship.relating_shape_aspect.of_shape.definition,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
       AND (acu\product_definition_relationship.relating_product_definition = SELF)
       )) >= 1))) >=1 ))) >= 1));
WR26: NOT(is_assembly_module_design(SELF)) OR
      ((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'assembly module')      
       ))
       AND (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj))AND
       (SIZEOF (QUERY( acu <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
        AND (acu\product_definition_relationship.relating_product_definition = SELF)
        )) = 0))) = 0));
WR27: NOT(is_assembly_module_design(SELF)) OR
      ((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'assembly module')      
       ))
       AND (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)) AND
        (SIZEOF (QUERY( cl <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect.of_shape.definition,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'REPRESENTATION.ITEMS') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_LOCATION' IN TYPEOF (cl))
        AND (aj IN cl\representation.items))) = 0))) = 0));
WR28: NOT(is_interconnect_module_design(SELF)) OR
       ((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'interconnect module')
       )) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATING_PRODUCT_DEFINITION') |
        (
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr))
       AND
       (pdr\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND
       (pdr.related_product_definition\product_definition.description = 'primary design layer stratum')
       AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM' IN TYPEOF(pdr.related_product_definition))
        )
       )
       ) = 1));

END_ENTITY; -- physical_unit
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit shall have a frame_of_reference with a name of
'physical design' or 'physical design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit shall be related to at most one property with a name of 'unit technology'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'assembly module', it shall have at least one shape_aspect that is of type assembly_module_terminal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'assembly module',
it shall have at most one representation with a name of 'maximum negative
component height'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'assembly module',
it shall have at most one representation with a name of 'maximum positive
component height'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'assembly module',
it shall have exactly one 'functional design usage' specified as the implemented
function.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design' of an 'assembly module',
it shall have no laminate components.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'interconnect
module', it shall have no more than one 'functional design usage' specified as the
'implemented function'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'interconnect
module', it shall have at most one requirements_property with a name of 'located
interconnect module thickness'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a physical design usage of an interconnect
module it shall be the definition for at most one property_definition
with a name of 'interconnect module usage view physical characteristics'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a physical design usage of an interconnect
module it shall be the definition for at most one property_definition
with a name of 'interconnect module usage view physical characteristics'
and related to a length_measure_with_unit with a name of
'minimum thickness over metal requirement'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a physical design usage of an interconnect
module it shall be the definition for at most one property_definition
with a name of 'interconnect module usage view physical characteristics'
and related to a length_measure_with_unit with a name of
'maximum thickness over metal requirement'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a physical design usage of an interconnect
module it shall be the definition for at most one property_definition
with a name of 'interconnect module usage view physical characteristics'
and related to a length_measure_with_unit with a name of
'minimum thickness over dielectric requirement'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a physical design usage of an interconnect
module it shall be the definition for at most one property_definition
with a name of 'interconnect module usage view physical characteristics'
and related to a length_measure_with_unit with a name of
'maximum thickness over dielectric requirement'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a physical design usage of an interconnect
module it shall be the definition for at most one property_definition
with a name of 'restraint' or 'tolerance specific restraint'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'interconnect module', it shall have no more than one shape_aspect that is implementation of secondary surface.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'interconnect module', it shall have no more than one shape_aspect that is implementation of primary surface.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit is a 'physical design usage' of an 'interconnect module', it shall have no more than one shape_aspect that is implementation of edge surface.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit that is a design view of an assembly module is referenced by an
assembly_joint through the of_shape attribute, at least one of the members
of component_definition that are related by the relating_shape_aspect of that
assembly_joint shall be related by members of assembly_component_usage to
this physical_unit.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit that is a design view of an assembly module is referenced by an assembly_joint through the of_shape attribute, each member of component_definition that are related by the related_shape_aspect of that assembly_joint shall be related by members of assembly_component_usage to this physical_unit.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit that is a design view of an assembly module is referenced by an assembly_joint through the of_shape attribute, the component_definition that is related by the assembly_joint\shape_aspect_relationship.related_shape_aspect attribute of that assembly_joint shall be positioned by a member of component_location which also references that assembly_joint.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit that is a design view of an interconnect module, there shall be exactly one primary design layer stratum related to the physical_unit by an assembly_component_usage. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_unit_datum">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_unit_datum is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Common_datum"></list.item>
<list.item><internal.ref Linkend="Datum"></list.item>
<list.item><internal.ref Linkend="Datum_axis"></list.item>
<list.item><internal.ref Linkend="Datum_plane"></list.item>
<list.item><internal.ref Linkend="Datum_point"></list.item>
<list.item><internal.ref Linkend="Edge_segment_vertex"></list.item>
<list.item><internal.ref Linkend="Single_datum"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_unit_datum
  SUPERTYPE OF (edge_segment_vertex)
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: SELF\shape_aspect.description IN ['axis', 'plane', 'point', ''];
    WR2: SELF\shape_aspect.product_definitional = False;
    WR3: SELF\shape_aspect.name IN ['single datum', 'common datum', ''];
    WR4: (NOT (SELF\shape_aspect.name = 'common datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum feature usage in datum system') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'DATUM_SYSTEM' IN TYPEOF(SAR)))) >= 1);
    WR5: (NOT (SELF\shape_aspect.name = 'common datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum feature usage in common datum') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'DATUM_SYSTEM' IN TYPEOF(SAR)))) >= 2);
    WR6: (NOT ((SELF\shape_aspect.description = 'axis') AND
         (SELF\shape_aspect.name IN ['common datum', 'single datum']))) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         NOT(sar\shape_aspect_relationship.name = 'reference axis') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR)))) = 1);
    WR7: (NOT ((SELF\shape_aspect.description = 'plane') AND
         (SELF\shape_aspect.name IN ['common datum', 'single datum']))) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         NOT(sar\shape_aspect_relationship.name = 'reference plane') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR)))) = 1);
    WR8: (NOT ((SELF\shape_aspect.description = 'point') AND
         (SELF\shape_aspect.name IN ['common datum', 'single datum']))) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         NOT(sar\shape_aspect_relationship.name = 'reference origin') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR)))) = 1);
    WR9: (NOT (SELF\shape_aspect.name = 'single datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum usage in datum system') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'DATUM_SYSTEM' IN TYPEOF(SAR)))) >= 1);
   WR10: (NOT (SELF\shape_aspect.name = 'single datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum feature usage in single datum') AND
         (TRUE))) <= 1);
   WR11: NOT ((SELF\shape_aspect.name IN [''])
         AND (SELF\shape_aspect.description IN ['']));
   WR12: (NOT(SELF\shape_aspect.description = 'plane')) OR
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'PROPERTY_DEFINITION.DEFINITION') |
         pd\property_definition.description = 'datum direction property')) <= 2);
END_ENTITY; -- physical_unit_datum
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The physical_unit_datum shall have a description of 'axis', 'plane', 'point' or 'null'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The physical_unit_datum shall not lie on the boundary of the shape of the product.
</Formal.propositions.rul>

<Formal.propositions.rul>
The physical_unit_datum shall have a name of 'single datum', 'common datum', or 'null'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the name of the physical_unit_datum is 'common datum' it shall be related to at least one 
datum_system as a 'datum usage in datum system'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the name of the physical_unit_datum is 'common datum', it shall relate to at least two 
shape_aspect to specify the 'datum feature usage in common datum'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the description of the physical_unit_datum is 'axis' and the physical_unit_datum is not related 
to a datum_reference_frame as a 'reference axis', it shall have a name of either 'common datum' or 
'single datum'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the description of the physical_unit_datum is 'plane' and the physical_unit_datum is not related 
to a datum_reference_frame as a 'reference plane', it shall have a name of either 'common datum' or 
'single datum'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the description of the physical_unit_datum is 'point' and the physical_unit_datum is not related 
to a datum_reference_frame as a 'reference origin', it shall have a name of either 'common datum' 
or 'single datum'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the name of the physical_unit_datum is 'single datum', it shall be related to at least one 
datum_system as a 'datum usage in datum system'.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the name of the physical_unit_datum is 'single datum', it shall relate to no more than one 
shape_aspect to specify the 'datum feature usage in single datum'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The name and description of the physical_unit_datum shall not both be an empty string.
</Formal.propositions.rul>

<formal.propositions.rul>
If the description of the physical_unit_datum is 'plane', it shall have at most two 
property_definitions with the description of 'datum direction property'.
</formal.propositions.rul>

</Formal.propositions>

<Informal.propositions rule.types="IP">
<InFormal.propositions.rul>
If the description of the physical_unit_datum is 'plane' and it has two property_definitions with 
the description of 'datum direction property', the names of the two property_definitions shall not 
be the same.
</InFormal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_unit_datum_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_unit_datum_feature is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Datum_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_unit_datum_feature
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'PROPERTY_DEFINITION.' + 'DEFINITION') | 
             (pd\property_definition.description = 'datum feature identification')))) = 1;
    WR2: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name IN ['datum feature usage in common datum',
         'datum feature usage in single datum'])) >= 1);
    WR3: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name = 'datum feature usage in single datum')) <= 1);
END_ENTITY; -- physical_unit_datum_feature
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The physical_unit_datum_feature shall have exactly one property that has the description of 'datum feature identification'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The physical_unit_datum_feature shall be related by at least one shape_aspect_relationship with a name of either 'datum feature usage in common datum' or 'datum feature usage in single datum'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The physical_unit_datum_feature shall be related to at most one shape_aspect as a 'datum feature usage in single datum'.
</Formal.propositions.rul>

</Formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The physical_unit_datum_feature shall either lie on the boundary of the shape of the product or be a part_template_definition.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_unit_datum_target">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_unit_datum_target is a shape_aspect that implements that ARM
concept of <internal.ref Linkend="Datum_target">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_unit_datum_target
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name = 'datum target usage')) >= 1);
END_ENTITY; -- physical_unit_datum_target
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">

<Formal.propositions.rul>
The physical_unit_datum_target shall be related to at least one shape_aspect as the 'datum target usage'.
</Formal.propositions.rul>

</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_unit_datum_target_set">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_unit_datum_target_set is a physical_unit_datum_feature that
implements the ARM concept of <internal.ref Linkend="Datum_target_set">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_unit_datum_target_set
  SUBTYPE OF (physical_unit_datum_feature);
WHERE
    WR1: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name = 'datum target usage')) >= 1);
    WR2: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name = 'constituent')) = 0);
END_ENTITY; -- physical_unit_datum_target_set
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The physical_unit_datum_target_set shall relate to at least one shape_aspect to specify the 'datum 
target usage'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The physical_unit_datum_target_set shall not be related to a shape_aspect as a 
'constituent'.
</Formal.propositions.rul>

</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_unit_geometric_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A physical_unit_geometric_tolerance is a geometric_tolerance and a
property_definition that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Circularity_tolerance"></list.item>
<list.item><internal.ref Linkend="Flatness_tolerance"></list.item>
<list.item><internal.ref Linkend="Geometric_tolerance"></list.item>
<list.item><internal.ref Linkend="Geometric_tolerance_without_referenced_datum_system"></list.item>
<list.item><internal.ref Linkend="Straightness_tolerance"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_unit_geometric_tolerance
  SUBTYPE OF (geometric_tolerance, property_definition);
WHERE
    WR1: SELF\geometric_tolerance.name = SELF\property_definition.name;
    WR2: SELF\geometric_tolerance.toleranced_shape_aspect
         = SELF\property_definition.definition;
    WR3: (NOT (SIZEOF([
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM',
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'LINEAR_PROFILE_TOLERANCE',
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'SURFACE_PROFILE_TOLERANCE',
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
              'POSITION_TOLERANCE'] * TYPEOF(SELF)) = 0))
         OR (SELF\geometric_tolerance.name IN ['circularity',
             'cylindricity', 'flatness', 'straightness']);
    WR4: (NOT (SELF\geometric_tolerance.name = 'circularity')) OR
         (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
    WR5: (NOT (SELF\geometric_tolerance.name = 'cylindricity')) OR
         (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
             'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
    WR6: (NOT (SELF\geometric_tolerance.name = 'flatness')) OR
         (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
         'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
    WR7: (SIZEOF (QUERY (pugt <* QUERY ( sar <* USEDIN(SELF,
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
          sar\shape_aspect_relationship.name = 'group geometric tolerance') | 
          pugt.relating_shape_aspect\shape_aspect.description = 
          'simultaneous requirement')) <= 1);
END_ENTITY; -- physical_unit_geometric_tolerance
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The value of two name attributes of the physical_unit_geometric_tolerance shall be identical.
</Formal.propositions.rul>

<Formal.propositions.rul>
The shape_aspect specified as the definition of the physical_unit_geometric_tolerance shall be the 
same shape_aspect specified as the toleranced_shape_aspect by the physical_unit_geometric_tolerance.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the physical_unit_geometric_tolerance is neither a 
geometric_tolerance_with_specified_datum_system, a linear_profile_tolerance, a 
surface_profile_tolerance, nor a position_tolerance, the name of the 
physical_unit_geometric_tolerance shall be either 'circularity', 'cylindricity', 'flatness', or 'straightness'.
</Formal.propositions.rul>

<formal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'circularity', it shall not be a 
modified_geometric_tolerance.
</formal.propositions.rul>

<Formal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'cylindricity', it shall not be a 
modified_geometric_tolerance.
</Formal.propositions.rul>

<Formal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'flatness', it shall not be a 
modified_geometric_tolerance.
</Formal.propositions.rul>

<Formal.propositions.rul>
The physical_unit_geometric_tolerance shall be related to at most one geometric_tolerance_group 
with a description of 'simultaneous requirement' as the 'group geometric tolerance'.
</Formal.propositions.rul>

</Formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The physical_unit_geometric_tolerance either shall relate to exactly one property_definition that has a 
description of either 'conical tolerance zone boundary size', 'positional boundary member 
property', 'profile related positional boundary property' to specify the 'defined boundary'; or 
shall be the defining_tolerance of exactly one tolerance_zone that is the zone of exactly one 
tolerance_zone_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
The toleranced_shape_aspect of the physical_unit_geometric_tolerance shall either lie 
on the boundary of the shape of the product; be a centre_of_symmetry with a 
description of either 'axis', 'plane', or 'point'; be a tangent with a description of 
'plane'; be a part_template_definition; or be a composite_shape_aspect the 'composing' 
shape_aspects of which either are all of type part_template_definition, are all of 
type tangent with a description of 'plane', or are all of type centre_of_symmetry and 
have the same description -- either 'axis', 'plane', or 'point'.
</Informal.propositions.rul>

<InFormal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'circularity', the 
toleranced_shape_aspect shall either be a part_template_definition, lie on the 
boundary of the shape of the product, or be a composite_shape_aspect the 'composing' 
shape_aspects of which are all of type part_template_definition.
</InFormal.propositions.rul>

<informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'circularity', the tolerance_zone_boundary 
shall be either a tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'cylindricity', the 
toleranced_shape_aspect shall either be a part_template_definition, lie on the 
boundary of the shape of the product, or be a composite_shape_aspect the 'composing' 
shape_aspects of which are all of type part_template_definition.
</Informal.propositions.rul>

<informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'cylindricity', the tolerance_zone_boundary 
shall be either a tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'flatness', the 
toleranced_shape_aspect shall either be a part_template_definition, lie on the 
boundary of the shape of the product, or be a composite_shape_aspect the 'composing' 
shape_aspects of which are all of type part_template_definition.
</Informal.propositions.rul>

<informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'flatness', the tolerance_zone_boundary 
shall be either a tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'flatness' and the 
physical_unit_geometric_tolerance is the defining_tolerance of a tolerance_zone that has a 
property_definition with a description of 'tolerance zone per unit size', the property_definition 
shall have exactly one representation that contains two length_measure_with_unit with a name of 
'per unit size'.
</Informal.propositions.rul>

<Informal.propositions.rul>
There shall exist exactly one requirements_property that has a representation that contains a 
descriptive_representation_item that has the name of 'requirements description' and a description 
of 'geometric dimensioning and tolerancing reference', and that requirements_property shall be an 
item of one or more document_reference the assigned_document of which are ee_specification.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'straightness'; the 
toleranced_shape_aspect shall either lie on the boundary of the shape of the product; 
be a centre_of_symmetry with a description of either 'axis' or 'plane', be a 
part_template_definition; or be a composite_shape_aspect the 'composing' shape_aspects 
of which either are all of type part_template_definition, or are all of type 
centre_of_symmetry and have the same description -- either 'axis' or 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'straightness' and the 
toleranced_shape_aspect of the physical_unit_geometric_tolerance is either a 
centre_of_symmetry with a description of 'axis', or a composite_shape_aspect the 
'composing' shape_aspects of which are all of type centre_of_symmetry and have a 
description of 'axis'; the tolerance_zone_boundary shall have a description of 
'circular or cylindrical or spherical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'straightness' and the 
toleranced_shape_aspect of the physical_unit_geometric_tolerance is neither a 
centre_of_symmetry with a description of 'axis', nor a composite_shape_aspect the 
'composing' shape_aspects of which are all of type centre_of_symmetry and have a 
description of 'axis'; the tolerance_zone_boundary shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'straightness' and the 
toleranced_shape_aspect either is a part_template_definition, lies on the boundary of 
the shape of the product, or is a composite_shape_aspect in which all the 'composing' 
shape_aspects are of type part_template_definition; the 
physical_unit_geometric_tolerance shall be the defining_tolerance of a tolerance_zone 
that has exactly one property_definition with a description of 'tolerance zone 
orientation' that relates to a property_definition with a description of 'viewing 
plane based orientation' to specify its 'zone orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the name of the physical_unit_geometric_tolerance is 'straightness' and the 
toleranced_shape_aspect is not a part_template_definition, does not lie on the 
boundary of the shape of the product, or is not a composite_shape_aspect in which all 
the 'composing' shape_aspects are of type part_template_definition; the 
physical_unit_geometric_tolerance shall be the defining_tolerance of a tolerance_zone 
that has exactly zero property_definition with a description of 'tolerance zone 
orientation'.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="physical_unit_network_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An physical_unit_network_definition is a product_definition that implements the ARM concept of
<internal.ref Linkend="Physical_unit_network_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY physical_unit_network_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\physical_unit_network_definition))) = 0;
  WR7: SELF.frame_of_reference.name IN ['physical network design'];
END_ENTITY; -- physical_unit_network_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the physical_unit_network_definition is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit_network_definition shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit_network_definition shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit_network_definition shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit_network_definition shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit_network_definition shall not be any other type of product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The physical_unit_network_definition shall have a frame_of_reference with a name of
'physical network design'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="plated_cutout_edge_segment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A plated_cutout_edge_segment is a cutout_edge_segment and plated_inter_stratum_feature 
that implements the ARM concept of<internal.ref Linkend="Plated_cutout_edge_segment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY plated_cutout_edge_segment
  SUBTYPE OF (cutout_edge_segment,plated_inter_stratum_feature);
WHERE
  WR1: SELF\shape_aspect.description IN ['plated cutout edge segment'];
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1;
  WR3: (NOT (SELF\shape_aspect.description = 'plated cutout edge segment')) OR
       (SIZEOF (QUERY (cc <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed cutout') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (cc.relating_shape_aspect)) AND
       (cc.relating_shape_aspect\shape_aspect.description =
       'plated cutout'))) = 1);
END_ENTITY; -- plated_cutout_edge_segment
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The plated_cutout_edge_segment shall have a description of 'plated cutout edge segment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The plated_cutout_edge_segment shall be related to at most one
join_shape_aspect with a name of 'inter stratum join' as a 'join
implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The plated_cutout_edge_segment shall be related to
exactly one cutout with a description of 'plated
cutout' as the 'composed cutout'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="plated_inter_stratum_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A plated_inter_stratum_feature is an inter_stratum_feature that implements the
ARM concepts of:
<list> 
<list.item><internal.ref Linkend="Inter_stratum_join_implementation"></list.item>
<list.item><internal.ref Linkend="Join_two_physical_connectivity_definition_supporting_inter_stratum_feature"></list.item>
<list.item><internal.ref Linkend="Physical_network_supporting_inter_stratum_feature"></list.item>
<list.item><internal.ref Linkend="Plated_cutout"></list.item>
<list.item><internal.ref Linkend="Plated_inter_stratum_feature"></list.item>
<list.item><internal.ref Linkend="Plated_interconnect_module_edge"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY plated_inter_stratum_feature
  SUPERTYPE OF (ONEOF(plated_passage,plated_cutout_edge_segment, 
 plated_interconnect_module_edge_segment))
  SUBTYPE OF (inter_stratum_feature);
WHERE
  WR1: (SELF\shape_aspect.description IN ['bonded conductive base blind via', 
        'buried via',
       'component termination passage', 'interfacial connection', 
       'non conductive base blind via', 
       'join two physical connectivity definition supporting inter stratum feature', 
       'plated conductive base blind via', 
       'plated cutout', 'plated interconnect module edge']) OR 
       (SIZEOF 
       (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
	'PLATED_CUTOUT_EDGE_SEGMENT',
	'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
	'PLATED_INTERCONNECT_MODULE_EDGE_SEGMENT'] * TYPEOF (SELF)) = 1 );
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1;
END_ENTITY; -- plated_inter_stratum_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The plated_inter_stratum_feature shall have a description of either
'bonded conductive base blind via', 'buried via', 'component termination
passage', 'interfacial connection', 'non conductive base blind via', 'plated
conductive base blind via', 'plated cutout', 
'join two physical connectivity definition supporting inter stratum feature',
or 'plated interconnect module edge' or shall be a segment subtype.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The plated_inter_stratum_feature shall be related to at most one
join_shape_aspect with a name of 'inter stratum join' as a 'join
implementation'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
The plated_inter_stratum_feature shall have an associated passage_technology
that shall have descriptive_representation_item with a description of 'true'.
</INFORMAL.PROPOSITIONS.RUL>
<INFORMAL.PROPOSITIONS.RUL>
If the plated_inter_stratum_feature description is 'join two physical connectivity definition supporting inter stratum feature', it shall be associated with two physical connectivity definitions as the joined definitions through property_definition_relationship instances.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="plated_interconnect_module_edge_segment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A plated_interconnect_module_edge_segment is a plated_inter_stratum_feature and interconnect_module_edge_segment that implements the
ARM concept of<internal.ref Linkend="Plated_interconnect_module_edge_segment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY plated_interconnect_module_edge_segment
  SUBTYPE OF (interconnect_module_edge_segment,
              plated_inter_stratum_feature);
WHERE
  WR1: SELF\shape_aspect.description IN ['plated interconnect module edge segment'];
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1;
  WR3: (NOT (SELF\shape_aspect.description = 
          'plated interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed edge') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_shape_aspect)) AND
       (ce.relating_shape_aspect\shape_aspect.description =
       'plated interconnect module edge'))) = 1);
END_ENTITY; -- plated_interconnect_module_edge_segment
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The plated_interconnect_module_edge_segment shall have a description of 
'plated interconnect module edge segment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The plated_interconnect_module_edge_segment shall be related to at most one
join_shape_aspect with a name of 'inter stratum join' as a 'join
implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The plated_interconnect_module_edge_segment shall be related to
exactly one interconnect_module_edge with a description of 'plated
interconnect module edge' as the 'composed edge'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
The associated passage_technology shall have descriptive_representation_item with a description of 'true'.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="plated_passage">
<ENTITY.DESCRIPTION>
A plated_passage is a plated_inter_stratum_feature that implements the ARM
concepts of:
<list> 
<list.item><internal.ref Linkend="Blind_via"></list.item>
<list.item><internal.ref Linkend="Bonded_conductive_base_blind_via"></list.item>
<list.item><internal.ref Linkend="Buried_via"></list.item>
<list.item><internal.ref Linkend="Component_termination_passage"></list.item>
<list.item><internal.ref Linkend="Interfacial_connection"></list.item>
<list.item><internal.ref Linkend="Non_conductive_base_blind_via"></list.item>
<list.item><internal.ref Linkend="Plated_conductive_base_blind_via"></list.item>
<list.item><internal.ref Linkend="Plated_passage"></list.item>
<list.item><internal.ref Linkend="Via"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY plated_passage 
  SUBTYPE OF (plated_inter_stratum_feature);
WHERE
  WR1: SELF\shape_aspect.description IN ['bonded conductive base blind via', 
       'buried via', 'component termination passage', 
       'interfacial connection', 'non conductive base blind via',
       'plated conductive base blind via'];
  WR2: (NOT (SELF\shape_aspect.description = 'bonded conductive base blind via')) OR
       (SIZEOF (QUERY (fj <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'features join') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP' IN
       TYPEOF (fj.relating_shape_aspect)) AND
       (fj.relating_shape_aspect\shape_aspect.name =
       'stratum feature conductive join'))) = 1);
  WR3: (NOT (SELF\shape_aspect.description = 'component termination passage')) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'component termination passage template'))) = 1);
(*
  WR4: (NOT (SELF\shape_aspect.description = 'component termination passage')) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'component termination passage interface terminal')))) >= 0);
  WR5: (NOT (SELF\shape_aspect.description = 'component termination passage')) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF)|
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'component termination passage join terminal')))) >= 1);
*)
  WR6: (NOT (SELF\shape_aspect.description IN
       ['bonded conductive base blind via',
       'buried via',
       'interfacial connection',
       'non conductive base blind via',
       'plated conductive base blind via'])) OR
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description =
       'via template'))) = 1);
END_ENTITY; -- plated_passage
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The plated_passage shall have a description of 'bonded conductive base
blind via', 'buried via', 'component termination passage', 'interfacial
connection', 'non conductive base blind via', or 'plated conductive base blind
via'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the plated_passage has a description of 'bonded conductive base
blind via', the plated_passage shall be related to exactly one
stratum_concept_relationship with a name of 'stratum feature conductive
join' as a 'features join'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the plated_passage has a description of 
'component termination passage', the plated_passage shall be related to 
exactly one part_template_definition with a description of
'component termination passage template' as an 'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the plated_passage has a description of 'component termination
passage', the plated_passage shall relate to zero or more 
component_shape_aspect that has a description of 'component termination
passage interface terminal' to specify the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the plated_passage has a description of 'component termination
passage', the plated_passage shall relate to at least one
component_terminal that has a description of 'component termination passage
join terminal' to specify the 'associated component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the plated_passage has a description of 'bonded conductive base
blind via', 'buried via', 'interfacial connection', 'non conductive base
blind via', or 'plated conductive base blind via', the plated_passage shall
be related to exactly one part_template_definition with a description of 'via
template' as an 'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<!--
 changed supertype mm 7/2/97
 commented out WRs mm 7/2/97 

-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="position_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A position_tolerance is a physical_unit_geometric_tolerance that implements the
ARM concepts of:
<list> 
<list.item><internal.ref Linkend="Boundary_based_position_tolerance"></list.item>
<list.item><internal.ref Linkend="Composite_feature_locating_position_tolerance"></list.item>
<list.item><internal.ref Linkend="Composite_feature_relating_position_tolerance"></list.item>
<list.item><internal.ref Linkend="Position_tolerance"></list.item>
<list.item><internal.ref Linkend="Position_tolerance_with_referenced_datum_system"></list.item>
<list.item><internal.ref Linkend="Position_tolerance_without_referenced_datum_system"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY position_tolerance
  SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
  WR1: (NOT(SELF\geometric_tolerance.name = 'boundary based position')) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
  WR2: (NOT(SELF\geometric_tolerance.name = 'boundary based position')) OR
       (SIZEOF(QUERY(gtr <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' 
        IN TYPEOF(gtr.related_geometric_tolerance)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SURFACE_PROFILE_TOLERANCE' 
        IN TYPEOF(gtr.related_geometric_tolerance)) AND
       (gtr.related_geometric_tolerance\geometric_tolerance.name IN ['surface profile',
        'surface profile locating', 'surface profile refinement']) AND
       (gtr\geometric_tolerance_relationship.name = 'profile control')
       )) <= 1);
  WR3: (NOT(SELF\geometric_tolerance.name = 
                              'feature relating position')) OR
       (SIZEOF(QUERY(gtr <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       (gtr\geometric_tolerance_relationship.name = 'position refining control') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITION_TOLERANCE' 
        IN TYPEOF(gtr.relating_geometric_tolerance))  AND
       (gtr.relating_geometric_tolerance\geometric_tolerance.name IN
       ['feature locating position', 'feature relating position'])
       )) = 1);
  WR4: (NOT(SELF\geometric_tolerance.name = 
                          'feature locating position')) OR
       (SIZEOF(QUERY(gtr <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITION_TOLERANCE' 
        IN TYPEOF(gtr.related_geometric_tolerance))  AND    
       (gtr.related_geometric_tolerance\geometric_tolerance.name = 'feature relating position')
       AND (gtr\geometric_tolerance_relationship.name = 'position refining control')
       )) = 1);
  WR5: (NOT(SELF\geometric_tolerance.name = 
                         'feature relating position')) OR
       (SIZEOF(QUERY(gtr <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITION_TOLERANCE' 
        IN TYPEOF(gtr.related_geometric_tolerance))  AND
       (gtr.related_geometric_tolerance\geometric_tolerance.name = 'feature relating position')
       AND (gtr\geometric_tolerance_relationship.name = 'position refining control')
       )) <= 1);
END_ENTITY; -- position_tolerance
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">

<formal.propositions.rul>
If the position_tolerance has a name of 'boundary based position', it shall be a 
modified_geometric_tolerance.
</formal.propositions.rul>

<formal.propositions.rul>
If the position_tolerance has a name of 'boundary based position', it shall relate to at most one 
geometric_tolerance_with_specified_datum_system that is a surface_profile_tolerance with a name of 
either 'surface profile', 'surface profile locating', or 'surface profile refinement' to specify 
the 'profile control'.
</formal.propositions.rul>

<formal.propositions.rul>
If the position_tolerance has a name of 'feature relating position', it shall be related as the 
'position refining control' to exactly one position_tolerance with a name of either 'feature 
locating position' or 'feature relating position'.
</formal.propositions.rul>

<formal.propositions.rul>
If the position_tolerance has a name of 'feature locating position', it shall relate to exactly one 
position_tolerance with a name of 'feature relating position' to specify the 'position refining 
control'.
</formal.propositions.rul>

<formal.propositions.rul>
If the position_tolerance has a name of 'feature relating position', it shall relate to at most one 
position_tolerance with a name of 'feature relating position' to specify the 'position refining 
control'.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
If position_tolerance is a geometric_tolerance_with_specified_datum_system, it shall have a name of 
either 'position', 'feature relating position', 'feature locating position', or 'boundary based 
position'; otherwise, it shall have the name of either 'position' or 'feature relating position'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the name of the position_tolerance is 'boundary based position', the toleranced_shape_aspect shall 
either be a part_template_definition, lie on the boundary of the shape of the product, or be a 
composite_shape_aspect the 'composing' shape_aspects of which are all of type part_template_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'boundary based position' and it relates to exactly one 
geometric_tolerance_with_specified_datum_system that is a surface_profile_tolerance with a name of 
either 'surface profile', 'surface profile locating', or 'surface profile refinement' to specify 
the 'profile control', the position_tolerance and surface_profile_tolerance shall specify the same 
shape_aspect as their toleranced_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'boundary based position' and it relates to exactly one 
geometric_tolerance_with_specified_datum_system that is a surface_profile_tolerance with a name of 
either 'surface profile', 'surface profile locating', or 'surface profile refinement' to specify 
the 'profile control', the physical_unit_datum of the datum_system referenced by the 
surface_profile_tolerance shall also be physical_unit_datum of the datum_system referenced by the 
position_tolerance and shall be assigned the same precedence.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'boundary based position' and it relates to exactly one 
geometric_tolerance_with_specified_datum_system that is a surface_profile_tolerance with a name of 
either 'surface profile', 'surface profile locating', or 'surface profile refinement' to specify 
the 'profile control', the position_tolerance shall relate to a property_definition that has a description of 
'profile related positional boundary property' to specify the 'defined boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'boundary based position' and it does not relate to a 
geometric_tolerance_with_specified_datum_system that is a surface_profile_tolerance with a name of 
either 'surface profile', 'surface profile locating', or 'surface profile refinement' to specify 
the 'profile control', the position_tolerance shall relate to a property_definition that has a description of 
'positional boundary member property' to specify the 'defined boundary'.
</Informal.propositions.rul>

<informal.propositions.rul>
If the name of the position_tolerance is 'feature locating position', the toleranced_shape_aspect 
shall be a composite_group_shape_aspect.
</informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position', it shall be related as the 
'position refining control' to exactly one position_tolerance with a name of either 'feature 
locating position' or 'feature relating position'. Both of these position_tolerances 
shall specify the same shape_aspect as the toleranced_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance is not a geometric_tolerance_with_specified_datum_system and has a name 
of 'feature relating position', it shall not relate to a position_tolerance with a name of 
'feature relating position' to specify the 'position refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is related as the 
'position refining control' to exactly one position_tolerance with a name of 'feature relating 
position', it shall either not reference a datum_system or it shall have less physical_unit_datum 
in its referenced datum_system than the datum_system referenced by the position_tolerance to which 
it is related as the 'position refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is related as the 
'position refining control' to exactly one position_tolerance with a name of 'feature locating 
position', it shall either not reference a datum_system or it shall have less than or an equal 
number of physical_unit_datum in its referenced datum_system than the datum_system referenced by 
the position_tolerance to which it is related as the 'position refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is a 
geometric_tolerance_with_specified_datum_system, the physical_unit_datum of its referenced 
datum_system shall be physical_unit_datum of the datum_system of the position_tolerance to which it 
is related as the 'position refining control' and shall be assigned the same precedence.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is a 
geometric_tolerance_with_specified_datum_system that relates to a property_definition of a datum_system that 
has the description of 'datum system property without material conditions' to specify its 
'referenced datum system definition', the position_tolerance to which it is related as the 
'position refining control' shall also be a geometric_tolerance_with_specified_datum_system that 
relates to a property_definition of a datum_system that has the description of 'datum system property without 
material conditions' to specify its 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is a 
geometric_tolerance_with_specified_datum_system that relates to a property_definition of a datum_system that 
has the description of 'datum system property with material conditions' to specify its 'referenced 
datum system definition', the position_tolerance to which it is related as the 'position refining 
control' shall also be a geometric_tolerance_with_specified_datum_system that relates to a property_definition 
of a datum_system that has the description of 'datum system property with material conditions' to 
specify its 'referenced datum system definition', and each of these property_definition shall relate to 
property_definition with a description of 'datum feature material condition property' to specify their 
'applied material condition property'. These property_definition shall be applied to 
physical_unit_datum_features in the context of the datum_systems referenced by each of the 
position_tolerance. The name of the property_definition applied to each of the physical_unit_datum_feature in 
the context of the datum_system referenced by this position_tolerance shall be the same as the name 
of the property_definition applied to the same physical_unit_datum_feature in the context of the datum_system 
referenced by the position_tolerance to which this position_tolerance is related as the 'position 
refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position', it shall specify a 
measure_with_unit as its magnitude that is less than the measure_with_unit specified as the 
magnitude of the position_tolerance to which it is related as the 'position refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is specified as the 
defining_tolerance by a tolerance_zone that has a description of 'conical', the position_tolerance 
that is related to this position_tolerance as the 'position refining control' shall also be 
specified as the defining_tolerance by a tolerance_zone that has a description of 'conical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is specified as the 
defining_tolerance by a tolerance_zone that is the zone of a projected_zone_definition, the 
position_tolerance that is related to this position_tolerance as the 'position refining control' 
shall also be specified as the defining_tolerance by a tolerance_zone that is the zone of a 
projected_zone_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and it is specified as the 
defining_tolerance by a tolerance_zone that has a property_definition with the description of 
'tolerance zone orientation' , the position_tolerance that is related to this position_tolerance as 
the 'position refining control' shall also be specified as the defining_tolerance by a 
tolerance_zone that has a property_definition with the description of 'tolerance zone orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and its tolerance_zone_boundary 
has a description of 'conical', the position_tolerance that is related to this position_tolerance 
as the 'position refining control' shall also have a tolerance_zone_boundary that has a description 
of 'conical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and its tolerance_zone_boundary 
has a description of 'circular or cylindrical or spherical', the position_tolerance that is related 
to this position_tolerance as the 'position refining control' shall also have a 
tolerance_zone_boundary that has a description of 'circular or cylindrical or spherical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and its tolerance_zone_boundary 
is a tolerance_zone_explicit_opposing_boundary_set, the position_tolerance that is related to this 
position_tolerance as the 'position refining control' shall also have a tolerance_zone_boundary 
that is a tolerance_zone_explicit_opposing_boundary_set.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the position_tolerance has a name of 'feature relating position' and its tolerance_zone_boundary 
is a tolerance_zone_implicit_opposing_boundary_set, the position_tolerance that is related to this 
position_tolerance as the 'position refining control' shall also have a tolerance_zone_boundary 
that is a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

<Informal.propositions.rul>
The toleranced_shape_aspect of the position_tolerance shall either lie on the 
boundary of the shape of the product; be a centre_of_symmetry with a description of 
either 'axis', 'plane', or 'point'; be a part_template_definition; or be a 
composite_shape_aspect the 'composing' shape_aspects of which either are all of type 
part_template_definition, or are all of type centre_of_symmetry and have the same 
description -- either 'axis', 'plane', or 'point'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the toleranced_shape_aspect of the position_tolerance is either a 
centre_of_symmetry with a description of 'plane', or a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'plane'; the tolerance_zone_boundary shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the toleranced_shape_aspect of the position_tolerance is either a 
centre_of_symmetry with a description of 'point', or a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'point'; the position_tolerance shall be specified as the defining_tolerance by 
exactly one tolerance_zone that is specified as the zone of a 
tolerance_zone_definition.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="positional_boundary">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A positional_boundary is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Dimension_related_positional_boundary"></list.item>
<list.item><internal.ref Linkend="Positional_boundary"></list.item>
<list.item><internal.ref Linkend="Profile_related_positional_boundary"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY positional_boundary
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN 
    ['dimension related positional boundary',
  'profile related positional boundary'];

  WR2: SELF\shape_aspect.product_definitional = False;

  WR3: (NOT(SELF\shape_aspect.description = 
           'dimension related positional boundary'))
       OR (SIZEOF(QUERY(sar <* USEDIN(SELF, 
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'POSITIONAL_BOUNDARY_MEMBER' IN 
               TYPEOF(sar.related_shape_aspect))
            AND (sar\shape_aspect_relationship.name = 'boundary member'))) >= 1);

  WR4: (NOT(SELF\shape_aspect.description = 
         'dimension related positional boundary'))
       OR (SIZEOF(QUERY(sar <*USEDIN(SELF, 
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | (sar.related_shape_aspect.product_definitional = True) AND
            (sar\shape_aspect_relationship.name = 'constrained feature'))) +
           SIZEOF(QUERY(sar <*USEDIN(SELF, 
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.related_shape_aspect))
            AND (sar\shape_aspect_relationship.name = 'constrained feature'))
           ) = 1);     

  WR5: (NOT(SELF\shape_aspect.description = 
              'dimension related positional boundary'))
       OR (SIZEOF(QUERY(pd <* USEDIN(SELF,
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'PROPERTY_DEFINITION.DEFINITION')        
          | (pd\property_definition.description = 
                'dimension related positional boundary property'))) = 1);

  WR6: (NOT(SELF\shape_aspect.description = 
                  'profile related positional boundary'))
       OR (SIZEOF(QUERY(pd <* USEDIN(SELF,
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'PROPERTY_DEFINITION.DEFINITION')        
          | (pd\property_definition.description = 
                  'profile related positional boundary property'))) = 1);
   
  WR7: (NOT(SELF\shape_aspect.description = 
                     'profile related positional boundary'))
       OR (SIZEOF(QUERY(sar <* USEDIN(SELF, 
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect))
            AND (sar\shape_aspect_relationship.name = 
               'positional boundary and profile boundary member'))) = 1);
END_ENTITY; -- positional_boundary
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The positional_boundary shall have a description of either 'dimension related positional boundary' 
or 'profile related positional boundary'.
</Formal.propositions.rul>

<formal.propositions.rul>
The positional_boundary shall not lie on the boundary of the shape of the product.
</formal.propositions.rul>

<formal.propositions.rul>
If the description of the positional_boundary is 'dimension related positional boundary', the 
positional_boundary shall relate to at least one positional_boundary_member to specify the 
'boundary member'.
</formal.propositions.rul>

<formal.propositions.rul>
If the description of the positional_boundary is 'dimension related positional boundary', the  
positional_boundary shall either relate to exactly one shape_aspect that lies on the boundary of 
the shape of the product to specify the 'constrained feature' or relate to exactly one 
part_template_definition to specify the 'constrained feature'.
</formal.propositions.rul>

<formal.propositions.rul>
If the description of the positional_boundary is 'dimension related positional_boundary', the 
positional_boundary shall have exactly one property_definition that has the description of 'dimension related 
positional boundary property'.
</formal.propositions.rul>

<formal.propositions.rul>
If the description of the positional_boundary is 'profile related positional boundary', the 
positional_boundary shall have exactly one property_definition that has the description of 'profile related 
positional boundary property'.
</formal.propositions.rul>

<formal.propositions.rul>
If the description of the positional_boundary is 'profile related positional boundary' it shall 
relate to exactly one shape_aspect to specify the 'positional boundary and profile boundary member'.
</formal.propositions.rul>
</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="positional_boundary_member">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A positional_boundary_member is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Positional_boundary_member">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY positional_boundary_member
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = False;

  WR2: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION')        
       | (pd\property_definition.description = 'positional boundary member property'))
       ) = 1;
  WR3: SIZEOF(QUERY(sar <* USEDIN(SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') 
       | (sar\shape_aspect_relationship.name = 'boundary member') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'POSITIONAL_BOUNDARY' IN TYPEOF(sar.relating_shape_aspect))
         AND (sar.relating_shape_aspect\shape_aspect.description =
         'dimension related positional boundary'))) = 1;
END_ENTITY; -- positional_boundary_member
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">
<formal.propositions.rul>
The positional_boundary_member shall not lie on the boundary of the shape of the product.
</formal.propositions.rul>

<formal.propositions.rul>
The positional_boundary_member shall have exactly one property_definition that has the description of 
'positional boundary member property'.
</formal.propositions.rul>

<formal.propositions.rul>
The positional_boundary_member shall be related to exactly one positional_boundary as the 'boundary 
member', and that positional_boundary shall have a description of 'dimension related positional 
boundary'.
</formal.propositions.rul>

</formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="power_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A power_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Power_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY power_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\power_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = watt;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- power_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The power_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The power_measure_with_unit shall reference an si_unit with a name of watt.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="pre_defined_parallel_datum_axis_symbol_3d_2d_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An pre_defined_parallel_datum_axis_symbol_3d_2d_relationship is a volume_shape_intersection 
that implements the ARM concept of <internal.ref Linkend="Pre_defined_parallel_datum_axis_symbol_3d_2d_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY pre_defined_parallel_datum_axis_symbol_3d_2d_relationship
  SUBTYPE OF (volume_shape_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\volume_shape_intersection || 
       SELF\pre_defined_parallel_datum_axis_symbol_3d_2d_relationship))) = 0;
END_ENTITY; -- pre_defined_parallel_datum_axis_symbol_3d_2d_relationship 
(* 
</EXPRESS.CODE> 

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The pre_defined_parallel_datum_axis_symbol_3d_2d_relationship shall not be a complex subtype of other than its direct supertypes.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship is a volume_shape_intersection 
that implements the ARM concept of <internal.ref Linkend="Pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship
  SUBTYPE OF (volume_shape_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\volume_shape_intersection || 
       SELF\pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship))) = 0;
END_ENTITY; -- pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship 
(* 
</EXPRESS.CODE> 

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship shall not be a complex subtype of other than its direct supertypes.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship is a volume_shape_intersection 
that implements the ARM concept of <internal.ref Linkend="Pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship
  SUBTYPE OF (volume_shape_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\volume_shape_intersection || 
       SELF\pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship))) = 0;
END_ENTITY; -- pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship 
(* 
</EXPRESS.CODE> 

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship shall not be a complex subtype of other than its direct supertypes.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="pressure_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A pressure_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Pressure_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY pressure_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\pressure_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = pascal;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- pressure_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The pressure_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The pressure_measure_with_unit shall reference an si_unit with a name of pascal.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="primary_orientation_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A primary_orientation_feature is a physical_unit_datum_feature that implements the ARM
concept of <internal.ref Linkend="Primary_orientation_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY primary_orientation_feature
 SUBTYPE OF (physical_unit_datum_feature);
WHERE
  WR1: SELF\shape_aspect.product_definitional = TRUE;
  WR2: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect)) 
       )) <= 1;
  WR3: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect)) 
       )) <= 1;
END_ENTITY; -- primary_orientation_feature
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
A primary_orientation_feature shall be on the surface of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A primary_orientation_feature shall be associated with no more than one package_body_bottom_surface.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A primary_orientation_feature shall be associated with no more than one package_body_top_surface.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="primary_reference_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A primary_reference_terminal is a package_terminal that implements the ARM
concept of <Internal.ref Linkend="Primary_reference_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY primary_reference_terminal
  SUBTYPE OF (package_terminal);
WHERE
 WR1: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       = 0;
 WR2: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       <= 1;
END_ENTITY; -- primary_reference_terminal
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The primary_reference_terminal shall be referenced by no shape_aspect_relationship with a description of 'precedent feature' as the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The primary_reference_terminal shall be referenced by no more than one shape_aspect_relationship with a description of 'precedent feature' as the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_component is a component_definition that implements the ARM concepts
of:
<list> 
<list.item><internal.ref Linkend="Layout_macro_component"></list.item>
<list.item><internal.ref Linkend="Printed_component"></list.item>
<list.item><internal.ref Linkend="Printed_connector_component"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_component
  SUPERTYPE OF(layout_macro_component)
  SUBTYPE OF (component_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'layout occurrence';
  WR2: SELF\product_definition.description = 'printed component';
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'part template occurrence') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |  
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description IN ['printed part template', 
       'printed part cross section template', 
       'printed connector template']))) = 1)) = 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'printed component join terminal'))) >= 1))) = 0;
  WR5: (NOT (SELF\product_definition.description = 'printed connector component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAMINATE_COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 
       'printed connector component interface terminal'))) >= 1))) = 0);
  WR6: (NOT (SELF\product_definition.description = 'printed connector component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'part template occurrence') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |  
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description = 
       'printed connector template'))) = 1)) = 1))) = 0);
  WR7: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |  
        SIZEOF(QUERY(sa <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') | 
        SIZEOF(QUERY(sar <* USEDIN(sa, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
        AND (sar\shape_aspect_relationship.name = 'stratum feature implementation')
        AND (sar.relating_shape_aspect.description = 'stratum feature template component'))
        )) >= 1
        )) >= 1 
        )) >= 1;
END_ENTITY; -- printed_component
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The printed_component shall have a frame_of_reference with a name of
'layout occurrence'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_component shall have a description that is 'printed component'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_component shall have exactly one shape_aspect with a name of
'part template occurrence' that is related to a part_template_definition with
a description of 'printed part template', 'printed part cross section
template', or 'printed connector template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_component shall have at least one shape_aspect that is a
component_terminal with a description of 'printed component join terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the printed_component has a description of 'printed connector component', 
it shall have at least one shape_aspect that is a
laminate_component_interface_terminal with a description of 'printed connector component
interface terminal'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the printed_component has a description of 'printed connector component',
it shall have exactly one shape_aspect with a name of 'part
template occurrence' that is related to a part_template_definition with a
description of 'printed connector template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_component shall be associated to at least one component_shape_aspect with a description of 'stratum feature template component' as a 'stratum feature implementation'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_component_link">
<ENTITY.DESCRIPTION>
A printed_component_link is a product_definition and a product_definition_relationship that implements the ARM concept of<internal.ref Linkend="Printed_component_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_component_link
  SUBTYPE OF (product_definition,product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\printed_component_link)) = 0;
  WR5: EXISTS(SELF\product_definition.name);
  WR6: SELF\product_definition.name = '';
  WR7: SELF\product_definition_relationship.name = '';
  WR8: SIZEOF(USEDIN(SELF, 
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
END_ENTITY; -- printed_component_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related element shall not be the relating element. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_component_link shall relate to only a component_definition in the related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_component_link shall relate to only a component_definition in the relating_product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of printed_component_link shall be only printed_component_link, product_definition, and product_definition_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition supertype shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the product_definition_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Each printed_component_link shall be referenced exactly once by a product_definition_relationship related_product_definition.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_connector_template_terminal_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_connector_template_terminal_relationship is a shape_aspect and a
shape_aspect_relationship that implements the ARM concept
of <internal.ref Linkend="Printed_connector_template_terminal_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_connector_template_terminal_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.relating_shape_aspect,
       SELF\shape_aspect_relationship.related_shape_aspect;
WHERE
  WR1: SIZEOF ( QUERY( sar <* USEDIN ( SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (( sar\shape_aspect_relationship.name = 'connector') AND
          (sar.relating_shape_aspect\shape_aspect.description = 
              'printed connector template'))
        )) = 1;
  WR2: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF 
       (SELF\shape_aspect_relationship.relating_shape_aspect)) AND
       (SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description 
        = 'interface terminal'));
  WR3: (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect)) AND
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description 
        = 'join terminal'));
  WR4: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY; -- printed_connector_template_terminal_relationship
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">

<FORMAL.PROPOSITIONS.RUL>
The combination of related and relating shape_aspects shall be unique within a population
of printed_connector_template_terminal_relationship.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The printed_connector_template_terminal_relationship shall be related to
a  part_template_definition with a description of 'printed connector template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_connector_template_terminal_relationship shall have a relating_shape_aspect
that is a printed_part_template_terminal with a description of 'interface terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_connector_template_terminal_relationship shall have a related_shape_aspect that is a printed_part_template_terminal with a description of 'join terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The related and relating shape aspects shall not be the same shape_aspect.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_part_cross_section_template_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_part_cross_section_template_terminal is a shape_aspect that implements the ARM concept
of<internal.ref Linkend="Printed_part_cross_section_template_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_part_cross_section_template_terminal
  SUBTYPE OF (printed_part_template_terminal);
WHERE
  WR1: 
       SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'cross section definition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (am.relating_shape_aspect)) AND
       (am.relating_shape_aspect\shape_aspect.description = 
       'printed part cross section template'))) = 1;

  WR2: SIZEOF (QUERY (ga <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN
       TYPEOF (ga.assigned_group)) AND 
       (ga.assigned_group.name IN  
                       ['area edge segment', 'curve edge segment']))
        )) = 1;
  WR3: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR4: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR5: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR6: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR7: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to right of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to left of terminal')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
       
  WR8: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to top of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to left of terminal')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
  WR9: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to bottom of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to left of terminal')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
 WR10: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to right of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to top of terminal')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
 WR11: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to right of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to bottom of terminal')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
 WR12: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to top of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to bottom of terminal')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
END_ENTITY; -- printed_part_cross_section_template_terminal
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The printed_part_cross_section_template_terminal shall be related to
exactly one part_template_definition with a description of 'printed part cross section
template' as the 'cross section definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_cross_section_template_terminal shall be in exactly one printed_part_template_terminal_connection_zone_category that has a name of 'area edge segment' or 'curve edge segment'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_cross_section_template_terminal shall be in no more than one shape_aspect_relationship with a name of 'material to left of terminal' that specifies a printed_part_template_material_link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_cross_section_template_terminal shall be in no more than one shape_aspect_relationship with a name of 'material to right of terminal' that specifies a printed_part_template_material_link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_cross_section_template_terminal shall be in no more than one shape_aspect_relationship with a name of 'material to top of terminal' that specifies a printed_part_template_material_link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_cross_section_template_terminal shall be in no more than one shape_aspect_relationship with a name of 'material to bottom of terminal' that specifies a printed_part_template_material_link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the material link to the left of the terminal exists and the material link to the right of the terminal exists, then they shall not be the same material link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the material link to the left of the terminal exists and the material link to the top of the terminal exists, then they shall not be the same material link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the material link to the left of the terminal exists and the material link to the bottom of the terminal exists, then they shall not be the same material link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the material link to the top of the terminal exists and the material link to the right of the terminal exists, then they shall not be the same material link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the material link to the bottom of the terminal exists and the material link to the right of the terminal exists, then they shall not be the same material link.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the material link to the top of the terminal exists and the material link to the bottom of the terminal exists, then they shall not be the same material link.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_part_template_connected_terminals_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_part_template_connected_terminals_definition is a shape_aspect that
implements the ARM concept
of <internal.ref Linkend="Printed_part_template_connected_terminals_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_part_template_connected_terminals_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (mct.related_shape_aspect)) AND
       (mct.related_shape_aspect\shape_aspect.description IN 
       ['interface terminal', 'join terminal']))) >= 2;
END_ENTITY; -- printed_part_template_connected_terminals_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_connected_terminals_definition shall relate to
at least two printed_part_template_terminals with a description of 'interface
terminal' or 'join terminal' to specify a 'member connected terminal'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_part_template_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_part_template_link is a stratum_technology_link and shape_aspect_relationship that implements the ARM
concept of<internal.ref Linkend="Printed_part_template_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_part_template_link
  SUBTYPE OF (stratum_technology_link,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship ||
       SELF\printed_part_template_link || SELF\property_definition ||
       SELF\stratum_technology_link || SELF\shape_aspect_relationship)) = 0;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN 
    TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
  WR4: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN 
    TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
  WR5: SELF\shape_aspect_relationship.name = '';
  WR6: SELF\shape_aspect_relationship.description = '';
  WR7: SELF\shape_aspect_relationship.related_shape_aspect.description =
       'printed part template';
  WR8: SELF\shape_aspect_relationship.relating_shape_aspect.description =
       'printed part template';
END_ENTITY; -- printed_part_template_link
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link shall not relate to the same shape_aspect through the related and relating attributes.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link shall not be any other subtype of shape_aspect_relationship or property_definition or property_definition_relationship. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link shall reference only a part_template_definition through the related attribute inherited from shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link shall reference only a part_template_definition through the relating attribute inherited from shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link name inherited from shape_aspect_relationship shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link description inherited from shape_aspect_relationship shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link shall reference only a shape_aspect with a description of 'printed part template' through the related attribute inherited from shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_link shall reference only a shape_aspect with a description of 'printed part template' through the relating attribute inherited from shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>
</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_part_template_material">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_part_template_material is a product_definition that implements the ARM concept of:
<internal.ref Linkend="Printed_part_template_material">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_part_template_material
 SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition))) = 1)) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) |
       ((sr_pdr.used_representation\representation.name = 
                'physical characteristics representation')
       AND
       (SIZEOF (sr_pdr.used_representation.items) = 2 )
       AND 
      ( SIZEOF(QUERY (it <* sr_pdr.used_representation.items |
       it\representation_item.name IN ['maximum width', 
                                        'minimum width'])) = 2 ))
       )) = 1)))
       = 0;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\printed_part_template_material)) = 0;
 WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'top')))) <= 1))) = 0;
 WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'bottom')))) <= 1))) = 0;
 WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'left')))) <= 1))) = 0;
 WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'right')))) <= 1))) = 0;
END_ENTITY; -- printed_part_template_material

(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material shall have exactly one property_definition that is related to a property_definition of a stratum_technology as the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material shall have exactly one representation that has a name of 'physical characteristics representation' and that has two representation items that have names of 'maximum width', 'minimum width'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material shall not participate in a complex instance.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material shall not have more than one top boundary.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material shall not have more than one bottom boundary.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material shall not have more than one left boundary.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material shall not have more than one right boundary.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_part_template_material_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_part_template_material_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Printed_part_template_material_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_part_template_material_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.related_shape_aspect, 
       SELF\shape_aspect_relationship.relating_shape_aspect;
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\printed_part_template_material_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SELF\shape_aspect_relationship.related_shape_aspect.of_shape :<>: 
       SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
  WR8: SELF\shape_aspect_relationship.relating_shape_aspect.description IN
       ['bottom', 'right'];
  WR9: SELF\shape_aspect_relationship.related_shape_aspect.description IN
       ['top', 'left'];
END_ENTITY; -- printed_part_template_material_link 
(* 
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">

<FORMAL.PROPOSITIONS.RUL>
The relating_shape_aspect, related_shape_aspect combination shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The related boundary shall not be the relating boundary. 
</FORMAL.PROPOSITIONS.RUL>


<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material_link shall relate to only a template_material_cross_section_boundary in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_material_link shall relate to only a template_material_cross_section_boundary in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of printed_part_template_material_link shall be only printed_part_template_material_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The shape specified by the related_shape_aspect shall not be the shape specified by the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The description attribute of the relating boundary shall be 'bottom' or 'right'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The description attribute of the related boundary shall be 'top' or 'left'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_part_template_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_part_template_terminal is a shape_aspect that implements the ARM
concepts of:
<list> 
<list.item><internal.ref Linkend="Printed_part_cross_section_template_terminal"></list.item>
<list.item><internal.ref Linkend="Printed_part_template_interface_terminal"></list.item>
<list.item><internal.ref Linkend="Printed_part_template_join_terminal"></list.item>
<list.item><internal.ref Linkend="Printed_part_template_terminal"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_part_template_terminal
  SUPERTYPE OF (printed_part_cross_section_template_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN ['interface terminal', 'join terminal'];
  WR2: SIZEOF (QUERY (ga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN
       TYPEOF (ga.assigned_group))) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 
       'connection zone')) >= 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR5: SIZEOF (QUERY (ad <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated definition') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (ad.relating_shape_aspect)) AND
       ((ad.relating_shape_aspect\shape_aspect.description = 'printed part template')
       OR
       (ad.relating_shape_aspect\shape_aspect.description = 'printed connector template'))
       )) = 1;
  WR6: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION' IN
       TYPEOF (mct.relating_shape_aspect))) <= 1;
END_ENTITY; -- printed_part_template_terminal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_terminal shall have a description of
'interface terminal' or 'join terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_terminal shall be in exactly one 
printed_part_template_terminal_connection_zone_category.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_terminal shall relate to  at least one 
'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_terminal shall have at least one property that
is represented by a shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_terminal shall be related to exactly one
part_template_definition with a description of 'printed part template' or 'printed
connector template' as the 'associated definition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_terminal shall be related to at most one
printed_part_template_connected_terminals_definition  as the 'member connected
terminal'.
</FORMAL.PROPOSITIONS.RUL>

<note>
Inverse cardinality rules required by Application Objects are implemented in rule 
printed_connector_template_terminal_relationship_unique_constraint.
</note>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="printed_part_template_terminal_connection_zone_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A printed_part_template_terminal_connection_zone_category is a group that
specifies either an area_edge_segment, a curve_edge_segment, a surface_area,
or a surface_point for
a <internal.ref Linkend="Printed_part_template_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY printed_part_template_terminal_connection_zone_category
   SUBTYPE OF (group);
WHERE
   WR1: SELF\group.name IN ['area edge segment','curve edge segment',
        'surface area','surface point'];
END_ENTITY; -- printed_part_template_terminal_connection_zone_category
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The printed_part_template_terminal_connection_zone_category shall have a
name equal to 'area edge segment', 'curve edge segment', 'surface area',
or 'surface point'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="probe_access_area">
<ENTITY.DESCRIPTION>
A probe_access_area is a component_shape_aspect that implements the ARM concepts of 
<internal.ref Linkend="Internal_probe_access_area">
and <internal.ref Linkend="Probe_access_area">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY probe_access_area
  SUBTYPE OF (component_shape_aspect);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
  WR2: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.name = 'interconnect module');
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description =
       'connection zone')) = 1;
  WR4: SIZEOF (QUERY (pli <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'probed layout item') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (pli.related_shape_aspect))) = 1;
  WR5: (NOT (SELF\shape_aspect.description = 
        'internal probe access area')) OR
       (SIZEOF (QUERY (i <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (i.relating_shape_aspect)))) = 1);
END_ENTITY; -- probe_access_area
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name of the product_definition associated with this probe_access_area shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The probe_access_area shall be an aspect of the shape of a component_definition that is a definition with a name of 'interconnect module'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The probe_access_area shall relate to exactly one shape_aspect with a
description of 'connection zone'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The probe_access_area shall relate to exactly one stratum_feature to
specify a 'probed layout item'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the probe_access_area has a description of 'internal probe access
area', the probe_access_area shall be related to exactly one
stratum_feature as the 'implementation'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="product_related_characterized_product_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A product_related_characterized_product_category is a 
characterized_product_category and a product_related_product_category 
that implements the ARM concept of
<internal.ref Linkend="Ee_product_related_characterized_product_category">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY product_related_characterized_product_category
  SUBTYPE OF (characterized_product_category, 
              product_related_product_category);
END_ENTITY; -- product_related_characterized_product_category
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="product_specific_parameter_value_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A product_specific_parameter_value_assignment is a 
characterized_product_category and a product_related_product_category 
that implements the ARM concept of
<internal.ref Linkend="Ee_product_specific_parameter_value_assignment">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY product_specific_parameter_value_assignment
  SUBTYPE OF (product_related_characterized_product_category); 
WHERE
  WR1: SIZEOF(SELF\product_related_product_category.products) = 1;
  WR2: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.description = 
                                'product category parameter') AND
       (SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MODEL_PARAMETER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'] *
       TYPEOF (pdr.used_representation)) = 1))) = 1))) = 1;
  WR3: SIZEOF(QUERY(pcr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY') |
       ((pcr\product_category_relationship.description = 
                                  'product value assignment') AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY') IN 
       TYPEOF (pcr.category))
       ))) = 1;
END_ENTITY; -- product_specific_parameter_value_assignment
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
There shall be exactly one product in the role of products.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
It shall be the definition of exactly one property_definition with a description of 
'product category parameter' that is the definition of a 
property_definition_representation with a used_representation that is
a representation that has in its items exactly one model_parameter, 
exactly one measure_representation_item, or exactly one descriptive_representation_item. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
It shall be the sub_category of exactly one category that is a product_related_product_category,
and the product_category_relationship establishing the sub_category relationship shall have
a description of 'product value assignment'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="promissory_usage_in_product_model">
<ENTITY.DESCRIPTION>
A promissory_usage_in_product_model is a group that participates in an assignment to indicate that a product_definition is to be associated with a product_model.  The promissory_usage_in_product_model string attributes may be populated with 'undefined' to indicate there is no requirement associated with these attributes.
<note>
The group entity is provided for structural consistency with other parts of this standard.
</note>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY promissory_usage_in_product_model
 SUBTYPE OF (group);
WHERE
   WR1: SIZEOF( QUERY(aga <* USEDIN(SELF,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'APPLIED_PROMISSORY_USAGE_IN_PRODUCT_MODEL_ASSIGNMENT' IN TYPEOF(aga))
           ) >= 1;
END_ENTITY; -- promissory_usage_in_product_model
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">

<Formal.propositions.rul>
The promissory_usage_in_product_model shall be referenced by an applied_promissory_usage_in_product_model_assignment.
</Formal.propositions.rul>

</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rectangular_array_placement_group_component_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An rectangular_array_placement_group_component_definition is a array_placement_group_component_definition that implements the ARM concept of
<internal.ref Linkend="Rectangular_array_placement_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rectangular_array_placement_group_component_definition
  SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY; -- rectangular_array_placement_group_component_definition
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rectangular_array_placement_group_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An rectangular_array_placement_group_component_shape_aspect is a array_placement_group_component_shape_aspect that implements the ARM concepts of
<internal.ref Linkend="Rectangular_array_placement_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rectangular_array_placement_group_component_shape_aspect
  SUBTYPE OF (array_placement_group_component_shape_aspect);
END_ENTITY; -- rectangular_array_placement_group_component_shape_aspect
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rectangular_composite_array_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A rectangular_composite_array_shape_aspect is a composite_shape_aspect that implements the ARM concept of<internal.ref Linkend="Part_rectangular_array_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rectangular_composite_array_shape_aspect
  SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY; -- rectangular_composite_array_shape_aspect
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="reference_packaged_part_assembly_implementation">
<ENTITY.DESCRIPTION>
A reference_packaged_part_assembly_implementation is a physical_unit.  A reference_packaged_part_assembly_implementation implements the ARM concept of a<internal.ref Linkend="Reference_packaged_part_assembly_implementation">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY reference_packaged_part_assembly_implementation
 SUBTYPE OF (physical_unit);
WHERE
  WR1: (SIZEOF (QUERY (prpc <* 
       USEDIN (SELF.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1) AND
       (SELF\product_definition.name = 'assembly module');
  WR2: (NOT (SELF.frame_of_reference.name = 'physical design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_ASSEMBLY_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name =
       'assembly module') AND
       (SIZEOF (QUERY (prpc <*
       USEDIN (du.relating_product_definition.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1)
       )) = 1);
END_ENTITY; -- reference_packaged_part_assembly_implementation
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The reference_packaged_part_assembly_implementation name shall be 'assembly model' and it shall be a definition of a product that is classified as an 'template model'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the reference_packaged_part_assembly_implementation is a physical design, it shall relate to exactly
one reference_packaged_part_assembly_implementation, externally_defined_reference_packaged_part_assembly_implementation, or 
library_defined_reference_packaged_part_assembly_implementation that is a physical design usage with a 
frame_of_reference name of 'assembly module' as the design usage.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="reference_packaged_part_interconnect_implementation">
<ENTITY.DESCRIPTION>
A reference_packaged_part_interconnect_implementation is a physical_unit that implements the ARM concept
of<internal.ref Linkend="Reference_packaged_part_interconnect_implementation">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY reference_packaged_part_interconnect_implementation
 SUBTYPE OF (physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: (SIZEOF (QUERY (prpc <*
       USEDIN (SELF.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1) AND
       (SELF\product_definition.name = 'interconnect module');
  WR3: SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PHYSICAL_UNIT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PHYSICAL_UNIT'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name =
       'interconnect module') AND
       (SIZEOF (QUERY (prpc <*
       USEDIN (du.relating_product_definition.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1) 
       )) <= 1;
  WR4: SELF.frame_of_reference.name = 'physical design';
END_ENTITY; -- reference_packaged_part_interconnect_implementation
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name attribute shall exist.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The reference_packaged_part_interconnect_implementation name shall be 'interconnect module' and it shall be a definition of a product that is classified as an 'template model'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The reference_packaged_part_interconnect_implementation shall relate to no more than one physical_unit, externally_defined_physical_unit, or library_defined_physical_unit that is a physical design usage with a name of 'interconnect module' as the design usage, and that is a 'template model'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The reference_packaged_part_interconnect_implementation shall be in the 'physical design' context.
</FORMAL.PROPOSITIONS.RUL>
<!--
 changed supertype mm 7/2/97
 removed WR2 mm 7/2/97 

-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="requirement_allocation_group">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A requirement_allocation_group is a group and a property_definition_relationship that implements the ARM concept of<internal.ref Linkend="Requirement_allocation"> and<internal.ref Linkend="Test_requirement_allocation">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY requirement_allocation_group
  SUBTYPE OF (group, property_definition_relationship);
WHERE
  WR1: (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_FORMATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONFIGURATION_ITEM'] * TYPEOF (aga.items)) = 1))) = 1);

  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN TYPEOF 
   (SELF\property_definition_relationship.relating_property_definition);

  WR4: NOT(SELF\property_definition_relationship.related_property_definition.description = 'test requirement') OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION'] * TYPEOF (aga.items)) = 1))) >= 1);
END_ENTITY; -- requirement_allocation_group
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The requirement_allocation_group shall be assigned to exactly one item that is a configuration_item, product, or product_definition_formation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirement_allocation_group shall reference a requirements_property as the relating_property_definition. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the property_definition_relationship references a property_definition with a description of 'test requirement' the requirement_allocation_group shall be assigned to more than one property_definition_representation.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="requirement_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

An requirement_definition is a product_definition that implements the ARM concepts of:
<internal.ref Linkend="Requirement_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY requirement_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\requirement_definition))) = 0;
  WR7: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'requirements model')) >= 1;
END_ENTITY; -- requirement_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the requirement_definition is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirement_definition shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirement_definition shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirement_definition shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirement_definition shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirement_definition shall not be any other type of product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirement_definition shall have a product_category with a name of 'requirements model'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="requirements_property">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A requirements_property is a property_definition that implements the ARM
concepts of:
<list> 
<list.item><internal.ref Linkend="Constraint_occurrence"></list.item>
<list.item><internal.ref Linkend="Design_characteristic_occurrence"></list.item>
<list.item><internal.ref Linkend="Design_requirement_occurrence"></list.item>
<list.item><internal.ref Linkend="Ee_requirement_occurrence"></list.item>
<list.item><internal.ref Linkend="Electrical_requirement_occurrence"></list.item>
<list.item><internal.ref Linkend="Electromagnetic_requirement_occurrence"></list.item>
<list.item><internal.ref Linkend="Interface_requirement_occurrence"></list.item>
<list.item><internal.ref Linkend="Material_electrical_conductivity_requirement_occurrence"></list.item>
<list.item><internal.ref Linkend="Part_based_constraint_occurrence"></list.item>
<list.item><internal.ref Linkend="Purpose_occurrence"></list.item>
<list.item><internal.ref Linkend="Thermal_requirement_occurrence"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY requirements_property
  SUBTYPE OF (property_definition);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'requirements property composition')) <= 1;
  WR2: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'requirements description'))) = 1)) <= 1;
  WR3: SIZEOF (QUERY (dr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EE_SPECIFICATION' IN 
       TYPEOF (dr.assigned_document))) >= 1;
  WR4: NOT(EXISTS(SELF\property_definition.description)) OR
       (NOT (SELF\property_definition.description IN ['constraint', 
        'part based constraint']) OR
       (SIZEOF (QUERY (dc <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'design constraint') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_DEFINITION' IN 
       TYPEOF (dc.relating_property_definition.definition))) = 1));
  WR5: NOT(EXISTS(SELF\property_definition.description)) OR
       (NOT (SELF\property_definition.description = 
          'part based constraint') OR
       (SIZEOF (QUERY (cp <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'constraining part') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP' IN
       TYPEOF (cp.relating_property_definition.definition)) AND
       (cp.relating_property_definition.definition\product_definition_relationship.name = 
       'constraining part') AND
   (cp.relating_property_definition.definition.related_product_definition.
       frame_of_reference.name = 'design requirement'))) = 1));
  WR6: NOT(EXISTS(SELF\property_definition.description)) OR
       (NOT (SELF\property_definition.description = 
         'interface requirement') OR
       (SIZEOF (QUERY (itnha <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'interface to next higher assembly') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION' IN
       TYPEOF (itnha.relating_property_definition.definition)) AND
    (itnha.relating_property_definition.definition.frame_of_reference.name
       = 'design requirement') AND
       (SIZEOF (QUERY (hai <* QUERY (pdr <* 
       USEDIN (itnha.relating_property_definition.definition,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'higher assembly interface') |
       SIZEOF (QUERY (pdr <* USEDIN (hai,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SPECIFIED_HIGHER_USAGE_OCCURRENCE'  
       IN TYPEOF (pdr))) = 1)) = 1))) = 1));
  WR7: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'requirements name'))) = 1)) = 1;
END_ENTITY; -- requirements_property
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.RUL>
The requirements_property shall be related to at most one property_definition 
as the 'requirements property composition'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirements_property shall have at most one representation that
contains a descriptive_representation_item with a name of 'requirements
description'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirements_property shall be referenced by at least one ee_specification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the requirements_property has a description of 'constraint' or 'part
based constraint', it shall be related to exactly one property_definition of a
rule_definition as the 'design constraint'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the requirements_property has a description of 'part based
constraint', it shall be related to exactly one property_definition of a
product_definition_relationship with name of 'constraining part' and a
related_product_definition that has a frame_of_reference name of 'design
requirement' as the 'constraining part'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the requirements_property has a description of 'interface
requirement', it shall be related to exactly one property_definition of a
product_definition that has a frame_of_reference name of 'design requirement',
and that relates exactly one product_definition to a product_definition that
is the component in exactly one specified_higher_usage_occurrence to specify
the 'higher assembly interface', as the 'interface to next higher assembly'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The requirements_property shall have exactly one representation that
contains a descriptive_representation_item with a name of 'requirements
name'.
</FORMAL.PROPOSITIONS.RUL>
</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="requirements_property_group">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A requirements_property_group is a requirements_property and a group that
implements the ARM concept
of <internal.ref Linkend="Requirement_group_occurrence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY requirements_property_group
  SUBTYPE OF (requirements_property, group);
WHERE
  WR1: SIZEOF (QUERY (rpc <* QUERY (pdr <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'requirements property composition') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (rpc.related_property_definition))) >= 1;
END_ENTITY; -- requirements_property_group
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The requirements_property_group shall relate to at least one   
requirements_property as a 'requirements property composition'.
</FORMAL.PROPOSITIONS.RUL>


</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="resistance_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A resistance_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Resistance_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY resistance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\resistance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = ohm;
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- resistance_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The resistance_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The resistance_measure_with_unit shall reference an si_unit with a name of ohm.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be an si_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="routed_physical_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A routed_physical_component is a component_definition that implements the ARM concept
of<internal.ref Linkend="Routed_physical_component">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY routed_physical_component
  SUBTYPE OF (component_definition);
WHERE
  WR1: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1;
  WR2: SELF\product_definition.description :<>: 'laminate component';
END_ENTITY; -- routed_physical_component
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The routed_physical_component shall be related, as the 'instantiated part',
to exactly one physical_unit that is in the 'physical design usage'
product_definition_context.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The routed_physical_component shall not have a description of 'laminate component'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="routed_printed_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A routed_printed_component is a printed_component that implements the
ARM concept of <internal.ref Linkend="Routed_printed_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY routed_printed_component
 SUBTYPE OF (printed_component);
WHERE
  WR1: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF(QUERY(sa <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (SIZEOF(QUERY(sar <* USEDIN(sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))
        AND (sar.relating_shape_aspect\shape_aspect.description = 
            'printed part cross section template')
        AND (sar\shape_aspect_relationship.name = 'instantiated template')
          )) = 1)
         )) = 1)
        )) = 1;
  WR2: SIZEOF(QUERY(csa <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'COMPONENT_SHAPE_ASPECT' IN TYPEOF(csa))      
         AND (SIZEOF(QUERY(sar <* USEDIN(csa, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (SIZEOF(QUERY(pdr <* USEDIN(sar,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND
        (pdr\product_definition_relationship.name = 'inter stratum extent')      
        )) = 1)
        AND (sar\shape_aspect_relationship.name = 'component extent')
        )) = 1)
        )) = 1;
END_ENTITY; -- routed_printed_component
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The routed_printed_component shall be associated to exactly one
part_template_definition with a description of
'printed part cross section template' as an 'instantiated template'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The routed_printed_component shall be associated to exactly one
component_shape_aspect that shall be related to exactly one shape_aspect
that is a shape_aspect for a product_definition_relationship with a name of
'inter stratum extent' to specify a 'component extent'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The routed_printed_component shall have exactly one property that has
exactly one representation.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_action">
<ENTITY.DESCRIPTION>
A rule_action is an action that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Rule_action"></list.item>
<list.item><internal.ref Linkend="Rule_adoption"></list.item>
<list.item><internal.ref Linkend="Rule_change_request"></list.item>
<list.item><internal.ref Linkend="Rule_creation"></list.item>
<list.item><internal.ref Linkend="Rule_expiration"></list.item>
<list.item><internal.ref Linkend="Rule_justification"></list.item>
<list.item><internal.ref Linkend="Rule_modification"></list.item>
<list.item><internal.ref Linkend="Rule_rejection"></list.item>
<list.item><internal.ref Linkend="Rule_request"></list.item>
<list.item><internal.ref Linkend="Rule_submission"></list.item>
<list.item><internal.ref Linkend="Rule_supersedence"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_action
  SUBTYPE OF (action);
WHERE
  WR1: SIZEOF (QUERY (aaa <* QUERY (aa <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'ACTION_ASSIGNMENT.ASSIGNED_ACTION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_ACTION_ASSIGNMENT' IN
       TYPEOF (aa)) |
       SIZEOF (QUERY (it <* aaa.items |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_FORMATION' IN 
       TYPEOF (it))
AND (it\product_definition_formation.description = 'rule version'))
)) = 1)) = 1;
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'participant date and time')) +
       SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'participant date')) = 1;
  WR3: (NOT (SELF\action.name = 'rule justification')) OR
       (SIZEOF (QUERY (ja <* QUERY (ar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ACTION_RELATIONSHIP.RELATED_ACTION') |
       ar\action_relationship.name = 'justified action') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_ACTION' IN
       TYPEOF (ja.relating_action))) = 1);
  WR4: (NOT (SELF\action.name = 'rule modification')) OR
       (SIZEOF (QUERY (mr <* QUERY (ar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ACTION_RELATIONSHIP.RELATED_ACTION') |
       ar\action_relationship.name = 'modification rationale') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_ACTION' IN
       TYPEOF (mr.relating_action)) AND
       (mr.relating_action\action.name = 'rule change request'))) = 1);
  WR5: (NOT (SELF\action.name = 'rule replacement from')) OR
       (SIZEOF (QUERY (rrfa <* QUERY (aa <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'ACTION_ASSIGNMENT.ASSIGNED_ACTION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_REPLACEMENT_FROM_ASSIGNMENT' IN
       TYPEOF (aa)) |
       SIZEOF (QUERY (it <* rrfa.items |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_FORMATION' IN 
       TYPEOF (it))
AND (it\product_definition_formation.description = 'rule version'))
)) = 1)) = 1);
  WR6: (NOT (SELF\action.name = 'rule replacement to')) OR
       (SIZEOF (QUERY (rrta <* QUERY (aa <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'ACTION_ASSIGNMENT.ASSIGNED_ACTION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_REPLACEMENT_TO_ASSIGNMENT' IN
       TYPEOF (aa)) |
       SIZEOF (QUERY (it <* rrta.items |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_FORMATION' IN 
       TYPEOF (it))
AND (it\product_definition_formation.description = 'rule version'))
)) = 1)) = 1);
END_ENTITY; -- rule_action
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_action shall be assigned to exactly one product_definition_formation with a description of 'rule version'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_action shall have exactly one date or one date and time 
with a role of 'participant date' or 'participant date and time'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the rule_action has a name of 'rule justification', it shall be
related to rule_action as the 'justified action'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the rule_action has a name of 'rule modification', it shall be
related to rule_action with a name of 'rule change request' as the
'modification rationale'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the rule_action has a name of 'rule replacement from', it shall be
assigned to exactly one product_definition_formation with a description of 'rule version' 
by a rule_replacement_from_assignment.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the rule_action has a name of 'rule replacement to', it shall be
assigned to exactly one product_definition_formation with a description of 'rule version'
by a rule_replacement_to_assignment.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_complex_clause">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A rule_complex_clause is a characterized_object and is an externally_defined_item that implements the ARM concept of <internal.ref Linkend="Ee_rule_complex_clause">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_complex_clause 
 SUBTYPE OF (representation);
UNIQUE
 UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_SIMPLE_CLAUSE' IN TYPEOF (rr.rep_1))) >= 1;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_complex_clause)) = 0;
END_ENTITY; -- rule_complex_clause
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">

<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within a population of rule_complex_clause.
</FORMAL.PROPOSITIONS.RUL>
</formal.propositions.group>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_complex_clause shall have at least one
representation_relationship that references a
rule_simple_clause.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_complex_clause shall not be a complex instance. 
</FORMAL.PROPOSITIONS.RUL>
</formal.propositions.group>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_conclusion_definition">
<ENTITY.DESCRIPTION>
A rule_conclusion_definition is a representation that implements the ARM concept of<internal.ref Linkend="Ee_rule_conclusion_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_conclusion_definition 
 SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'RULE_DEFINITION' IN TYPEOF
       (pdr.definition.definition))) = 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'RULE_SIMPLE_CLAUSE' IN TYPEOF 
       (rr\representation_relationship.rep_1))) >= 1;

  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_conclusion_definition)) = 0;
END_ENTITY; -- rule_conclusion_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_conclusion_definition shall have one
property_definition_representation that references a
rule definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_conclusion_definition shall have at least one
representation_relationship that references a
rule_simple_clause.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_conclusion_definition shall not be a complex instance. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_definition">
<ENTITY.DESCRIPTION>
A rule_definition is a product_definition that implements the ARM concept of<internal.ref Linkend="Ee_rule_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_definition 
 SUBTYPE OF (product_definition);
WHERE
  WR1: SELF\product_definition.formation.description = 'rule version';
END_ENTITY; -- rule_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_definition shall reference a product_definition_formation with a description of 'rule version'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_function_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A rule_function_definition is a representation that implements the ARM
concept of <internal.ref Linkend="Ee_rule_function">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_function_definition 
 SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MODEL_PARAMETER' IN
       TYPEOF (it))) >= 1;
  WR2: SIZEOF(QUERY(adf <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adf\document_reference.assigned_document.kind\document_type.product_data_type
       = 'reference document') AND
       (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EE_SPECIFICATION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DOCUMENT'] * 
        TYPEOF(adf\document_reference.assigned_document))>=1))) = 1;
  WR3: SIZEOF(QUERY(adf <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adf\document_reference.assigned_document.kind\document_type.product_data_type =
       'source code') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EE_SPECIFICATION' IN 
        TYPEOF(adf\document_reference.assigned_document)))) = 1;
END_ENTITY; -- rule_function_definition
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_function_definition shall contain at least one model_parameter.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_function_definition shall contain exactly one document or ee_specification with a document_type of 'reference document'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_function_definition shall contain exactly one ee_specification with a document_type of 'source code'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The combination of identifier and the item which has a document type of
'reference document' shall be unique for rule_function_definition.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_premise_definition">
<ENTITY.DESCRIPTION>
A rule_premise_definition is a representation that implements the ARM concept of <internal.ref Linkend="Ee_rule_premise_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_premise_definition 
 SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'RULE_DEFINITION' IN TYPEOF
       (pdr.definition.definition))) = 1;

  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'RULE_COMPLEX_CLAUSE' IN TYPEOF 
       (rr\representation_relationship.rep_1))) >= 1;

  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_premise_definition)) = 0;
END_ENTITY; -- rule_premise_definition
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_premise_definition shall have one
property_definition_representation that references a
rule definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_premise_definition shall have at least one
representation_relationship that references a
rule_complex_clause.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_premise_definition shall not be a complex instance. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_replacement_from_assignment">
<ENTITY.DESCRIPTION>
The rule_replacement_from_assignment is an action_assignment that specifies
a rule version which is being superseded in a <internal.ref Linkend="Rule_supersedence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_replacement_from_assignment
 SUBTYPE OF (action_assignment);
     items : SET [1:?] OF replacement_from_item;
END_ENTITY; -- rule_replacement_from_assignment
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_replacement_to_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A rule_replacement_to_assignment is an action_assignment that specifies a
rule version which is superseding another rule version in
a <internal.ref Linkend="Rule_supersedence">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_replacement_to_assignment
 SUBTYPE OF (action_assignment);
     items : SET [1:?] OF replacement_to_item;
END_ENTITY; -- rule_replacement_to_assignment
(*
</EXPRESS.CODE>

<INFORMAL.PROPOSITIONS RULE.TYPES="IP">

<INFORMAL.PROPOSITIONS.RUL>
The assigned_action shall be in the role of a related_action for an
action_relationship where the relating_action is an action that has been
assigned by a rule_replacement_from_assignment.
</INFORMAL.PROPOSITIONS.RUL>

</INFORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_set">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A rule_set is a group that implements the ARM concepts of
<internal.ref Linkend="Rule_set"> and <internal.ref Linkend="Rule_set_group">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_set 
 SUBTYPE OF (group);
UNIQUE
  UR1: SELF\group.name;
WHERE
  WR1: (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT' IN 
       TYPEOF (ga)) |
       SIZEOF (QUERY (rd <* QUERY (it <* aga.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_DEFINITION' IN
       TYPEOF (it)) |
       SIZEOF (QUERY (pd <* USEDIN (rd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'rule priority')) >= 1)) >= 1)) >= 1)) >= 1) OR
       (SIZEOF (QUERY (rsge <* QUERY (gr <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GROUP_RELATIONSHIP.RELATING_GROUP') |
       gr\group_relationship.name = 'rule set group element') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_SET' IN
       TYPEOF (rsge.related_group))) >= 2);
END_ENTITY; -- rule_set
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_set shall be assigned to at least one rule_definition that has
at least one property that has at least one representation with a name of
'rule priority', or it shall relate to at least one rule_sets to specify a 'rule set
group element'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="rule_simple_clause">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A rule_simple_clause is a representation that implements the ARM concept of <internal.ref Linkend="Ee_rule_simple_clause">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY rule_simple_clause 
 SUBTYPE OF (representation);
UNIQUE
 UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN
       TYPEOF (rr.rep_2))) >= 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_FUNCTION_DEFINITION' IN TYPEOF (rr.rep_1))) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_simple_clause)) = 0;
END_ENTITY; -- rule_simple_clause
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">

<FORMAL.PROPOSITIONS.RUL>
The name shall be unique within a population of rule_simple_clause. 
</FORMAL.PROPOSITIONS.RUL>
</formal.propositions.group>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The rule_simple_clause shall have at least one
representation_relationship that references a
parameter_assignment_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_simple_clause shall have exactly one
representation_relationship that references a rule_function_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The rule_simple_clause shall not be a complex instance. 
</FORMAL.PROPOSITIONS.RUL>
</formal.propositions.group>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="scalar_terminal_definition_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A scalar_terminal_definition_link is a shape_aspect and a shape_aspect_relationship that implements the ARM concept of<internal.ref Linkend="Scalar_terminal_definition_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY scalar_terminal_definition_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
UNIQUE
  UR1: related_shape_aspect, relating_shape_aspect;
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\scalar_terminal_definition_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'scalar terminal';
  WR8: SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'scalar terminal';
END_ENTITY; -- scalar_terminal_definition_link 
(* 
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The related_shape_aspect in combination with the relating shape_aspect shall be unique. 
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The related point shall not be the relating point. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The scalar_terminal_definition_link shall relate to only a functional_unit_terminal_definition in the related_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The scalar_terminal_definition_link shall relate to only a functional_unit_terminal_definition in the relating_shape_aspect.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The types of scalar_terminal_definition_link shall be only scalar_terminal_definition_link, shape_aspect, and shape_aspect_relationship.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The name attribute of the shape_aspect_relationship supertype shall be an empty string.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The scalar_terminal_definition_link shall relate to only a functional_unit_terminal_definition in the relating_shape_aspect that has a description of 'scalar terminal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The scalar_terminal_definition_link shall relate to only a functional_unit_terminal_definition in the related_shape_aspect that has a description of 'scalar terminal'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="scattering_parameter_measure_with_unit">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A scattering_parameter_measure_with_unit is a measure_with_unit that implements the ARM
concept of <internal.ref Linkend="Scattering_parameter_measure_with_unit">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY scattering_parameter_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\scattering_parameter_measure_with_unit))) = 0;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- scattering_parameter_measure_with_unit
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The scattering_parameter_measure_with_unit shall not be any other type of measure_with_unit.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The unit_component shall be a ratio_unit.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="seating_plane">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

The seating_plane is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Seating_plane">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY seating_plane
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
         SELF\seating_plane)) = 0;
END_ENTITY; -- seating_plane
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The seating_plane shall not be any other subtype of shape_aspect.
</Formal.propositions.rul>

</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="secondary_orientation_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A secondary_orientation_feature is a physical_unit_datum_feature that implements the ARM
concept of<internal.ref Linkend="Secondary_orientation_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY secondary_orientation_feature
 SUBTYPE OF (physical_unit_datum_feature);
WHERE
 WR1:SIZEOF ((TYPEOF (SELF)) * 
      ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRIMARY_ORIENTATION_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SEATING_PLANE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VIEWING_PLANE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT']) = 0;
 WR2: SELF.product_definitional = TRUE;
 WR3: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
 WR4: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
END_ENTITY; -- secondary_orientation_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The secondary_orientation_feature shall not be a primary_orientation_feature,
a seating_plane, a viewing_plane, a component_shape_aspect, or
a physical_unit_datum.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A secondary_orientation_feature shall be on the surface of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A primary_orientation_feature shall be associated with no more than one package_body_bottom_surface.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A primary_orientation_feature shall be associated with no more than one package_body_top_surface.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="sequential_laminate_passage_based_fabrication_joint">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A sequential_laminate_passage_based_fabrication_joint is a shape_aspect that 
implements the ARM concept of <internal.ref Linkend="Interconnect_module_product_assembly_view_fabrication_joint">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY sequential_laminate_passage_based_fabrication_joint
  SUBTYPE OF (shape_aspect);
END_ENTITY; -- sequential_laminate_passage_based_fabrication_joint
(*
</EXPRESS.CODE>
  
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="shape_formed_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A shape_formed_terminal is an altered_package_terminal that implements the ARM
concept of <Internal.ref Linkend="Shape_formed_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY shape_formed_terminal
   SUBTYPE OF (altered_package_terminal);
WHERE
 WR1: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EE_SPECIFICATION' IN
       TYPEOF (ada.assigned_document)) AND
       (ada.assigned_document.kind\document_type.product_data_type =
       'lead form specification') AND
       (SIZEOF (QUERY (dr <* USEDIN (ada.assigned_document,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT') |
       dr.relating_document.kind\document_type.product_data_type =
       'material specification')) = 1))) = 1);
END_ENTITY; -- shape_formed_terminal
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The shape_formed_terminal shall have exactly one document_reference where the assigned_document is an
ee_specification with a product_data_type of 'lead form specification' and is
related to a document with a product_data_type of 'material specification'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="shape_modification">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A shape_modification is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Design_intent_modification"></list.item>
<list.item><internal.ref Linkend="Electrical_isolation_removal_structure"></list.item>
<list.item><internal.ref Linkend="Filled_area_material_removal_structure"></list.item>
<list.item><internal.ref Linkend="Material_addition_feature"></list.item>
<list.item><internal.ref Linkend="Material_removal_feature"></list.item>
<list.item><internal.ref Linkend="Material_shape_modification"></list.item>
<list.item><internal.ref Linkend="Thermal_isolation_removal_structure"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY shape_modification
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (dim <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design intent') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (dim.relating_shape_aspect))) = 1;
  WR2: (SIZEOF (QUERY (pd<* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pd)) AND
       (pd\property_definition.description = 'modification causal'))) = 1) OR
       (SIZEOF (QUERY (mcf <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'modification causal feature') |
       (SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE'] *
       TYPEOF (mcf.relating_shape_aspect)) = 1) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM' IN
       TYPEOF (mcf.relating_shape_aspect.of_shape.definition)))) = 1);
  WR3: (NOT (SELF\shape_aspect.description IN ['electrical isolation removal',
         'thermal isolation removal'])) OR (SIZEOF(
          QUERY ( pd <* USEDIN(SELF,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PROPERTY_DEFINITION.DEFINITION') | 
         (pd\property_definition.name = 'spacing requirement')  AND
         (SIZEOF(QUERY (pdr <* USEDIN(pd,
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|
         (pdr\property_definition_relationship.name = 'spacing requirement') AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'REQUIREMENTS_PROPERTY' IN
         TYPEOF(pdr.relating_property_definition)))) = 1) ))
                = 1);
  WR4: (NOT (SELF\shape_aspect.description IN ['electrical isolation removal',
       'thermal isolation removal'])) OR
       (SIZEOF (QUERY (di <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design intent') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (di.relating_shape_aspect)) AND
       (di.relating_shape_aspect\shape_aspect.description IN ['conductive filled area',
       'connected filled area']))) = 1);
  WR5: (NOT (SELF\shape_aspect.description = 'thermal isolation removal')) OR
       (SIZEOF (QUERY (pd<* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pd)) AND
       (pd\property_definition.description = 'angular orientation requirement'))) = 1);
  WR6: (NOT (SELF\shape_aspect.description = 'thermal isolation removal')) OR
       (SIZEOF (QUERY (pd<* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pd)) AND
       (pd\property_definition.description = 'effective current capacity requirement'))) = 1);
  WR7: (NOT (SELF\shape_aspect.description = 'material addition feature')) OR
       (SIZEOF (QUERY (dim <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material addition shape') |
       (dim.relating_shape_aspect\shape_aspect.description =
       'material addition feature template'))) = 1);
END_ENTITY; -- shape_modification
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The shape_modification shall be related to exactly one stratum_feature as the 'design intent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The shape_modification shall have exactly one requirements_property with
a description of 'modification causal', or it shall be related to exactly one
component_shape_aspect, component_terminal, component_interface_terminal,
stratum_feature, or  shape_aspect of a stratum as the 'modification causal
feature'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the shape_modification has a description of 'electrical isolation
removal' or 'thermal isolation removal', it shall have exactly one
requirements_property with a description of 'spacing requirement'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the shape_modification has a description of 'electrical isolation
removal' or 'thermal isolation removal', it shall be related to exactly one
stratum_feature with a description of 'conductive filled area' or 'connected
filled area' as the 'design intent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the shape_modification has a description of 'thermal isolation
removal', it shall have exactly one requirements_property with the description
of 'angular orientation requirement'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the shape_modification has a description of 'thermal isolation
removal', it shall have exactly one requirements_property with the description
of 'effective current capacity requirement'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the shape_modification has a description of 'material addition feature', it
shall be related to exactly one 'material addition feature template'.
</FORMAL.PROPOSITIONS.RUL>


</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="shape_representation_relationship_with_transformation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A shape_representation_relationship_with_transformation is a shape_representation_relationship
and a representation_relationship_with_transformation
that implements the ARM concept of <internal.ref Linkend="Component_part_2d_non_planar_geometric_representation_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY shape_representation_relationship_with_transformation
  SUBTYPE OF (shape_representation_relationship, representation_relationship_with_transformation);
END_ENTITY; -- shape_representation_relationship_with_transformation 
(* 
</EXPRESS.CODE> 

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="shell_based_2d_wireframe_shape_representation">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A shell_based_2d_wireframe_shape_representation is a shape_representation that
implements the ARM concept
of <internal.ref Linkend="Shell_based_2d_wireframe">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY shell_based_2d_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF\representation.items |
       NOT (SIZEOF ( 
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_2D'] *
       TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF\representation.items |
       SIZEOF ( 
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM'] * 
       TYPEOF (it)) = 1)) >= 1;
  WR3: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <* 
       sbwm\shell_based_wireframe_model.sbwm_boundary |                  
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
       ws\wire_shell.wire_shell_extent |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_LOOP' IN TYPEOF (wsb)) | 
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_CURVE' IN
       TYPEOF (el.edge_element)))) = 0))) = 0))) = 0))) = 0;
  WR4: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
       ws\wire_shell.wire_shell_extent |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (pline_el <*  QUERY (el <* eloop\path.edge_list |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POLYLINE' IN
       TYPEOF (el.edge_element\edge_curve.edge_geometry)) |
       NOT (SIZEOF (pline_el.edge_element\edge_curve.
       edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT (valid_2d_wireframe_edge_curve
       (el.edge_element\edge_curve.edge_geometry,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')))) =
       0))) = 0))) = 0))) = 0;
  WR6: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
       ws\wire_shell.wire_shell_extent |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_POINT' IN
       TYPEOF (el.edge_element.edge_start)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_POINT' IN
       TYPEOF (el.edge_element.edge_end))) )) = 0))) = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
       ws\wire_shell.wire_shell_extent |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT ((valid_wireframe_vertex_point 
       (el.edge_element.edge_start\vertex_point.vertex_geometry)) AND
       (valid_wireframe_vertex_point
       (el.edge_element.edge_end\vertex_point.vertex_geometry))))) =
       0))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
       TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
       ws\wire_shell.wire_shell_extent |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (con_edges <* QUERY (el <* eloop\path.edge_list |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CONIC' IN
       TYPEOF (el.edge_element\edge_curve.edge_geometry)) | 
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'AXIS2_PLACEMENT_2D' IN
       TYPEOF (con_edges.edge_element\edge_curve.
       edge_geometry\conic.position)))) = 0))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
       TYPEOF(it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <*
       ws\wire_shell.wire_shell_extent |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_LOOP' IN TYPEOF (wsb)) |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_POINT' IN
       TYPEOF (vloop\vertex_loop.loop_vertex)))) = 0))) = 0))) = 0;
  WR10: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
        TYPEOF(it)) |
        NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
        sbwm\shell_based_wireframe_model.sbwm_boundary |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'WIRE_SHELL' IN TYPEOF (sb)) |
        NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <*
        ws\wire_shell.wire_shell_extent |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_LOOP' IN TYPEOF (wsb)) |
        NOT (valid_wireframe_vertex_point (vloop\vertex_loop.
        loop_vertex\vertex_point.vertex_geometry)))) =
        0))) = 0))) = 0;
  WR11: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
        TYPEOF(it)) |
        NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
        sbwm\shell_based_wireframe_model.sbwm_boundary |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_SHELL' IN TYPEOF (sb)) |
        NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_POINT' IN
        TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex)))) 
        = 0))) = 0;
  WR12: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHELL_BASED_WIREFRAME_MODEL' IN
        TYPEOF(it)) |
        NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
        sbwm\shell_based_wireframe_model.sbwm_boundary |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VERTEX_SHELL' IN TYPEOF (sb)) |
        NOT (valid_wireframe_vertex_point (vs\vertex_shell.
        vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry))))
        = 0))) = 0;
  WR13: SIZEOF (QUERY (mi <* QUERY (it <* SELF\representation.items |
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAPPED_ITEM' IN TYPEOF (it)) |
        NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHELL_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION' IN
        TYPEOF(mi\mapped_item.mapping_source.mapped_representation)
        ))) = 0;
  WR14: SELF.context_of_items\geometric_representation_context.
        coordinate_space_dimension = 2;
END_ENTITY; -- shell_based_2d_wireframe_shape_representation
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The items in a shell_based_2d_wireframe_shape_representation shall be a
shell_based_wireframe_model, a mapped_item, or an axis2_placement_2d.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At least one of the items in a shell_based_2d_wireframe_shape_representation 
shall be either a shell_based_wireframe_model or a mapped_item.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Every edge defined for an edge_loop in a shell_based_wireframe_model
shall be an edge_curve.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Every polyline that underlies an edge in a shell_based_wireframe_model
shall contain more than two distinct points.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The edge_geometry that underlies an edge for a shell_based_wireframe_model 
shall be a line, circle, ellipse, parabola, hyperbola, b_spline_curve,
offset_curve_2d, polyline, or curve_replica and the curves that have a basis
defined by other curves shall be defined consistently. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Every vertex defined as the start or end vertex for an edge in a 
shell_based_wireframe_model shall be a vertex_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The vertex_geometry that underlies the vertices that define the
boundaries of the edges in an edge_loop for a shell_based_wireframe_model
shall be a cartesian_point or point_replica, and the point_replica shall
replicate either another point_replica or a cartesian_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The position of a conic that underlies an edge in an edge_loop for a
shell_based_wireframe_model shall only be an axis2_placement_2d.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The vertex that defines the vertex_loop which is used as a bound in a
shell_based_wireframe_model shall be a vertex_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The vertex that defines the vertex_loop which is used as a bound in a
shell_based_wireframe_model shall be underlaid by a cartesian_point or 
point_replica, and the point_replica shall replicate either another 
point_replica or a cartesian_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The vertex that defines the vertex_loop which is used as the 
vertex_shell_extent for a vertex_shell in a shell_based_wireframe_model shall 
be a vertex_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The vertex that defines the vertex_loop which is used as the 
vertex_shell_extent for a vertex_shell in a shell_based_wireframe_model shall be
underlaid by a cartesian_point or point_replica, and the point_replica shall
replicate either another point_replica or a cartesian_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If there is a mapped_item in a shell_based_2d_wireframe_shape_representation, 
the source of the mapped_item shall be a 
shell_based_2d_wireframe_shape_representation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The dimensionality of the shell_based_2d_wireframe_shape_representation
is two.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="signal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A signal is a characterized_object that implements
the ARM concept of <internal.ref Linkend="Signal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY signal
  SUBTYPE OF (characterized_object);
WHERE
  WR1: SIZEOF (QUERY (aca <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SIGNAL_CATEGORY' IN
       TYPEOF (aca.assigned_group))) >= 1;
  WR2: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
       duc\document_usage_constraint.subject_element = 'signal category')) = 1)) = 1);
  WR3: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
END_ENTITY; -- signal
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The signal shall be classified in at least one signal_category.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The signal shall be referenced by exactly one document that has a usage constraint that identifies the 'signal category'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The signal shall be referenced by exactly one document.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="signal_category">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A signal_category is a group and an externally_defined_item that specifies the
<internal.ref Linkend="External_definition"> for
a <internal.ref Linkend="Signal_property">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY signal_category
  SUBTYPE OF (group, externally_defined_item);
WHERE
  WR1: SELF\group.description IN ['signal characteristic category', 
       'signal property category'];
END_ENTITY; -- signal_category
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The signal_category shall have a group description of either 'signal
characteristic category' or 'signal property category'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="solid_curve_font">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A solid_curve_font is a pre_defined_curve_font that implements the ARM concept
of <internal.ref Linkend="Solid_curve">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY solid_curve_font
 SUBTYPE OF (pre_defined_curve_font);
END_ENTITY; -- solid_curve_font
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="start_request">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A start_request is a formal notification of a desire to begin a new design
for a product or group of <express.construct NAME.Linkend="product">s.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY start_request
 SUBTYPE OF (action_request_assignment);
     items : SET [1:?] OF start_request_item;
END_ENTITY; -- start_request
(*
</EXPRESS.CODE>



</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="start_work">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A start_work identifies the <express.construct NAME.Linkend="start_request">s
that have been fulfilled and, as a result, have established a new version of
a product.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY start_work
 SUBTYPE OF (action_assignment);
     items : SET [1:?] OF work_item;
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIRECTED_ACTION' IN 
       TYPEOF (SELF.assigned_action);
END_ENTITY; -- start_work
(*
</EXPRESS.CODE>




<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The start_work shall assign a directed_action.
</FORMAL.PROPOSITIONS.RUL>



<!--
 added statistical_dimensional_location mm 7/2/97

-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="statistical_dimensional_location">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A statistical_dimensional_location is a dimensional_location that implements
the combination of the ARM concepts <internal.ref Linkend="Statistical_dimensional_tolerance">
and <internal.ref Linkend="Dimensional_location">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY statistical_dimensional_location
 SUBTYPE OF (dimensional_location);
END_ENTITY; -- statistical_dimensional_location
(*
</EXPRESS.CODE>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The statistical_dimensional_location shall have exactly one property_definition with a description 
of 'dimensional location property', and that property_definition shall be related to at most one 
property_definition, of a dimensional_location, with a description of 'dimensional location 
property' as the 'substitutable dimension'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The statistical_dimensional_location shall have exactly one property_definition with a description 
of 'dimensional location property', and that property_definition shall relate to a 
requirements_property to specify the 'dimensional tolerance statistical control requirement'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The statistical_dimensional_location shall have exactly one property_definition with a description 
of 'dimensional location property', and if that property_definition is related to a 
property_definition, of a dimensional_location, with a description of 'dimensional location 
property' as the 'substitutable dimension', that dimensional_location shall not be a
statistical_dimensional_location.
</Informal.propositions.rul>

<Informal.propositions.rul>
The statistical_dimensional_location shall have exactly one property_definition with a description 
of 'dimensional location property', and if that property_definition is related to a 
property_definition, of a dimensional_location, with a description of 'dimensional location 
property' as the 'substitutable dimension', both the statistical_dimensional_location and the 
dimensional_location shall specify the same two shape_aspects as the related_shape_aspect and the 
relating_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="statistical_dimensional_size">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A statistical_dimensional_size is a dimensional_size_property that implements
the combination of the ARM concepts <internal.ref Linkend="Statistical_dimensional_tolerance">
and <internal.ref Linkend="Dimensional_size">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY statistical_dimensional_size
 SUBTYPE OF (dimensional_size_property);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 'substitutable dimension'))) 
       <= 1))) <= 1;       
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 
        'dimensional tolerance statistical control requirement')))
       <= 1))) <= 1;       
  WR3: (NOT(SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 'substitutable dimension'))) 
       <= 1))) <= 1))
       OR (NOT(SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STATISTICAL_DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition))) AND
       (pdr\property_definition_relationship.name = 'substitutable dimension'))) 
       <= 1))) <= 1));     
END_ENTITY; -- statistical_dimensional_size
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">
<formal.propositions.rul>
The statistical_dimensional_size shall be related to at most one dimensional_size as the 
'substitutable dimension'.
</formal.propositions.rul>

<formal.propositions.rul>
The statistical_dimensional_size shall relate to a requirements_property to specify the 
'dimensional tolerance statistical control requirement'.
</formal.propositions.rul>

<formal.propositions.rul>
If the statistical_dimensional_size is related to a dimensional_size, as the 'substitutable 
dimension', that dimensional_size shall not be a statistical_dimensional_size.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
If the statistical_dimensional_size is related to a dimensional_size as 
the 'substitutable dimension', both the statistical_dimensional_size and the dimensional_size 
shall apply to the same shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="statistical_geometric_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A statistical_geometric_tolerance is a physical_unit_geometric_tolerance
that implements the ARM concept
of <internal.ref Linkend="Statistical_geometric_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY statistical_geometric_tolerance
  SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN
       TYPEOF(gtr.relating_geometric_tolerance)) AND
       (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance')
       )) <= 1;
  WR2: SIZEOF(QUERY(pdr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF(pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 'geometric tolerance statistical control requirement')
       )) = 1;
  WR3: SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STATISTICAL_GEOMETRIC_TOLERANCE' IN
       TYPEOF(gtr.relating_geometric_tolerance)) AND
       (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance')
       )) <= 0;
END_ENTITY; -- statistical_geometric_tolerance
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">
<formal.propositions.rul>
The statistical_geometric_tolerance shall be related to at most one 
physical_unit_geometric_tolerance as the 'substitutable geometric tolerance'.
</formal.propositions.rul>

<formal.propositions.rul>
The statistical_geometric_tolerance shall relate to exactly one requirements_property to specify 
the 'geometric tolerance statistical control requirement'.
</formal.propositions.rul>

<formal.propositions.rul>
The statistical_geometric_tolerance shall be related to exactly zero 
statistical_geometric_tolerance as the 'substitutable geometric tolerance'.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
If the statistical_geometric_tolerance is related to exactly one physical_unit_geometric_tolerance 
as the 'substitutable geometric tolerance', the statistical_geometric_tolerance and the 
physical_unit_geometric_tolerance shall specify the same shape_aspect as their 
toleranced_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum">
<ENTITY.DESCRIPTION>
A stratum is a product_definition that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Design_layer_stratum"></list.item>
<list.item><internal.ref Linkend="Documentation_layer_stratum"></list.item>
<list.item><internal.ref Linkend="Stratum"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum
 SUBTYPE OF (product_definition);
UNIQUE
  UR1: SELF\product_definition.id, SELF\product_definition.formation;
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition))) = 1)) = 1;
  WR3: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
       duc\document_usage_constraint.subject_element = 'attachment region size')) = 1)) <= 1) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'stratum usage') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNAL_DEFINITION' IN 
       TYPEOF (tu.relating_property_definition))) = 1)) <= 1);
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = '3d bound volume shape')) <= 1))) 
       = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = 
                  'planar projected shape')) <= 1))) = 0;
  WR6: SIZEOF (QUERY (acu <* QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE' IN
       TYPEOF (pdr)) |
       acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship'
       )) >= 1;
  WR7: NOT(SELF\product_definition.name = 'design layer') OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition)) AND
       (tu.relating_property_definition.definition\characterized_object.description =
       'design layer'))) = 1)) = 1);
  WR8: NOT(SELF\product_definition.name = 'design layer') OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (sa))) >= 1)) >= 1);
  WR9: NOT(SELF\product_definition.name = 'documentation layer') OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition)) AND
       (tu.relating_property_definition.definition\characterized_object.description =
       'documentation layer'))) = 1)) = 1);
  WR10: NOT(SELF\product_definition.name = 'design layer') OR
       ((NOT(SELF\product_definition.description = 'primary design layer stratum') OR 
       (SIZEOF(QUERY(imps <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (imps,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       SIZEOF (QUERY (sar <* USEDIN (sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT' IN
       TYPEOF (sar.relating_shape_aspect)) AND 
        (sar.relating_shape_aspect\shape_aspect.description = 
       'interconnect module primary surface'))) >= 0)) >= 0)) = 1)) OR 
       (NOT (SELF\product_definition.description = 'non primary design layer stratum') OR
       (SIZEOF(QUERY(imps <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (imps,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       SIZEOF(QUERY (sar <* USEDIN (sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT' IN
       TYPEOF (sar.relating_shape_aspect)) AND
        (sar.relating_shape_aspect\shape_aspect.description =
       'interconnect module primary surface'))) >= 0)) >= 0)) = 0)));
END_ENTITY; -- stratum
(*
</EXPRESS.CODE>

<formal.propositions>
<formal.propositions.group rule.types="UR">
<formal.propositions.rul>
The name shall be unique in the context of the version of the product.
</formal.propositions.rul>
</formal.propositions.group>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<formal.propositions.rul>
The name shall exist.
</formal.propositions.rul>

<FORMAL.PROPOSITIONS.RUL>
The stratum shall have exactly one property_definition that is related
to a property_definition of a stratum_technology as the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum shall be referenced by at most one document with a usage
constraint that specifies the 'attachment region size', or it shall have at most
one property that is related to an external_definition as the 'stratum usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum shall have at most one shape_representation with a name of
'3d bound volume shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum shall have at most one shape_representation with a name of
'planar projected shape'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum shall be the component in at least one assembly_component_usage 
as the 'interconnect module stratum assembly relationship'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum is a definition of a product that has a name of 'design layer', it shall have exactly one property_definition that is related to exactly one property_definition of a stratum_technology with a description of 'design layer' as the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum is a definition of a product that has a name of 'design layer', it shall have at least one layer_connection_point.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum is a definition of a product that has a name of 
'documentation layer', it shall have exactly one property_definition that is
related to exactly one property_definition of a stratum_technology with a
description of 'documentation layer' as the 'technology usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum is a definition of a product that has a name of 'design layer', then either the description shall be 'primary design layer stratum' and it shall be assigned to an interconnect module primary surface, or the description shall be 'non primary design layer stratum' and it shall not be assigned to an interconnect module primary surface.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum_concept_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A stratum_concept_relationship is a shape_aspect and a 
shape_aspect_relationship that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Dielectric_crossover_area"></list.item>
<list.item><internal.ref Linkend="Inter_stratum_join_implementation"></list.item>
<list.item><internal.ref Linkend="Physical_network_supporting_stratum_feature_conductive_join"></list.item>
<list.item><internal.ref Linkend="Stratum_concept_relationship"></list.item>
<list.item><internal.ref Linkend="Stratum_feature_conductive_join"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum_concept_relationship
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF (pd))) >= 1; 
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (USEDIN (pd, 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1)) = 1;
  WR3: (NOT (SELF\shape_aspect_relationship.name = 
       'dielectric crossover area')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN 
       TYPEOF (SELF.relating_shape_aspect)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (SELF.related_shape_aspect)));
  WR4: (NOT (SELF\shape_aspect_relationship.name = 
       'dielectric crossover area')) OR
       (SIZEOF (QUERY (rdc <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'resulting dielectric crossover') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE' IN
       TYPEOF (rdc.relating_shape_aspect)))) = 1);
  WR5: (NOT (SELF\shape_aspect_relationship.name = 
       'stratum feature conductive join')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND' IN 
       TYPEOF (SELF.relating_shape_aspect)) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'stratum feature template component')));
  WR6: (NOT (SELF\shape_aspect_relationship.name = 
       'stratum feature conductive join')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND' IN 
       TYPEOF (SELF.related_shape_aspect)) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description = 
       'stratum feature template component')));
  WR7: (NOT (SELF\shape_aspect_relationship.name =
       'stratum feature conductive join')) OR
       (SIZEOF (QUERY (fj <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'features join') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PLATED_PASSAGE' IN
       TYPEOF (fj.related_shape_aspect)) AND
       (fj.related_shape_aspect\shape_aspect.description =
       'bonded conductive base blind via'))) <= 1);
  WR8: (NOT ((SELF\shape_aspect.description =
       'physical network supporting stratum feature conductive join') AND
       (SELF\shape_aspect_relationship.name =
       'stratum feature conductive join'))) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) = 1);
END_ENTITY; -- stratum_concept_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The stratum_concept_relationship shall have at least one requirements_property.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_concept_relationship shall have exactly one property_definition 
that is represented.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_concept_relationship has a shape_aspect_relationship name
of 'dielectric crossover area', it shall relate two stratum_features.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_concept_relationship has a shape_aspect_relationship name
of 'dielectric crossover area', the stratum_concept_relationship shall be
related to exactly one stratum_feature as a 'resulting dielectric crossover'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_concept_relationship has a shape_aspect_relationship name
of 'stratum feature conductive join', it shall have a relating_shape_aspect
that is either a land or a component_definition with a description of 'stratum
feature template component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_concept_relationship has a shape_aspect_relationship name
of 'stratum feature conductive join', it shall have a related_shape_aspect
that is either a land or a component_definition with a description of 'stratum
feature template component'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_concept_relationship has a shape_aspect_relationship
name of 'stratum feature conductive join', the stratum_concept_relationship
shall relate to at most one plated_passage that has a description of
'bonded conductive base blind via' to specify the 'features join'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_concept_relationship has a shape_aspect description of
'physical network supporting stratum feature conductive join' and a
shape_aspect_relationship name of 'stratum feature conductive join', the
stratum_concept_relationship shall be related, as the 'join
implementation', to exactly one join_shape_aspect that has a name of 'inter
stratum join'.
</FORMAL.PROPOSITIONS.RUL>

<!--
-this may need some work (name change?) with the arm concepts
stratum and stratum_surface added to this list.


-->
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A stratum_feature is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Conductive_filled_area"></list.item>
<list.item><internal.ref Linkend="Conductor"></list.item>
<list.item><internal.ref Linkend="Connected_filled_area"></list.item>
<list.item><internal.ref Linkend="Stratum_feature"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum_feature
  SUPERTYPE OF (fiducial_stratum_feature)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'feature of size') AND
       (it\descriptive_representation_item.description IN 
             ['true', 'false']))) = 1)) = 1))) = 0;
  WR3: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'conductor') OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name = 
       'intra stratum join'))) = 1));
  WR4: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'connected filled area') OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name = 
       'intra stratum join'))) = 1));
  WR5: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'conductor') OR
       (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
  WR6: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'connected filled area') OR
       (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
END_ENTITY; -- stratum_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The stratum_feature shall be an aspect of the shape of a stratum.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_feature shall have exactly one representation that specifies
if the stratum_feature is a 'feature of size'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_feature has a description of 'conductor', it shall be related to exactly one join_shape_aspect with a name of 'intra stratum join' as the 'join implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_feature has a description of 'connected filled area', it
shall be related to exactly one join_shape_aspect with a name of 'intra
stratum join' as the 'join implementation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_feature has a description of 'conductor', it shall be related to a 'design layer'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_feature has a description of 'connected filled area ', it shall be related to a 'design layer'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum_occurrence_specific_padstack_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A stratum_occurrence_specific_padstack_definition is a product_definition that implements the ARM concepts of:
<internal.ref Linkend="Stratum_occurrence_specific_padstack_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum_occurrence_specific_padstack_definition 
 SUBTYPE OF (padstack_definition);
END_ENTITY; -- stratum_occurrence_specific_padstack_definition 
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the padstack_definition is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall not be any other type of product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have a frame_of_reference with a name of 'layout design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall be associated with a product that is a template model.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum_surface">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A stratum_surface is a shape_aspect that implements the ARM concepts
of <internal.ref Linkend="Stratum_surface">
and <internal.ref Linkend="Stratum_average_surface">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum_surface
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: SELF\shape_aspect.description IN ['primary surface',
         'secondary surface', 'average surface']; 
    WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'STRATUM' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
END_ENTITY; -- stratum_surface
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
The stratum_surface shall have a description of 'primary surface', 
'secondary surface', or 'average surface'.
</formal.propositions.rul>
<formal.propositions.rul>
The stratum_surface shall be the shape of a stratum.
</formal.propositions.rul>
</formal.propositions>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum_technology">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A stratum_technology is a characterized_object that implements the ARM concepts
of:
<list> 
<list.item><internal.ref Linkend="Design_layer_technology"></list.item>
<list.item><internal.ref Linkend="Documentation_layer_technology"></list.item>
<list.item><internal.ref Linkend="Stratum_technology"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum_technology
  SUBTYPE OF (characterized_object);
UNIQUE
  UR1: SELF\characterized_object.name;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'stiffness class representation')) <= 1))) = 0;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation')) = 1))) = 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (scr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 'stratum class representation') |
       NOT (SIZEOF (QUERY (it <* scr.used_representation.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'laminate stiffness class') AND
       (it\descriptive_representation_item.description IN ['fluid like', 'conformal coat', 
       'stiff laminate']))) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT ({2 <= SIZEOF (pcr.used_representation.items) 
        <= 8}))) = 0))) = 0;
  WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items | 
       NOT (it\representation_item.name IN ['layer purpose', 
       'layer position', 
       'maximum feature size requirement', 
       'minimum finished feature spacing', 
       'minimum finished feature size', 
       'maximum thickness',  
       'minimum thickness']))) = 0))) = 0))) = 0;
  WR7: NOT(EXISTS(SELF\characterized_object.description)) OR
       (NOT (SELF\characterized_object.description = 'design layer') OR 
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum finished feature size'))) = 1))) = 0))) = 0));
  WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'maximum thickness'))) = 1))) = 0))) = 0;
  WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum thickness'))) = 1))) = 0))) = 0;
 WR10: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'maximum feature size requirement'))) <= 1))) = 0))) = 0;
 WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum finished feature spacing'))) <= 1))) = 0))) = 0;
 WR12: NOT(EXISTS(SELF\characterized_object.description)) OR
       ((NOT (SELF\characterized_object.description = 'documentation layer')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'layer purpose'))) = 1))) = 0))) = 0));
 WR13: NOT(EXISTS(SELF\characterized_object.description)) OR
       ((NOT (SELF\characterized_object.description = 'design layer')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum finished feature spacing'))) = 1))) = 0))) = 0));
 WR14: NOT(EXISTS(SELF\characterized_object.description)) OR
       ((NOT (SELF\characterized_object.description = 'design layer')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'layer purpose') AND
       (it\descriptive_representation_item.description IN ['power or ground', 'other signal', 
       'lands only']))) = 1))) = 0))) = 0));
 WR15:  SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'layer position') AND
       (it\descriptive_representation_item.description IN [
        'primary', 
        'secondary', 
        'internal', 
        'external', 
        'all']))) = 1))) = 0))) = 0;
 WR16: NOT(EXISTS(SELF\characterized_object.description)) OR
        (SELF\characterized_object.description IN [
         'design layer',
         'documentation layer']);
END_ENTITY; -- stratum_technology
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR">
<FORMAL.PROPOSITIONS.RUL>
The name shall be unique.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The stratum_technology shall have exactly one material designation.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_technology shall have at most one representation with a name
of 'stiffness class representation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_technology shall have exactly one representation with a name
of 'physical characteristics representation'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Exactly one item in the representation  with a name of 'stiffness class
representation' shall be a descriptive_representation_item with a name of
'laminate stiffness class' and a description of 'fluid like', 'conformal
coat', or 'stiff laminate'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_technology shall have at least two and at most eight items
in its representation with a name of 'physical characteristics
representation'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The items in the representation with a name of 'physical
characteristics representation' of a stratum_technology shall have a name of
either 'documentation layer purpose', 'design layer purpose', 'design layer
position', 'maximum feature size requirement', 'minimum finished feature
spacing', 'minimum finished feature size', 'maximum stratum thickness', or
'minimum stratum thickness'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Exactly one item in the representation with a name of 'physical
characteristics representation' of a stratum_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'minimum finished feature size'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Exactly one item in the representation with a name of 'physical
characteristics representation' of a stratum_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'maximum stratum thickness'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
Exactly one item in the representation with a name of 'physical
characteristics representation' of a stratum_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'minimum stratum thickness'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At most one item in the representation with a name of 'physical
characteristics representation' of a stratum_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'maximum feature size requirement'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
At most one item in the representation with a name of 'physical
characteristics representation' of a stratum_technology shall be a
measure_representation_item and a length_measure_with_unit with a name of
'minimum finished feature spacing'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_technology has a description of 'documentation layer',
exactly one item in its representation with a name of 'physical
characteristics representation' shall be a descriptive_representation_item
with a name of 'layer purpose'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_technology has a description of 'design layer', exactly
one item in its representation with a name of 'physical characteristics
representation' shall be a measure_representation_item and a
length_measure_with_unit with a name of 'minimum finished feature spacing'. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_technology has a description of 'design layer', exactly
one item in its representation with a name of 'physical characteristics
representation' shall be a descriptive_representation_item with a name of
'layer purpose' and a description of 'power or ground', 'other signal', or
'lands only'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the stratum_technology has a description of 'design layer', exactly one item in its representation with a name of 'physical characteristics representation' shall be a descriptive_representation_item with a name of 'layer position' and a description of 'primary', 'secondary', 'all', 'external' or 'internal'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
If the description attribute exists, it shall be either 'design layer' or 'documentation layer'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum_technology_link">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A stratum_technology_link is a property_definition_relationship that implements the ARM
concept of<internal.ref Linkend="Stratum_technology_link">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum_technology_link
  SUPERTYPE OF ( printed_part_template_link)
  SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
  WR1: SELF\property_definition_relationship.related_property_definition.definition :<>:
       SELF\property_definition_relationship.relating_property_definition.definition;
  WR2: (SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship ||
       SELF\stratum_technology_link || SELF\property_definition)) = 0) OR
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_LINK' IN TYPEOF(SELF));
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
    TYPEOF(SELF\property_definition_relationship.related_property_definition.definition);
  WR4: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_TECHNOLOGY' IN 
    TYPEOF(SELF\property_definition_relationship.relating_property_definition.definition);
  WR5: SELF\property_definition.name = '';
  WR6: SELF\property_definition.description = '';
  WR7: SELF\property_definition_relationship.name = '';
  WR8: SELF\property_definition_relationship.description = '';
  WR9: ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\property_definition.definition)) AND
       (SELF\property_definition.definition.description = 'printed part template');
 WR10: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       pdr.name = 'precedent stratum technology link')) <= 1; 
 WR11: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr.name = 'precedent stratum technology link')) <= 1; 
END_ENTITY; -- stratum_technology_link
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link shall not relate to the same property_definition definition through the related and relating
attributes.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link shall not be any other subtype of property_definition_relationship or property_definition. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link shall reference only a stratum_technology through the related attribute.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link shall reference only a stratum_technology through the relating attribute.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link name inherited from property_definition shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link description inherited from property_definition shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link name inherited from property_definition_relationship shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link description inherited from property_definition_relationship shall be blank.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link shall be referenced exactly once by a part_template_definition that has a description of 'printed part template'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link shall be referenced as a relating_property_definition no more than once by another stratum_technology_link.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
The stratum_technology_link shall be referenced as a related_property_definition no more than once by another stratum_technology_link.
</FORMAL.PROPOSITIONS.RUL>
<note>
The stratum_technology_link that is not referenced as a related_property_definition but that is referenced by a relating_property_definition attribute of a property_definition_relationship with a name of 'precedent stratum technology link' is considered the initial link.  The stratum_technology itself has no instance information and the sequence is only defined for printed part template purposes.  The actual stackup in the interconnect is not formally constrained in this standard.
</note>
</Formal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="stratum_type_independent_padstack_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A stratum_type_independent_padstack_definition is a product_definition that implements the ARM concepts of:
<internal.ref Linkend="Stratum_type_independent_padstack_definition">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY stratum_type_independent_padstack_definition 
 SUBTYPE OF (padstack_definition);
END_ENTITY; -- stratum_type_independent_padstack_definition 
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
If the padstack_definition is a product_definition_with_associated_documents,
there shall be at most one document in the set of documentation_ids that has a
product_data_type of 'CAD filename'
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one creation date.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one approval.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have at least one organization or 
person_and_organization as the creator.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have exactly one security_classification.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall not be any other type of product_definition.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall have a frame_of_reference with a name of 'layout design usage'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The padstack_definition shall be associated with a product that is a template model.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->
</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="structured_text_representation_context">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A structured_text_representation_context is a context that implements the ARM concept of <internal.ref Linkend="Structured_text"> in association with the structured_text_representation_item.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY structured_text_representation_context
  SUBTYPE OF (representation_context);
WHERE
  WR1: SIZEOF (QUERY (rep <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION.CONTEXT_OF_ITEMS') | NOT (
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN
       TYPEOF (rep)))) = 0;
END_ENTITY; -- structured_text_representation_context
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The structured_text_representation_context shall only be a context for representations that contain structured_text_representation_items.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="structured_text_representation_item">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A structured_text_representation_item is a representation and a descriptive_representation_item
that implements the ARM concept of<internal.ref Linkend="Structured_text">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY structured_text_representation_item
  SUBTYPE OF (representation, descriptive_representation_item);
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN
       TYPEOF (rr.rep_1) ))<= 1;
  WR2: SIZEOF (USEDIN (SELF, 
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) >= 1;
  WR3: (SIZEOF (QUERY (it <* SELF\representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) = 1); 
END_ENTITY; -- structured_text_representation_item
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The structured_text_representation_item shall relate to at most one structured_text_representation_item through a representation_relationship. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The structured_text_representation_item shall be referenced by at least one document.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The structured_text_representation_item shall contain exactly one externally_defined_representation_item.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="supplied_part_relationship">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A supplied_part_relationship relates the identifications of
two <express.construct NAME.Linkend="product">s and specifies that one is the
identification used by the internal design organization and the other is
the identification used by a supplier.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY supplied_part_relationship
 SUBTYPE OF (product_definition_relationship);
WHERE
  WR1: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN
       TYPEOF (SELF.related_product_definition.formation);
  WR2: NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION' IN ROLESOF (SELF));
END_ENTITY; -- supplied_part_relationship
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The supplied_part_relationship shall have a related_product_definition
in which the source is specified.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The supplied_part_relationship shall not be the definition of a
product_definition_shape.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="surface_prepped_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A surface_prepped_terminal is a package_terminal that implements the ARM
concept of <Internal.ref Linkend="Surface_prepped_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY surface_prepped_terminal
   SUBTYPE OF (altered_package_terminal);
WHERE
WR2: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EE_SPECIFICATION' IN
       TYPEOF (ada.assigned_document)) AND
       (ada.assigned_document.kind\document_type.product_data_type =
       'surface finish specification'))) = 1);
END_ENTITY; -- surface_prepped_terminal
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The surface_prepped_terminal shall have exactly one document_reference where the
assigned_document is an ee_specification with a product_data_type of
'surface finish specification'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="surface_profile_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A surface_profile_tolerance is a physical_unit_geometric_tolerance that
implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Composite_surface_profile_locating_tolerance"></list.item>
<list.item><internal.ref Linkend="Composite_surface_profile_refinement_tolerance"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_surface_tolerance"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_surface_tolerance_with_referenced_datum_system"></list.item>
<list.item><internal.ref Linkend="Profile_of_any_surface_tolerance_without_referenced_datum_system"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY surface_profile_tolerance
  SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
  WR1: (NOT(SELF\geometric_tolerance.name = 
               'surface profile refinement'))
       OR (SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SURFACE_PROFILE_TOLERANCE' IN 
             TYPEOF(gtr.relating_geometric_tolerance))
       AND ((gtr.relating_geometric_tolerance\geometric_tolerance.name = 
           'surface profile locating')
       OR (gtr.relating_geometric_tolerance\geometric_tolerance.name = 
               'surface profile refinement'))
       AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control')
       )) = 1);
  WR2: (NOT(SELF\geometric_tolerance.name = 'surface profile locating'))
       OR (SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SURFACE_PROFILE_TOLERANCE' IN 
               TYPEOF(gtr.related_geometric_tolerance))
       AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 
               'surface profile refinement')
       AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control')
       )) = 1);
  WR3: (NOT((NOT(
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(SELF)))
       AND(SELF\geometric_tolerance.name = 'surface profile refinement')))
       OR (SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SURFACE_PROFILE_TOLERANCE' IN 
             TYPEOF(gtr.related_geometric_tolerance))
       AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 
              'surface profile refinement')
       AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control')
       )) = 0);
  WR4: (NOT(SELF\geometric_tolerance.name = 
            'surface profile refinement'))
       OR (SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SURFACE_PROFILE_TOLERANCE' IN 
            TYPEOF(gtr.related_geometric_tolerance))
       AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 
            'surface profile refinement')
       AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control')
       )) = 1);
  WR5: NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
END_ENTITY; -- surface_profile_tolerance
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">

<formal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement', it shall be related as 
the 'surface profile refining control' to exactly one surface_profile_tolerance with a name of 
either 'surface profile locating' or 'surface profile refinement'.
</formal.propositions.rul>

<formal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile locating', it shall relate to 
exactly one surface_profile_tolerance with a name of 'surface profile refinement' to specify the 
'surface profile refining control'.
</formal.propositions.rul>

<formal.propositions.rul>
If the surface_profile_tolerance is not a geometric_tolerance_with_specified_datum_system and has a 
name of 'surface profile refinement', it shall not relate to a surface_profile_tolerance 
with a name of 'surface profile refinement' to specify the 'surface profile refining control'.
</formal.propositions.rul>

<formal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement', it shall relate to at 
most one surface_profile_tolerance with a name of 'surface profile refinement' to specify the 
'surface profile refining control'.
</formal.propositions.rul>

<formal.propositions.rul>
The surface_profile_tolerance shall not be a modified_geometric_tolerance.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
If surface_profile_tolerance is a geometric_tolerance_with_specified_datum_system, it shall have a 
name of either 'surface profile', 'surface profile refinement', or 'surface profile locating'; 
otherwise, it shall have the name of either 'surface profile' or 'surface profile refinement'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement', it shall be related as 
the 'surface profile refining control' to exactly one surface_profile_tolerance with a name of 
either 'surface profile locating' or 'surface profile refinement'. Both of these surface_profile_tolerances 
shall specify the same shape_aspect as the toleranced_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement' and it is related as 
the 'surface profile refining control' to exactly one surface_profile_tolerance with a name of 
'surface profile refinement', it shall either not reference a datum_system or it shall have less 
physical_unit_datum in its referenced datum_system than the datum_system referenced by the 
surface_profile_tolerance to which it is related as the 'surface profile refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement' and it is related as 
the 'surface profile refining control' to exactly one surface_profile_tolerance with a name of 
'surface profile locating', it shall either not reference a datum_system or it shall have less than 
or an equal number of physical_unit_datum in its referenced datum_system than the datum_system 
referenced by the surface_profile_tolerance to which it is related as the 'surface profile refining 
control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement' and it is a 
geometric_tolerance_with_specified_datum_system, the physical_unit_datum of its referenced 
datum_system shall be physical_unit_datum of the datum_system of the surface_profile_tolerance to 
which it is related as the 'surface profile refining control' and shall be assigned the same 
precedence.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement' and it is a 
geometric_tolerance_with_specified_datum_system that relates to a property_definition of a datum_system that 
has the description of 'datum system property without material conditions' to specify its 
'referenced datum system definition', the surface_profile_tolerance to which it is related as the 
'surface profile refining control' shall also be a geometric_tolerance_with_specified_datum_system 
that relates to a property_definition of a datum_system that has the description of 'datum system property 
without material conditions' to specify its 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement' and it is a 
geometric_tolerance_with_specified_datum_system that relates to a property_definition of a datum_system that 
has the description of 'datum system property with material conditions' to specify its 'referenced 
datum system definition', the surface_profile_tolerance to which it is related as the 'surface 
profile refining control' shall also be a geometric_tolerance_with_specified_datum_system that 
relates to a property_definition of a datum_system that has the description of 'datum system property with 
material conditions' to specify its 'referenced datum system definition', and each of these 
property_definition shall relate to property_definition with a description of 'datum feature material condition 
property' to specify their 'applied material condition property'. These property_definition shall be applied 
to physical_unit_datum_features in the context of the datum_systems referenced by each of the 
surface_profile_tolerance. The name of the property_definition applied to each of the 
physical_unit_datum_feature in the context of the datum_system referenced by this 
surface_profile_tolerance shall be the same as the name of the property_definition applied to the same 
physical_unit_datum_feature in the context of the datum_system referenced by the 
surface_profile_tolerance to which this surface_profile_tolerance is related as the 'surface 
profile refining control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement', it shall specify a 
measure_with_unit as its magnitude that is less than the measure_with_unit specified as the 
magnitude of the surface_profile_tolerance to which it is related as the 'surface profile refining 
control'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the surface_profile_tolerance has a name of 'surface profile refinement', there shall exist a 
property_definition that has a description of 'true profile' that is related as the 'basic profile' to a 
property_definition of the tolerance_zone_boundary of this surface_profile_tolerance and to a property_definition of the 
tolerance_zone_boundary of the surface_profile_tolerance that this surface_profile_tolerance is 
related to as the 'surface profile refining control', and these property_definition shall have the 
description of 'boundary zone definition with specified size' and a name of either 'profile 
boundary' or 'profile boundary with offsets'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The toleranced_shape_aspect of the surface_profile_tolerance shall either be a 
part_template_definition, lie on the boundary of the shape of the product, or be 
a composite_shape_aspect the 'composing' shape_aspects of which are all of type part_template_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
The tolerance_zone_boundary of the surface_profile_tolerance shall have a property_definition with a 
description of 'boundary zone definition with specified size' and a name of either 'profile 
boundary' or 'profile boundary with offsets'.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="symmetry_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A symmetry_tolerance is a geometric_tolerance_with_specified_datum_system that
implements the ARM concept of <internal.ref Linkend="Symmetry_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY symmetry_tolerance
  SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
WHERE
  WR1: SELF\geometric_tolerance.name = 'symmetry';
END_ENTITY; -- symmetry_tolerance
(*
</EXPRESS.CODE>

<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name for the symmetry_tolerance shall be 'symmetry'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The toleranced_shape_aspect of the symmetry_tolerance shall either be a 
centre_of_symmetry with a description of 'plane', or a composite_shape_aspect in which 
the 'composing' shape_aspects are all of type centre_of_symmetry with a description of 
'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The symmetry_tolerance shall have at most two physical_unit_datum in its referenced datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
The symmetry_tolerance shall have at least one physical_unit_datum in its referenced datum_system 
that has description of 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The tolerance_zone_boundary of the symmetry_tolerance shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="table_representation_item">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A table_representation_item is a compound_representation_item
that implements the ARM concept of <internal.ref Linkend="Characteristic_data_table">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY table_representation_item
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS')) > 0;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIST_REPRESENTATION_ITEM'
       IN TYPEOF(SELF\compound_representation_item.item_element);
END_ENTITY; -- table_representation_item
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The table_representation_item shall be referenced by exactly
one applied_document_reference.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The item_element attribute shall be a list_representation_item.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="template_material_cross_section_boundary">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A template_material_cross_section_boundary is a shape_aspect that implements the ARM concepts of:
<internal.ref Linkend="Template_material_cross_section_boundary">
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY template_material_cross_section_boundary
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\template_material_cross_section_boundary)) = 0;
  WR2: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF 
       (SELF.of_shape\property_definition.definition);
  WR3: SELF\shape_aspect.description IN
       ['top', 'left', 'right', 'bottom'];
END_ENTITY; -- template_material_cross_section_boundary
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The template_material_cross_section_boundary shall not participate in a complex instance.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The template_material_cross_section_boundary shall be an aspect of a printed_part_template_material.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The land_physical_template description shall only be 'top', 'bottom', 'left' or 'right'. 
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="template_stratum_assignment">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A template_stratum_assignment relates a specific part_template_definition to a specific stratum
for the purposes of binding them for one or more padstack definition. 
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY template_stratum_assignment
 SUBTYPE OF (shape_aspect_relationship);
END_ENTITY; -- template_stratum_assignment
(*
</EXPRESS.CODE>

<!--
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="tertiary_orientation_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A tertiary_orientation_feature is a physical_unit_datum_feature that implements the ARM
concept of<internal.ref Linkend="Tertiary_orientation_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY tertiary_orientation_feature
 SUBTYPE OF (physical_unit_datum_feature);
WHERE
 WR1:SIZEOF ((TYPEOF (SELF)) * 
      ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRIMARY_ORIENTATION_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SECONDARY_ORIENTATION_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SEATING_PLANE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'VIEWING_PLANE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT']) = 0;
 WR2: SELF.product_definitional = TRUE;
 WR3: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
 WR4: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
END_ENTITY; -- tertiary_orientation_feature
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The tertiary_orientation_feature shall not be a primary_orientation_feature, a secondary_orientation_feature,
a seating_plane, a viewing_plane, a component_shape_aspect, or
a physical_unit_datum.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A tertiary_orientation_feature shall be on the surface of the product.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A tertiary_orientation_feature shall be associated with no more than one package_body_bottom_surface.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
A tertiary_orientation_feature shall be associated with no more than one package_body_top_surface.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="test_point_part_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A test_point_part_feature is a part_tooling_feature that implements the ARM
concept of <internal.ref Linkend="Fiducial_part_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY test_point_part_feature
 SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- test_point_part_feature
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="thermal_component">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A thermal_component is a component_definition that implements the ARM concept
of <Internal.ref Linkend="Thermal_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY thermal_component
  SUBTYPE OF (component_definition);
END_ENTITY; -- thermal_component
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="thermal_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A thermal_component_shape_aspect is a component_shape_aspect that implements
the ARM concept of <Internal.ref Linkend="Thermal_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY thermal_component_shape_aspect
  SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- thermal_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="thermal_feature">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A thermal_feature is a shape_aspect that implements the ARM
concept of <internal.ref Linkend="Thermal_feature">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY thermal_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY; -- thermal_feature
(*
</EXPRESS.CODE>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="thermal_isolation_component_shape_aspect">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A thermal_isolation_component_shape_aspect is a filled_area_material_removal_component_shape_aspect
that implements the ARM concept of <Internal.ref Linkend="Thermal_isolation_laminate_component">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY thermal_isolation_component_shape_aspect
  SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
END_ENTITY; -- thermal_isolation_component_shape_aspect
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="thermal_isolation_removal_template_definition">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A thermal_isolation_removal_template_definition is a part_template_definition that implements the ARM concept of
<internal.ref Linkend="Thermal_isolation_removal_template">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY thermal_isolation_removal_template_definition
  SUBTYPE OF (part_template_definition);
(*
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL' IN
       TYPEOF (it))) = 1)) = 1))) = 0);
  WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font vertical extent'))) = 1
       )) = 1))) = 0);
  WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font horizontal extent'))) = 1
       )) = 1))) = 0);
*)
END_ENTITY; -- thermal_isolation_removal_template_definition
(*
</EXPRESS.CODE>
<!--

<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
The thermal_isolation_removal_template_definition shall have a representation that has exactly one text_literal.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The thermal_isolation_removal_template_definition shall have a representation that has exactly one
measure_representation_item that is a length_measure_with_unit with a name of
'maximum font vertical extent'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The thermal_isolation_removal_template_definition shall have a representation that has exactly one
measure_representation_item that is a length_measure_with_unit with a name of
'maximum font horizontal extent'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>
-->

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="thermal_network">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A thermal_network is a functional_unit that implements the ARM concept
of <Internal.ref Linkend="Thermal_network_definition">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY thermal_network
  SUBTYPE OF (functional_unit);
END_ENTITY; -- thermal_network
(*
</EXPRESS.CODE>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="tolerance_zone_boundary">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A tolerance_zone_boundary is a shape_aspect that implements the ARM concepts of:
<list>
<list.item><internal.ref Linkend="Conical_tolerance_zone_boundary"></list.item>
<list.item><internal.ref Linkend="Tolerance_zone_boundary"></list.item>
<list.item><internal.ref Linkend="Tolerance_zone_circular_or_cylindrical_or_spherical_boundary"></list.item>
</list>
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY tolerance_zone_boundary
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: (NOT(SELF\shape_aspect.description = 'conical'))
       OR (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET'
                IN TYPEOF(SELF))
           OR('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET'
               IN TYPEOF(SELF))));
  WR2: (NOT(SELF\shape_aspect.description = 
                 'circular or cylindrical or spherical'))
       OR (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET'
                IN TYPEOF(SELF))
           OR('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
               'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET'
               IN TYPEOF(SELF))));
  WR3: SELF\shape_aspect.product_definitional = False;
  WR4: NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET'
           IN TYPEOF(SELF))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET'
           IN TYPEOF(SELF)));
    WR5: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
       'boundary zone definition with specified size') OR 
       (pd\property_definition.description = 'conical tolerance zone boundary')
       )) = 1;
  WR6: SIZEOF(USEDIN(SELF, 
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_DEFINITION.BOUNDARIES')) = 1;
END_ENTITY; -- tolerance_zone_boundary
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">
<formal.propositions.rul>
If the description of the tolerance_zone_boundary is 'conical', it shall not be either a 
tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</formal.propositions.rul>

<formal.propositions.rul>
If the description of the tolerance_zone_boundary is 'circular or cylindrical or spherical', it 
shall not be either a tolerance_zone_explicit_opposing_boundary_set or a 
tolerance_zone_implicit_opposing_boundary_set.
</formal.propositions.rul>

<formal.propositions.rul>
The tolerance_zone_boundary shall not lie on the boundary of the shape of the product.
</formal.propositions.rul>

<formal.propositions.rul>
The tolerance_zone_boundary shall not be both a tolerance_zone_explicit_opposing_boundary_set and a 
tolerance_zone_implicit_opposing_boundary_set.
</formal.propositions.rul>

<formal.propositions.rul>
The tolerance_zone_boundary shall have exactly one property_definition that has the description of either 
'boundary zone definition with specified size' or 'conical tolerance zone boundary'.
</formal.propositions.rul>

<formal.propositions.rul>
The tolerance_zone_boundary shall be specified as the boundaries by exactly one 
tolerance_zone_definition.
</formal.propositions.rul>

</formal.propositions>

<informal.propositions rule.types="IP">
<Informal.propositions.rul>
If the description of the tolerance_zone_boundary is 'conical', the tolerance_zone_boundary shall 
relate to exactly two shape_aspect to specify the 'conical tolerance zone boundary and surface'.
</Informal.propositions.rul>

<Informal.propositions.rul>
If the description of the tolerance_zone_boundary is 'circular or cylindrical or spherical', the 
tolerance_zone_boundary shall have exactly one property_definition with a description of 'boundary 
zone definition with specified size', and that property_definition shall be represented by exactly 
one representation that has a name of 'diametrical boundary size'.
</Informal.propositions.rul>

</informal.propositions>
</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="tolerance_zone_explicit_opposing_boundary_set">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A tolerance_zone_explicit_opposing_boundary_set is a tolerance_zone_boundary
that implements the ARM concepts of
<internal.ref Linkend="Tolerance_zone_explicit_opposing_boundary_set">
and <internal.ref Linkend="Tolerance_zone_opposing_boundary_set">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY tolerance_zone_explicit_opposing_boundary_set
  SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY; -- tolerance_zone_explicit_opposing_boundary_set
(*
</EXPRESS.CODE>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The tolerance_zone_explicit_opposing_boundary_set shall relate to exactly two shape_aspect instances that 
have a description of 'tolerance zone boundary member' to specify the 'zone boundary member'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The tolerance_zone_explicit_opposing_boundary_set shall have exactly one property_definition with a 
description of 'boundary zone definition with specified size', and that property_definition shall 
be represented by exactly one representation that has a name of 'opposing boundary set size'.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="tolerance_zone_implicit_opposing_boundary_set">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A tolerance_zone_implicit_opposing_boundary_set is a tolerance_zone_boundary
that implements the ARM concept
of <internal.ref Linkend="Tolerance_zone_implicit_opposing_boundary_set">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY tolerance_zone_implicit_opposing_boundary_set
  SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY; -- tolerance_zone_implicit_opposing_boundary_set
(*
</EXPRESS.CODE>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The tolerance_zone_implicit_opposing_boundary_set shall have exactly one property_definition with a 
description of 'boundary zone definition with specified size', and that property_definition shall 
be represented by exactly one representation that has a name of 'opposing boundary set size'.
</Informal.propositions.rul>
</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="total_runout_tolerance">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A total_runout_tolerance is a geometric_tolerance_with_specified_datum_system
that implements the ARM concept 
of <internal.ref Linkend="Total_runout_tolerance">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY total_runout_tolerance
  SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
WHERE
  WR1: SELF\geometric_tolerance.name = 'total runout';
  WR2: NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
END_ENTITY; -- total_runout_tolerance
(*
</EXPRESS.CODE>


<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The name for the total_runout_tolerance shall be 'total runout'.
</FORMAL.PROPOSITIONS.RUL>

<formal.propositions.rul>
The total_runout_tolerance shall not be a modified_geometric_tolerance.
</formal.propositions.rul>

</FORMAL.PROPOSITIONS>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
The toleranced_shape_aspect of the total_runout_tolerance shall either be a 
part_template_definition, lie on the boundary of the shape of the product, or be 
a composite_shape_aspect the 'composing' shape_aspects of which are all of type part_template_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
The total_runout_tolerance shall have at most two physical_unit_datum 
instances in its referenced datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
The total_runout_tolerance shall have at least one physical_unit_datum in its referenced 
datum_system that has a description of 'axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The total_runout_tolerance shall relate to exactly one property_definition that has the description of 'datum 
system property without material conditions' to specify the 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
The tolerance_zone_boundary of the total_runout_tolerance shall be either a 
tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="usage_view_connection_zone_terminal_shape_relationship">
<ENTITY.DESCRIPTION>
A usage_view_connection_zone_terminal_shape_relationship is a representation and a representation_relationship_with_transformation that implements the ARM concept of <internal.ref Linkend="Usage_view_connection_zone_terminal_shape_relationship">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY usage_view_connection_zone_terminal_shape_relationship
  SUBTYPE OF (representation, representation_relationship_with_transformation);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'] *
       TYPEOF (SELF.rep_1)) = 1;
  WR2: SIZEOF (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION'] *
       TYPEOF (SELF.rep_2)) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\representation_relationship_with_transformation || 
       SELF\usage_view_connection_zone_terminal_shape_relationship))) = 0;
  WR4: SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
END_ENTITY; -- usage_view_connection_zone_terminal_shape_relationship 
(* 
</EXPRESS.CODE> 
<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR"> 
<FORMAL.PROPOSITIONS.RUL>
The combination of rep_1 and rep_2 shall be unique within a population of usage_view_connection_zone_terminal_shape_relationship.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The usage_view_connection_zone_terminal_shape_relationship shall reference a shape_representation as its rep_1.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The usage_view_connection_zone_terminal_shape_relationship shall reference a shape_representation as its rep_2.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The usage_view_connection_zone_terminal_shape_relationship shall only be a representation, representation_relationship, or representation_relationship_with_transformation in addition to itself.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The usage_view_connection_zone_terminal_shape_relationship rep_1 shall not be the rep_2.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="viewing_plane">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

The viewing_plane is a shape_aspect that implements the ARM concept
of <internal.ref Linkend="Viewing_plane">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY viewing_plane
  SUBTYPE OF (shape_aspect);
  WHERE
    wr1: SELF\shape_aspect.description = 'affected plane';
    wr2: (SIZEOF(QUERY ( pd <* USEDIN (SELF,
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION.' + 'DEFINITION') | (pd\property_definition.description = 
             'viewing plane property')))) =1;
    wr3: NOT SELF\shape_aspect.product_definitional;
END_ENTITY; -- viewing_plane
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
The viewing_plane shall have a description of 'affected plane'.
</Formal.propositions.rul>

<Formal.propositions.rul>
The viewing_plane shall have exactly one property_definition that has the description of 'viewing plane 
property'.
</Formal.propositions.rul>

<formal.propositions.rul>
The viewing_plane shall not lie on the boundary of the shape of the product.
</formal.propositions.rul>

</Formal.propositions>


</ENTITY.DEF>
</ENTITY.DEF.CL5>
<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="volume_shape_intersection">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A volume_shape_intersection is a representation and a shape_representation_relationship
that implements the ARM concept of <internal.ref Linkend="Volume_shape_intersection">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY volume_shape_intersection
  SUPERTYPE OF (ONEOF(edge_segment_cross_section,
              pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship))
  SUBTYPE OF (representation, 
              shape_representation_relationship, 
              representation_relationship_with_transformation);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
  WR2: (SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\representation_relationship_with_transformation || 
       SELF\volume_shape_intersection))) = 0)  OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EDGE_SEGMENT_CROSS_SECTION' IN TYPEOF (SELF)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_PARALLEL_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF (SELF)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_PERPENDICULAR_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF (SELF)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_PERPENDICULAR_DATUM_PLANE_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF (SELF));
  WR3: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF 
       (SELF\representation_relationship_with_transformation.transformation_operator);

END_ENTITY; -- volume_shape_intersection 
(* 
</EXPRESS.CODE> 
<FORMAL.PROPOSITIONS>
<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="UR"> 
<FORMAL.PROPOSITIONS.RUL>
The combination of rep_1 and rep_2 shall be unique within a population of volume_shape_intersection.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS.GROUP>

<FORMAL.PROPOSITIONS.GROUP RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The volume_shape_intersection rep_1 shall not be rep_2. 
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The volume_shape_intersection shall not be a complex subtype of other than its direct supertypes.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The volume_shape_intersection shall reference an item_defined_transformation.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS.GROUP>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

<ENTITY.DEF.CL5>
<ENTITY.DEF NAME="wire_terminal">
<ENTITY.DESCRIPTION>
<note> The local rules for this entity have not been fully updated to agree with the changes in clause 4.2.</note>

A wire_terminal is a package_terminal that implements the ARM
concept of <Internal.ref Linkend="Wire_terminal">.
</ENTITY.DESCRIPTION>
<EXPRESS.CODE>
*)
ENTITY wire_terminal
   SUBTYPE OF (package_terminal);
WHERE
WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM') IN TYPEOF (it))
       AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_UNIT') IN
   TYPEOF (it\measure_with_unit.unit_component)))) = 2))) = 1)) )) = 0);
 WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (QUERY (it <* pdr.used_representation.items | (
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) AND
       (it\representation_item.name = 'maximum wire terminal length')
       AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_UNIT') IN
        TYPEOF (it\measure_with_unit.unit_component)))) = 1
                                               ))) = 1)) )) = 0);
 WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (QUERY (it <* pdr.used_representation.items | (
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) AND
       (it\representation_item.name = 'minimum wire terminal length')
       AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_UNIT') IN
       TYPEOF (it\measure_with_unit.unit_component)))) = 1)))
                                                     = 1)) )) = 0);
 WR4: (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'internal connection zone') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1);
END_ENTITY; -- wire_terminal
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">

<FORMAL.PROPOSITIONS.RUL>
The wire_terminal shall have a representation that contains exactly two length_measure_with_units.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The wire_terminal shall have a representation that contains exactly one length_measure_with_unit with
a name of 'maximum wire terminal length'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The wire_terminal shall have a representation that contains exactly one length_measure_with_unit with
a name of 'minimum wire terminal length'.
</FORMAL.PROPOSITIONS.RUL>

<FORMAL.PROPOSITIONS.RUL>
The wire_terminal shall be related to exactly one shape_aspect with a description of
'connection zone' as the 'internal connection zone'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>

</ENTITY.DEF>
</ENTITY.DEF.CL5>

</ENTITY.DEFS.CL4>
<Import.Entity.Defs.CL4>

<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="action" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="rule_supersedence_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_action">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="action_assignment" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_combination_action_assignment">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="action_directive" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_action_directive">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="action_request_assignment"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_action_request_assignment">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="action_request_status" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_action_request_status">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="versioned_action_request_requires_status">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="address" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_address">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_address">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="alternate_product_relationship" From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_alternate_product_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="angular_size"
From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="angular_size_dimension_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="annotation_fill_area_occurrence"
From.Part="46">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="fill_area_occurrence_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="application_context" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="application_context_requires_ap_definition">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="application_protocol_definition"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="application_context_requires_ap_definition">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="approval" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="approval_requires_approval_date_time">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="approval_requires_approval_person_organization">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="approvals_are_assigned">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="approval_assignment" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="approvals_are_assigned">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="approval_date_time" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="approval_requires_approval_date_time">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="approval_person_organization"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="approval_requires_approval_person_organization">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="approval_status" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_approval_status">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_approval_status">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="assembly_component_usage"
From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="acu_requires_security_classification">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_composition_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_composition_relationship_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="interconnect_module_stratum_assembly_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="interconnect_module_stratum_assembly_relationship_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="material_assembly_relationship_constraint"
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="material_assembly_relationship_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="assembly_component_usage_substitute" From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="substitute_product_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="centre_of_symmetry" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="centre_of_symmetry_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="certification_type" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_certification_type">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_certification_type"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="characterized_object" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_certification_type">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_characterized_object">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="composite_shape_aspect" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="composite_shape_element_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_feature_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_composite_shape_aspect">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="configuration_effectivity"
From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="planned_effectivity_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="planned_effectivity_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="configuration_item" From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="configuration_item_requires_person_organization">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_configuration_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_configuration_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_concept_requires_configuration_item">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="contract" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="contract_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="contract_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="contract_type" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_contract_type">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="curve_style" From.Part="46">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="curve_style_requires_length_measure_with_unit"
>
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="date" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="date_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_date">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_date">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="date_and_time" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="date_and_time_require_minute_and_second">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="date_role" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_date_role">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_date_role">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="date_time_role" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_date_time_role">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_date_time_role"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="derived_shape_aspect" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="derived_shape_element_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="directed_axis_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="directed_axis_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="descriptive_representation_item"
From.Part="45">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_feature_external_reference_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_feature_external_reference_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="configuration_controlled_message_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="package_terminal_external_reference_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="package_terminal_external_reference_unique_constraint">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="marked_text_constraint"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="dimensional_location" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimension_along_curve_constraint"> -->
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimensional_characteristic_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimensional_location_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_locating_relationship_constraint"> 
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_locating_relationship_unique_constraint"> 
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_dimensional_location">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="dimensional_size" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimensional_characteristic_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimensional_size_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_dimensional_size">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="directed_action" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="directed_action_requires_approval">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="directed_action_requires_date_or_date_and_time">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="work_order_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="work_order_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="document" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_document_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_document_identifier_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_document_unique_constraint">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="marked_text_constraint"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="document_type" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_document_type">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_document_type"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="externally_defined_item" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_externally_defined_item">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="externally_defined_text_font"
From.Part="46">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="registered_font_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="registered_font_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="geometric_tolerance" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_geometric_tolerance">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="global_unit_assigned_context"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="cartesian_coordinate_system_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="group" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_group">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="make_from_usage_option" From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="no_shape_for_make_from">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_make_from_relationship_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="mapped_item" From.Part="43">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_intent_modification_in_stratum_3d_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_intent_modification_in_stratum_planar_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="device_2d_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="device_3d_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_feature_in_stratum_3d_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_feature_in_stratum_planar_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_interconnect_module_3d_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_interconnect_module_planar_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_surface_in_stratum_3d_position_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_mapped_item">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="material_designation" From.Part="45">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_material_constraint"
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_material_unique_constraint"
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="printed_part_template_material_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="measure_qualification" From.Part="45">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimension_qualifier_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="geometric_tolerance_qualifier_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="pre_defined_dimension_qualifier_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="pre_defined_geometric_tolerance_qualifier_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="user_defined_dimension_qualifier_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="user_defined_geometric_tolerance_qualifier_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="modified_geometric_tolerance" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="geometric_tolerance_with_applied_material_condition_property_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="named_unit" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_named_unit">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="next_assembly_usage_occurrence"
From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="coordinated_assembly_and_shape">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="next_higher_assembly_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="next_higher_assembly_relationship_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="organization_role" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_organization_role">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_organization_role"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="parametric_representation_context"
From.Part="43">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_parametric_representation_context">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="person_and_organization_role"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_person_and_organization_role">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_person_organization_role"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="plus_minus_tolerance" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="plus_minus_tolerance_range_representation_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="pre_defined_item" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_pre_defined_item">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="product" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="mandatory_product_related_product_category_value">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_requires_person_organization">
<!-- <Assoc.Global.Rule.List.Item
 Rule.Name.Linkend="product_requires_product_category"> -->
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_requires_product_definition_formation"
>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="substitute_product_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="product_concept" From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_model_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_concept_requires_configuration_item">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="product_definition" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_feature_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_definition_requires_date_or_date_and_time">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_definition_requires_person_organization">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_product_definition">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="product_definition_formation"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="bus_structural_definition_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_version_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_version_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="pdf_requires_security_classification">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_definition_formation_requires_approval">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_definition_formation_requires_person_organization">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_requires_product_definition_formation">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def
Name="product_definition_formation_relationship"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="product_association_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="product_definition_relationship"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="aggregate_connectivity_requirement_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_requirement_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="bus_element_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="bus_element_relationship_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="connectivity_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="connectivity_allocation_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_composition_path_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_functional_unit_allocation_to_assembly_component_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_functional_unit_allocation_to_assembly_component_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_functional_unit_allocation_to_assembly_joint_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_functional_unit_allocation_to_assembly_joint_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_functional_unit_allocation_to_fabrication_joint_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_functional_unit_allocation_to_fabrication_joint_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_functional_unit_allocation_to_reference_functional_unit_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_object_management_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="equivalent_functional_unit_definition_assignment_constraint">
<Assoc.Global.Rule.List.Item 
Rule.Name.Linkend="functional_unit_requirement_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="interface_component_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="inter_stratum_extent_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_device_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_device_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="physical_node_requirement_to_implementing_component_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="physical_unit_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="reference_composition_path_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="reference_functional_unit_assignment_to_part_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shield_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_product_definition_relationship">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="thermal_requirement_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="transmission_line_functional_unit_to_routed_printed_component_allocation_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="product_definition_usage"
From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_product_definition_usage">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def
Name="product_definition_with_associated_documents"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_product_definition_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def
Name="product_material_composition_relationship"
From.Part="45">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="material_composition_relationship_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<!-- <Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="product_related_product_category" 
From.Part="41"> 
<Import.Construct.Mod.Description> 
<Import.Construct.Mod.Descr.OS> 
<Import.Construct.Mod.Descr.Text> 
</Import.Construct.Mod.Descr.Text> 
</Import.Construct.Mod.Description> 
<Assoc.Global.Rules.List> 
<Assoc.Global.Rules.Intro.Text> 
<Assoc.Global.Rule.List.Item 
Rule.Name.Linkend="mandatory_product_related_product_category_value"> 
<Assoc.Global.Rule.List.Item 
Rule.Name.Linkend="product_requires_product_category"> 
<Assoc.Global.Rule.List.Item 
Rule.Name.Linkend="restrict_product_category_value"> 
</Assoc.Global.Rules.List> 
</Import.Entity.Def> 
</Import.Entity.Def.CL5> -->
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="projected_zone_definition" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="projected_tolerance_zone_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="projected_zone_and_base_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="projected_zone_height_characteristic_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="promissory_usage_occurrence"
From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="promissory_usage_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="promissory_usage_relationship_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="property_definition" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="boundary_zone_definition_with_specified_size_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="conical_tolerance_zone_boundary_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="conical_tolerance_zone_boundary_diametrical_size_characteristic_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_axis_related_orientation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_based_direction_vector_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_based_vector_orientation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_feature_material_condition_property_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_precedence_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_precedence_assignment_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_system_defining_conditions_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_system_defining_conditions_with_material_conditions_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_system_defining_conditions_without_material_conditions_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimension_related_positional_boundary_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dimension_set_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="direction_element_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="composite_signal_property_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="positional_boundary_member_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="positional_boundary_offset_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="profile_boundary_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="profile_boundary_definition_with_offsets_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="profile_related_positional_boundary_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restraint_condition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="signal_property_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_property_definition">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="technology_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_specific_restraint_condition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_boundary_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_boundary_member_offset_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_definition_with_specified_orientation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_per_unit_size_specification_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="true_profile_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="viewing_plane_based_orientation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="viewing_plane_definition_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="property_definition_relationship"
From.Part="45">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="composite_signal_property_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_unit_network_terminal_definition_bus_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_unit_network_terminal_definition_node_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_unit_terminal_bus_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_unit_terminal_node_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="operational_requirement_occurrence_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="requirement_composition_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="property_definition_representation"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="analytical_model_vector_port_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_component_2d_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_component_3d_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_placement_restriction_assignment_constraint">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_intent_modification_surface_representation_constraint"> -->
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_intent_modification_styled_area_representation_constraint"> -->
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_specification_to_requirement_occurrence_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="located_interconnect_module_thickness_requirement_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_property_definition_representation">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="representation" From.Part="43">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="boundary_size_characteristic_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_external_reference_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_overlap_relationship_constraint"
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_mounting_clearance_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="connection_zone_constraint"
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="curve_style_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_based_length_measure_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="diametrical_boundary_size_characteristic_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_rule_conclusion_definition_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_rule_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_rule_definition_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_rule_premise_definition_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_specification_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="marking_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="opposing_boundary_set_size_characteristic_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="package_external_reference_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_terminal_external_reference_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="registered_style_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="rule_priority_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="signal_specification_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_technology_line_width_tolerance_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_representation">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="representation_context" From.Part="43">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_representation_context">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="representation_item" From.Part="43">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="characteristic_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="characteristic_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_representation_item">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="representation_relationship"
From.Part="43">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="ee_rule_function_instance_constraint"> -->
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="evaluated_characteristic_constraint">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_combination_representation_relationship"> -->
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_feature_shape_stratum_average_surface_shape_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_feature_shape_stratum_surface_shape_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="terminal_pair_port_equivalence_relationship_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="runout_zone_definition" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="runout_tolerance_zone_definition_with_specified_angle_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="runout_zone_orientation"
From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_runout_zone_orientation">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="runout_zone_orientation_reference_direction" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="runout_zone_orientation_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="security_classification" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="security_classification_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="security_classification_level"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_security_classification_level">
<!-- <Assoc.Global.Rule.List.Item
Rule.Name.Linkend="restrict_security_classification_level"> -->
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="shape_aspect" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_termination_passage_template_terminal_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_termination_passage_template_terminal_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="conductive_interconnect_element_with_pre_defined_transitions_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="conductive_interconnect_element_with_user_defined_single_transition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="connection_zone_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="interconnect_module_surface_feature_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="mating_connector_termination_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="mating_connector_termination_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="non_feature_shape_element_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_device_terminal_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_device_terminal_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_feature_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_feature_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="polarity_indication_feature_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_combination_shape_aspect">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_boundary_member_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="topological_junction_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="topological_junction_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="via_template_terminal_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="via_template_terminal_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="shape_aspect_deriving_relationship" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_deriving_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_deriving_relationship_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="shape_aspect_relationship"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="adjacent_stratum_surface_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="adjacent_stratum_surface_definition_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_requirement_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="assembly_separation_requirement_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_feature_to_layout_feature_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_terminal_to_assembly_module_terminal_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_terminal_to_interconnect_module_terminal_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_terminal_to_interconnect_module_terminal_assignment_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_terminal_to_pca_terminal_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_terminal_to_pca_terminal_assignment_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="conical_tolerance_zone_boundary_and_surface_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_axis_and_tolerance_zone_orienting_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_feature_usage_in_common_datum_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_feature_usage_in_datum_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_feature_usage_in_datum_relationship_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_feature_usage_in_datum_system_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_feature_usage_in_single_datum_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_target_usage_in_datum_target_set_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_target_usage_in_datum_target_set_relationship_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_usage_in_datum_system_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="datum_usage_in_datum_system_relationship_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_intent_modification_sequence_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="design_intent_modification_sequence_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="device_terminal_map_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="edge_segment_vertex_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="equivalent_functional_terminals_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="feature_group_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_usage_view_to_part_terminal_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_usage_view_to_part_terminal_assignment_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_usage_view_to_printed_part_template_terminal_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="internal_stratum_access_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="internal_stratum_access_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="junction_vertex_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="junction_vertex_allocation_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="layout_spacing_requirement_non_conforming_design_object_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="parallel_shape_element_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="perpendicular_shape_element_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="physical_connectivity_abstraction_map_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="physical_connectivity_definition_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="placement_group_area_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="positional_boundary_and_profile_boundary_member_relationship_constraint">
<!--
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="printed_connector_template_terminal_relationship_constraint">
-->
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="printed_part_template_terminal_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="runout_tolerance_zone_orienting_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_boundary_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_composing_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_constituent_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_constituent_relationship_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_element_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_concept_to_physical_usage_view_assignment_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_exclusive_shape_aspect_relationship">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_and_viewing_plane_orienting_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="transmission_line_functional_unit_terminal_allocation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="transmission_line_functional_unit_terminal_allocation_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="shape_dimension_representation" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="limit_dimension_representation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="plus_minus_tolerance_range_representation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_dimension_representation_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="singular_dimension_representation_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="shape_representation" From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="bevel_edge_feature_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="default_assembly_bond_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_shape_representation">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="feature_shape_occurrence_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="mating_connector_placement_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_template_3d_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="part_template_planar_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="physical_unit_3d_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="physical_unit_planar_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="planar_curve_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="planar_projected_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="radius_edge_feature_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="shape_representation_requires_origin">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="step_edge_feature_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_3d_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="stratum_planar_shape_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_shape_representation">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="shape_representation_relationship"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_part_2d_geometric_representation_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="component_part_3d_geometric_representation_relationship_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="consistent_part_template_shape_projection_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="consistent_physical_unit_shape_projection_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="consistent_stratum_shape_projection_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="specified_higher_usage_occurrence"
From.Part="44">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="next_higher_assembly_interface_requirement_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="text_literal" From.Part="46">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="subtype_mandatory_text_literal">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="tolerance_value" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="dependent_instantiable_tolerance_value">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="tolerance_zone" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="tolerance_zone_definition" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="conical_tolerance_zone_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_definition_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_definition_with_per_unit_size_specification_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="tolerance_zone_form" From.Part="47">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<One.Assoc.Global.Rule.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="tolerance_zone_form_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>
<Import.Entity.Def.CL5>
<Import.Entity.Def.OS>
<Import.Construct.Def.OS>
</Import.Entity.Def.OS>
<Import.Entity.Def Name="versioned_action_request"
From.Part="41">
<Import.Construct.Mod.Description>
<Import.Construct.Mod.Descr.OS>
<Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Descr.Text>
</Import.Construct.Mod.Description>
<Assoc.Global.Rules.List>
<Assoc.Global.Rules.Intro.Text>
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="change_request_unique_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="versioned_action_request_requires_approval">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="versioned_action_request_requires_date_or_date_and_time">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="versioned_action_request_requires_person_organization">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="versioned_action_request_requires_status">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="work_request_constraint">
<Assoc.Global.Rule.List.Item
Rule.Name.Linkend="work_request_unique_constraint">
</Assoc.Global.Rules.List>
</Import.Entity.Def>
</Import.Entity.Def.CL5>

</Import.Entity.Defs.CL4>
</Multi.Ent.Defs.and.Imports.CL3>
</Entity.Defs.Section>

<RULE.DEF.CL4>
<RULE.DEF NAME="add_design_object_management_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The add_design_object_management_relationship_unique_constraint rule constrains
the add_design_object_assignment and add_design_object_request_assignment population
members, that fill the role of ARM add_design_object_management_relationship, so
that the combination of ARM current_design and ARM current_design_object attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE add_design_object_management_relationship_unique_constraint FOR
 ( add_design_object_assignment, add_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  adoa_bag : BAG OF add_design_object_assignment;
  adora_bag : BAG OF add_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(add_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(add_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(add_design_object_assignment[i].items[j]))
    AND (add_design_object_assignment[i].items[j].name = 
            'design object addition') ) THEN
      IF EXISTS( add_design_object_assignment[i].items[j].
                          related_product_definition ) 
                                                               THEN
        IF( NOT( add_design_object_assignment[i].items[j].
                           related_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                    add_design_object_assignment[i].items[j].
                             related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(add_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
        SIZEOF(add_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
           TYPEOF(add_design_object_request_assignment[i].items[j]))
AND (add_design_object_request_assignment[i].items[j].name = 
                             'design object addition') ) THEN
      IF EXISTS( 
           add_design_object_request_assignment[i].items[j].
                             related_product_definition ) 
                                                          THEN
        IF( NOT( 
           add_design_object_request_assignment[i].items[j].
                               related_product_definition 
                                           IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
             add_design_object_request_assignment[i].items[j].
                                    related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
                         (pdr\product_definition_relationship.name = 'design object addition') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adoa_bag := QUERY( adoa <* add_design_object_assignment | 
                                 (pdr_bag[j] IN adoa.items) );
    REPEAT k := 1 to SIZEOF(adoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adoa_bag[k].items) by 1;
        IF EXISTS( adoa_bag[k].items[l] ) THEN
          IF ( adoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + adoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adora_bag := QUERY( adora <* add_design_object_request_assignment | 
                                          (pdr_bag[j] IN adora.items) );
    REPEAT k := 1 to SIZEOF(adora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adora_bag[k].items) by 1;
        IF ( adora_bag[k].items[l] IN mdo_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          mdo_bag := mdo_bag + adora_bag[k].items[l];
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- add_design_object_management_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of add_design_object_assignment and add_design_object_request_assignment
that has a common product_definition that is the related_product_definition of a
product_definition_relationship that has a name of 'design object addition' where the
product_definition_relationship is a member of the items attribute of the
add_design_object_assignment and add_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="adjacent_stratum_surface_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The adjacent_stratum_surface_definition_constraint rule 
constrains the related and relating shape_aspect of a shape_aspect_relationship
when it is used as a adjacent stratum surface definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE adjacent_stratum_surface_definition_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'STRATUM_SURFACE' IN TYPEOF (sar.related_shape_aspect)) AND
   (sar.related_shape_aspect\shape_aspect.description IN ['secondary surface']))))) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'STRATUM_SURFACE' IN TYPEOF (sar.relating_shape_aspect)) AND
    (sar.relating_shape_aspect\shape_aspect.description IN ['primary surface']))))) = 0;
END_RULE; -- adjacent_stratum_surface_definition_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
If shape_aspect_relationship.name = 'adjacent stratum surface definition' the 
shape_aspect_relationship.related_shape_aspect shall be a stratum_surface 
with a description of 'secondary surface'.
</formal.propositions.rul>
<formal.propositions.rul>
If shape_aspect_relationship.name = 'adjacent stratum surface definition' the 
shape_aspect_relationship.relating_shape_aspect shall be a stratum_surface 
with a description of 'primary surface'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="adjacent_stratum_surface_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The adjacent_stratum_surface_definition_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
adjacent_stratum_surface_definition, so that the ARM name shall be unique
and that the combination of ARM precedent_surface and ARM subsequent_surface
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE adjacent_stratum_surface_definition_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  assd : BAG OF shape_aspect_relationship := 
      QUERY( sar <* shape_aspect_relationship
| (sar\shape_aspect_relationship.description = 'adjacent stratum surface definition') );
  pass1 : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
  pss_bag : BAG OF stratum_surface := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass2 : BOOLEAN := TRUE;
  sss_bag : BAG OF stratum_surface;
END_LOCAL;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i]\shape_aspect_relationship.name ) THEN
    IF ( assd[i]\shape_aspect_relationship.name IN name_bag ) THEN
      pass1 := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + assd[i]\shape_aspect_relationship.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i].relating_shape_aspect ) THEN
    IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_SURFACE' IN TYPEOF(assd[i].relating_shape_aspect) ) THEN
      IF( NOT( assd[i].relating_shape_aspect IN pss_bag ) ) THEN
        pss_bag := pss_bag + assd[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pss_bag) by 1;
  IF ( NOT pass2 ) THEN ESCAPE;
  END_IF;
  sss_bag := [];
  sar_bag := QUERY( sar <* assd | (sar.relating_shape_aspect :=: 
              pss_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_SURFACE' IN TYPEOF(assd[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sss_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          sss_bag := sss_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- adjacent_stratum_surface_definition_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of
'adjacent stratum surface definition' must have a unique name attribute.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of
'adjacent stratum surface definition' must have a unique combination of
relating_shape_aspect and related_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="aggregate_connectivity_requirement_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The aggregate_connectivity_requirement_unique_constraint rule constrains
product_definition_relationship population members, that fill the role
of ARM aggregate_connectivity_requirement, so that the ARM
design_definition_path attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE aggregate_connectivity_requirement_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  acr : BAG OF product_definition_relationship := 
                     QUERY( pdr <* product_definition_relationship |
                     (pdr\product_definition_relationship.name = 'aggregate connectivity requirement') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].related_product_definition ) THEN
    IF ( acr[i].id = 'design composition path' ) THEN
      IF ( acr[i].related_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + acr[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- aggregate_connectivity_requirement_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'aggregate connectivity requirement' must have a unique
related_product_definition attribute that points to a
product_definition with an id of 'design composition path'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="analytical_model_port_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The analytical_model_port_unique_constraint rule constrains the analytical_model_port
population members, that fill the role of ARM analytical_model_port, so that the
combination of ARM port_name and ARM accessed_analytical_model attributes shall be
unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE analytical_model_port_unique_constraint FOR
 ( analytical_model_port );
LOCAL
  name_bag : BAG OF STRING := [];
  amp_bag : BAG OF analytical_model_port;
  rr_bag : BAG OF representation_relationship;
  pass : BOOLEAN := TRUE;
  am_bag : BAG OF analytical_model;
END_LOCAL;

REPEAT i := 1 to SIZEOF(analytical_model_port) by 1;
  IF EXISTS( analytical_model_port[i].name ) THEN
    IF( NOT( analytical_model_port[i].name IN name_bag ) ) THEN
      name_bag := name_bag + analytical_model_port[i].name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  amp_bag := QUERY( amp <* analytical_model_port | 
          (amp\representation.name = name_bag[i]) );
  am_bag := [];
  REPEAT j := 1 to SIZEOF(amp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rr_bag := QUERY( rr <* USEDIN( amp_bag[j], 
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'REPRESENTATION_RELATIONSHIP.REP_2' ) | ((rr\representation_relationship.name = 'access mechanism') 
 AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1))) );
    REPEAT k := 1 to SIZEOF(rr_bag) by 1;
      IF EXISTS( rr_bag[k].rep_1 ) THEN
        IF ( rr_bag[k].rep_1 IN am_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          am_bag := am_bag + rr_bag[k].rep_1;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- analytical_model_port_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of analytical_model_port must have a unique combination of name
attribute and analytical_model entity assigned to the analytical_model_port by a
representation_relationship with a name of 'access mechanism'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="analytical_model_vector_port_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The analytical_model_vector_port_assignment_constraint rule constrains the
definition of the property_definition_representation to ensure that
there will be an ordered list of assigned_functional_unit_terminals.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE analytical_model_vector_port_assignment_constraint FOR
(property_definition_representation);
END_RULE; -- analytical_model_vector_port_assignment_constraint
*)
(*
</EXPRESS.CODE>
<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
IF the property_definition_representation.used_representation [is an
analytical_model_port] [is an items of a group_assignment that has a
name = ('vector port') ('digital vector port')] THEN
property_definition_representation.definition.description shall be an
integer greater than or equal to 0.
</INFORMAL.PROPOSITIONS.RUL>
<INFORMAL.PROPOSITIONS.RUL>
IF the property_definition_representation.used_representation [is an
analytical_model_port] [is an items of a group_assignment that has a
name = ('vector port') ('digital vector port')] THEN
the combination of the property_definition_representation.used_representation
and property_definition_representation.definition.description shall be
unique.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="angular_dimension_with_direction_vector_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The angular_dimension_with_direction_vector_unique_constraint rule constrains the
angular_dimension_with_orientation population members, that fill the role of ARM
angular_dimension_with_direction_vector, so that the ARM measurement_orientation
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE angular_dimension_with_direction_vector_unique_constraint FOR
 ( angular_dimension_with_orientation );
LOCAL
  p_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(angular_dimension_with_orientation) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  p_bag := QUERY( pd <* USEDIN(angular_dimension_with_orientation[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
         'dimensional location property') );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN(p_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'measurement orientation') AND
(pdr.related_property_definition\property_definition.description = 
        'datum based vector orientation')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS(  pdr_bag[k].related_property_definition ) THEN
        IF ( pdr_bag[k].related_property_definition IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + pdr_bag[k].related_property_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- angular_dimension_with_direction_vector__unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of angular_dimension_with_orientation must have a
unique property_definition entity with a name of 'datum based vector orientation'
that is related to the angular_dimension_with_orientation by a
property_definition_relationship with a name of 'measurement orientation'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="angular_size_dimension_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The angular_size_dimension_constraint rule constrains the use of an angular_size when it is used as an angular size dimension.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE angular_size_dimension_constraint FOR
  (angular_size);
END_RULE; -- angular_size_dimension_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each angular_size shall be represented by exactly zero shape_dimension_representation that contain at least one representation_item that has a name that is neither 'full angle' nor 'half angle'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each angular_size shall be represented by exactly zero shape_dimension_representation that contains a representation_item with the name of 'full angle' and a representation_item with a name of 'half angle'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each angular_size shall have a name of 'angular'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="application_context_requires_ap_definition">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The application_context_requires_ap_definition rule assures that each
instance of application_context has an application_protocol_definition with
name equal to 'electronic_assembly_interconnect_and_packaging_design'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE application_context_requires_ap_definition FOR
  (application_context, application_protocol_definition);
WHERE
  WR1: SIZEOF (QUERY (ac <* application_context |
       NOT (SIZEOF (QUERY (apd <* application_protocol_definition |
       (ac :=: apd\application_protocol_definition.application)
       AND
       (apd\application_protocol_definition.application_interpreted_model_schema_name =
         'electronic_assembly_interconnect_and_packaging_design'
       ))) = 1 ))) = 0;
END_RULE; --application_context_requires_ap_definition
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of application_context, there shall be exactly one
instance of application_protocol_definition that references the instance of
application_context as its application with a value of
'electronic_assembly_interconnect_and_packaging_design' as its application_interpreted_model_schema_name.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="approval_requires_approval_date_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approval_requires_approval_date_time rule assures that each instance of approval
has an associated date or time. 
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approval_requires_approval_date_time FOR (approval,
         approval_date_time);
WHERE
  WR1: SIZEOF(QUERY ( app <* approval |
       NOT (SIZEOF (QUERY (adt <* approval_date_time |
       app :=: adt.dated_approval)) = 1))) = 0;
END_RULE; -- approval_requires_approval_date_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, there shall be exactly one instance of
approval_date_time.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="approval_requires_approval_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approval_requires_approval_person_organization rule assures that for each
instance of approval there is an organization or person that is 
responsible for that approval.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approval_requires_approval_person_organization FOR (approval,
         approval_person_organization);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (apo <* approval_person_organization |
       app :=: apo.authorized_approval)) >= 1))) = 0;
END_RULE; -- approval_requires_approval_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, there shall be one or more instances of
approval_person_organization.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="approval_role_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approval_role_constraint rule assures that each
approval_role has a role that is 'authorizer'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approval_role_constraint FOR
  (approval_role);
WHERE
  WR1: SIZEOF (QUERY (apr <* approval_role |
       NOT (apr\approval_role.role = 'authorizer')
       )) = 0;
END_RULE; -- approval_role_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval_role, the role shall be 'authorizer'. 
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="approvals_are_assigned">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approvals_are_assigned rule assures that each
approval is referenced by at least one approval_assignment as
assigned_approval.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approvals_are_assigned FOR
  (approval, approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (aa <* approval_assignment |
       app :=: aa.assigned_approval )) >= 1 ))) = 0;
END_RULE; -- approvals_are_assigned
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, there shall be one or more instances of
approval_assignment.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_alternate_product_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_alternate_product_constraint rule constrains the base of
alternate_product_relationship when it is used as an assembly alternate
product.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE assembly_alternate_product_constraint FOR 
(alternate_product_relationship);
END_RULE; --assembly_alternate_product_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
IF alternate_product_relationship.basis = 
'assembly alternate product' THEN alternate_product_relationship.base 
shall be a product which is the related_product_definition of an 
assembly_component_usage whose relating_product_definition {is a 
physical_unit} {has a frame_of_reference of an 
application_context_element where application_context_element.name = 
'physical design'}.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_composition_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_composition_relationship_unique_constraint rule constrains
assembly_component_usage population members, that fill the role of ARM
assembly_composition_relationship, so that the combination of ARM assembly
and ARM component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE assembly_composition_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  acr : BAG OF assembly_component_usage := 
 QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'assembly composition') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  cd_bag : BAG OF component_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].relating_product_definition ) THEN
    IF( (acr[i].relating_product_definition.frame_of_reference.name = 
         'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(acr[i].relating_product_definition)) ) THEN
      IF ( NOT ( acr[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + acr[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cd_bag := [];
  acu_bag := QUERY( acu <* acr | (acu.relating_product_definition :=: 
                               pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].related_product_definition ) THEN
      IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN 
             TYPEOF(acu_bag[j].related_product_definition) ) THEN
        IF ( acu_bag[j].related_product_definition IN cd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          cd_bag := cd_bag + acu_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- assembly_composition_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of assembly_component_usage with a name of
'assembly composition' must have a unique combination of
related_product_definition and relating_product_definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_module_usage_view_connector_relationship_unique_constraint">
<RULE.DESCRIPTION>
The assembly_module_usage_view_connector_relationship_unique_constraint rule constrains
assembly_module_usage_view_connector_relationship population members, that fill the
role of ARM assembly_module_usage_view_connector_relationship, so that the combination
of ARM externally_visible_partial_reference_designation and ARM associating_usage
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE assembly_module_usage_view_connector_relationship_unique_constraint FOR
 ( assembly_module_usage_view_connector_relationship );
LOCAL
  r_bag : BAG OF representation;
  pdr_bag : BAG OF property_definition_representation;
  pu_bag : BAG OF physical_unit := [];
  pd_bag : BAG OF property_definition;
  amuvcr : BAG OF assembly_module_usage_view_connector_relationship;
  rr_bag : BAG OF representation_relationship;
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to 
         SIZEOF(assembly_module_usage_view_connector_relationship) by 1;
  r_bag := USEDIN(assembly_module_usage_view_connector_relationship[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                                   'REPRESENTATION.ITEMS');
  REPEAT j := 1 to SIZEOF(r_bag) by 1;
    pdr_bag := QUERY( pdr <* USEDIN(r_bag[j], 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | (
( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(pdr.definition.definition)) AND
(pdr.definition.definition.frame_of_reference.name = 
                              'physical design usage') AND 
(pdr.definition.definition\product_definition.name = 'assembly module')
));
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].definition.definition ) THEN
        IF( NOT( pdr_bag[k].definition.definition IN pu_bag ) ) THEN
          pu_bag := pu_bag + pdr_bag[k].definition.definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  desc_bag := [];
  pd_bag := USEDIN(pu_bag[i],
          'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION');
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := USEDIN( pd_bag[j], 
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      amuvcr := 
        QUERY( r <* assembly_module_usage_view_connector_relationship |
(r IN pdr_bag[k].used_representation.items) );
      REPEAT l := 1 to SIZEOF(amuvcr) by 1;
        IF ( NOT pass ) THEN ESCAPE;
        END_IF;
        r_bag := USEDIN( amuvcr[l], 
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'REPRESENTATION.ITEMS' );
        REPEAT m := 1 to SIZEOF(r_bag) by 1;
          IF ( NOT pass ) THEN ESCAPE;
          END_IF;
          rr_bag := QUERY( rr <* USEDIN(r_bag[m],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'REPRESENTATION_RELATIONSHIP.REP_2') | 
((rr\representation_relationship.name = 'reference designation assignment') AND
(rr.rep_1\representation.name = 'externally visible partial reference designation') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(rr.rep_1.items[1])) AND
(rr.rep_1.items[1]\representation_item.name = 'partial reference designation')) );
          REPEAT n := 1 to SIZEOF(rr_bag) by 1;
            IF EXISTS( rr_bag[n].rep_1.items[1]\descriptive_representation_item.description ) THEN
              IF ( rr_bag[n].rep_1.items[1]\descriptive_representation_item.description IN desc_bag ) THEN
                pass := FALSE;
                ESCAPE;
              ELSE
                desc_bag := desc_bag + rr_bag[n].rep_1.items[1]\descriptive_representation_item.description;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- assembly_module_usage_view_connector_relationship_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of assembly_module_usage_view_connector_relationship must have
a unique combination of physical_unit entity and descriptive_representation_item
description attribute where the physical_unit is related to the
assembly_module_usage_view_connector_relationship by a property_definition_representation
and the descriptive_representation_item has a name of 'partial reference designation'
and is related to the assembly_module_usage_view_connector_relationship by a
representation_relationship with a name of 'reference designation assignment'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_requirement_allocation_constraint rule constrains the related and 
relating shape_aspect or product_definition when the shape_aspect_relationship 
or the product_definition_relationship is being used as an assembly requirement.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE assembly_requirement_allocation_constraint FOR 
( shape_aspect_relationship,
product_definition_relationship );
END_RULE; -- assembly_requirement_allocation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'assembly requirement allocation'
the related_shape_aspect must be a
(component_terminal)
(component_interface_terminal)
(component_shape_aspect whose description is ('component feature')
   ('component termination passage interface terminal')
   ('land interface terminal')
   ('non functional land interface terminal')
   ('printed connector component interface terminal'))
or it shall be an assembly_joint.
</Informal.propositions.rul>

<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'assembly requirement allocation'
the relating_shape_aspect shall have a {of_shape with a property_definition
with a definition that is a product_definition with a frame_of_reference
that is a application_context_element with a name of 'assembly requirement'}
and a definition for a property_definition that is a requirements_property.
</Informal.propositions.rul> 

<Informal.propositions.rul>
IF product_definition_relationship.name = 'assembly requirement allocation'
the related_product_definition shall be a component_definition.
</Informal.propositions.rul>  

<Informal.propositions.rul>
IF product_definition_relationship.name = 'assembly requirement allocation' 
the relating_product_definition shall have a {frame_of_reference with a 
that is a application_context_element with a name of 'assembly requirement'}
and a definition for a property_definition that is a requirements_property.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_separation_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_separation_requirement_allocation_constraint rule constrains the
related_shape_aspect of a shape_aspect_relationship when it is being used as
an assembly separation requirement.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE assembly_separation_requirement_allocation_constraint FOR 
( shape_aspect_relationship );
END_RULE; -- assembly_separation_requirement_allocation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'assembly separation requirement'
the related_shape_aspect shall be a
(component_terminal) 
(component_interface_terminal) 
(component_shape_aspect whose description is 
   ('component feature') 
   ('component termination passage interface terminal') 
   ('land interface terminal') 
   ('non functional land interface terminal') 
   ('printed connector component interface terminal')) or the related_shape_aspect
shall be an assembly_joint.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="bare_die_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The bare_die_unique_constraint rule constrains the bare_die,
externally_defined_bare_die and library_defined_bare_die population members, that
fill the role of ARM bare_die, so the combination of ARM implemented_function and
ARM used_package shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE bare_die_unique_constraint FOR
 ( bare_die, externally_defined_bare_die, library_defined_bare_die );
LOCAL
  bd : BAG OF physical_unit := QUERY( r <* bare_die |
(r.frame_of_reference.name = 'physical design usage') );
  edbd : BAG OF physical_unit := QUERY( r <* externally_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') );
  ldbd : BAG OF physical_unit := QUERY( r <* library_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') );
  pu : BAG OF physical_unit;
  pdr_bag : BAG OF product_definition_relationship;
  fu_bag : BAG OF functional_unit := [];
  pu_bag : BAG OF physical_unit;
  ut_bag : BAG OF property_definition;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition;
END_LOCAL;

pu := bd + edbd + ldbd;
REPEAT i := 1 to SIZEOF(pu) by 1;
  pdr_bag := QUERY( pdr <* USEDIN( pu[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
( (pdr\product_definition_relationship.name = 'implemented function') AND
(pdr.relating_product_definition.frame_of_reference.name = 
         'functional design usage')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) ) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].relating_product_definition ) THEN
      IF( NOT( pdr_bag[j].relating_product_definition IN fu_bag ) ) THEN
        fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pu_bag := QUERY( r <* pu | (SIZEOF(QUERY(pdr <* USEDIN( fu_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION' ) |
((pdr\product_definition_relationship.name = 'implemented function')AND
        (pdr.related_product_definition :=: r)) ))>0) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(pu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ut_bag := QUERY( pd <* USEDIN( pu_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION' ) | (pd\property_definition.name = 'unit technology') );
    REPEAT k := 1 to SIZEOF(ut_bag) by 1;
      IF EXISTS( ut_bag[k] ) THEN
        IF ( ut_bag[k] IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + ut_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- bare_die_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of bare_die, externally_defined_bare_die and library_defined_bare_die
must have a unique combination of functional_unit entity related by an
'implemented function' product_definition_relationship and a property_definition entity
with a name of 'unit technology' whose definition attribute points to the bare_die,
externally_defined_bare_die and library_defined_bare_die.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="bevel_edge_feature_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The bevel_edge_feature_shape_constraint rule requires maximum
and minimum bevel width and bevel angles to be assigned to a 
shape_representation when it is being used as a bevel edge feature shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE bevel_edge_feature_shape_constraint FOR ( shape_representation );
END_RULE; -- bevel_edge_feature_shape_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
For each shape_representation\ representation.name = 
'bevel edge feature shape' there shall be exactly one representation_item 
that is a length_measure_with_unit where representation_item.name = 
'maximum bevel width' assigned to representation.items.
</Informal.propositions.rul>
<Informal.propositions.rul>
For each shape_representation\ representation.name = 'bevel edge feature shape'
there shall be exactly one representation_item which is a 
length_measure_with_unit where representation_item.name = 'minimum bevel width'
assigned to representation.items.
</Informal.propositions.rul> 
<Informal.propositions.rul>
For each shape_representation\ representation.name = 'bevel edge feature shape'
there shall be exactly one representation_item which is a 
plane_angle_measure_with_unit where representation_item.name = 
'maximum bevel angle' assigned to representation.items.
</Informal.propositions.rul>  
<Informal.propositions.rul>
For each shape_representation\ representation.name = 'bevel edge feature shape'
there shall be exactly one representation_item which is a 
plane_angle_measure_with_unit where representation_item.name = 
'minimum bevel angle' assigned to representation.items.
</Informal.propositions.rul>
<Informal.propositions.rul>
This representation shall only be a representation of the shape of
an edge segment of the interconnect product.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="boundary_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The boundary_size_characteristic_constraint rule constrains the use of a representation when it is used as a boundary size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE boundary_size_characteristic_constraint FOR
  (representation);
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'diametrical boundary size')
        OR (rep\representation.name = 'opposing boundary set size'))
       AND (NOT(SIZEOF(QUERY(lmwu <* rep.items |
       (lmwu\representation_item.name = 'tolerance value'))) = 1)))) = 0;
END_RULE; -- boundary_size_characteristic_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each representation with a name of either 'diametrical boundary size' or 'opposing boundary set size' shall contain exactly one length_measure_with_unit that has a name of 'tolerance value'.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name of either 'diametrical boundary size' or 'opposing boundary set size' shall contain exactly one length_measure_with_unit that has a name of 'tolerance value', and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the physical_unit_geometric_tolerance that is specified as the defining_tolerance by the tolerance_zone that is specified as the zone by the tolerance_zone_definition that specifies the tolerance_zone_boundary as its boundaries and the property_definition of which has a description of 'boundary zone definition with specified size' and is represented by the instance of representation with a name of either 'diametrical boundary size' or 'opposing boundary set size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="boundary_zone_definition_with_specified_size_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The boundary_zone_definition_with_specified_size_constraint rule constrains the use of a property_definition when it is used as a boundary zone definition with specified size.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE boundary_zone_definition_with_specified_size_constraint FOR
  (property_definition);
END_RULE; -- boundary_zone_definition_with_specified_size_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' shall be a property_definition of a tolerance_zone_boundary.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' shall have exactly one representation with a name of either 'diametrical boundary size' or 'opposing boundary set size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="bus_structural_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The bus_strucutral_definition_unique_constraint rule constrains the product.name population members to satisfy the uniqueness requirement of the ARM application object Bus_structural_definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)

RULE bus_structural_definition_unique_constraint FOR 
(bus_structural_definition, product_definition_formation, product);

LOCAL
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(bus_structural_definition) by 1;
  IF EXISTS( bus_structural_definition[i].formation.of_product.name ) THEN
    IF (bus_structural_definition[i].formation.of_product.name IN 
                                                       name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + 
bus_structural_definition[i]\product_definition.formation.of_product.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1: pass;

END_RULE; -- bus_structural_definition_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The product.name shall be unique within a population of bus_structural_definition.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="cartesian_coordinate_system_constraint">
<RULE.DESCRIPTION>
The cartesian_coordinate_system_constraint rule requires the units of
a global_unit_assigned_context to at least include a length_unit and a
plane_angle_unit when the global_unit_assigned_context is also a geometric_representation_context
and is a global_uncertainty_assigned_context.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE cartesian_coordinate_system_constraint FOR 
    (global_unit_assigned_context,
     geometric_representation_context,
     global_uncertainty_assigned_context);
LOCAL
  guac_inst : SET OF global_unit_assigned_context := 
              QUERY ( guac <* global_unit_assigned_context |
            ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (guac)) AND
            ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN TYPEOF (guac)));
END_LOCAL;
WHERE
  WR1: SIZEOF (QUERY (guac <* guac_inst |
       NOT (SIZEOF (guac.units) <= 3))) = 0;
  WR2: SIZEOF (QUERY (guac <* guac_inst | (NOT (
       (SIZEOF (QUERY (u <* guac.units |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT'
       IN TYPEOF (u)))) = 1) 
       AND 
       (SIZEOF (QUERY (u <* guac.units |
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PLANE_ANGLE_UNIT'
       IN TYPEOF (u)))) = 1) 
       AND
       (SIZEOF (QUERY (u <* guac.units |
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SOLID_ANGLE_UNIT'
       IN TYPEOF (u)) )) <= 1)
       )))) = 0;
  WR3: SIZEOF( QUERY( grc <* guac_inst |
       NOT( (grc.coordinate_space_dimension = 2) OR
       (grc.coordinate_space_dimension = 3)))) = 0;
  WR4: SIZEOF (QUERY (guac <* guac_inst |
       NOT ((SIZEOF (QUERY (u <* guac.uncertainty |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (u))) = 1)))) = 0;
  WR5: SIZEOF (QUERY (guac <* guac_inst | 
       NOT (SIZEOF (QUERY (u <* guac.units |NOT(
   NOT((
    'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'PLANE_ANGLE_UNIT' IN TYPEOF(u)) AND
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'CONVERSION_BASED_UNIT' IN TYPEOF(u)) AND
    (u\conversion_based_unit.name = 'degree'))
  OR
      ((abs(u\conversion_based_unit.
          conversion_factor\measure_with_unit.value_component - 
              0.0174532925) <= 0.001) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PLANE_ANGLE_MEASURE_WITH_UNIT' 
       IN TYPEOF(u\conversion_based_unit.conversion_factor)))
  ))) = 0)
  )) = 0;
END_RULE; -- cartesian_coordinate_system_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of global_unit_assigned_context implementing the arm Cartesian_coordinate_system, the set of units 
shall contain a maximum of 3 elements.
</formal.propositions.rul>
<formal.propositions.rul>
For each instance of global_unit_assigned_context implementing the arm Cartesian_coordinate_system, exactly one element of
the set of units shall be a length_unit, exactly one element of the set of
units shall be a plane_angle_unit where the unit is either radian or degree, 
and no more than one element of the set of units shall be a solid_angle_unit.
</formal.propositions.rul>
<formal.propositions.rul>
Each geometric_representation_context implementing the arm Cartesian_coordinate_system, the coordinate_space_dimension shall
have a value of 2 or 3.
</formal.propositions.rul>
<formal.propositions.rul>
For each global_uncertainty_assigned_context implementing the arm Cartesian_coordinate_system, exactly one element 
of the set of uncertainty shall be a length_measure_with_unit.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="cartesian_transformation_operator_2d_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The cartesian_transformation_operator_2d_constraint rule requires the units of
a global_unit_assigned_context to at least include a length_unit and a
plane_angle_unit and a scale greater than zero.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE cartesian_transformation_operator_2d_constraint FOR 
                  (cartesian_transformation_operator_2d);
WHERE
  WR1: SIZEOF(QUERY ( cto2 <* cartesian_transformation_operator_2d |  NOT(
       EXISTS(cto2.axis1) AND EXISTS(cto2.axis2)
       AND (cto2.scale > 0.0 )))) = 0;
END_RULE; -- cartesian_transformation_operator_2d_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Axis1 and axis2 shall exist and the scale value shall be greater than 0.0.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="centre_of_symmetry_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The centre_of_symmetry_constraint rule constrains the use of a centre_of_symmetry when it is used as a centre of symmetry.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE centre_of_symmetry_constraint FOR
  (centre_of_symmetry);
END_RULE; -- centre_of_symmetry_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each centre_of_symmetry shall have description of either 'axis', 'plane', or 'point'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="certification_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The certification_requires_date_or_date_and_time rule assures that
each certification has an associated applied_date_assignment or
an applied_date_and_time_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE certification_requires_date_or_date_and_time FOR
  (certification, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (cert <* certification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       cert IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       cert IN ada.items )) = 1 )))) = 0;
END_RULE; -- certification_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of certification, exactly one instance of
applied_date_and_time_assignment or exactly one instance of
applied_date_assignment shall contain the instance of certification in its
set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="certification_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The certification_unique_constraint rule constrains the certification.name population members to satisfy the uniqueness requirement of the ARM application object Certification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)

RULE certification_unique_constraint FOR (certification);

LOCAL
  r :  BAG OF certification := QUERY (r <* certification | TRUE);
  pass :  BOOLEAN := TRUE;
  name_bag :  BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\certification.name ) THEN
    IF (r[i]\certification.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\certification.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1:  pass;

END_RULE; -- certification_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of certification.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="change_design_object_management_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The change_design_object_management_relationship_unique_constraint rule constrains
the change_from_design_object_assignment, change_from_design_object_request_assignment,
change_to_design_object_assignment and change_to_design_object_request_assignment population
members, that fill the role of ARM change_design_object_management_relationship, so
that the combination of ARM current_design and ARM current_design_object attributes
shall be unique within the population and that the combination of ARM previous_design
and ARM previous_design_object attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE change_design_object_management_relationship_unique_constraint FOR
 (  change_from_design_object_assignment, 
 change_from_design_object_request_assignment,
change_to_design_object_assignment, 
change_to_design_object_request_assignment );
LOCAL
  pd_bag : BAG OF product_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  ctdoa_bag : BAG OF change_to_design_object_assignment;
  ctdora_bag : BAG OF change_to_design_object_request_assignment;
  cfdoa_bag : BAG OF change_from_design_object_assignment;
  cfdora_bag : BAG OF change_from_design_object_request_assignment;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(change_from_design_object_assignment) by 1;
  REPEAT j := 1 TO 
          SIZEOF(change_from_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
     TYPEOF(change_from_design_object_assignment[i].items[j]))
AND (change_from_design_object_assignment[i].items[j].name = 
                                   'design object change') ) THEN
      IF EXISTS
( change_from_design_object_assignment[i].items[j].
 relating_product_definition ) 
                                                             THEN
        IF( NOT
          ( change_from_design_object_assignment[i].items[j].
                               relating_product_definition 
                                               IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
            change_from_design_object_assignment[i].items[j].
                               relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to 
         SIZEOF(change_from_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
       SIZEOF(change_from_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(change_from_design_object_request_assignment[i].items[j]))
AND (change_from_design_object_request_assignment[i].items[j].name = 
                      'design object change') ) THEN
      IF EXISTS
  ( change_from_design_object_request_assignment[i].items[j].
                                    relating_product_definition )
                                                THEN
        IF( NOT
  ( change_from_design_object_request_assignment[i].items[j].
                                       relating_product_definition 
                                          IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
    change_from_design_object_request_assignment[i].items[j].
                                      relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT (pass1 AND pass2) ) THEN ESCAPE;
  END_IF;
  IF ( pass1 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
        (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdoa_bag := QUERY( ctdoa <* change_to_design_object_assignment | 
                (pdr_bag[j] IN ctdoa.items) );
      REPEAT k := 1 to SIZEOF(ctdoa_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdoa_bag[k].items) by 1;
          IF EXISTS( ctdoa_bag[k].items[l] ) THEN
            IF ( ctdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdora_bag := 
         QUERY( ctdora <* change_to_design_object_request_assignment | 
                    (pdr_bag[j] IN ctdora.items) );
      REPEAT k := 1 to SIZEOF(ctdora_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdora_bag[k].items) by 1;
          IF EXISTS( ctdora_bag[k].items[l] ) THEN
            IF ( ctdora_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  IF ( pass2 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
   (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdoa_bag := QUERY( cfdoa <* change_from_design_object_assignment | 
                                           (pdr_bag[j] IN cfdoa.items) );
      REPEAT k := 1 to SIZEOF(cfdoa_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdoa_bag[k].items) by 1;
          IF EXISTS( cfdoa_bag[k].items[l] ) THEN
            IF ( cfdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdora_bag := 
        QUERY( cfdora <* change_from_design_object_request_assignment | 
                                        (pdr_bag[j] IN cfdora.items) );
      REPEAT k := 1 to SIZEOF(cfdora_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdora_bag[k].items) by 1;
          IF EXISTS( cfdora_bag[k].items[l] ) THEN
            IF ( cfdora_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- change_design_object_management_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of change_to_design_object_assignment and change_to_design_object_request_assignment
that has a common product_definition that is the related_product_definition of a
product_definition_relationship that has a name of 'design object change' where the
product_definition_relationship is a member of the items attribute of the
change_to_design_object_assignment and change_to_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of change_from_design_object_assignment and change_from_design_object_request_assignment
that has a common product_definition that is the relating_product_definition of a
product_definition_relationship that has a name of 'design object change' where the
product_definition_relationship is a member of the items attribute of the
change_from_design_object_assignment and change_from_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="change_request_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The change_request_unique_constraint rule constrains the versioned_action_request
population members, that fill the role of ARM change_request, so that the
combination of ARM version and ARM work_request_id attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE change_request_unique_constraint FOR
 ( versioned_action_request );
LOCAL
  cr : BAG OF versioned_action_request := 
          QUERY( v <* versioned_action_request
               | (SIZEOF(QUERY(ara <* 
USEDIN(v,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')|(
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CHANGE_REQUEST' IN TYPEOF(ara)) ))>0) );
  version_bag : BAG OF STRING := [];
  var_bag : BAG OF versioned_action_request;
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(versioned_action_request) by 1;
  IF EXISTS( versioned_action_request[i].version ) THEN
    IF( NOT( versioned_action_request[i].version IN version_bag ) ) THEN
      version_bag := version_bag + versioned_action_request[i].version;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(version_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  var_bag := QUERY( v <* versioned_action_request | 
                       (v\versioned_action_request.version = version_bag[i]) );
  id_bag := [];
  REPEAT j := 1 to SIZEOF(var_bag) by 1;
    IF EXISTS( var_bag[j].id ) THEN
      IF ( var_bag[j].id IN id_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        id_bag := id_bag + var_bag[j].id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- change_request_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of versioned_action_request that is the assigned_action_request
of a change_request entity must have a unique combination of version and id
attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The characteristic_constraint rule constrains the use of a
representation_item or a measure_representation_item when it is used as a characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE characteristic_constraint FOR
  (representation_item, measure_representation_item);
END_RULE; -- characteristic_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation_item that is supporting the ARM concept of 
a characteristic shall be specified as the item in an 
applied_document_reference.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="unique_characterized_product_category">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The characterized_product_category_unique_constraint rule constrains the characterized_product_category 
members so that the combination of name inherited from product_category and the document referenced by applied_document_reference
assigned_document shall be unique within those members.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE characterized_product_category_unique_constraint FOR
                  (characterized_product_category); 
LOCAL 
  adr : BAG OF applied_document_reference := []; 
  documents : BAG OF document := []; 
  labels : BAG OF label := []; 
  pass : BOOLEAN := TRUE;
  size_of : BAG OF INTEGER := [];
END_LOCAL;
  -- build the set of applied_document_reference that reference characterized_product_category.
  -- build the set of labels that characterized_product_category references as name.

  REPEAT i := 1 TO SIZEOF(characterized_product_category);
   adr := adr + USEDIN(characterized_product_category[i],
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'APPLIED_DOCUMENT_REFERENCE.ITEMS');
    labels := labels + characterized_product_category[i]\product_category.name;
  END_REPEAT;

  IF SIZEOF(adr) <> SIZEOF(labels)
  THEN pass := FALSE;
  END_IF;

  REPEAT k := 1 TO SIZEOF(adr);
    documents := documents + adr[k]\document_reference.assigned_document;
  END_REPEAT;
  
  IF SIZEOF(documents) <> SIZEOF(labels)
  THEN pass := FALSE;
  END_IF;
 
  -- check that each label is related to one and only one instance of document 
  -- check that each document is related to one and only one label
  REPEAT i := 1 to SIZEOF(labels);
   REPEAT j := 1 to SIZEOF(documents);
    REPEAT k := 1 to SIZEOF(adr);
     IF ((labels[i] = adr[k].items[1]\product_category.name) AND
        (documents[j] = adr[k]\document_reference.assigned_document))
     THEN
       size_of[i] := size_of[i] + 1;
     END_IF;
    END_REPEAT;
   END_REPEAT;
  END_REPEAT;
 REPEAT i := 1 to SIZEOF(labels);
  IF (size_of[i] <> 1)
  THEN pass := FALSE;
  END_IF;
 END_REPEAT;
 
WHERE
  WR1: pass;
END_RULE; -- via_template_terminal_unique_constraint 
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
No more than one instance of characterized_product_category shall relate a specific product_category.name to a specific document through applied_document_reference.
<note>
The same label may be used for different characterized_product_category when different documents are referenced.  This is the mechanism that permits category names to be isolated in the different contexts established by different dictionaries.
</note>
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_external_reference_constraint rule constrains the use of a representation when it is used as a component external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_external_reference_constraint FOR
  (representation);
WHERE
   WR1: SIZEOF( QUERY( rep <* representation | (rep\representation.name =
        'component external reference') AND 
        (SIZEOF( QUERY( dri <* rep.items | NOT(
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'design owner')))) = 1)))=0;
   WR2: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'part number')))) = 1)))=0;
   WR3: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'revision code')))) = 1)))=0;
   WR4: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'product definition id')))) = 1)))=0;
   WR5: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'reference designation')))) = 1)))=0;
END_RULE; -- component_external_reference_constraint
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'design owner'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'part number'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'revision code'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'product definition id'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'reference designation'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_external_reference_constraint rule constrains the use of a
descriptive_representation_item when it is used as a component feature external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE component_feature_external_reference_constraint FOR
  (descriptive_representation_item);
END_RULE; -- component_feature_external_reference_constraint
*)
(*
</EXPRESS.CODE>
<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
Each descriptive_representation_item with a name of 'component feature external reference'
shall be a member of items for a representation with a name of `component external reference'.
</INFORMAL.PROPOSITIONS.RUL>
<INFORMAL.PROPOSITIONS.RUL>
For each descriptive_representation_item with a name of 'component feature external reference'
the combination of the its description and the representation with a name of 
`component external reference' of which it is a member of items shall be unique.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_external_reference_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_external_reference_unique_constraint rule constrains the
property_definition_representation population members, that fill the role of ARM
component_feature_external_reference, so that the combination of ARM name
and ARM associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_feature_external_reference_unique_constraint FOR
 ( descriptive_representation_item );
LOCAL
  cfer : BAG OF descriptive_representation_item := 
      QUERY( dri <* descriptive_representation_item
| (dri\representation_item.name = 'component feature external reference') );
  desc_bag : BAG OF STRING := [];
  dri_bag : BAG OF descriptive_representation_item;
  rep_bag : BAG OF representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(cfer) by 1;
  IF EXISTS( cfer[i]\descriptive_representation_item.description ) THEN
    IF ( NOT ( cfer[i]\descriptive_representation_item.description IN desc_bag )) THEN
      desc_bag := desc_bag + cfer[i]\descriptive_representation_item.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(desc_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  r_bag := [];
  dri_bag := QUERY( dri <* cfer | (dri\descriptive_representation_item.description = desc_bag[i]) );
  REPEAT j := 1 to SIZEOF(dri_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rep_bag := QUERY( r <* USEDIN( dri_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'REPRESENTATION.ITEMS' ) | (r\representation.name = 'component external reference' ) );
    REPEAT k := 1 to SIZEOF(rep_bag) by 1;
      IF EXISTS( rep_bag[k] ) THEN
        IF ( rep_bag[k] IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + rep_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_feature_external_reference_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of descriptive_representation_item with a name of
'component feature external reference' must have a unique combination of
description attributes and representation entities where the representations
have the descriptive_representation_items in their items attribute and the
representations have a name of 'component external reference'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_to_layout_feature_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_to_layout_feature_relationship_constraint rule 
constrains the related and relating shape_aspect of a 
shape_aspect_relationship that is used as a component feature to layout feature.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_feature_to_layout_feature_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_TERMINAL']
       * TYPEOF(sar.relating_shape_aspect)) > 0)
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM_FEATURE']
       * TYPEOF(sar.related_shape_aspect)) > 0)
       )) = 0;
END_RULE; -- component_feature_to_layout_feature_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'component feature to layout feature'
the shape_aspect_relationship.relating_shape_aspect is a
(component_shape_aspect) 
(component_interface_terminal) 
(component_terminal).
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'component feature to layout feature'
the shape_aspect_relationship.related_shape_aspect is a 
(component_shape_aspect) 
(stratum_feature).
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_unique_constraint rule constrains the component_terminal
and component_interface_terminal population members, that fill the role of
ARM component_feature, so that the combination of ARM definition and ARM
associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_feature_unique_constraint FOR
 ( component_terminal, component_interface_terminal );
LOCAL
  ct : BAG OF shape_aspect := 
     QUERY( ct <* component_terminal | (ct\shape_aspect.description IN 
['assembly module component terminal',
'bare die component terminal',
'interconnect component join terminal',
'interconnect module component terminal',
'interconnect module component stratum based terminal',
'minimally defined component terminal',
'packaged component join terminal']) );
  cit : BAG OF shape_aspect := 
         QUERY( cit <* component_interface_terminal | (
cit\shape_aspect.description IN ['interconnect component interface terminal',
'packaged connector component interface terminal']) );
  cf : BAG OF shape_aspect;
  cd_bag : BAG OF component_definition := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  def_bag : BAG OF shape_aspect;
END_LOCAL;

cf := ct + cit;
REPEAT i := 1 to SIZEOF(cf) by 1;
  IF EXISTS( cf[i].of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN TYPEOF(cf[i].of_shape.definition) ) THEN
      IF ( NOT ( cf[i].of_shape.definition IN cd_bag )) THEN
        cd_bag := cd_bag + cf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  def_bag := [];
  sa_bag := QUERY( sa <* cf | (sa.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
             (sar\shape_aspect_relationship.name = 'instantiated feature') );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN def_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          def_bag := def_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_feature_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of 'assembly module component terminal',
'bare die component terminal', 'interconnect component join terminal',
'interconnect module component terminal', 'interconnect module component stratum based terminal',
'minimally defined component terminal' or 'packaged component join terminal' and
component_interface_terminal with a name of either 'interconnect component interface terminal'
or 'packaged connector component interface terminal' must have a unique combination of
of_shape.definition attributes and shape_aspect entities where the shape_aspects
are related to the component_terminals and component_interface_terminals by a
shape_aspect_relationship with a name of 'instantiated feature'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_mounting_clearance_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_mounting_clearance_relationship_constraint rule
constrain the items of a representation and constrain the usage of that 
representation when it is used as a component mounting clearance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_mounting_clearance_relationship_constraint FOR
( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'mounting clearance')
       AND (SIZEOF(QUERY(lmwu <* rep.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))
       AND (lmwu\representation_item.name = 'minimum height')
       )) = 0))) = 0;
END_RULE; -- component_mounting_clearance_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF the representation name = 'mounting clearance' it shall contain one item that 
is a length_measure_with_unit that has a name = 'minimum height'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF the representation name = 'mounting clearance' there shall be one 
property_definition_representation for which the representation is the 
used_representation and the definition for the 
property_definition_representation is a property_definition with a name 
equal to 'component mounting property', and the shape_aspect for the property_definition
is a component_feature_relationship.
</Informal.propositions.rul> 
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_overlap_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_overlap_relationship_constraint rule
constrain the items of a representation and constrain the usage of that 
representation when it is used as a component overlap clearance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_overlap_relationship_constraint FOR
( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'overlap clearance')
       AND (SIZEOF(QUERY(lmwu <* rep.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))
       AND (lmwu\representation_item.name = 'minimum clearance')
       )) = 0))) = 0;
END_RULE; -- component_overlap_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF the representation name = 'overlap clearance' it shall contain one item that 
is a length_measure_with_unit that has a name = 'minimum clearance'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF the representation name = 'overlap clearance' there shall be two 
property_definition_representations for which the representation is the 
used_representation and the definition for the 
property_definition_representations is a property_definition with a name 
equal to 'component mounting property' and one of the property_definitions 
has a description = 'current component' and the second property_definition
has a description = 'previously placed component'.
</Informal.propositions.rul> 
<Informal.propositions.rul> 
IF the representation name = 'overlap clearance' the two 
property_definition_representations for which the representation is the 
used_representation must have two 
product_definition_relationships which point to 
one product_definition.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_part_2d_geometric_representation_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_part_2d_geometric_representation_relationship_constraint rule 
constrains the rep_1 and rep_2 attributes of a shape_representation_relationship when it is used to relate a component planar shape and the defining part planar shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_part_2d_geometric_representation_relationship_constraint FOR 
( shape_representation_relationship );
LOCAL
 rr: SET OF representation_relationship :=
      QUERY ( srr <* shape_representation_relationship |
       srr\representation_relationship.name = 
                            'component part planar shape');
 pass: BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(rr) by 1;
IF ((rr[i].rep_1.context_of_items.coordinate_space_dimension) <>
          (rr[i].rep_2.context_of_items.coordinate_space_dimension))
THEN
  pass := FALSE;
END_IF;
END_REPEAT;
WHERE
 WR1: pass;
END_RULE; -- component_part_2d_geometric_-
          -- representation_relationship_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part planar shape' the representation_relationship.rep_1 shall
have the same dimensionality as representation_relationship.rep_2.
</Formal.propositions.rul>
</Formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part planar shape' the representation_relationship.rep_1 shall be 
a shape_representation with name = 'planar projected shape' that is the 
used_representation of a property_definition_representation where 
property_definition_representation references an instance through the definition attribute that
(is a physical_unit) 
(is a part_template_definition whose shape is defined by a 
characterized_object).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part planar shape' the representation_relationship.rep_2 shall be 
a shape_representation with name = 'planar projected shape' that is the 
used_representation of a property_definition_representation where 
({property_definition_representation definition is a product_definition_shape} 
{property_definition_representation references a product_definition that is a 
component_definition}) 
(property_definition_representation references a shape_aspect that is a 
component_shape_aspect).
</Informal.propositions.rul>
<Informal.propositions.rul>
The combination of representation_relationship.rep_1, 
representation_relationship.rep_2 shall be unique within a population
of representation_relationship with a representation_relationship 
name = 'component part planar shape'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="component_part_3d_geometric_representation_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_part_3d_geometric_representation_relationship_constraint rule 
constrains the rep_1 and rep_2 attributes of a 
shape_representation_relationship when it is used to relate a component 3d shape and the defining part 3d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_part_3d_geometric_representation_relationship_constraint FOR
( shape_representation_relationship );
LOCAL
 rr: SET OF representation_relationship :=
      QUERY ( srr <* shape_representation_relationship |
       srr\representation_relationship.name = 'component part 3d shape');
 pass: BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(rr) by 1;
IF ((rr[i].rep_1.context_of_items.coordinate_space_dimension) <> 
          (rr[i].rep_2.context_of_items.coordinate_space_dimension))
THEN
  pass := FALSE;
END_IF;
END_REPEAT;
WHERE
 WR1: pass;
END_RULE; -- component_part_3d_geometric_representation_-
          -- relationship_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part 3d shape' the representation_relationship.rep_1 shall
have the same context dimensionality as representation_relationship.rep_2.
</Formal.propositions.rul>
</Formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part 3d shape' the representation_relationship.rep_1 shall be 
a shape_representation with name = '3d bound volume shape' or 
'part template non planar 2d shape' that is the 
used_representation of a property_definition_representation where 
property_definition_representation.definition.definition 
(is a physical_unit) 
(is a part_template_definition whose shape is defined by a 
characterized_object).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part 3d shape' the representation_relationship.rep_2 shall be 
a shape_representation with name = '3d bound volume shape' that is the 
used_representation of a property_definition_representation where 
({property_definition_representation definition is a product_definition_shape} 
{property_definition_representation definition references a 
component_definition}) 
(property_definition_representation definition references a 
component_shape_aspect).
</Informal.propositions.rul>
<Informal.propositions.rul>
The combination of representation_relationship.rep1 and
representation_relationship.rep2 shall be unique.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="component_placement_restriction_assignment_constraint">
<RULE.DESCRIPTION>
The component_placement_restriction_assignment_constraint rule constrains
a representation that is used as a component placement restriction assignment.
This rule implements WR1 of the Application object.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_placement_restriction_assignment_constraint FOR
( representation );
LOCAL
  cpra : SET OF representation := QUERY( cpra <* representation |
          cpra.name = 'component placement restriction assignment');
     i : INTEGER ;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
  mra : BOOLEAN := FALSE;
  mrv : BOOLEAN := FALSE;
END_LOCAL;
 REPEAT i := 1 to SIZEOF (cpra);
  IF NOT(pass1) THEN ESCAPE; END_IF;

  IF NOT((SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment area') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))
    ) = 1 ) 
     )) <=1 ) OR
(SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment volume') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))
    ) = 1 )
     )) <=1 )
        ) THEN pass1 := FALSE;
  END_IF;      
  mra := (SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment area') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))
    ) = 1 )
     )) =1 );
  mrv := (SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment volume') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))
    ) = 1 )
     )) =1 );
  IF NOT(mra OR mrv) THEN pass1 := FALSE; END_IF;
 END_REPEAT;
 REPEAT i := 1 to SIZEOF (cpra);
  IF NOT(pass1) THEN ESCAPE; END_IF;
  IF NOT(pass2) THEN ESCAPE; END_IF;

  IF NOT(SIZEOF(QUERY(pdr <* USEDIN(cpra[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.definition))
    AND
    (pdr.definition\group.name =
    'item restricted requirements property')
     )
    ) = 1 ) THEN pass2 := FALSE;
  END_IF;
 END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2; 
END_RULE; -- component_placement_restriction_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF representation_relationship.name = 'component placement restriction assignment area' the 
shape_aspect at the end of the path starting with rep_2 through used_representation of a property_definition_representation and ending with property_definition_representation.definition.definition shall be a mounting_restriction_area.

IF representation_relationship.name = 'component placement restriction assignment volume' the 
shape_aspect at the end of the path starting with rep_2 through used_representation of a property_definition_representation and ending with property_definition_representation.definition.definition shall be a mounting_restriction_volume.

At least one of area or volume shall exist.
</formal.propositions.rul>
<formal.propositions.rul> 
IF representation.name = 
'component placement restriction assignment' the representation shall be referenced as a used_representation by a
property_definition_representation that shall have a definition that shall be a 
grouped_requirements_property which has a name = 
'item restricted requirements property'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_interface_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_assembly_module_interface_terminal_assignment_constraint rule
constrains the related_shape_aspect of a shape_aspect_relationship when it is
used as a component terminal to assembly module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE component_terminal_to_assembly_module_interface_terminal_assignment_constraint 
   FOR ( shape_aspect_relationship );
END_RULE; -- component_terminal_to_assembly_module_interface_terminal_-
          -- assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_interface_terminal where the product_definition referenced through the path 
assembly_module_interface_terminal to it's supertype
shape_aspect.of_shape.definition.name = 'assembly module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_terminal where component_terminal\shape_aspect.description = 
   ('assembly module component terminal') 
   ('interconnect module component terminal')) 
(component_interface_terminal) 
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_assembly_module_interface_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE 
component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
              'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) ) 
    THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_assembly_module_interface_terminal_assignment_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique assembly_module_interface_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_join_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_assembly_module_join_terminal_assignment_constraint rule
constrains the related_shape_aspect of a shape_aspect_relationship when it is
used as a component terminal to assembly module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE component_terminal_to_assembly_module_join_terminal_assignment_constraint 
   FOR ( shape_aspect_relationship );
END_RULE; -- component_terminal_to_assembly_module_join_terminal_-
          -- assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_join_terminal where the product referenced through the path 
assembly_module_join_terminal to it's supertyp
shape_aspect.of_shape.definition is a product_definition has a name = 'assembly module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_terminal where component_terminal\shape_aspect.description = 
   ('assembly module component terminal') 
   ('interconnect module component terminal')) 
(component_interface_terminal) 
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_assembly_module_join_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE 
component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
              'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_join_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_MODULE_JOIN_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) ) 
    THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_assembly_module_join_terminal_assignment_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique assembly_module_join_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_interface_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_interconnect_module_interface_terminal_assignment_constraint
rule constrains the related_shape_aspect of a shape_aspect_relationship when
it is used as a component terminal to interconnect module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE
 component_terminal_to_interconnect_module_interface_terminal_assignment_constraint
FOR ( shape_aspect_relationship );
END_RULE; -- component_terminal_to_assembly_module_interface_terminal_assignment_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_interface_terminal where the product referenced through the path 
assembly_module_interface_terminal to it's supertype
shape_aspect.of_shape.definition is a 
product_definition that has a name = 'interconnect module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_shape_aspect where component_shape_aspect description =
   ('component termination passage interface terminal') 
   ('land interface terminal') 
   ('non functional land interface terminal') 
   ('printed connector component interface terminal)).
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_interconnect_module_interface_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERCONNECT_MODULE_INTERFACE_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique interconnect_module_interface_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_join_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_interconnect_module_join_terminal_assignment_constraint
rule constrains the related_shape_aspect of a shape_aspect_relationship when
it is used as a component terminal to interconnect module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE
 component_terminal_to_interconnect_module_join_terminal_assignment_constraint
FOR ( shape_aspect_relationship );
END_RULE; -- component_terminal_to_assembly_module_join_terminal_assignment_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_join_terminal where the product referenced through the path 
assembly_module_join_terminal to it's supertype
shape_aspect.of_shape.definition is a 
product_definition that has a name = 'interconnect module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_shape_aspect where component_shape_aspect description =
   ('component termination passage interface terminal') 
   ('land interface terminal') 
   ('non functional land interface terminal') 
   ('printed connector component interface terminal)).
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_interconnect_module_join_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_join_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERCONNECT_MODULE_JOIN_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique interconnect_module_join_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_pca_terminal_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_pca_terminal_assignment_constraint rule constrains
the related_shape_aspect of a shape_aspect_relationship when it is used as a
component terminal to pca terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE component_terminal_to_pca_terminal_assignment_constraint FOR
( shape_aspect_relationship );
END_RULE; -- component_terminal_to_pca_terminal_assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_terminal\shape_aspect.description = 'pca terminal'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_terminal where component_terminal\shape_aspect.description = 
   ('assembly module component terminal') 
   ('interconnect module component terminal')) 
(component_interface_terminal) 
(assembly_module_terminal where 
assembly_module_terminal\shape_aspect.description = 'pca terminal').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_pca_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_pca_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_pca_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
             'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT' IN TYPEOF(cttamta[i].relating_shape_aspect)) AND
(cttamta[i].relating_shape_aspect\shape_aspect.description = 'pca terminal') ) THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_pca_terminal_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'component feature to physical usage view assignment'
must have a unique assembly_module_terminal entity with a description of
'pca terminal' as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_termination_passage_template_terminal_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_termination_passage_template_terminal_constraint rule constrains
the use of a shape_aspect when it is used as a component termination passage
template terminal.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE component_termination_passage_template_terminal_constraint FOR
( shape_aspect );
END_RULE; -- component_termination_passage_template_terminal_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF a shape_aspect 
{has a description = ('component termination passage interface terminal') 
('component termination passage join terminal')} 
{is the related_shape_aspect of a shape_aspect_relationship which 
   {has a name = 'access mechanism'} 
   {has a relating_shape_aspect which is a part_template_definition with 
      {a description = 'component termination passage template'} 
      {a of_shape.definition which is a characterized_object}}} 
the shape_aspect must be the relating_shape_aspect of at least one 
shape_aspect_relationship where 
{shape_aspect_relationship.name = 'terminal connection zone'} 
{shape_aspect_relationship.related_shape_aspect is a 
shape_aspect.description = 'connection zone'}.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_termination_passage_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_termination_passage_template_terminal_unique_constraint rule constrains
the shape_aspect population members, that fill the role of ARM
component_termination_passage_template_terminal, so the combination of ARM
associated_definition and ARM name shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_termination_passage_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  ctptt : BAG OF shape_aspect := QUERY( sa <* shape_aspect |
((sa\shape_aspect.description = 
'component termination passage template interface terminal') OR
(sa\shape_aspect.description = 
'component termination passage template join terminal')) );
  name_bag : BAG OF STRING := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ctptt) by 1;
  IF EXISTS( ctptt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ctptt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ctptt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ptd_bag := [];
  sa_bag := QUERY( sa <* ctptt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'access mechanism') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND
(sar.relating_shape_aspect\shape_aspect.name = 
       'component termination passage template')) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ptd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_termination_passage_template_terminal_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of either
'component termination passage template interface terminal' or
'component termination passage template join terminal' must have a unique
combination of name attribute and part_template_definition entity with a name
of 'component termination passage template' where the part_template_definition
is related to the shape_aspect by a shape_aspect_relationship with a name of
'access mechanism'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="composite_shape_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The composite_shape_element_constraint rule constrains the use of a composite_shape_aspect when it is used as a composite shape element or as an implementation of the ARM object Part_group_feature or as an implementation of the ARM object Composite_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE composite_shape_element_constraint FOR
  (composite_shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(csa <* composite_shape_aspect |
        SIZEOF(QUERY(sar <* USEDIN(csa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name = 'composing')
        )) < 2)) = 0;
  WR2: SIZEOF(QUERY(csa <* composite_shape_aspect |
        NOT ((SIZEOF(TYPEOF(csa)) > 2) OR 
        (csa\shape_aspect.description <> '') OR 
        (csa\shape_aspect.name <> ''))
        )) = 0;
END_RULE; -- composite_shape_element_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each composite_shape_aspect shall be specified as the relating_shape_aspect by at least two shape_aspect_relationship that have a name of 'composing'.
</formal.propositions.rul>
<formal.propositions.rul>
Each composite_shape_aspect shall be at least one other type of shape_aspect.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each composite_shape_aspect that has a description of 'part group feature' shall only be related to
other part features by the 'composing' shape_aspect_relationship.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="composite_signal_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The composite_signal_property_constraint rule constrains the use
of a property_definition when it is used as a composite signal property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE composite_signal_property_constraint FOR 
( property_definition ); 
END_RULE; -- composite_signal_property_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A property_definition with a name = 'composite signal property' shall be 
the relating_property_definition of at least one 
property_definition_relationship with a name = 
'composite signal property relationship'.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="conductive_interconnect_element_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conductive_interconnect_element_terminal_unique_constraint rule constrains
component_terminal population members, that fill the role of ARM
conductive_interconnect_element_terminal, so that the combination of ARM
name and ARM associated_component shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE conductive_interconnect_element_terminal_unique_constraint FOR
 ( component_terminal );
LOCAL
  ciet : BAG OF component_terminal := QUERY( ct <* component_terminal |
(ct\shape_aspect.description = 'conductive interconnect element terminal') );
  name_bag : BAG OF STRING := [];
  ct_bag : BAG OF component_terminal;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  csa_bag : BAG OF component_shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ciet) by 1;
  IF EXISTS( ciet[i]\shape_aspect.name ) THEN
    IF( NOT( ciet[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ciet[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ct_bag := QUERY( ct <* ciet | (ct\shape_aspect.name = name_bag[i]) );
  csa_bag := [];
  REPEAT j := 1 to SIZEOF(ct_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( ct_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'associated component') AND (sar.relating_shape_aspect\shape_aspect.description IN
['conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition'])
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF( sar_bag[k].relating_shape_aspect IN csa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          csa_bag := csa_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- conductive_interconnect_element_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of
'conductive interconnect element terminal' must have a
unique combination of name attributes and component_shape_aspect
entities that are related via a shape_aspect_relationship with a
name of 'associated component'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conductive_interconnect_element_with_pre_defined_transitions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conductive_interconnect_element_with_pre_defined_transitions_constraint rule
constrains the use of a shape_aspect when it is used as a conductive
interconnect element with pre defined transitions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE 
conductive_interconnect_element_with_pre_defined_transitions_constraint
FOR ( shape_aspect );
END_RULE; -- conductive_interconnect_element_with_pre_defined_transitions_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with pre defined transitions'} 
{of_shape.definition is a component_definition} shall be the definition of 
exactly one property_definition_representation that has a used_representation
(that is a shape_representation.name = 'bound face' and one item is a 
face_surface) 
(that is a representation.name = 'styled curve' and one item is 
an annotation_curve_occurrence).
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with pre defined transitions'} 
shall be the relating_shape_aspect of at least one shape_aspect_relationship with a 
name = 'connected points' where the related_shape_aspect is a 
layer_connection_point_link.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with pre defined transitions'} 
{of_shape.definition is a component_definition} shall be the 
related_shape_aspect of exactly one shape_aspect_relationship with a 
name = 'instantiated feature' that has a relating_shape_aspect that is a 
part_template_definition with a description = 'trace template'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="conductive_interconnect_element_with_user_defined_single_transition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The
conductive_interconnect_element_with_user_defined_single_transition_constraint
rule constrains the use of a shape_aspect when it is used as a conductive
interconnect element with user defined single transition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE conductive_interconnect_element_with_user_defined_single_transition_constraint
FOR ( shape_aspect );
END_RULE;  -- conductive_interconnect_element_with_user_defined_single_transition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the relating_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'end terminus'} 
{shape_aspect_relationship.related_shape_aspect is a layer_connection_point}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the relating_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'start terminus'} 
{shape_aspect_relationship.related_shape_aspect is a layer_connection_point}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall participate as a definition of exactly two 
property_definition_representations whose used_representation is a 
shape_representation and one shape_representation.items is a curve.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the related_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'instantiated feature'} 
{shape_aspect_relationship.description = 'end feature'} 
{shape_aspect_relationship.relating_shape_aspect is a 
part_template_definition whose description = 'trace template'}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the related_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'instantiated feature'} 
{shape_aspect_relationship.description = 'start feature'} 
{shape_aspect_relationship.relating_shape_aspect is a 
part_template_definition whose description = 'trace template'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="configuration_controlled_message_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The configuration_controlled_message_constraint rule constrains the value
of the description of a descriptive_representation_item when it is used as
an approval date, manufacturers code, part number, or revision identifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE configuration_controlled_message_constraint FOR 
( descriptive_representation_item );
END_RULE; -- configuration_controlled_message_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF descriptive_representation_item\representation_item.name = 
'approval date' the descriptive_representation_item shall be an item in a 
representation that is referenced in an approval_assignment and the value 
of SELF.description shall be the concatenation of the value of 
date.year_component + ',' + the value of calendar_date.month_component + 
',' + the value of  calendar_date.day_component + ',' + 
the value of local_time.hour_component + ',' +  the value of 
local_time.minute_component + ',' + the value of local_time.second_component +
',' + the value of  coordinated_universal_time_offset.hour_offset + ',' + 
the value of  coordinated_universal_time_offset.minute_offset + ',' + 
the value of coordinated_universal_time_offset.sense.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF descriptive_representative_item\representative_item.name = 
'manufacturers code' the descriptive_representation_item shall be an item in a
representation that is referenced in an organization_assignment and the
value of SELF.description shall be identical to that of organization.id.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF descriptive_representative_item\representative_item.name = 'part number' 
the descriptive_representation_item shall be an item in a representation that 
is referenced in a property_definition_representation which has a 
definition.definition.formation that is a product_definition_formation and 
the value of SELF.description shall be identical to that of 
product_definition_formation.of_product.id.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF descriptive_representative_item\representative_item.name = 
'revision identifier' the descriptive_representation_item shall be an item 
in a representation which is referenced in a 
property_definition_representation that has a definition.definition.formation 
that is a product_definition_formation and the value of SELF.description 
shall be identical to that of product_definition_formation.id.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="configuration_item_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The configuration_item_requires_person_organization rule assures
that each configuration_item has an
applied_person_and_organization_assignment or an
applied_organization_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE configuration_item_requires_person_organization FOR
  (configuration_item,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (ci <* configuration_item |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       ci IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       ci IN aoa.items )) = 1 )))) = 0;
END_RULE; -- configuration_item_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of configuration_item, there shall be exactly one instance of
applied_person_and_organization_assignment that contains the instance of
configuration_item in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_boundary_and_surface_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_boundary_and_surface_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a conical tolerance zone boundary and surface relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE conical_tolerance_zone_boundary_and_surface_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- conical_tolerance_zone_boundary_and_surface_relationship_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'conical tolerance zone boundary and surface' shall have a related_shape_aspect that is either a part_template_definition or is on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'conical tolerance zone boundary and surface' shall have a relating_shape_aspect that is a tolerance_zone_boundary with a description of 'conical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'conical tolerance zone boundary and surface' shall have exactly one property_definition with a description of 'conical tolerance zone boundary size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a conical tolerance zone boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE conical_tolerance_zone_boundary_definition_constraint FOR
  (property_definition);
END_RULE; -- conical_tolerance_zone_boundary_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall be a property_definition of a tolerance_zone_boundary that has a description of 'conical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size' and each of the property_definition that have a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance shall have the same name.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size' and each of the property_definition that have a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance shall relate to the same property_definition with a description of either 'datum system property with material conditions' or 'datum system property without material conditions' to specify their 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size' and each of the property_definition that have a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance either shall not be modified_geometric_tolerance or shall have the same modifier.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone 
boundary' shall relate to exactly two property_definition that have a description of 
'conical tolerance zone boundary size' to specify its 'boundary size' and each of the 
property_definition that have a description of 'conical tolerance zone boundary size' 
shall be related as a 'defined boundary' to exactly one 
physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance 
shall specify the same instance of shape_aspect as their toleranced_shape_aspect, and 
that shape_aspect shall either be a centre_of_symmetry with a description of 'axis', 
or a composite_shape_aspect in which all the 'composing' shape_aspects are of type 
centre_of_symmetry and have a description of 'axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall be a property_definition of a tolerance_zone_boundary that has a description of 'conical' and that tolerance_zone_boundary shall be specified as the first of the boundaries of a tolerance_zone_definition that specifies as its zone a tolerance_zone that has a description of 'conical'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_boundary_diametrical_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_boundary_diametrical_size_characteristic_constraint rule constrains the use of a property_definition when it is used as a conical tolerance zone boundary diametrical size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE 
conical_tolerance_zone_boundary_diametrical_size_characteristic_constraint
FOR  (property_definition);
END_RULE; -- conical_tolerance_zone_boundary_diametrical_size_-
          -- characteristic_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be a property_definition of a shape_aspect_relationship that has a name of 'conical tolerance zone boundary and surface'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be related as a 'boundary size' to exactly one property_definition that has a description of 'conical tolerance zone boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'conical tolerance zone boundary value', and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the physical_unit_geometric_tolerance that relates to the instance of property_definition that has a description of 'conical tolerance zone boundary size' to specify its 'defined boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and that physical_unit_geometric_tolerance shall be either a position_tolerance, a parallelism_tolerance, a perpendicularity_tolerance, or an angularity_tolerance.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be related as a 'boundary size' to exactly one property_definition that has a description of 'conical tolerance zone boundary' and that property_definition shall be applied to the same instance of tolerance_zone_boundary as specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'conical tolerance zone boundary and surface' and to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_definition_constraint rule constrains the use of a tolerance_zone_definition when it is used as a conical tolerance zone definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE conical_tolerance_zone_definition_constraint FOR
  (tolerance_zone_definition);
END_RULE; -- conical_tolerance_zone_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_definition that specifies a tolerance_zone with a description of 'conical' shall have exactly one boundary that is a tolerance_zone_boundary with a description of 'conical' and that tolerance_zone_boundary shall have exactly one property_definition that has a description of 'conical tolerance zone boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each tolerance_zone_definition that specifies a tolerance_zone with a description of 'conical' as it zone, shall have that tolerance_zone specify exactly two physical_unit_geometric_tolerance, as its defining_tolerance, and these physical_unit_geometric_tolerance shall be the same physical_unit_geometric_tolerance that relate to the property_definitions with a description of 'conical tolerance zone boundary size' that are applied to shape_aspect_relationships with names of 'conical tolerance zone boundary and surface' that specify the tolerance_zone_boundary, as the relating_shape_aspect, that is specified as the boundaries of the tolerance_zone_definition.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="connection_zone_constraint">
<RULE.DESCRIPTION>
The connection_zone_constraint rule constrains the use of
shape_aspect and shape_representation when implementing the ARM concepts
of Connection_zone and the associated colour.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE connection_zone_constraint FOR ( shape_aspect, representation );
WHERE
   WR1: SIZEOF( QUERY( sa <* shape_aspect | 
        (sa\shape_aspect.description = 'connection zone') AND NOT 
        (SIZEOF (USEDIN (sa, '')) >= 1))) = 0;
   WR2: SIZEOF( QUERY( sa <* shape_aspect | 
              (sa\shape_aspect.description = 'connection zone') AND 
        NOT(SIZEOF( QUERY( sar <* USEDIN(sa,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name IN [
        'connection',
        'minimum attachment region size',
        'maximum attachment region size',
        'external connection area', 
        'external connection zone',
        'internal connection zone',
        'mounting area', 
        'terminal connection zone'
         ]))) >= 1))) = 0;
END_RULE; -- connection_zone_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
Each instance of shape_aspect with a description of 'connection zone'
shall be referenced at least once.
</formal.propositions.rul> 
<formal.propositions.rul> 
Each instance of shape_aspect with a description of 'connection zone'
shall be referenced by at least one shape_aspect_relationship with a 
name of 
'connection',
'minimum attachment region size',
'maximum attachment region size',
'external connection area',
'external connection zone',
'internal connection zone',
'mounting area', or
'terminal connection zone'.
</formal.propositions.rul> 
</formal.propositions> 
<informal.propositions rule.types="IP">  
<informal.propositions.rul> 
Each instance of shape_aspect with a description of 'connection zone'
that is represented by a shape_representation that is capable of
representing topological information shall be represented by a
shape_representation that describes the connection zone
as being a set of connected points.
<example>
If a manifold_surface_shape_representation were to represent a connection zone,
there would only be one shell in the representation.
</example>
</informal.propositions.rul> 
</informal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="contract_unique_constraint">
<RULE.DESCRIPTION>
The contract_unique_constraint rule constrains the contract.name population members to satisfy the uniqueness requirement of the ARM application object Contract.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)

RULE contract_unique_constraint FOR (contract);

LOCAL
  r : BAG OF contract := QUERY (r <* contract | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\contract.name ) THEN
    IF (r[i]\contract.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\contract.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;

END_RULE; -- contract_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of contract.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="curve_extension_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_extension_constraint rule limits the values that the
extension for curve_style_with_extension shall be.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE curve_extension_constraint for ( curve_style_with_extension );
END_RULE; -- curve_extension_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
 The allowed values for extension are: 
    + 0.5*width +/- delta,
    0 +/- delta,
    - 0.5*width +/- delta.
where delta is uncertainty_measure_with_unit, assigned by user.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="curve_style_font_and_scaling_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_style_font_and_scaling_unique_constraint rule constrains the curve_style_font_and_scaling name attribute in a population to satisfy the uniqueness requirement of the ARM application object Curve_style_font_and_scaling.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE curve_style_font_and_scaling_unique_constraint 
   FOR (curve_style_font_and_scaling);

LOCAL
  r : BAG OF curve_style_font_and_scaling := 
                         QUERY (r <* curve_style_font_and_scaling | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\curve_style_font_and_scaling.name ) THEN
    IF (r[i]\curve_style_font_and_scaling.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\curve_style_font_and_scaling.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;

END_RULE; -- curve_style_font_and_scaling_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of curve_style_font_and_scaling.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="curve_style_requires_length_measure_with_unit">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_style_requires_length_measure_with_unit rule constrains the
entity pointed to by the curve_width attribute of a curve_style.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE curve_style_requires_length_measure_with_unit FOR ( curve_style );
WHERE
  WR1: SIZEOF(QUERY(cs <* curve_style |
       NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(cs))
       )) = 0;
END_RULE; -- curve_style_requires_length_measure_with_unit
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A curve_style.curve_width shall be a length_measure_with_unit.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="curve_style_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_style_unique_constraint rule constrains the representation
population members, that fill the role of ARM curve_style, so that the
ARM name shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE curve_style_unique_constraint FOR
 ( representation );
LOCAL
  cs : BAG OF representation := QUERY( r <* representation |
((r\representation.name = 'curve style parameters') AND (r.context_of_items\representation_context.context_type =
'curve style parametric context')) );
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cs) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  REPEAT j := 1 to SIZEOF(cs[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(cs[i].items[j])) AND
(cs[i].items[j]\representation_item.name = 'curve style name') ) THEN
      IF EXISTS( cs[i].items[j]\descriptive_representation_item.description ) THEN
        IF ( cs[i].items[j]\descriptive_representation_item.description IN desc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          desc_bag := desc_bag + cs[i].items[j]\descriptive_representation_item.description;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- curve_style_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of representation with a name of 'curve style parameters' must
have a unique descriptive_representation_item.description attribute where the
descriptive_representation_item has a name of 'curve style name' and is a member
of the representation's set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="date_and_time_require_minute_and_second">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The date_and_time_require_minute_and_second rule constrains date_and_time
to include a minute and second component.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE date_and_time_require_minute_and_second FOR ( date_and_time );
WHERE
  WR1: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.minute_component)))) = 0;
  WR2: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.second_component)))) = 0;
END_RULE; -- date_and_time_require_minute_and_second
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A date_and_time shall have a time_component.minute_component.
</formal.propositions.rul>
<formal.propositions.rul>
A date_and_time shall have a time_component.second_component.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="date_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The date_constraint rule specifies that all instances of
date shall have a year_number that has 4 digits.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE date_constraint FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       d.year_component < 1856)) = 0;
END_RULE; -- date_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date, the year_component shall be greater than or equal to 1856.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="datum_axis_and_tolerance_zone_orienting_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_axis_and_tolerance_zone_orienting_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum axis and tolerance zone orienting relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_axis_and_tolerance_zone_orienting_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- datum_axis_and_tolerance_zone_orienting_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum axis and tolerance zone' shall have a related_shape_aspect that is a physical_unit_datum with a description of 'axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum axis and tolerance zone' shall have a relating_shape_aspect that is a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum axis and tolerance zone' shall have exactly one property_definition with a description of 'datum axis related orientation'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_axis_related_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_axis_related_orientation_constraint rule constrains the use of a property_definition when it is used as a datum axis related orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_axis_related_orientation_constraint FOR
  (property_definition);
END_RULE; -- datum_axis_related_orientation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum axis related orientation' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum axis and tolerance zone'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum axis related orientation' shall have a name of either 'centred on arc' or 'centred on radial'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum axis related orientation' shall be related as a 'zone orientation' to exactly one property_definition that has a description of 'tolerance zone orientation'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_based_direction_vector_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_based_direction_vector_constraint rule constrains the use of a property_definition when it is used as a datum based direction vector.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_based_direction_vector_constraint FOR
  (property_definition);
END_RULE; -- datum_based_direction_vector_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall be a property_definition of a physical_unit_datum that has a description of 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall have a representation that contains exactly one axis1_placement that has a name of 'orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall have a name of either 'positive direction vector' or 'negative direction vector'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall be related as a 'element direction vector' to at least one property_definition that has a description of 'direction element'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_based_length_measure_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_based_length_measure_constraint rule constrain the usage of a
representation and the items of a representation when it is used as
maximum component height or clearance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_based_length_measure_constraint FOR ( representation );
END_RULE; -- datum_based_length_measure_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name = 
('maximum positive component height') 
('maximum negative component height')
(`maximum mounting clearance')
(`minimum mounting clearance') shall have one items that is a 
length_measure_with_unit.name = 'measure'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation with a name = 
('maximum positive component height') 
('maximum negative component height') 
(`maximum mounting clearance')
(`minimum mounting clearance') shall have one items that is a 
direction.name = 'measure orientation' or that is a descriptive_representation_item.name = 'measure orientation'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation with a name = 
('maximum positive component height') 
('maximum negative component height') 
(`maximum mounting clearance')
(`minimum mounting clearance') shall be the used_representation of
one property_definition_representation that has a definition.definition that
is a datum.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="datum_based_vector_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_based_vector_orientation_constraint rule constrains the use of a property_definition when it is used as a datum based vector orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_based_vector_orientation_constraint FOR
  (property_definition);
END_RULE; -- datum_based_vector_orientation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall be a property_definition of a shape_aspect that has a description of 'vector'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall relate to exactly two property_definition that have a description of 'direction element' to specify its 'direction component'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' either shall be related as a 'zone orientation' to at least one property_definition that has a description of 'tolerance zone orientation', shall be related as a 'measurement orientation' to at least one property_definition that has a description of 'dimensional location property' and that is a property_definition of a dimensional_location_with_direction, or shall be related as a 'measurement orientation' to at least one property_definition that has a description of 'dimensional location property' and that is a property_definition of an angular_dimension_with_orientation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall relate to exactly two property_definition that have a description of 'direction element' to specify its 'direction component' and each of these shall be a property_definition of instances of shape_aspect_relationship that have a name of 'datum plane and half plane relationship' and each of these shape_aspect_relationship shall specify a different physical_unit_datum that has a description of 'plane' as their related_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall relate to exactly two property_definition that have a description of 'direction element' to specify its 'direction component' and each of these shall be a property_definition of instances of shape_aspect_relationship that have a name of 'datum plane and half plane relationship' and each of these shape_aspect_relationship shall specify a different physical_unit_datum that has a description of 'plane' as their related_shape_aspect and these physical_unit_datum shall be related to the same datum_reference_frame as 'reference plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector', and this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'. 

Additionally, each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector', and this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'.

Finally, each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship' and that shape_aspect_relationship shall have a related_shape_aspect that is of type physical_unit_datum and has a description of 'plane'. 

None of these physical_unit_datum shall be the same.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector', this property_definition shall be a property_definition of a physical_unit_datum that has a description of 'plane'. 

Additionally, each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector', this property_definition shall be a property_definition of a physical_unit_datum that has a description of 'plane'.

Finally, each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship' and that shape_aspect_relationship shall have a related_shape_aspect of type physical_unit_datum that has a description of 'plane'. 

These physical_unit_datum shall be related to the same datum_reference_frame as 'reference plane'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_material_condition_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_material_condition_property_constraint rule constrains the use of a property_definition when it is used as a datum feature material condition property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_feature_material_condition_property_constraint FOR
  (property_definition);
END_RULE; -- datum_feature_material_condition_property_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum feature usage in datum system'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall be related as a 'applied material condition property' to exactly one property_definition that has a description of 'datum system property with material conditions'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall have a name of either 'least material requirement' or 'maximum material principle'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall be related as an 'applied material condition property' to exactly one property_definition that has a description of 'datum system property with material conditions' and that property_definition shall be applied to the same instance of datum_system as specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'datum feature usage in datum system' and to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_common_datum_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_common_datum_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in common datum relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_feature_usage_in_common_datum_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- datum_feature_usage_in_common_datum_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in common datum' shall have a relating_shape_aspect that is a physical_unit_datum that has a name of 'common datum'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_datum_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_datum_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in datum relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_feature_usage_in_datum_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- datum_feature_usage_in_datum_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'datum feature usage in common datum' or 'datum feature usage in single datum' shall have a related_shape_aspect that is a physical_unit_datum_feature.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'datum feature usage in common datum' or 'datum feature usage in single datum' shall have a relating_shape_aspect that is a physical_unit_datum.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'datum feature usage in common datum' or 'datum feature usage in single datum' shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_datum_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_datum_relationship_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
datum_feature_usage_in_datum_relationship, so that the combination of ARM
relating_shape_element and ARM related_shape_element attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE datum_feature_usage_in_datum_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  dfuidr : BAG OF shape_aspect_relationship := 
           QUERY( sar <* shape_aspect_relationship |
((sar\shape_aspect_relationship.name = 'datum feature usage in common datum') OR
(sar\shape_aspect_relationship.name = 'datum feature usage in single datum')) );
  pudf_bag : BAG OF physical_unit_datum_feature := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pud_bag : BAG OF physical_unit_datum;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuidr) by 1;
  IF EXISTS( dfuidr[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM' IN TYPEOF(dfuidr[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dfuidr[i].relating_shape_aspect IN pud_bag ) ) THEN
        pud_bag := pud_bag + dfuidr[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pud_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pudf_bag := [];
  sar_bag := 
  QUERY( sar <* dfuidr | ((sar.relating_shape_aspect :=: pud_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM_FEATURE' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pudf_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pudf_bag := pudf_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- datum_feature_usage_in_datum_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of either
'datum feature usage in common datum' or 'datum feature usage in single datum'
must have a unique combination of relating_shape_aspect and related_shape_aspect
attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_datum_system_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_datum_system_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in datum system relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_feature_usage_in_datum_system_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- datum_feature_usage_in_datum_system_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have a related_shape_aspect that is a physical_unit_datum_feature.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have a relating_shape_aspect that is a datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have exactly one property_definition with a description of 'datum feature material condition property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have a related_shape_aspect that is a physical_unit_datum_feature that is in the set of physical_unit_datum_feature that are related as either 'datum feature usage in common datum' or 'datum feature usage in single datum' to the physical_unit_datum that are related as the 'datum usage in datum system' to the datum_system that is the relating_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_single_datum_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_single_datum_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in single datum relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_feature_usage_in_single_datum_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- datum_feature_usage_in_single_datum_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in single datum' shall have a relating_shape_aspect that is a physical_unit_datum that has a name of 'single datum'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_precedence_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_precedence_assignment_constraint rule constrains the use of a property_definition when it is used as a datum precedence assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_precedence_assignment_constraint FOR
  (property_definition);
END_RULE; -- datum_precedence_assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum usage in datum system'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall be related as a 'assigned datum precedence' to exactly one property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall have a name of either 'primary', 'secondary', or 'tertiary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall be related as an 'assigned datum precedence' to exactly one property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' and that property_definition shall be applied to the same instance of datum_system as specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'datum usage in datum system' and to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_precedence_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_precedence_assignment_unique_constraint rule constrains
property_definition population members, that fill the role
of ARM datum_precedence_assignment, so that the combination of ARM
name and ARM datum_system_conditions_definition shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE datum_precedence_assignment_unique_constraint FOR
 ( property_definition );
LOCAL
  dpa : BAG OF property_definition := QUERY( pd <* property_definition |
(pd\property_definition.description = 'datum precedence assignment') );
  name_bag : BAG OF STRING := [];
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  pds : BAG OF property_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dpa) by 1;
  IF EXISTS( dpa[i]\property_definition.name ) THEN
    IF( NOT( dpa[i]\property_definition.name IN name_bag ) ) THEN
      name_bag := name_bag + dpa[i]\property_definition.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pds := [];
  pd_bag := QUERY( pd <* dpa | (pd\property_definition.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION' ) |
((pdr\property_definition_relationship.name = 'assigned datum precedence') AND
(pdr.relating_property_definition\property_definition.description IN [
'datum system property with material conditions',
'datum system property without material conditions'])) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_property_definition ) THEN
        IF ( pdr_bag[k].relating_property_definition IN pds ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pds := pds + pdr_bag[k].relating_property_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- datum_precedence_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of property_definition with a description of
'datum precedence assignment' must have a unique combination of
name attribute and property_definition entity with a description of
either 'datum system property with material conditions' or
'datum system property without material conditions' where the
property_definitions are related by a property_definition_relationship
with a name of 'assigned datum precedence'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_system_defining_conditions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_system_defining_conditions_constraint rule constrains the use of a property_definition when it is used as a datum system defining conditions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_system_defining_conditions_constraint FOR
  (property_definition);
END_RULE; -- datum_system_defining_conditions_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' shall be a property_definition of a datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' shall relate to exactly one, two, or three property_definition that have a description of 'datum precedence assignment' to specify its 'assigned datum precedence'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' that relates, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'tertiary' shall also relate, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'secondary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' that relates, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'secondary' shall also relate, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'primary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property with material conditions' shall be related as a 'referenced datum system definition' to at least one geometric_tolerance_with_specified_datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property without material conditions' either shall be related as a 'referenced datum system definition' to at least one geometric_tolerance_with_specified_datum_system or shall be related as a 'referenced datum system property' to at least one property_definition that has a description of 'dimensional location property' and that is a property_definition for a datum_system_based_dimensional_location.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' shall relate to exactly one, two, or three property_definition that have a description of 'datum precedence assignment' to specify its 'assigned datum precedence' and those property_definition shall have unique names.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_system_defining_conditions_with_material_conditions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_system_defining_conditions_with_material_conditions_constraint rule constrains the use of a property_definition when it is used as a datum system defining conditions with material conditions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_system_defining_conditions_with_material_conditions_constraint
FOR (property_definition);
END_RULE; -- datum_system_defining_conditions_with_material_-
          -- conditions_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property with material conditions' shall relate to at least one property_definition that has a description of 'datum feature material condition property' to specify its 'applied material condition property'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_system_defining_conditions_without_material_conditions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_system_defining_conditions_without_material_conditions_constraint rule constrains the use of a property_definition when it is used as a datum system defining conditions without material conditions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE 
datum_system_defining_conditions_without_material_conditions_constraint FOR
  (property_definition);
END_RULE; -- datum_system_defining_conditions_without_material_-
          -- conditions_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property without material conditions' shall relate to exactly zero property_definition that have a description of 'datum feature material condition property' to specify its 'applied material condition property'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_target_usage_in_datum_target_set_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_target_usage_in_datum_target_set_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum target usage in datum target set relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_target_usage_in_datum_target_set_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- datum_target_usage_in_datum_target_set_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum target usage' shall have a related_shape_aspect that is a physical_unit_datum_target.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum target usage' shall have a relating_shape_aspect that is a physical_unit_datum_target_set.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum target usage' shall have a description that is expressed only by digits and represents a positive integer.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum target usage' shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum target usage' shall specify a unique combination of relating_shape_aspect and description.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_target_usage_in_datum_target_set_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_target_usage_in_datum_target_set_relationship_unique_constraint rule
constrains shape_aspect_relationship population members, that fill the role of ARM
datum_target_usage_in_datum_target_set_relationship, so that the combination of ARM
used_datum_target and ARM defined_datum_target attributes and that the combination
of ARM datum_target_number and ARM defined_datum_target attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE datum_target_usage_in_datum_target_set_relationship_unique_constraint
FOR ( shape_aspect_relationship );
LOCAL
  dtuidts : BAG OF shape_aspect_relationship := 
    QUERY( sar <* shape_aspect_relationship |
(sar\shape_aspect_relationship.name = 'datum target usage'));
  pudts_bag : BAG OF physical_unit_datum_target_set := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass1 : BOOLEAN := TRUE;
  pudt_bag : BAG OF physical_unit_datum_target;
  pass2 : BOOLEAN := TRUE;
  num_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dtuidts) by 1;
  IF EXISTS( dtuidts[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM_TARGET_SET' IN 
   TYPEOF(dtuidts[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dtuidts[i].relating_shape_aspect IN pudts_bag ) ) THEN
        pudts_bag := pudts_bag + dtuidts[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pudts_bag) by 1;
  IF ( NOT (pass1 AND pass2) ) THEN ESCAPE;
  END_IF;
  num_bag := [];
  pudt_bag := [];
  sar_bag := 
     QUERY( sar <* dtuidts | (sar.relating_shape_aspect :=: pudts_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT (pass1 AND pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass1 AND 
          ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM_TARGET' IN 
               TYPEOF(sar_bag[j].related_shape_aspect)) ) THEN
      IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
        IF ( sar_bag[j].related_shape_aspect IN pudt_bag ) THEN
          pass1 := FALSE;
        ELSE
          pudt_bag := pudt_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
    IF ( pass2 ) THEN
      IF EXISTS( sar_bag[j]\shape_aspect_relationship.description ) THEN
        IF ( sar_bag[j]\shape_aspect_relationship.description IN num_bag ) THEN
          pass2 := FALSE;
        ELSE
          num_bag := num_bag + sar_bag[j]\shape_aspect_relationship.description;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- datum_target_usage_in_datum_target_set_relationship_unique_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'datum target usage'
must have a unique combination of related_shape_aspect and relating_shape_aspect attributes.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'datum target usage'
must have a unique combination of description and relating_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_usage_in_datum_system_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_usage_in_datum_system_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum usage in datum system relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE datum_usage_in_datum_system_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- datum_usage_in_datum_system_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum usage in datum system' shall have a related_shape_aspect that is a physical_unit_datum, and the name of physical_unit_datum shall be either 'common datum' or 'single datum'
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum usage in datum system' shall have a relating_shape_aspect that is a datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum usage in datum system' shall have exactly one property_definition with a description of 'datum precedence assignment'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum usage in datum system' shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_usage_in_datum_system_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_usage_in_datum_system_relationship_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
datum_usage_in_datum_system_relationship, so that the combination of ARM
established_datum_system and ARM used_datum attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE datum_usage_in_datum_system_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  duidsr : BAG OF shape_aspect_relationship := 
      QUERY( sar <* shape_aspect_relationship |
(sar\shape_aspect_relationship.name = 'datum usage in datum system'));
  ds_bag : BAG OF datum_system := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pud_bag : BAG OF physical_unit_datum;
END_LOCAL;

REPEAT i := 1 to SIZEOF(duidsr) by 1;
  IF EXISTS( duidsr[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DATUM_SYSTEM' IN TYPEOF(duidsr[i].relating_shape_aspect) ) THEN
      IF ( NOT ( duidsr[i].relating_shape_aspect IN ds_bag ) ) THEN
        ds_bag := ds_bag + duidsr[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ds_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pud_bag := [];
  sar_bag := 
     QUERY( sar <* duidsr | (sar.relating_shape_aspect :=: ds_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM' IN 
               TYPEOF(sar_bag[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN pud_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pud_bag := pud_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- datum_usage_in_datum_system_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'datum usage in datum system'
must have a unique combination of related_shape_aspect and relating_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="default_assembly_bond_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The default_assembly_bond_shape_constraint rule constrains the usage of
a shape_representation when it is used as a default assembly bond shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE default_assembly_bond_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'default assembly bond shape')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(sr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT'
       IN TYPEOF(pdr.definition.definition)))) = 1))) = 0;
END_RULE; -- default_assembly_bond_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_representation\representation.name = 'default assembly bond shape' 
shall be related to exactly one assembly_bond_definition.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="default_passage_based_land_physical_template_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The default_passage_based_land_physical_template_unique_constraint rule constrains
land_physical_template population members, that fill the role of ARM
default_passage_based_land_physical_template, so that the combination of ARM
of_passage_technology and ARM of_stratum_technology attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE default_passage_based_land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  dpblpt : BAG OF land_physical_template := 
QUERY( lpt <* land_physical_template |
(lpt\shape_aspect.description IN ['default via based',
'default attachment size and via based',
'default unsupported passage based',
'default component termination passage based',
'default attachment size and component termination passage based']) );
  sar_bag : BAG OF shape_aspect_relationship;
  pt_bag : BAG OF passage_technology := [];
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  st_bag : BAG OF stratum_technology;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dpblpt) by 1;
  sar_bag := QUERY( sar <* USEDIN(dpblpt[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PASSAGE_TECHNOLOGY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].related_shape_aspect IN pt_bag ) ) THEN
        pt_bag := pt_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pt_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  st_bag := [];
  sar_bag := QUERY( sar <* USEDIN(pt_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND (sar.relating_shape_aspect IN dpblpt)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := 
    QUERY( pdr <* USEDIN(sar_bag[j].relating_shape_aspect\shape_aspect.of_shape,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'technology usage') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_TECHNOLOGY' IN 
      TYPEOF(pdr.relating_property_definition.definition))) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_property_definition.definition ) THEN
        IF 
          ( pdr_bag[k].relating_property_definition.definition IN st_bag ) 
                                                                      THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          st_bag := st_bag + 
                       pdr_bag[k].relating_property_definition.definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- default_passage_based_land_physical_template_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of land_physical_template with a description of either
'default via based', 'default attachment size and via based',
'default unsupported passage based', 'default component termination passage based'
 or 'default attachment size and component termination passage based' must
have a unique combination of passage_technology and stratum_technology entities
where the passage_technology is related to the land_physical_template by a
shape_aspect_relationship with a name of 'technology usage' and where the
stratum_technology is related to the land_physical_template by a
property_definition_relationship with a name of 'technology usage'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="delete_design_object_management_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The delete_design_object_management_relationship_unique_constraint rule constrains
the delete_design_object_assignment and delete_design_object_request_assignment population
members, that fill the role of ARM delete_design_object_management_relationship, so
that the combination of ARM previous_design and ARM previous_design_object attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE delete_design_object_management_relationship_unique_constraint FOR
 ( delete_design_object_assignment, 
   delete_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  ddoa_bag : BAG OF delete_design_object_assignment;
  ddora_bag : BAG OF delete_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(delete_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(delete_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
        IN TYPEOF(delete_design_object_assignment[i].items[j]))
AND (delete_design_object_assignment[i].items[j].name = 
                          'design object deletion') ) THEN
      IF EXISTS( delete_design_object_assignment[i].items[j].
                                      relating_product_definition )
                                                               THEN
        IF( NOT( delete_design_object_assignment[i].items[j].
                                          relating_product_definition 
                                                 IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                 delete_design_object_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(delete_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
         SIZEOF(delete_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
         IN TYPEOF(delete_design_object_request_assignment[i].items[j]))
AND (delete_design_object_request_assignment[i].items[j].name = 
                                     'design object deletion') ) THEN
      IF EXISTS
       ( delete_design_object_request_assignment[i].items[j].
                                        relating_product_definition )
                                                            THEN
        IF( NOT
( delete_design_object_request_assignment[i].items[j].
                                         relating_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
          delete_design_object_request_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
                        (pdr\product_definition_relationship.name = 'design object deletion') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddoa_bag := QUERY( ddoa <* delete_design_object_assignment | 
                                   (pdr_bag[j] IN ddoa.items) );
    REPEAT k := 1 to SIZEOF(ddoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddoa_bag[k].items) by 1;
        IF EXISTS( ddoa_bag[k].items[l] ) THEN
          IF ( ddoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddora_bag := 
        QUERY( ddora <* delete_design_object_request_assignment | 
                                    (pdr_bag[j] IN ddora.items) );
    REPEAT k := 1 to SIZEOF(ddora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddora_bag[k].items) by 1;
        IF EXISTS( ddora_bag[k].items[l] ) THEN
          IF ( ddora_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddora_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- delete_design_object_management_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of delete_design_object_assignment and delete_design_object_request_assignment
that has a common product_definition that is the relating_product_definition of a
product_definition_relationship that has a name of 'design object deletion' where the
product_definition_relationship is a member of the items attribute of the
delete_design_object_assignment and delete_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_action_directive">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_action_directive rule specifies that all
instances of action_directive are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_action_directive FOR (action_directive);
WHERE
  WR1: SIZEOF (QUERY (ad <* action_directive |
       NOT (SIZEOF (USEDIN (ad, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_action_directive
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of action_directive, there shall be a reference to the
action_directive instance from an attribute of another entity.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_approval_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_approval_status rule specifies that all
instances of approval_status are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_approval_status FOR (approval_status);
WHERE
WR1: SIZEOF (QUERY (ast <* approval_status |
     NOT (SIZEOF (USEDIN (ast, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_approval_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of approval_status, there shall be a reference to the 
approval_status instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_certification_type">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_certification_type rule specifies that all
instances of certification_type are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_certification_type FOR (certification_type);
WHERE
  WR1: SIZEOF (QUERY (ct <* certification_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_certification_type
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of certification_type, there shall be a reference to the 
certification_type instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_contract_type">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_contract_type rule specifies that all
instances of contract_type are dependent on the usage to define another
entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_contract_type FOR (contract_type);
WHERE
  WR1: SIZEOF(QUERY ( ct <* contract_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_contract_type
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of contract_type, there shall be a reference to the 
contract_type instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_date">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_date rule specifies that all instances of
date are dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (dt <* date |
       NOT (SIZEOF(USEDIN (dt, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date, there shall be a reference to the 
date instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_date_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_date_role rule specifies that all instances
of date_role are dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (SIZEOF (USEDIN (dr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date_role, there shall be a reference to the 
date_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_date_time_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_date_time_role rule specifies that all
instances of date_time_role are dependent on the usage to define another
entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_date_time_role FOR (date_time_role);
WHERE
  WR1: SIZEOF (QUERY (dtr <* date_time_role |
       NOT (SIZEOF (USEDIN (dtr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date_time_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date_time_role, there shall be a reference to the 
date_time_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_document_type">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_document_type rule specifies that all
instances of document_type are dependent on the usage to define another
entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_document_type FOR (document_type);
WHERE
  WR1: SIZEOF (QUERY (dt <* document_type |
       NOT (SIZEOF (USEDIN (dt, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_document_type
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of document_type, there shall be a reference to the 
document_type instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_named_unit">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_named_unit rule specifies that all instances
of named_unit are dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_named_unit FOR (named_unit);
WHERE
  WR1: SIZEOF (QUERY (nu <* named_unit |
       NOT (SIZEOF (USEDIN (nu, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_named_unit
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of named_unit, there shall be a reference to the 
named_unit instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_organization_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_organization_role rule specifies that all
instances of organization_role are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_organization_role FOR (
         organization_role);
WHERE
  WR1: SIZEOF (QUERY (org <* organization_role |
       NOT (SIZEOF (USEDIN (org, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_organization_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of organization_role, there shall be a reference to the 
organization_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_parametric_representation_context">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_parametric_representation_context rule
specifies that all instances of parametric_representation_context are
dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_parametric_representation_context FOR
  (parametric_representation_context);
WHERE
  WR1: SIZEOF (QUERY (prc <* parametric_representation_context |
       NOT (SIZEOF (USEDIN (prc, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_parametric_representation_context
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of parametric_representation_context, there shall be a
reference to the parametric_representation_context instance from an
attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_person_and_organization_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_person_and_organization_role rule specifies
that all instances of person_and_organization_role are dependent on the
usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_person_and_organization_role FOR (
         person_and_organization_role);
WHERE
  WR1: SIZEOF (QUERY (poar <* person_and_organization_role |
       NOT (SIZEOF (USEDIN (poar, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_person_and_organization_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of person_and_organization_role, there shall be a reference to
the person_and_organization_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_representation_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_representation_item rule specifies that all
instances of representation_item are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF (QUERY (ri <* representation_item |
       NOT (SIZEOF (USEDIN (ri, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_representation_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of representation_item, there shall be a reference to the 
representation_item instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_security_classification_level">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_security_classification_level rule specifies
that all instances of security_classification_level are dependent on the
usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_security_classification_level FOR (
         security_classification_level);
WHERE
  WR1: SIZEOF (QUERY (scl <* security_classification_level |
       NOT (SIZEOF (USEDIN (scl, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_security_classification_level
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of security_classification_level, there shall be a reference
to the security_classification_level instance from an attribute of another
entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_shape_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_shape_representation rule specifies that all
instances of shape_representation are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_shape_representation FOR (
         shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
       NOT (SIZEOF(USEDIN(sr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_shape_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of shape_representation, there shall be a reference to the 
shape_representation instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_tolerance_value">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_tolerance_value rule specifies that all
instances of tolerance_value are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_tolerance_value FOR (
         tolerance_value);
WHERE
  WR1: SIZEOF (QUERY (tv <* tolerance_value |
       NOT (SIZEOF(USEDIN(tv, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_tolerance_value
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of tolerance_value, there shall be a reference to the 
tolerance_value instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="derived_shape_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The derived_shape_element_constraint rule constrains the use of a derived_shape_aspect when it is used as a derived shape element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE derived_shape_element_constraint FOR
  (derived_shape_aspect);
END_RULE; -- derived_shape_element_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each derived_shape_aspect shall not be derived from itself either directly or through intermediate derived_shape_aspects.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_composition_path_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_composition_path_constraint rule constrains relating and related
product_definition of a product_definition_relationship when it is used as
a design composition path.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE design_composition_path_constraint FOR 
( product_definition_relationship );
END_RULE; -- design_composition_path_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 'design composition path' the 
relating_product_definition shall be a component_functional_unit with a 
frame_of_reference that is an application_context_element.name = 
'functional occurrence' and product_definition.description = 
'design definition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 'design composition path' the 
related_product_definition shall be a component_functional_unit with a 
frame_of_reference that is an application_context_element.name = 
'functional occurrence'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_component_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_component_constraint rule
constrains the relating and related product_definition for a
product_definition_relationship when it is used as a design functional unit
allocation to assembly_component.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_functional_unit_allocation_to_assembly_component_constraint FOR
( product_definition_relationship );
WHERE
   WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
     (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
                 (NOT(
    (pdr.relating_product_definition\product_definition.description = 'design definition path')
                    AND
            (pdr.relating_product_definition.id = 'design composition path')
                 ))
               )) = 0;

   WR2: SIZEOF (QUERY (pdr <* product_definition_relationship |
   (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
     (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'COMPONENT_DEFINITION' IN TYPEOF (pdr.related_product_definition))) 
               )) = 0;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_relationship.name =
'design functional unit allocation to assembly component' the
SELF.relating_product_definition shall have a description = 'design definition path'
and an id = 'design composition path'.
</formal.propositions.rul>
<formal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly component' the 
SELF.related_product_definition shall be a component_definition.
</formal.propositions.rul>
</formal.propositions>

<informal.propositions rule.types="IP">
<informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly component' 
it shall be the definition of a property_definition which
is the definintion of a property_definition_representation which
has an item that is a descriptive_representation_item with a name
of 'local swappable' and a description of 'false' or 'true'.
</informal.propositions.rul>
<informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly component' 
it shall be the definition of a property_definition which
is the definintion of a property_definition_representation which
has an item that is a descriptive_representation_item with a name
of 'global swappable' and a description of 'false' or 'true'.
</informal.propositions.rul>
</informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_component_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_component_unique_constraint rule
constrains product_definition_relationship population members, that fill the role
of ARM design_functional_unit_allocation_to_assembly_component, so that the
combination of ARM implementation and ARM path_alias shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE
design_functional_unit_allocation_to_assembly_component_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatac : BAG OF product_definition_relationship := 
QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') );
  cd_bag : BAG OF component_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatac) by 1;
  IF EXISTS( dfuatac[i].related_product_definition ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN 
TYPEOF(dfuatac[i].related_product_definition) ) THEN
      IF( NOT( dfuatac[i].related_product_definition IN cd_bag ) ) THEN
        cd_bag := cd_bag + dfuatac[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdr_bag := QUERY( pdr <* dfuatac | 
                 (pdr.related_product_definition :=: cd_bag[i]) );
  id_bag := [];
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].id ) THEN
      IF ( pdr_bag[j].id IN id_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        id_bag := id_bag + pdr_bag[j].id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'design functional unit allocation to assembly component' must have a
unique combination related_product_definition and id attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_joint_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_joint_constraint rule
constrains the relating and related product_definitions of a 
product_definition_relationship when it is a design functional unit
allocation to assembly joint.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE design_functional_unit_allocation_to_assembly_joint_constraint FOR 
( product_definition_relationship );
END_RULE; -- design_functional_unit_allocation_to_assembly_joint_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly joint' THEN 
SELF.relating_product_definition shall be a 
component_functional_unit.description = 'design definition path' that is the 
relating_product_definition of a product_definition_relationship.name = 
'design composition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly joint' THEN 
SELF.related_product_definition shall be a product_definition that is 
the of_shape.definition of an assembly_joint.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_joint_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_joint_unique_constraint rule
constrains product_definition_relationship population members, that fill the role
of ARM design_functional_unit_allocation_to_assembly_joint, so that the ARM
functional_design_definition_path shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE
design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  dfuataj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuataj) by 1;
  IF EXISTS( dfuataj[i].relating_product_definition ) THEN
    IF ( dfuataj[i].relating_product_definition.id = 
                         'design composition path' ) THEN
      IF ( dfuataj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuataj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_functional_unit_allocation_to_assembly_joint_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'design functional unit allocation to assembly joint' must have a
unique relating_product_definition attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_fabrication_joint_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_fabrication_joint_constraint rule
constrains the relating and related product_definition for a
product_definition_relationship when it is a design functional unit
allocation to fabrication joint.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE design_functional_unit_allocation_to_fabrication_joint_constraint FOR
( product_definition_relationship );
END_RULE; -- design_functional_unit_allocation_to_fabrication_-
          -- joint_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to fabrication joint' THEN 
SELF.relating_product_definition shall be a 
component_functional_unit.description = 'design definition path' that is the 
relating_product_definition of a product_definition_relationship.name = 
'design composition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to fabrication joint' THEN 
SELF.related_product_definition shall be a product_definition that is the 
of_shape.definition of an fabrication_joint.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_fabrication_joint_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_fabrication_joint_unique_constraint rule
constrains product_definition_relationship population members, that fill the role
of ARM design_functional_unit_allocation_to_fabrication_joint, so that the ARM
functional_design_definition_path shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE
design_functional_unit_allocation_to_fabrication_joint_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatfj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to fabrication joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatfj) by 1;
  IF EXISTS( dfuatfj[i].relating_product_definition ) THEN
    IF ( dfuatfj[i].relating_product_definition.id = 
                    'design composition path' ) THEN
      IF ( dfuatfj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuatfj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_functional_unit_allocation_to_fabrication_joint_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'design functional unit allocation to fabrication joint' must have a
unique relating_product_definition attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_reference_functional_unit_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_reference_functional_unit_constraint
rule constrains the related and relating product_definition for a
product_definition_relationship when it is a design functional unit
allocation to reference function unit.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE 
design_functional_unit_allocation_to_reference_functional_unit_constraint
FOR ( product_definition_relationship );
END_RULE; -- design_functional_unit_allocation_to_reference_functional_-
          -- unit_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to reference functional unit' THEN 
SELF.relating_product_definition shall be a 
component_functional_unit.description = 'design definition path' that is the 
relating_product_definition of a product_definition_relationship.name = 
'design composition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to reference functional unit' THEN 
SELF.related_product_definition shall be a 
component_functional_unit.description = 'reference definition path' that 
shall be the relating_product_definition of a 
product_definition_relationship.name = 'reference composition path'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_3d_position_constraint
rule constrains mapped_item when it is used as a
design intent modification in stratum planar position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_intent_modification_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'positioned design intent modification 3d shape')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
END_RULE; -- design_intent_modification_3d_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item with a name of
'positioned design intent modification 3d shape' shall
have a mapping_target that is a axis2_placement_3d.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item with a name of
'positioned design intent modification 3d shape' shall
be an item for a shape_representation with a name of
'3d bound volume shape' that is the used_representation
of a property_definiton_representation with a definition
that is a product_definition_shape with a definition
that is a physical_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each mapped_item with a name of
'positioned design intent modification 3d shape' shall
have a mapping_source that has a mapped_representation
that has a name of '3d bound volume shape' or is a
manifold_surface_shape_representation and that mapped_representation
is the used_representation for a property_definition_representation.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_planar_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_planar_position_constraint
rule constrains mapped_item when it is used as a
design intent modification planar position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_intent_modification_planar_position_constraint FOR
( mapped_item );
WHERE
 WR1: SIZEOF(QUERY(mi <* mapped_item |
     (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
 WR2: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
       AND (SIZEOF(QUERY(rep <* USEDIN(mi,       
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REPRESENTATION.ITEMS') |
       SIZEOF(USEDIN(rep,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
     + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) = 0
       )) = 0))) = 0;
 WR3: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN
      TYPEOF(mi.mapping_source.mapped_representation)))) = 0;
END_RULE; -- design_intent_modification_planar_position_-
     -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
have a mapping_target that is a axis2_placement_2d.
</formal.propositions.rul>

<formal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
be an item for a representation that is a 
used_representation of a property_definition_representation.
</formal.propositions.rul>

<formal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
have a mapping_source that has a mapped_representation
that is a property_definition_representation.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
be an item for a shape_representation with a name of
'planar projected shape' that is the used_representation
of a property_definiton_representation with a definition
that is a product_definition_shape with a definition
that is a physical_unit.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_non_planar_2d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_non_planar_2d_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a design intent modification non planar 2d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE design_intent_modification_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
END_RULE; -- design_intent_modification_non_planar_2d_shape_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'design intent modification non planar 2d shape' shall be
the used_representation for exactly one property_definition
that shall have a definition that is a shape_modification.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_sequence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_sequence_constraint rule constrains the
related and relating shape_aspect of a shape_aspect_relationship when it
is a shape modification sequence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_intent_modification_sequence_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'shape modification sequence')
               AND
         (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
            'SHAPE_MODIFICATION' IN TYPEOF (sar.relating_shape_aspect)))
               )) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'shape modification sequence')
               AND
        (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
            'SHAPE_MODIFICATION' IN TYPEOF (sar.related_shape_aspect)))
               )) = 0;
END_RULE; -- design_intent_modification_sequence_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'shape modification sequence' 
THEN SELF.relating_shape_aspect shall be a shape_modification.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'shape modification sequence' 
THEN SELF.related_shape_aspect shall be a shape_modification.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_sequence_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_sequence_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
design_intent_modification_sequence, so that the combination of ARM
precedent_modification and ARM subsequent_modification attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_intent_modification_sequence_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  dims : BAG OF shape_aspect_relationship := 
         QUERY( sar <* shape_aspect_relationship |
(sar\shape_aspect_relationship.name = 'shape modification sequence'));
  pm_bag : BAG OF shape_modification := [];
  sar_bag : BAG OF shape_aspect_relationship;
  sm_bag : BAG OF shape_modification;
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dims) by 1;
  IF EXISTS( dims[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_MODIFICATION' IN TYPEOF(dims[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dims[i].relating_shape_aspect IN pm_bag ) ) THEN
        pm_bag := pm_bag + dims[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pm_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* dims | 
         (sar.relating_shape_aspect :=: pm_bag[i]) );
  sm_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_MODIFICATION' IN 
                     TYPEOF(sar_bag[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sm_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sm_bag := sm_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_intent_modification_sequence_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'shape modification sequence'
that references a common shape_modification through its relating_shape_aspect attribute must
have a unique reference to a shape_modification through its related_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_object_management_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_object_management_relationship_constraint rule constrains the
related and relating product_definition of a product_definition_relationship
when it is a design object management relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE design_object_management_relationship_constraint FOR 
( product_definition_relationship );
END_RULE; -- design_object_management_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
('design object addition') 
('design object change') 
('design object deletion') 
THEN SELF.related_product_definition shall be a 
(product_definition_with_associated_documents) 
(physical_unit) 
(functional_unit).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
('design object addition') 
('design object change') 
('design object deletion') 
THEN SELF.relating_product_definition shall be a 
(product_definition_with_associated_documents) 
(physical_unit) 
(functional_unit).
</Informal.propositions.rul>
<Informal.propositions.rul>
FOR each product_definition_relationship.name = 
('design object addition') 
('design object change') 
('design object deletion') 
there must be exactly one 
(add_design_object_assignment) 
(delete_design_object_assignment) 
({change_to_design_object_assignment} 
 {change_from_design_object_assignment}) populated.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="device_2d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The device_2d_position_constraint rule constrains the mapping_target of a
mapped_item when it is used as a device_2d_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE device_2d_position_constraint FOR ( mapped_item );
END_RULE; -- device_2d_position_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = 'planar projected shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be a representation_item that is an 
items of a shape_representation where 
{shape_representation.name = 'planar projected shape'} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
packaged_part} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
physical_unit}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = 'planar projected shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item shall be an items of a shape_representation that is the 
used_representation of a property_definition_representation that has a 
definition.definition of a product_definition_relationship.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = 'planar projected shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be an axis2_placement_2d.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="device_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The device_3d_position_constraint rule constrains the mapping_target and the
usage of a mapped_item when it is used as a device_3d_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE device_3d_position_constraint FOR ( mapped_item );
END_RULE; -- device_3d_position_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = '3d bound volume shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be a representation_item that is an 
items of a shape_representation where 
{shape_representation.name = '3d bound volume shape'} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
packaged_part} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
physical_unit}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = '3d bound volume shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item shall be an items of a shape_representation that is the 
used_representation of a property_definition_representation that has a 
definition.definition that is a product_definition_relationship.
</Informal.propositions.rul> 
<Informal.propositions.rul> 
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = '3d bound volume shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be an axis2_placement_3d.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="device_terminal_map_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The device_terminal_map_relationship_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is used
as a device terminal map relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE device_terminal_map_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'device terminal map relationship')
               AND
      (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'DEVICE_TERMINAL_MAP' IN TYPEOF (sar.relating_shape_aspect)))
               )) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'device terminal map relationship')
               AND
    (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP' IN TYPEOF (sar.related_shape_aspect)))
               )) = 0;
END_RULE; -- device_terminal_map_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'device terminal map relationship' 
THEN shape_aspect_relationship.relating_shape_aspect shall be a 
device_terminal_map.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'device terminal map relationship' 
THEN shape_aspect_relationship.related_shape_aspect shall be a 
device_terminal_map.
</formal.propositions.rul>
</formal.Propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="diametrical_boundary_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The diametrical_boundary_size_characteristic_constraint rule constrains the use of a representation when it is used as a diametrical boundary size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE diametrical_boundary_size_characteristic_constraint FOR
  (representation);
END_RULE; -- diametrical_boundary_size_characteristic_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name of 'diametrical boundary size' shall represent at least one property_definition that has a description of 'boundary zone definition with specified size' and that property_definition shall be applied to a tolerance_zone_boundary that has a description of 'circular or cylindrical or spherical'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_along_curve_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_along_curve_constraint rule constrains the use of a dimensional_location_with_path when it is used as a dimension along curve.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE dimension_along_curve_constraint FOR
  (dimensional_location_with_path);
END_RULE; -- dimension_along_curve_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location_with_path shall have a description that is either 'arc length' or 'linear'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_along_curve_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_along_curve_unique_constraint rule constrains the
dimensional_location_with_path population members, that fill the
role of ARM dimension_along_curve, so that the ARM path
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dimension_along_curve_unique_constraint FOR
 ( dimensional_location_with_path );
LOCAL
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location_with_path) by 1;
  IF EXISTS( dimensional_location_with_path[i].path ) THEN
    IF ( dimensional_location_with_path[i].path IN sa_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      sa_bag := sa_bag + dimensional_location_with_path[i].path;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- dimension_along_curve_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of dimensional_location_with_path must have a
unique path attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_location_with_direction_vector_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_location_with_direction_vector_unique_constraint rule constrains the
dimensional_location_with_direction population members, that fill the role of ARM
dimension_location_with_direction_vector, so that the ARM measurement_direction
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dimension_location_with_direction_vector_unique_constraint FOR
 ( dimensional_location_with_direction );
LOCAL
  p_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_relationship;
  pdrep_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition := [];
  place_bag : BAG OF placement := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location_with_direction) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  p_bag := QUERY( pd <* USEDIN(dimensional_location_with_direction[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | 
(pd\property_definition.description = 'dimensional location property') );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN(p_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'measurement orientation') AND
(pdr.related_property_definition\property_definition.description = 
         'datum based vector orientation')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].related_property_definition ) THEN
        IF ( pdr_bag[k].related_property_definition IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + pdr_bag[k].related_property_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdrep_bag := USEDIN(p_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdrep_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(pdrep_bag[k].used_representation.items) by 1;
        IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PLACEMENT' IN TYPEOF(pdrep_bag[k].used_representation.items[l])) AND
(pdrep_bag[k].used_representation.items[l]\representation_item.name = 'orientation') ) THEN
          IF EXISTS( pdrep_bag[k].used_representation.items[l] ) THEN
           IF ( pdrep_bag[k].used_representation.items[l] IN 
                                                 place_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              place_bag := place_bag + 
                           pdrep_bag[k].used_representation.items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- dimension_location_with_direction_vector_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of dimensional_location_with_direction must either have a
unique property_definition entity with a name of 'datum based vector orientation'
that is related to the dimensional_location_with_direction by a
property_definition_relationship with a name of 'measurement orientation' or
have a unique placement entity with a name of 'orientation' that is related
to the dimensional_location_with_direction by a property_definition_representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a dimension qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE dimension_qualifier_constraint FOR
  (measure_qualification);
END_RULE; -- dimension_qualifier_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has a name of either 'predefined dimension qualifier' or 'user defined dimension qualifier' shall have a qualified_measure that is a measure_with_unit that is contained in the shape_dimension_representation that is a representation of at least one dimensional_location or dimensional_size.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_related_positional_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_related_positional_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a dimension related positional boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE dimension_related_positional_boundary_definition_constraint FOR
  (property_definition);
END_RULE; -- dimension_related_positional_boundary_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall be a property_definition of a positional_boundary that has a description of 'dimension related positional boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall relate to at least one property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary member property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall relate to at least one property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary member property' and each of the property_definition that have a description of 'positional boundary member property' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance shall relate to the same property_definition with a description of either 'datum system property with material conditions' or 'datum system property without material conditions' to specify their 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall relate to at least one property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary member property' and each of the property_definition that have a description of 'positional boundary member property' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance either shall not be modified_geometric_tolerance or shall have the same modifier.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_set_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_set_constraint rule constrains the use of a property_definition when it is used as a dimension set.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE dimension_set_constraint FOR
  (property_definition);
END_RULE; -- dimension_set_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension set' shall relate, to specify its 'set associated dimension', to at least one property_definition that is either a dimensional_size_property, or is a property_definition of a dimensional_location, that has a description of 'dimensional location property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension set' shall be related as a 'true profile specification' to at least one property_definition that has a description of 'true profile'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimensional_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimensional_characteristic_constraint rule constrains the use of a dimensional_location and a dimensional_size when they are used as a dimensional characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE dimensional_characteristic_constraint FOR
  (dimensional_location, dimensional_size, requirements_property);
END_RULE; -- dimensional_characteristic_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location description shall be among 'angular', 'arc length', 'controlled radius', 'diameter', 'linear', or 'radius'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size name shall be among 'angular', 'arc length', 'controlled radius', 'diameter', 'linear', or 'radius'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location shall be represented by exactly one shape_dimension_representation that contains a descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location shall be represented by exactly zero shape_dimension_representation that contains more than one descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size shall be represented by exactly one shape_dimension_representation that contains a descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size shall be represented by exactly zero shape_dimension_representation that contains more than one descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location shall be specified as the dimension by at most one dimensional_characteristic_representation that is not an auxiliary_characteristic_dimension_representation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size shall be specified as the dimension by at most one dimensional_characteristic_representation that is not an auxiliary_characteristic_dimension_representation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location that has a description of 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not plane_angle_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size that has a name of 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not plane_angle_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location that has a description that is not 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not length_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size that has a name that is not 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not length_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
If there is at least one dimensional_location, there shall exist exactly one requirements_property that has a representation that contains a descriptive_representation_item that has the name of 'requirements description' and a description of 'geometric dimensioning and tolerancing reference', and that requirements_property shall be an item of one or more document_reference the assigned_document of which are ee_specification.
</Informal.propositions.rul>

<Informal.propositions.rul>
If there is at least one dimensional_size, there shall exist exactly one requirements_property that has a representation that contains a descriptive_representation_item that has the name of 'requirements description' and a description of 'geometric dimensioning and tolerancing reference', and that requirements_property shall be an item of one or more document_reference the assigned_document of which are ee_specification.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimensional_location_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimensional_location_constraint rule constrains the use of a dimensional_location when it is used as a dimensional location.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE dimensional_location_constraint FOR
  (dimensional_location);
END_RULE; -- dimensional_location_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location shall have a description that is not 'diameter'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimensional_size_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimensional_size_constraint rule constrains the use of a dimensional_size when it is used as a dimensional size.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE dimensional_size_constraint FOR
  (dimensional_size);
END_RULE; -- dimensional_size_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_size shall be represented by exactly zero shape_dimension_representation that name if it exists is not 'envelope tolerance'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="directed_action_requires_approval">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_action_requires_approval rule assure that each
instance of directed_action has an associated 
applied_approval_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_action_requires_approval FOR
  (directed_action, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       da IN aaa.items )) = 1 ))) = 0;
END_RULE; -- directed_action_requires_approval
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of directed_action, there shall be exactly one instance
of applied_approval_assignment that contains the instance of directed_action
in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="directed_action_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_action_requires_date_or_date_and_time rule
assures that each instance of directed_action has an
associated applied_date_assignment or an
applied_date_and_time_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_action_requires_date_or_date_and_time FOR
  (directed_action, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (da IN adata.items)
       AND (adata.role\date_time_role.name = 'start date'))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (da IN ada.items)
       AND (ada.role\date_role.name = 'start date'))) = 1 )))) = 0;
END_RULE; -- directed_action_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of directed_action, there shall be exactly one
instance of applied_date_and_time_assignment whose role.name is 'start date'
or exactly one instance of applied_date_assignment whose role.name is
'start date' that contains the instance of directed_action in
its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="directed_axis_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_axis_constraint rule constrains the use of a derived_shape_aspect when it is used as a directed axis.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_axis_constraint FOR
  (derived_shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'derived axis')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       AND (sar\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'axis')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'end shape aspect')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'start shape aspect')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
END_RULE; -- directed_axis_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall relate to exactly one centre_of_symmetry that has a description of 'axis' to specify its 'derived axis'.
</formal.propositions.rul>

<formal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall relate to exactly one shape_aspect to specify its 'end shape aspect'.
</formal.propositions.rul>

<formal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall relate to exactly one shape_aspect to specify its 'start shape aspect'.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall specify a unique combination of shape_aspect that relate to the derived_shape_aspect to specify its 'start shape aspect' and its 'derived axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall not relate to the same shape_aspect to specify its 'start shape aspect' and its 'end shape aspect'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="directed_axis_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_axis_unique_constraint rule constrains the derived_shape_aspect
population members, that fill the role of ARM directed_axis, so that the
combination of ARM axis_to_be_oriented and ARM start_shape_element attributes
shall be unique within the population
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_axis_unique_constraint FOR
 ( derived_shape_aspect );
LOCAL
  da : BAG OF derived_shape_aspect := QUERY( r <* derived_shape_aspect |
(r\shape_aspect.description = 'directed axis') );
  sar_bag : BAG OF shape_aspect_relationship;
  cos_bag : BAG OF centre_of_symmetry := [];
  sar2_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(da) by 1;
  sar_bag := QUERY( sar <* USEDIN(da[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.related_shape_aspect\shape_aspect.description = 'axis') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CENTRE_OF_SYMMETRY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( NOT( sar_bag[j].related_shape_aspect IN cos_bag ) ) THEN
        cos_bag := cos_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cos_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  sar_bag := QUERY( sar <* USEDIN(cos_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.relating_shape_aspect IN da)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar2_bag := QUERY( sar <* USEDIN(sar_bag[j].relating_shape_aspect,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
(sar\shape_aspect_relationship.name = 'start shape aspect') );
    REPEAT k := 1 to SIZEOF(sar2_bag) by 1;
      IF EXISTS( sar2_bag[k].related_shape_aspect ) THEN
        IF ( sar2_bag[k].related_shape_aspect IN sa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sa_bag := sa_bag + sar2_bag[k].related_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- directed_axis_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of derived_shape_aspect with a description of 'derived axis'
must have a unique combination of centre_of_symmetry and shape_aspect
entities where the centre_of_symmetry is related to the derived_shape_aspect
by a shape_aspect_relationship with a name of 'derived axis' and the
shape_aspect is related to the derived_shape_aspect by a
shape_aspect_relationship with a name of 'start shape aspect'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="direction_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The direction_element_constraint rule constrains the use of a property_definition when it is used as a direction element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE direction_element_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'element direction vector')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'half datum plane direction vector')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'direction component')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description =
       'datum based vector orientation'))) = 1))) = 0;
END_RULE; -- direction_element_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall be related as a 'direction component' to at least one property_definition that has a description of 'datum based vector orientation'.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship'. The shape_aspect_relationship shall have a related_shape_aspect of type physical_unit_datum that has a description of 'plane' and a relating_shape_aspect of type shape_aspect that has a description of 'half plane' and that is not on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall have a representation that contains exactly one plane_angle_measure_with_unit that has a name of 'angle value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector', this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'. 

Additionally, each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector', this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'.

Finally, each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship' and that shape_aspect_relationship shall have a related_shape_aspect of type physical_unit_datum that has a description of 'plane'. 

Each of these three physical_unit_datum shall not be the same.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="edge_segment_vertex_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The edge_segment_vertex_constraint rule constrains the shape_aspect and shape_aspect_relationship population members to satisfy the requirements of the ARM object Edge_segment_vertex.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE edge_segment_vertex_constraint 
FOR (shape_aspect_relationship, edge_segment_vertex);
LOCAL
sar : BAG OF shape_aspect_relationship := [];
esv : BAG OF edge_segment_vertex := edge_segment_vertex;
pass : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 1 to SIZEOF (esv) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
      sar := QUERY (sar <* shape_aspect_relationship |
       esv[i] = sar\shape_aspect_relationship.related_shape_aspect);
       pass := (SIZEOF(sar) = 2);
      REPEAT j := 2 to SIZEOF (sar) by 1;
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( (sar[j]) :<>: (sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( TYPEOF(sar[j]) = TYPEOF(sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := (sar[j].relating_shape_aspect :=:
               sar[j-1].relating_shape_aspect);
      END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;  -- edge_segment_vertex_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each edge_segment_vertex shall be referenced by two different segments for the same edge,
where the types of the two segments shall be the same.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="edge_segment_vertex_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The edge_segment_vertex_unique_constraint rule constrains the
edge_segment_vertex population members, that fill the role of ARM
edge_segment_vertex, to have unique ARM name attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE edge_segment_vertex_unique_constraint FOR
 ( edge_segment_vertex );
LOCAL
  esv : BAG OF edge_segment_vertex := QUERY( r <* edge_segment_vertex
| (r\shape_aspect.name = 'single datum') );
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(esv) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := QUERY( pd <* USEDIN( esv[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | 
(pd\property_definition.description = 'shape element characterization') );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := USEDIN( pd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      IF ( (pdr_bag[k].used_representation\representation.name = 
           'shape element characterization') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pdr_bag[k].used_representation.items[1])) ) THEN
        IF EXISTS
            ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description ) THEN
          IF ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description IN 
                   desc_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            desc_bag := desc_bag + 
                      pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- edge_segment_vertex_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of edge_segment_vertex with a name of 'single datum' must have
unique description attributes on descriptive_representation_item entities that are
the first entry in the used_representation.items attribute of
property_definition_representation entities that have said edge_segment_vertex
entities as the property_definition_representation's definition.defintion attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_colour_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_colour_unique_constraint rule constrains the colour_specification.name population members to satisfy the uniqueness requirement of the ARM application object Ee_colour.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE ee_colour_unique_constraint FOR (colour_rgb, colour_specification);

LOCAL
  r : BAG OF colour_rgb := QUERY (r <* colour_rgb | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\colour_specification.name ) THEN
    IF (r[i]\colour_specification.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\colour_specification.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;
END_RULE; -- ee_colour_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The colour_specification.name shall be unique within a population of colour_rgb.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_document_constraint">
<RULE.DESCRIPTION>
The ee_document_constraint rule constrains the usage of a document.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_document_constraint FOR ( document );
WHERE
  WR1: SIZEOF(QUERY(doc <* document |
       (SIZEOF(QUERY(adata <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(doc <* document |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'publisher')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'publisher')
       )) = 1)))) = 0;
  WR3: SIZEOF(QUERY(doc <* document |
       NOT (SIZEOF(USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS')) = 1)
       )) = 0;
END_RULE; -- ee_document_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A document shall be an items of an applied_date_and_time_assignment where the date and time is in the role of 'creation date'.
</formal.propositions.rul>
<formal.propositions.rul>
A document shall be an items of 
(an applied_organization_assignment.role.name = 'publisher') 
(a applied_person_and_organization_assignment.role.name = 'publisher').
</formal.propositions.rul>
<formal.propositions.rul>
A document shall be an items of exactly one document_identifier_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_document_unique_constraint">
<RULE.DESCRIPTION>
The ee_document_unique_constraint rule constrains document population members, that fill the role of ARM ee_document, so that ARM identification attributes shall be unique within the population.
The combination of base_identifier and revision shall be unique.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_document_unique_constraint FOR
 ( document, document_identifier_assignment );
LOCAL
  pass : BOOLEAN := TRUE;
  rev_exists_bag : BAG OF document := [];
  dia_bag : BAG OF document_identifier_assignment := [];
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(document) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  IF NOT(EXISTS( document[i].description )) THEN
   pass := FALSE;
  END_IF;
END_REPEAT;


REPEAT i := 1 to SIZEOF(document_identifier_assignment) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(document_identifier_assignment[i].items) by 1;
     desc_bag := desc_bag + document_identifier_assignment[i].items[j]\document.description;
  END_REPEAT;
  IF NOT(value_unique(desc_bag)) THEN
    pass := FALSE;
  END_IF;
END_REPEAT;

WHERE
  WR1: pass;
END_RULE; -- ee_document_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of document must have a unique combination of document_identifier and document.description.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_material_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_material_constraint rule constrains the use of a material_designation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE ee_material_constraint FOR
  (material_designation);
END_RULE; -- ee_material_constraint
*)
(*
</EXPRESS.CODE>
<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<Informal.propositions.rul>
The material_designation shall be the designation for at most one material_electrical_conductivity_category.
</Informal.propositions.rul>

<Informal.propositions.rul>
The material_designation shall be the designation for at most one material_optical_conductivity_category.
</Informal.propositions.rul>

<Informal.propositions.rul>
The material_designation shall be the designation for at most one material_thermal_conductivity_category.
</Informal.propositions.rul>

<Informal.propositions.rul>
The material_designation shall be an items for exactly one applied_document_reference.
</Informal.propositions.rul>

</INFORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_material_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_material_unique_constraint rule constrains the material_designation
population members, that fill the role of ARM ee_material, so that the
combination of ARM material_name and ARM registration_document attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_material_unique_constraint FOR
 ( material_designation );
LOCAL
  name_bag : BAG OF STRING := [];
  md_bag : BAG OF material_designation;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(material_designation) by 1;
  IF EXISTS( material_designation[i].name ) THEN
    IF( NOT( material_designation[i].name IN name_bag ) ) THEN
      name_bag := name_bag + material_designation[i].name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  md_bag := QUERY( md <* material_designation | (md\material_designation.name = name_bag[i]) );
  doc_bag := [];
  REPEAT j := 1 to SIZEOF(md_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( md_bag[j], 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DOCUMENT') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- ee_material_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of material_designation must have a unique combination of name
attribute and document entity assigned to the material_designation by an
applied_document_reference's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_configuration_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_configuration_constraint rule constrains the usage of an
ee_product_configuration.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE ee_product_configuration_constraint FOR ( configuration_item );
END_RULE; -- ee_product_configuration_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A configuration_item shall be the item of one 
(organization_assignment.role.name = 'configuration manager') 
(person_and_organization_assignment.role.name = 'configuration manager').
</Informal.propositions.rul>
<Informal.propositions.rul>
A configuration_item shall be an items of an approval_assignment.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_configuration_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_configuration_unique_constraint rule constrains the configuration_item
population members, that fill the role of ARM ee_product_configuration, so that the
combination of ARM item_id and ARM satisfying_product attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_configuration_unique_constraint FOR
 ( configuration_item );
LOCAL
  id_bag : BAG OF STRING := [];
  ci_bag : BAG OF configuration_item;
  cd_bag : BAG OF configuration_design;
  pass : BOOLEAN := TRUE;
  pdf_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_item) by 1;
  IF EXISTS( configuration_item[i].id ) THEN
    IF( NOT( configuration_item[i].id IN id_bag ) ) THEN
      id_bag := id_bag + configuration_item[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdf_bag := [];
  ci_bag := QUERY( ci <* configuration_item | (ci.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(ci_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    cd_bag := USEDIN( ci_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'CONFIGURATION_DESIGN.CONFIGURATION');
    REPEAT k := 1 to SIZEOF(cd_bag) by 1;
      IF EXISTS( cd_bag[k].design ) THEN
        IF ( cd_bag[k].design IN pdf_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pdf_bag := pdf_bag + cd_bag[k].design;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- ee_product_configuration_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of configuration_item must have a unique combination of id
attribute and product_definition_formation entity related to the configuration_item
by a configuration_design entity.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_constraint">
<RULE.DESCRIPTION>
The ee_product_constraint rule constrains the usage of a product.
<note>
Since there is no standard interpretation of category for Ee_product, there is no population constraint on product_category in this rule.
</note>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_constraint FOR ( product );
WHERE
  WR1: SIZEOF(QUERY(prod <* product |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(prod,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'design owner')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(prod,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'design owner')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(p <* product |
              SIZEOF(USEDIN(p,
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT')) = 0)) = 0;
END_RULE; -- ee_product_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A product shall be an items in 
(an organization_assignment.role.name = 'design owner') 
(a person_and_organization_assignment.role.name = 'design owner').
</formal.propositions.rul>
<formal.propositions.rul>
A product shall be the of_product of at least one 
product_definition_formation.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_definition_constraint rule constrains the use of a
product_definition_with_associated_documents.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_definition_constraint FOR 
( product_definition_with_associated_documents );
WHERE
  WR1: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(QUERY(adata <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'creator')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'creator')
       )) = 1))
       )) = 0;
  WR3: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
  WR4: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
END_RULE; -- ee_product_definition_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of one 
applied_date_and_time_assignment with a date and time role name = 'creation date'.
</formal.propositions.rul>
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of at least one 
(applied_organization_assignment with an organization role name = 'creator') 
(applied_person_and_organization_assignment with a person and organization role name = 'creator').
</formal.propositions.rul>
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of one 
applied_approval_assignment.
</formal.propositions.rul>
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of one 
applied_security_classification_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_definition_unique_constraint rule constrains the
product_definition_with_associated_documents, physical_unit and functional_unit
population members, that fill the role of ARM ee_product_definition, so that the
the combination of ARM product_definition_id and ARM version attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_definition_unique_constraint FOR
 ( product_definition_with_associated_documents, 
   physical_unit, functional_unit );
LOCAL
  pdwad : BAG OF product_definition := 
QUERY( r <* product_definition_with_associated_documents | (TRUE) );
  pu : BAG OF product_definition := QUERY( r <* physical_unit | (TRUE) );
  fu : BAG OF product_definition := QUERY( r <* functional_unit | (TRUE) );
  epd : BAG OF product_definition;
  pdf_bag : BAG OF product_definition_formation;
  pd_bag : BAG OF product_definition;
  pass1 : BOOLEAN := TRUE;
  lcs_bag : BAG OF STRING;
  pass2 : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

epd := pdwad + pu + fu;
REPEAT i := 1 to SIZEOF(epd) by 1;
  IF EXISTS( epd[i].formation ) THEN
    IF( NOT( epd[i].formation IN pdf_bag ) ) THEN
      pdf_bag := pdf_bag + epd[i].formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  lcs_bag := [];
  id_bag := [];
  pd_bag := QUERY( pd <* epd | (pd.formation :=: pdf_bag[i]) );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass2 ) THEN
      IF EXISTS( pd_bag[j].id ) THEN
        IF ( pd_bag[j].id IN id_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + pd_bag[j].id;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass2;
END_RULE; -- ee_product_definition_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_with_associated_documents, physical_unit and
functional_unit must have a unique combination of formation and id attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_model_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_model_unique_constraint rule constrains the product_concept.id population members to satisfy the uniqueness requirement of the ARM application object Ee_product_model.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE ee_product_model_unique_constraint FOR (product_concept);

LOCAL
  r : BAG OF product_concept := QUERY (r <* product_concept | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\product_concept.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;
END_RULE; -- ee_product_model_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The id shall be unique within a population of product_concept.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_unique_constraint">
<RULE.DESCRIPTION>
The ee_product_unique_constraint rule constrains the product
population members, that fill the role of ARM ee_product, so that the
combination of ARM part_number and ARM design_owner attributes shall
be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_unique_constraint FOR
 ( product );
LOCAL
  id_bag : BAG OF STRING := [];
  p_bag : BAG OF product;
  aoa_bag : BAG OF applied_organization_assignment;
  apaoa_bag : BAG OF applied_person_and_organization_assignment;
  pass : BOOLEAN := TRUE;
  o_bag : BAG OF organization;
  pao_bag : BAG OF person_and_organization;
END_LOCAL;

REPEAT i := 1 to SIZEOF(product) by 1;
  IF EXISTS( product[i].id ) THEN
    IF( NOT( product[i].id IN id_bag ) ) THEN
      id_bag := id_bag + product[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  o_bag := [];
  pao_bag := [];
  p_bag := QUERY( p <* product | (p.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aoa_bag := QUERY( aoa <* USEDIN( p_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ORGANIZATION' IN TYPEOF(aoa.assigned_organization)) AND 
(aoa.role\organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(aoa_bag) by 1;
      IF EXISTS( aoa_bag[k].assigned_organization ) THEN
        IF ( aoa_bag[k].assigned_organization IN o_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          o_bag := o_bag + aoa_bag[k].assigned_organization;
        END_IF;
      END_IF;
    END_REPEAT;
    apaoa_bag := QUERY( apaoa <* USEDIN( p_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PERSON_AND_ORGANIZATION' IN 
TYPEOF(apaoa.assigned_person_and_organization)) 
AND (apaoa.role\person_and_organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(apaoa_bag) by 1;
      IF EXISTS( apaoa_bag[k].assigned_person_and_organization ) THEN
        IF ( apaoa_bag[k].assigned_person_and_organization IN pao_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pao_bag := pao_bag + 
                     apaoa_bag[k].assigned_person_and_organization;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- ee_product_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product must have a unique combination of id
attribute and either organization or person_and_organization entity
assigned to the product by either an applied_organization_assignment's
or an applied_person_andorganization_assignment's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_version_supersedence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_version_supersedence_constraint rule constrains the usage of a
product_definition_formation_relationship when it is a product version supersedence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_version_supersedence_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       ((pdfr\product_definition_formation_relationship.name = 'product version supersedence')
       AND (NOT(pdfr.relating_product_definition_formation.of_product :=:
           pdfr.related_product_definition_formation.of_product)))
       )) = 0;
END_RULE; -- ee_product_version_supersedence_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_formation_relationship.name = 'product version supersedence' 
THEN the relating version and the related version shall be for the same product. 
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_rule_conclusion_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_rule_conclusion_definition_unique_constraint rule constrains the rule_conclusion_definition population members to be uniquely identifiable within the scope of a rule definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_rule_conclusion_definition_unique_constraint FOR 
(rule_conclusion_definition,
representation,representation_relationship);
LOCAL
r : BAG of representation := 
           QUERY (r <* representation | r\representation.name = 
                                             'rule definition');
rr : BAG OF representation_relationship := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
name_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   count := 0;
   name_bag := [];
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr := USEDIN(r[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'REPRESENTATION_RELATIONSHIP.REP_1');
   REPEAT j := 1 to SIZEOF (rr) by 1;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_CONCLUSION_DEFINITION' IN
       TYPEOF (rr[j].rep_2)
    THEN
      IF EXISTS( rr[j].rep_2\representation.name ) THEN
        IF rr[j].rep_2\representation.name IN name_bag
        THEN
         pass := FALSE;
        ELSE
         name_bag := name_bag + rr[j].rep_2\representation.name;
        END_IF;
      END_IF;
    END_IF;
   END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;  --  ee_rule_conclusion_definition_unique_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
No more than one rule_conclusion_definition shall have the same name within the scope of a rule definition.
</Formal.propositions.rul>

</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_rule_function_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_rule_function_unique_constraint rule constrains the
rule_function_definition population members, that fill the role of
ARM ee_rule_function, so that the combination of ARM identifier
and ARM reference_document attributes shall be unique within the
population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_rule_function_unique_constraint FOR
 ( rule_function_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  rfd_bag : BAG OF rule_function_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_function_definition) by 1;
  IF EXISTS( rule_function_definition[i]\representation.name ) THEN
    IF( NOT( rule_function_definition[i]\representation.name IN name_bag ) ) THEN
      name_bag := name_bag + rule_function_definition[i]\representation.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  doc_bag := [];
  rfd_bag := QUERY( am <* rule_function_definition | 
               (am\representation.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(rfd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( rfd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) |
(adr.assigned_document.kind\document_type.product_data_type = 'reference document') );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- ee_rule_function_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of rule_function_definition must have a unique combination of name
attribute and document entity assigned to the rule_function_definition by an
applied_document_reference's items attribute where the document has a
kind.product_data_type of 'reference document'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_rule_premise_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_rule_premise_definition_unique_constraint rule constrains the rule_premise_definition population members to be uniquely identifiable within the scope of a rule definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_rule_premise_definition_unique_constraint FOR
(rule_premise_definition,
representation,representation_relationship);
LOCAL
r : BAG of representation := 
              QUERY (r <* representation | r\representation.name = 
                             'rule definition');
rr : BAG OF representation_relationship := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
name_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   count := 0;
   name_bag := [];
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr := USEDIN(r[i],
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
                     'REPRESENTATION_RELATIONSHIP.REP_1');
   REPEAT j := 1 to SIZEOF (rr) by 1;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'RULE_PREMISE_DEFINITION' IN
       TYPEOF (rr[j].rep_2)
    THEN
      IF EXISTS( rr[j].rep_2\representation.name ) THEN
        IF rr[j].rep_2\representation.name IN name_bag
        THEN
         pass := FALSE;
        ELSE
         name_bag := name_bag + rr[j].rep_2\representation.name;
        END_IF;
      END_IF;
    END_IF;
   END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;  -- ee_rule_premise_definition_unique_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
No more than one rule_premise_definition shall have the same name within the scope of a rule definition.
</Formal.propositions.rul>

</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="equivalent_functional_terminals_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The equivalent_functional_terminals_assignment_constraint rule constrains
the related and relating shape_aspect of a shape_aspect_relationship when it
is used as an equivalent functional terminals assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE equivalent_functional_terminals_assignment_constraint FOR 
( shape_aspect_relationship );
END_RULE; -- equivalent_functional_terminals_assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'equivalent functional terminals 
assignment' THEN {related_shape_aspect} {relating_shape_aspect} shall be 
functional_unit_terminal_definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="equivalent_functional_unit_definition_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The equivalent_functional_unit_definition_assignment_constraint rule constrains
the use of the related and relating product_definition of a
product_definition_relationship when it is used as an equivalent functional
unit definition assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE equivalent_functional_unit_definition_assignment_constraint FOR
( product_definition_relationship );
END_RULE; -- equivalent_functional_unit_definition_assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'equivalent functional unit definition assignment' THEN 
{related_product_definition} 
{relating_product_definition} shall be a functional_unit with a 
frame_of_reference that is an application_context_element.name = 
('functional network design') ('functional design usage').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="evaluated_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The evaluated_characteristic_constraint rule constrains the rep_1, rep_2, and
description of a representation_relationship when it is used as an
evaluated characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE evaluated_characteristic_constraint FOR 
( representation_relationship );
END_RULE; -- evaluated_characteristic_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of representation_relationship whose name = 
'evaluated characteristic' shall have one rep_2 which is a 
coordinated_representation_item.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each instance of representation_relationship whose name = 
'evaluated characteristic' shall have a description = ('valid') ('invalid') 
('not evaluatable') ('to be evaluated').
</Informal.propositions.rul>
<Informal.propositions.rul>
Each instance of representation_relationship whose name = 
'evaluated characteristic' shall have one rep_1 that is a representation that 
is the used_representation of a property_definition_representation that has a 
name = 'planned characteristic'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="explicitly_located_layer_connection_point_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The explicitly_located_layer_connection_point_unique_constraint rule constrains the
layer_connection_point population members, that fill the role of ARM
explicitly_located_layer_connection_point, so that the combination of ARM location
and ARM resident_design_layer_stratum attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE explicitly_located_layer_connection_point_unique_constraint FOR
 ( layer_connection_point );
LOCAL
  ellcp : BAG OF layer_connection_point := 
   QUERY( lcp <* layer_connection_point
| (lcp\shape_aspect.description = 'explicitly located') );
  s_bag : BAG OF stratum := [];
  lcp_bag : BAG OF layer_connection_point;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  cp_bag : BAG OF cartesian_point;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ellcp) by 1;
  IF EXISTS( ellcp[i].of_shape.definition ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM' IN TYPEOF(ellcp[i].of_shape.definition) ) THEN
      IF( NOT( ellcp[i].of_shape.definition IN s_bag ) ) THEN
        s_bag := s_bag + ellcp[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cp_bag := [];
  lcp_bag := 
    QUERY( lcp <* ellcp | (lcp.of_shape.definition :=: s_bag[i]) );
  REPEAT j := 1 to SIZEOF(lcp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := USEDIN( lcp_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PROPERTY_DEFINITION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := QUERY( pdr <* USEDIN( pd_bag[k],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
((pdr.used_representation\representation.name =
'connection point location') AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CARTESIAN_POINT' IN TYPEOF(pdr.used_representation.items[1]))) );
      REPEAT l := 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].used_representation.items[1] ) THEN
          IF ( pdr_bag[l].used_representation.items[1] IN cp_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            cp_bag := cp_bag + pdr_bag[l].used_representation.items[1];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- explicitly_located_layer_connection_point_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of layer_connection_point with a description of 'explicitly located'
must have a unique combination of of_shape.definition attribute and
cartesian_point entity related to the layer_connection_point by a
property_definition_representation entity that has the layer_connection_point
as its definition.definition attribute and has the cartesian_point in the items
attribute of shape_representation that the property_definition_representation
has as its used_representation attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="feature_group_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The feature_group_relationship_constraint rule constrains
the relating_shape_aspect of a shape_aspect_relationship when it is used
as a feature group relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE feature_group_relationship_constraint FOR
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'feature group relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       )) = 0;
END_RULE; -- feature_group_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'feature group relationship' THEN 
SELF.relating_shape_aspect shall be a composite_shape_aspect.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="feature_shape_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The feature_shape_definition_constraint rule constrains the use of a 
shape_representation when it is used as a feature_shape_definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE feature_shape_definition_constraint FOR (
         shape_representation);
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'zone shape')
       AND (sr.context_of_items.coordinate_space_dimension = 3)
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(sr)))) = 0;
END_RULE; -- feature_shape_definition_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
Each instance of shape_representation with a name of 'zone shape' and a dimensionality of 3
shall be a manifold_subsurface_shape_representation.
</formal.propositions.rul> 

</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="fill_area_occurrence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The fill_area_occurrence_constraint rule constrains the values of styled_item,
fill_style_target, and styles of an annotation_fill_area_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE fill_area_occurrence_constraint FOR 
( annotation_fill_area_occurrence );
WHERE
  WR1: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'ANNOTATION_FILL_AREA' IN TYPEOF(afao.item))
       )) = 0;
  WR2: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CARTESIAN_POINT' IN TYPEOF(afao.fill_style_target))
       )) = 0;
  WR3: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       SIZEOF(QUERY(psa <* afao.styles |
       SIZEOF(QUERY(cs <* psa.styles |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CURVE_STYLE' IN TYPEOF(cs))
       )) = 0
       )) = 0
       )) = 0;
END_RULE; -- fill_area_occurrence_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
An annotation_fill_area_occurrence shall have a SELF\styled_item.item that is an 
annotation_fill_area.
</formal.propositions.rul>
<formal.propositions.rul>
An annotation_fill_area_occurrence shall have a fill_style_target that is a 
cartesian_point.
</formal.propositions.rul>
<formal.propositions.rul>
An annotation_fill_area_occurrence shall have at least one styles.styles 
that is a curve_style.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
An annotation_fill_area_occurrence shall have a styled_item.item.boundaries 
that is a representation_item that is an item of a styled_item that has 
one styles.styles that is a curve_style.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="fill_area_style_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

fill_area_style_constraint
The fill_area_style_constraint rule constrains the size of fill_styles of a fill_area_style.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE fill_area_style_constraint FOR ( fill_area_style );
WHERE
  WR1: SIZEOF(QUERY(fas <* fill_area_style |
       NOT (SIZEOF(fas.fill_styles) = 1 )
       )) = 0;
END_RULE; -- fill_area_style_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
The size of fill_styles shall be exactly 1.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="fill_area_style_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The fill_area_style_unique_constraint rule constrains the fill_area_style.name population members to satisfy the uniqueness requirement of the ARM application object Fill_area_style.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE fill_area_style_unique_constraint FOR (fill_area_style);

LOCAL
  r :  BAG OF fill_area_style := QUERY (r <* fill_area_style | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\fill_area_style.name ) THEN
    IF (r[i]\fill_area_style.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\fill_area_style.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;

END_RULE; -- fill_area_style_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of fill_area_style.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_specification_to_requirement_occurrence_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_specification_to_requirement_occurrence_assignment_constraint
rule constrains a representation_relationship when it
is used as a functional_specification_to_requirement_occurrence_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE 
functional_specification_to_requirement_occurrence_assignment_constraint
FOR ( representation_relationship );
END_RULE; -- functional_specification_to_requirement_occurrence_-
          -- assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {representation_relationship.name = 'functional specification to requirement occurrence assignment'}
THEN rep_1 shall reference a representation that is a used_representation for a property_definition_representation
that has a definition that is a requirements_property.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF {representation_relationship.name = 'functional specification to requirement occurrence assignment'}
THEN rep_2 shall be a functional_specification.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_network_node_definition_unique_constraint">
<RULE.DESCRIPTION>
The functional_unit_network_node_definition_unique_constraint rule constrains
the network_node_definition population members, that fill the role of ARM
functional_unit_network_node_definition, so that the combination of ARM
functional_unit_network_node_name and ARM associated_functional_unit_definition
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_network_node_definition_unique_constraint FOR
 ( network_node_definition );
LOCAL
  funnd : BAG OF network_node_definition := 
 QUERY( nnd <* network_node_definition
| (nnd.frame_of_reference.name = 'functional network design') );
  name_bag : BAG OF STRING := [];
  nnd_bag : BAG OF network_node_definition;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(funnd) by 1;
  IF EXISTS( funnd[i]\product_definition.name ) THEN
    IF( NOT( funnd[i]\product_definition.name IN name_bag ) ) THEN
      name_bag := name_bag + funnd[i]\product_definition.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  nnd_bag := QUERY( nnd <* funnd | (nnd\product_definition.name = 
          name_bag[i]) );
  REPEAT j := 1 to SIZEOF(nnd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( nnd_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND 
                  (pdr\product_definition_relationship.name = 'functional unit network node')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_unit_network_node_definition_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of network_node_definition with a frame_of_reference.name
of 'functional network design' must have a unique combination of
formation.of_product.name attribute and functional_unit entity
related to the network_node_definition by a product_definition_relationship
with a name of 'functional unit network node'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_network_terminal_definition_bus_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_network_terminal_definition_bus_assignment_constraint rule
constrains the related and relating property_definition for a
property_definition_relationship when it is used as a functional unit network
terminal definition bus assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_network_terminal_definition_bus_assignment_constraint
FOR ( property_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* property_definition_relationship |
  (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION' IN
       TYPEOF(pdr.relating_property_definition.definition))
       )) = 0;
  WR2: SIZEOF(QUERY(pdr <* property_definition_relationship |
  (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE' IN
       TYPEOF(pdr.related_property_definition.definition))
       AND (SIZEOF(QUERY(futd <* 
                       USEDIN(pdr.related_property_definition.definition,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION.OF_SHAPE' IN TYPEOF(futd))
       )) > 0)))) = 0;
END_RULE; -- functional_unit_network_terminal_definition_bus_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition bus assignment' THEN SELF.relating_property_definition.definition 
shall be a bus_structural_definition.
</formal.propositions.rul>
<formal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition bus assignment' THEN SELF.related_property_definition shall be a 
product_definition_shape that is the of_shape of a 
functional_unit_terminal_definition.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_network_terminal_definition_node_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_network_terminal_definition_node_assignment_constraint rule
constrains the value of the related and relating property_definition of a 
property_definition_relationship when it is a functional unit network
terminal definition node assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE functional_unit_network_terminal_definition_node_assignment_constraint
FOR ( property_definition_relationship );
END_RULE; -- functional_unit_network_terminal_definition_node_-
          -- assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition node assignment' THEN SELF.relating_property_definition.definition 
shall be a network_node_definition that has a frame_of_reference that is 
an application_context_element.name = 'functional network design'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition node assignment' THEN SELF.related_property_definition shall be a 
product_definition_shape that is the of_shape of a 
functional_unit_terminal_definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_requirement_allocation_constraint rule constrains the
related and relating product_definition of a product_definition_relationship
when it is a functional unit requirement allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE  functional_unit_requirement_allocation_constraint FOR
( product_definition_relationship );
END_RULE; -- functional_unit_requirement_allocation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship name = 'functional unit requirement 
allocation' THEN the relating_product_definition {shall be a 
product_definition with a frame_of_reference that is an 
application_context_element with name = 'design requirement'} 
{shall be the definition of a property_definition that is the
related_property_definition for a property_definition_relationship 
{with a name of 'functional requirement'} and a relating_property_relationship 
that is a requirements_property}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 'functional unit requirement 
allocation' THEN the related_product_definition shall be a 
component_functional_unit whose frame_of_reference is an 
application_context_element name = 'functional occurrence'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_terminal_bus_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_terminal_bus_assignment_constraint rule constrains the
related and relating property_definition of a property_definition_relationship
when it is a functional unit terminal bus assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_terminal_bus_assignment_constraint FOR
( property_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* property_definition_relationship |
       (pdr\property_definition_relationship.name = 'functional unit terminal bus assignment')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'BUS_STRUCTURAL_DEFINITION'
       IN TYPEOF(pdr.relating_property_definition.definition))
       )) = 0;
END_RULE; -- functional_unit_terminal_bus_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal 
bus assignment' THEN the relating_property_definition definition shall be
a bus_structural_definition.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal 
bus assignment' THEN the related_property_definition shall be a 
product_definition_shape that is the of_shape of a 
component_functional_terminal whose description = 'unit terminal'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_terminal_node_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_terminal_node_assignment_constraint rule constrains the
related and relating property_definition of a property_definition_relationship
when it is a functional unit terminal node assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE functional_unit_terminal_node_assignment_constraint FOR
( property_definition_relationship );
END_RULE; -- functional_unit_terminal_node_assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal node 
assignment' THEN the relating_property_definition definition shall be a 
network_node_definition that has a frame_of_reference that is an 
application_context_element with a name = 'functional network design'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal node 
assignment' THEN the relating_property_definition shall be a
product_definition_shape that is the of_shape of a 
component_functional_terminal whose description = 'unit terminal'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_unique_constraint rule constrains the component_functional_unit
population members, that fill the role of ARM component_functional, so that the
combination of ARM reference_designation and ARM composed_network attributes shall
be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_unique_constraint FOR
 ( component_functional_unit );
LOCAL
  fu : BAG OF component_functional_unit := 
QUERY( cfu <* component_functional_unit
| (cfu.frame_of_reference.name = 'functional occurrence') );
  id_bag : BAG OF STRING := [];
  cfu_bag : BAG OF component_functional_unit;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fu) by 1;
  IF EXISTS( fu[i].id ) THEN
    IF( NOT( fu[i].id IN id_bag ) ) THEN
      id_bag := id_bag + fu[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  cfu_bag := QUERY( cfu <* fu | (cfu.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(cfu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( cfu_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
((pdr\product_definition_relationship.name = 'network composition')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'FUNCTIONAL_UNIT'
IN TYPEOF(pdr.relating_product_definition)) AND 
      (pdr.relating_product_definition.frame_of_reference.name =
       'functional network design')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_unit_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_functional_unit with a frame_of_reference.name of
'functional occurrence' must have a unique combination of id attribute and
functional_unit entity related to the component_functional_unit
by a product_definition_relationship entity with a name of 'network composition'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_usage_view_terminal_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_usage_view_terminal_definition_unique_constraint rule
constrains the functional_unit_terminal_definition population members, that
fill the role of ARM functional_unit_usage_view_terminal_definition, so that
the combination of ARM signal_name and ARM associated_functional_unit_definition
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR
 ( functional_unit_terminal_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  futd_bag : BAG OF functional_unit_terminal_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(functional_unit_terminal_definition) by 1;
  IF EXISTS( functional_unit_terminal_definition[i]\shape_aspect.name ) THEN
    IF( NOT( functional_unit_terminal_definition[i]\shape_aspect.name IN 
                                              name_bag ) ) THEN
      name_bag := name_bag + 
                    functional_unit_terminal_definition[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  futd_bag := QUERY( futd <* functional_unit_terminal_definition |
((futd\shape_aspect.name = name_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(futd.of_shape.definition)) AND
(futd.of_shape.definition.frame_of_reference.name = 
                                    'functional design usage')) );
  REPEAT j := 1 to SIZEOF(futd_bag) by 1;
    IF EXISTS( futd_bag[j].of_shape.definition ) THEN
      IF ( futd_bag[j].of_shape.definition IN fu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        fu_bag := fu_bag + futd_bag[j].of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_unit_usage_view_terminal_definition_unique_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of functional_unit_terminal_definition must have a unique
combination of name and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_part_terminal_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_usage_view_to_part_terminal_assignment_constraint rule 
constrains the related and relating shape_aspect of a shape_aspect_relationship
when it is used as a functional terminal allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_usage_view_to_part_terminal_assignment_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF(sar.relating_shape_aspect)) AND
       (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal')
       ))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'BARE_DIE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'INTERCONNECT_MODULE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PACKAGED_PART_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect))
       ))) = 0;
END_RULE; -- functional_usage_view_to_part_terminal_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.relating_shape_aspect shall be a functional_unit_terminal_definition 
with a description = 'scalar terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.related_shape_aspect shall be an (assembly_module_terminal) 
(bare_die_terminal) (interconnect_module_terminal) 
(packaged_part_terminal).
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_part_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_usage_view_to_part_terminal_assignment_unique_constraint rule constrains 
shape_aspect_relationship population members, that fill the role of ARM
functional_usage_view_to_part_terminal_assignment, so that the combination of ARM
functional_usage_view_terminal and ARM physical_usage_view_terminal attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_usage_view_to_part_terminal_assignment_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  fuvtpta : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'functional terminal allocation'));
  futd_bag : BAG OF functional_unit_terminal_definition := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fuvtpta) by 1;
  IF EXISTS( fuvtpta[i].relating_shape_aspect ) THEN
    IF ( fuvtpta[i].relating_shape_aspect\shape_aspect.description = 
                                             'scalar terminal' ) THEN
      IF ( NOT ( fuvtpta[i].relating_shape_aspect IN futd_bag ) ) THEN
        futd_bag := futd_bag + fuvtpta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(futd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* fuvtpta | 
        ((sar.relating_shape_aspect :=: futd_bag[i]) AND
(SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_MODULE_TERMINAL',
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'BARE_DIE_TERMINAL',
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERCONNECT_MODULE_TERMINAL',
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL'] * TYPEOF(sar.related_shape_aspect))>0)) );
  sa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_usage_view_to_part_terminal_assignment_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'functional terminal allocation'
that references a common functional_unit_terminal_definition with a name of 'scalar terminal'
through its relating_shape_aspect attribute must have a unique reference to either an
assembly_module_terminal, bare_die_terminal, interconnect_module_terminal 
or packaged_part_terminal through its related_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_printed_part_template_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The functional_usage_view_to_printed_part_template_terminal_assignment_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is used as
a functional terminal allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_usage_view_to_printed_part_template_terminal_assignment_constraint
FOR ( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF(sar.relating_shape_aspect)) AND
       (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal'))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) AND
       ((sar.related_shape_aspect\shape_aspect.description = 'interface terminal')
       OR (sar.related_shape_aspect\shape_aspect.description = 'join terminal')))
       )) = 0;
END_RULE;  -- functional_usage_view_to_printed_part_template_terminal_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.relating_shape_aspect shall be a functional_unit_terminal_definition 
with a description = 'scalar terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.related_shape_aspect shall be an 
(printed_part_template_terminal whose description = 
   ('interface terminal') ('join terminal')).
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
functional_usage_view_to_part_terminal_assignment, so that the combination of ARM
functional_usage_view_terminal and ARM physical_usage_view_terminal attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint
FOR ( shape_aspect_relationship );
LOCAL
  fuvtpptta : BAG OF shape_aspect_relationship := 
             QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'functional terminal allocation'));
  futd_bag : BAG OF functional_unit_terminal_definition := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pptt_bag : BAG OF printed_part_template_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fuvtpptta) by 1;
  IF EXISTS( fuvtpptta[i].relating_shape_aspect ) THEN
    IF ( fuvtpptta[i].relating_shape_aspect\shape_aspect.description = 
                                   'scalar terminal' ) THEN
      IF ( NOT ( fuvtpptta[i].relating_shape_aspect IN futd_bag ) ) THEN
        futd_bag := futd_bag + fuvtpptta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(futd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pptt_bag := [];
  sar_bag := QUERY( sar <* fuvtpptta |
((sar.relating_shape_aspect :=: futd_bag[i]) AND
(sar.related_shape_aspect\shape_aspect.description IN ['interface terminal',
'join terminal']) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pptt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pptt_bag := pptt_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of
'functional terminal allocation' must have a unique combination of
related_shape_aspect and relating_shape_aspect attributes where the
related_shape_aspect points to a printed_part_template_terminal
entity.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="geometric_tolerance_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The geometric_tolerance_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a geometric tolerance qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE geometric_tolerance_qualifier_constraint FOR
  (measure_qualification);
WHERE
  WR1: SIZEOF(QUERY(mq <* measure_qualification |
       ((mq\measure_qualification.name = 'predefined geometric tolerance qualifier')
       OR (mq\measure_qualification.name = 'user defined geometric tolerance qualifier'))
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MEASURE_WITH_UNIT' IN TYPEOF(mq.qualified_measure))
       AND(SIZEOF(QUERY(pugt <* USEDIN(mq.qualified_measure,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GEOMETRIC_TOLERANCE.MAGNITUDE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt)))) = 0)
       ))) = 0;
END_RULE; -- geometric_tolerance_qualifier_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each measure_qualification that has a name of either 'predefined geometric tolerance qualifier' or 'user defined geometric tolerance qualifier' shall have a qualified_measure that is a measure_with_unit that is the magnitude of a least one physical_unit_geometric_tolerance.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="geometric_tolerance_with_applied_material_condition_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The geometric_tolerance_with_applied_material_condition_property_constraint rule constrains the use of a modified_geometric_tolerance when it is used as a geometric tolerance with applied material condition property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE
geometric_tolerance_with_applied_material_condition_property_constraint
FOR (modified_geometric_tolerance);
END_RULE; -- geometric_tolerance_with_applied_material_condition_-
          -- property_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each modified_geometric_tolerance shall specify as its toleranced_shape_aspect a 
shape_aspect that either lies on the boundary of the shape of the product; is a 
centre_of_symmetry with a description of either 'axis', 'plane', or 'point'; is a 
part_template_definition; or is a composite_shape_aspect the 'composing' shape_aspects 
of which either are all of type part_template_definition, or are all of type 
centre_of_symmetry and have the same description -- either 'axis', 'plane', or 
'point'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each modified_geometric_tolerance that specifies as its toleranced_shape_aspect a 
shape_aspect that is either on the boundary of the shape of the product, is a 
part_template_definition, or is a composite_shape_aspect the 'composing' shape_aspects 
of which are all of type part_template_definition; shall also be a position_tolerance 
with a name of 'boundary based position'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="inter_stratum_extent_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The inter_stratum_extent_constraint rule constrains the related and
relating product_definition of a product_definition_relationship when it is
an inter stratum extent.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE inter_stratum_extent_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'inter stratum extent') AND
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.related_product_definition)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.relating_product_definition)) 
       ))) = 0;
END_RULE; -- inter_stratum_extent_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_relationship.name = 'inter stratum extent' THEN 
{SELF.related_product_definition shall be a stratum} 
{SELF.relating_product_definition shall be a stratum}.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_component_interface_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_component_interface_terminal_unique_constraint rule constrains
the component_terminal population members, that fill the role of ARM
interconnect_component_interface_terminal, so that the combination of ARM name
and ARM associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_component_interface_terminal_unique_constraint FOR
 ( component_interface_terminal );
LOCAL
  icit : BAG OF component_interface_terminal := QUERY( cit <*
component_interface_terminal | (cit\shape_aspect.description =
'interconnect component interface terminal') );
  icd_bag : BAG OF interface_component_definition := [];
  cit_bag : BAG OF component_interface_terminal;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(icit) by 1;
  IF EXISTS( icit[i].of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(icit[i].of_shape.definition) ) 
                                                          THEN
      IF ( NOT ( icit[i].of_shape.definition IN icd_bag )) THEN
        icd_bag := icd_bag + icit[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(icd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  cit_bag := 
        QUERY( cit <* icit | (cit.of_shape.definition :=: icd_bag[i]) );
  REPEAT j := 1 to SIZEOF(cit_bag) by 1;
    IF EXISTS( cit_bag[j]\shape_aspect.name ) THEN
      IF ( cit_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + cit_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- interconnect_component_interface_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of 'interconnect component interface terminal'
must have a unique combination of name and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_component_join_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_component_join_terminal_unique_constraint rule constrains
the component_terminal population members, that fill the role of ARM
interconnect_component_join_terminal, so that the combination of ARM name
and ARM associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_component_join_terminal_unique_constraint FOR
 ( component_terminal );
LOCAL
  icjt : BAG OF component_terminal := QUERY( ct <* component_terminal |
(ct\shape_aspect.description = 'interconnect component join terminal') );
  cd_bag : BAG OF component_definition := [];
  ct_bag : BAG OF component_terminal;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(icjt) by 1;
  IF EXISTS( icjt[i].of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN TYPEOF(icjt[i].of_shape.definition) ) THEN
      IF ( NOT ( icjt[i].of_shape.definition IN cd_bag )) THEN
        cd_bag := cd_bag + icjt[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  ct_bag := QUERY( ct <* icjt | (ct.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(ct_bag) by 1;
    IF EXISTS( ct_bag[j]\shape_aspect.name ) THEN
      IF ( ct_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + ct_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- interconnect_component_join_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of 'interconnect component join terminal'
must have a unique combination of name and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_constraint_region_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_module_constraint_region_terminal_constraint rule constrains
the use of a group_shape_aspect when it is used to implement the ARM
concept of interconnect_module_constraint_region.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_module_constraint_region_constraint FOR
  ( group_shape_aspect );
WHERE

  WR1: SIZEOF(QUERY(gsa <* group_shape_aspect |
       NOT(gsa\shape_aspect.description =
       'interconnect module constraint region')
       OR NOT (SIZEOF (QUERY (pd <* USEDIN (gsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CSG_2D_SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) OR
       (pdr.used_representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 3))
       )) = 1))) = 0)
       )) = 0;
END_RULE; -- interconnect_module_constraint_region_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A group_shape_aspect with a description of 
"interconnect module constraint region" shall
have exactly one shape_representation
that shall be a csg_2d_shape_representation or that shall be a 3 dimensional representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_stratum_assembly_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_module_stratum_assembly_relationship_constraint rule
constrains the related and relating product_definition and the use of an
assembly_component_usage when it is an interconnect module stratum
assembly relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_module_stratum_assembly_relationship_constraint FOR
( assembly_component_usage );
WHERE
  WR1: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT' IN TYPEOF(acu.relating_product_definition))
       )) = 0;
  WR2: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(acu.related_product_definition))
       )) = 0;
END_RULE; -- interconnect_module_stratum_assembly_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN 
SELF.relating_product_definition shall be a physical_unit.
</formal.propositions.rul>

<formal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN 
SELF.related_product_definition shall be a stratum.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN 
SELF.relating_product_definition shall be a physical_unit {whose 
frame_of_reference shall be an application_context_element.name = 
'physical design'} {whose formation.of_product shall be a product that is 
used in a product_categorization.name = 'interconnect module'}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN SELF shall be the 
definition of not more than one product_definition_shape that is the definition
of a property_definition_representation whose used_representation.items[i] 
is a mapped_item\representation_item.name = '3d positioned stratum shape in 
interconnect module' or 'planar positioned stratum shape in
interconnect module'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_stratum_assembly_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_module_stratum_assembly_relationship_unique_constraint rule constrains
assembly_component_usage population members, that fill the role of ARM
interconnect_module_stratum_assembly_relationship, so that the combination of ARM assembly
and ARM reference_designation attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  imsar : BAG OF assembly_component_usage := 
QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(imsar) by 1;
  IF EXISTS( imsar[i].relating_product_definition ) THEN
    IF( (imsar[i].relating_product_definition.frame_of_reference.name = 
        'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(imsar[i].relating_product_definition)) ) THEN
      IF ( NOT ( imsar[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + imsar[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  acu_bag := 
   QUERY( acu <* imsar | (acu.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].reference_designator ) THEN
      IF ( acu_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + acu_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- interconnect_module_stratum_assembly_relationship_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of assembly_component_usage with a name of
'interconnect module stratum assembly relationship' that has a common
relating_prooduct_definition must have a unique reference_designator.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_surface_feature_constraint">
<RULE.DESCRIPTION>
The interconnect_module_surface_feature_constraint rule constrains the use of a shape_aspect when it is used to implement the ARM concept of Interconnect_module_surface_feature.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_module_surface_feature_constraint FOR
 (shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(sa <* shape_aspect |
      ((sa\shape_aspect.description = 'interconnect module edge segment surface') OR
      (sa\shape_aspect.description = 'interconnect module cavity surface') OR
      (sa\shape_aspect.description = 'interconnect module cutout surface') OR
      (sa\shape_aspect.description = 'interconnect module edge surface') OR
      (sa\shape_aspect.description = 'interconnect module primary surface') OR
      (sa\shape_aspect.description = 'interconnect module secondary surface') OR
      (sa\shape_aspect.description = 'interconnect module surface feature'))
       AND NOT (
       (sa.of_shape.definition\product_definition.name = 'interconnect module')
       AND (sa.of_shape.definition.frame_of_reference.name = 
       'physical design usage')
       AND(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition))
       OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition))
       OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LIBRARY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition)))
       ))) = 0;
END_RULE; -- interconnect_module_surface_feature_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">

<formal.propositions.rul>
Each shape_aspect with a description of
'interconnect module surface feature' shall have an of_shape that
is a product_definition_shape with a definition that is a physical_unit
, externally_defined_physical_unit or a library_defined_physical_unit
that has a name of 'interconnect module', and a frame_of_reference which
is an application_context_element with a name of 'physical design usage'. 
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="interface_component_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interface_component_allocation_constraint rule constrains the related
and relating product_definition of a product_definition_relationship when it
is an interface component allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interface_component_allocation_constraint FOR 
( product_definition_relationship );
   WHERE
     WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
          (pdr\product_definition_relationship.name = 'interface component allocation') AND
          NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_product_definition)) AND
(pdr.relating_product_definition\product_definition.description = 'mating connector')))) = 0;
END_RULE; -- interface_component_allocation_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A product_definition_relationship with a name of 'interface component allocation' 
shall have a relating_product_definition that is a component_definition whose 
description is 'mating connector'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 'interface component allocation' 
THEN SELF.related_product_definition is a interface_component_definition 
{whose frame_of_reference is an application_context_element.name = 
'physical occurrence'} {is the related_product_definition of a 
product_definition_relationship 
   {whose name = 'instantiated part'} 
   {whose relating_product_definition is a physical_unit with a 
frame_of_reference which is an application_context_element.name = 
'physical design usage'}}.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="internal_stratum_access_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The internal_stratum_access_constraint rule constrains the related and
relating shape_aspect of a shape_aspect_relationship when it is an internal
stratum access.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE internal_stratum_access_constraint FOR ( shape_aspect_relationship );
END_RULE; -- internal_stratum_access_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'internal stratum access' THEN 
SELF.relating_shape_aspect shall be a 
probe_access_area\shape_aspect.description = 'internal probe access area' 
whose of_shape.definition is a component_definition whose formation.of_product 
is a product which is related to a product_category.name = 
'interconnect module'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'internal stratum access' THEN 
SELF.related_shape_aspect shall be a plated_passage\shape_aspect.description = 
('bonded conductive base blind via') ('buried via') 
('interfacial connection') ('non conductive base blind via') 
('plated conductive base blind via').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="internal_stratum_access_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The internal_stratum_access_unique_constraint rule constrains the
shape_aspect_relationship population members, that fill the role of ARM
internal_stratum_access, so that the combination of ARM connected_probe
and ARM inter_stratum_feature attributes shall be unique within the
population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE internal_stratum_access_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  isa : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'internal stratum access'));
  paa_bag : BAG OF probe_access_area := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pp_bag : BAG OF plated_passage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(isa) by 1;
  IF EXISTS( isa[i].relating_shape_aspect ) THEN
    IF ( (isa[i].relating_shape_aspect\shape_aspect.description = 
'internal probe access area') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROBE_ACCESS_AREA' IN TYPEOF(isa[i].relating_shape_aspect)) ) THEN
      IF ( NOT ( isa[i].relating_shape_aspect IN paa_bag ) ) THEN
        paa_bag := paa_bag + isa[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(paa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pp_bag := [];
  sar_bag := QUERY( sar <* isa | ((sar.relating_shape_aspect :=: 
paa_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PLATED_PASSAGE' IN TYPEOF(sar.related_shape_aspect)) AND
(sar.related_shape_aspect\shape_aspect.description IN 
['bonded conductive base blind via',
'buried via','interfacial connection','non conductive base blind via',
'plated conductive base blind via'])) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pp_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pp_bag := pp_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- internal_stratum_access_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'internal stratum access'
must have a unique combination of relating_shape_aspect and related_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="junction_vertex_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The junction_vertex_allocation_constraint rule constrains the related and
relating shape_aspect of a shape_aspect_relationship when it is a junction
vertex allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE junction_vertex_allocation_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'junction vertex allocation')
       AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'LAYER_CONNECTION_POINT' IN TYPEOF(sar.related_shape_aspect))
       AND (sar.related_shape_aspect\shape_aspect.description = 'explicitly located')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'JOIN_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect))
       AND (sar.related_shape_aspect\shape_aspect.name = 'inter stratum join'))
       ))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'junction vertex allocation') AND
       NOT (sar.relating_shape_aspect\shape_aspect.description = 
                        'topological junction'))) = 0;
END_RULE; -- junction_vertex_allocation_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'junction vertex allocation' THEN 
SELF.related_shape_aspect shall be 
(a layer_connection_point\shape_aspect.description = 'explicitly located') 
(a join_shape_aspect\shape_aspect.name = 'inter stratum join').
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'junction vertex allocation' THEN 
SELF.relating_shape_aspect shall have a description = 'topological junction'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'junction vertex allocation' THEN 
SELF.related_shape_aspect AND SELF.relating_shape_aspect shall be 
within the same product definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="junction_vertex_allocation_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The junction_vertex_allocation_unique_constraint rule constrains the
shape_aspect_relationship population members, that fill the role of
ARM junction_vertex_allocation, so that the ARM required_vertex
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE junction_vertex_allocation_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  jva : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 'junction vertex allocation') );
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(jva) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  IF EXISTS( jva[i].relating_shape_aspect ) THEN
    IF ( jva[i].relating_shape_aspect\shape_aspect.description = 
                       'topological junction' ) THEN
      IF ( jva[i].relating_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + jva[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- junction_vertex_allocation_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'junction vertex allocation' must have a unique shape_aspect entity
with a name of 'topological junction' as the shape_aspect_relationship's
relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="land_physical_template_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The land_physical_template_unique_constraint rule constrains the
land_physical_template population members, that fill the role of
ARM land_physical_template, so that the ARM pre_defined_classification_code
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  adr_bag : BAG OF applied_document_reference;
  duc : BAG OF document_usage_constraint;
  pass : BOOLEAN := TRUE;
  duc_bag : BAG OF document_usage_constraint := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(land_physical_template) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  adr_bag := USEDIN(land_physical_template[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
  REPEAT j := 1 to SIZEOF(adr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    duc := QUERY( r <* USEDIN(adr_bag[j].assigned_document,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (r\document_usage_constraint.subject_element =
'predefined classification code') );
    REPEAT k := 1 to SIZEOF(duc) by 1;
      IF EXISTS( duc[k] ) THEN
        IF ( duc[k] IN duc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          duc_bag := duc_bag + duc[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- land_physical_template_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of land_physical_template must have a unique
document_usage_constraint entity with a subject_element of
'predefined classification code' where the document_usage_constraint's
source attribute references the same entity as an applied_document_reference's
assigned_document attribute and the land_physical_template is a member
of the applied_document_reference's items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="land_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The land_template_terminal_unique_constraint rule constrains the
land_template_terminal population members, that fill the role of ARM
land_template_terminal, so the combination of ARM associated_definition
and ARM name shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE land_template_terminal_unique_constraint FOR
 ( land_template_terminal );
LOCAL
  ltt : BAG OF land_template_terminal := 
QUERY( sa <* land_template_terminal |
(sa\shape_aspect.description IN ['interface terminal','join terminal']) );
  name_bag : BAG OF STRING := [];
  ltt_bag : BAG OF land_template_terminal;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  lpt_bag : BAG OF land_physical_template;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ltt) by 1;
  IF EXISTS( ltt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ltt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ltt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  lpt_bag := [];
  ltt_bag := QUERY( sa <* ltt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(ltt_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(ltt_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'associated definition') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN lpt_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          lpt_bag := lpt_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- land_template_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of land_template_terminal with a description of either
'interface terminal' or 'join terminal' must have a unique
combination of name attribute and land_physical_template entity where
the land_physical_template is related to the land_template_terminal by
a shape_aspect_relationship with a name of 'associated definition'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="layout_spacing_requirement_non_conforming_design_object_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The layout_spacing_requirement_non_conforming_design_object_constraint rule
constrains the related and relating shape_aspect and the use of a
shape_aspect_relationship when it is a layout spacing requirement violation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE layout_spacing_requirement_non_conforming_design_object_constraint FOR
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'layout spacing requirement violation')
       AND (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM_FEATURE'] * TYPEOF(sar.related_shape_aspect)
       ) = 0))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'layout spacing requirement violation')
       AND (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM_FEATURE'] * TYPEOF(sar.relating_shape_aspect)
       ) = 0))) = 0;
  WR3: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'layout spacing requirement violation')
       AND NOT(SIZEOF(QUERY(grp <* USEDIN(sar,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GROUP' IN TYPEOF(grp))
       AND (grp\group.name = 'layout spacing requirements property')
       )) = 1))) = 0;
END_RULE; -- layout_spacing_requirement_non_conforming_design_-
          -- object_constraint
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'layout spacing requirement violation' THEN
SELF.related_shape_aspect shall be a
(component_shape_aspect)
(component_terminal)
(component_interface_terminal)
(stratum_feature).
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'layout spacing requirement violation' THEN
SELF.relating_shape_aspect shall be a
(component_shape_aspect)
(component_terminal)
(component_interface_terminal)
(stratum_feature).
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'layout spacing requirement violation' THEN
SELF shall be the definition of exactly one group.name = 
'layout spacing requirements property'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="layout_spacing_requirement_occurrence_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The layout_spacing_requirement_occurrence_unique_constraint rule constrains
grouped_requirements_property population members, that fill the role of ARM
layout_spacing_requirement_occurrence, so that the combination of ARM
dependent_design_object_category and ARM reference_design_object_category
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE layout_spacing_requirement_occurrence_unique_constraint FOR
 ( grouped_requirements_property, characterized_object );
LOCAL
  lsro : BAG OF grouped_requirements_property := QUERY( grp <*
grouped_requirements_property | 
(grp\group.name = 'layout spacing requirements property') );
  ddo : BAG OF characterized_object := QUERY( co <* characterized_object |
(co\characterized_object.description = 'dependent design object category') );
  ga_bag : BAG OF group_assignment;
  ddname_bag : BAG OF STRING := [];
  co_bag : BAG OF characterized_object;
  pdb : BAG OF property_definition := [];
  pd_bag : BAG OF property_definition;
  grp_bag : BAG OF grouped_requirements_property;
  rga_bag : BAG OF group_assignment;
  pass : BOOLEAN := TRUE;
  rdname_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(lsro) by 1;
  ga_bag := QUERY( aga <* USEDIN(lsro[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga));
  REPEAT j := 1 to SIZEOF(ga_bag) by 1;
    REPEAT k := 1 to SIZEOF(ga_bag[j].items) by 1;
      IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'PROPERTY_DEFINITION' IN TYPEOF(ga_bag[j].items[k])) 
     THEN pdb[1] := ga_bag[j].items[k];
     ELSE pdb := [];
     END_IF; 

    IF ( (pdb :<>: []) AND
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'CHARACTERIZED_OBJECT' IN TYPEOF(pdb[1]\property_definition.definition)) AND
        (pdb[1]\property_definition.definition\characterized_object.description = 
        'dependent design object category') ) THEN
      IF EXISTS( pdb[1]\property_definition.definition\characterized_object.name ) THEN
        IF( NOT( pdb[1]\property_definition.definition\characterized_object.name IN ddname_bag ) ) THEN
          ddname_bag := ddname_bag + pdb[1]\property_definition.definition\characterized_object.name;
        END_IF;
      END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ddname_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  rdname_bag := [];
  co_bag := QUERY( co <* ddo | (co\characterized_object.name = ddname_bag[i]) );
  REPEAT j := 1 to SIZEOF(co_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := USEDIN( co_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PROPERTY_DEFINITION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      ga_bag := QUERY( ga <* USEDIN(pd_bag[k], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_GROUP_ASSIGNMENT.ITEMS') | 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(ga.assigned_group)) );
      REPEAT l := 1 to SIZEOF(ga_bag) by 1;
        IF ( NOT pass ) THEN ESCAPE;
        END_IF;
        IF( NOT( ga_bag[l].assigned_group IN grp_bag ) ) THEN
          grp_bag := grp_bag + ga_bag[l].assigned_group;
        END_IF;
      END_REPEAT;
      REPEAT l := 1 to SIZEOF(grp_bag) by 1;
        IF ( NOT pass ) THEN ESCAPE;
        END_IF;
        rga_bag := USEDIN(grp_bag[l], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'GROUP_ASSIGNMENT.ASSIGNED_GROUP');
        REPEAT m := 1 to SIZEOF(rga_bag) by 1;
          IF ( NOT pass ) THEN ESCAPE;
          END_IF;
          REPEAT n:= 1 TO SIZEOF(rga_bag[m].items) by 1;
      IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'PROPERTY_DEFINITION' IN TYPEOF(rga_bag[n].items[m]))
     THEN pdb[1] := rga_bag[n].items[m];
     ELSE pdb := [];
     END_IF;

    IF ( (pdb :<>: []) AND
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
          'CHARACTERIZED_OBJECT' IN 
         TYPEOF(pdb[1]\property_definition.definition)) AND
(pdb[1]\property_definition.definition\characterized_object.description = 
'reference design object category') ) THEN
              IF EXISTS( pdb[1]\property_definition.definition\characterized_object.name ) THEN
                IF( pdb[1]\property_definition.definition\characterized_object.name IN rdname_bag ) THEN
                  pass := FALSE;
                  ESCAPE;
                ELSE
                  rdname_bag := rdname_bag + 
                          pdb[1]\property_definition.definition\characterized_object.name;
                END_IF;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- layout_spacing_requirement_occurrence_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of grouped_requirements_property must have
a unique combination of characterized_object name attribute where the characterized_object
has a description of 'dependent design object category' and characterized_object name
attribute where the characterized_object has a description of 'reference design object category'
and the characterized_objects are members of an applied_group_assignment's items.definition
and the applied_group_assignment's assigned_group is the grouped_requirements_property.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="limit_dimension_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The limit_dimension_representation_constraint rule constrains the use of a shape_dimension_representation when it is used as a limit dimension representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE limit_dimension_representation_constraint FOR
  (shape_dimension_representation);
END_RULE; -- limit_dimension_representation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'upper value' shall contain exactly two measure_with_unit in which the second measure_with_unit is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'lower value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'lower value' shall contain exactly two measure_with_unit in which the second measure_with_unit is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'upper value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_dimension_representation that contains two measure_with_unit that are the qualified_measure of two measure_qualification that have the name of 'dimension value qualifier' and in which the qualifiers are type_qualifier with the name of 'lower value' and 'upper value' shall have the measure_with_unit that is qualified as the 'upper value' to be greater than the measure_with_unit qualified as the 'lower value'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="located_interconnect_module_thickness_requirement_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The located_interconnect_module_thickness_requirement_unique_constraint rule constrains the
property_definition_representation population members, that fill the role of ARM
located_interconnect_module_thickness_requirement, so that the combination of ARM design
and ARM reference_location attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE located_interconnect_module_thickness_requirement_unique_constraint FOR
 ( property_definition_representation );
LOCAL
  limrt : BAG OF property_definition_representation := 
QUERY( pdr <* property_definition_representation
| (pdr.definition\property_definition.name = 
 'located interconnect module thickness') AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)));
  pu_bag : BAG OF physical_unit := [];
  pdr_bag : BAG OF property_definition_representation;
  rr_bag : BAG OF representation_relationship;
  pass : BOOLEAN := TRUE;
  ri_bag : BAG OF representation_item;
END_LOCAL;

REPEAT i := 1 to SIZEOF(limrt) by 1;
  IF EXISTS( limrt[i].definition.definition.of_shape.definition ) THEN
    IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PHYSICAL_UNIT' IN
         TYPEOF(limrt[i].definition.definition.of_shape.definition)))
        THEN
      IF ( NOT ( limrt[i].definition.definition.of_shape.definition IN 
                 pu_bag )) THEN
        pu_bag := pu_bag + 
                  limrt[i].definition.definition.of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ri_bag := [];
  pdr_bag := QUERY( pdr <* limrt | 
          (pdr.definition.definition.of_shape.definition :=: 
           pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rr_bag := QUERY( rr <* USEDIN( pdr_bag[j].used_representation,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'REPRESENTATION_RELATIONSHIP.REP_2' ) | 
(rr\representation_relationship.name = 'reference location') );
    REPEAT k := 1 to SIZEOF(rr_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(rr_bag[k].rep_1.items) by 1;
        IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'AXIS2_PLACEMENT_2D' IN TYPEOF(rr_bag[k].rep_1.items[l])) OR (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'AXIS2_PLACEMENT_3D' IN TYPEOF(rr_bag[k].rep_1.items[l])) ) THEN
          IF EXISTS( rr_bag[k].rep_1.items[l] ) THEN
            IF ( rr_bag[k].rep_1.items[l] IN ri_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ri_bag := ri_bag + rr_bag[k].rep_1.items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- located_interconnect_module_thickness_requirement_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of property_definition_representation with a definition.name
of `located interconnect module thickness' must have a unique combination of
definition.definition.of_shape.definition attributes and axis_placement_2d,
axis_placement_3d entities where the axis_placements are in the items of
a representation that is related to the property_definition_representation's
used_representation attribute through a representation_relationship with a
name of 'reference location'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="marking_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The marking_constraint rule constrains the usage of a representation when it
is a marking.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE marking_constraint FOR ( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'marking')
       AND (SIZEOF(QUERY(pdr <* USEDIN(rep,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition)))) > 0))
       AND NOT (SIZEOF(QUERY(place <* rep.items |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PLACEMENT' IN TYPEOF (place))
       AND (place\representation_item.name = 'marking location'))
       )) = 1)
       )) = 0;
END_RULE; -- marking_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall have exactly one items that is a 
placement\representation_item.name = 'marking location'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall be the used_representation on one property_definition_representation
whose definition
({is a pca_definition} 
 {has a formation.of_product that is a product of a product_categorization.name
  = 'assembly module'} 
 {has a frame_of_reference that is an application_context_element.name = 
  'physical design'})
({is a pcb_definition} 
 {has a formation.of_product that is a product of a product_categorization.name
  = 'interconnect module'} 
 {has a frame_of_reference that is an application_context_element.name = 
  'physical design'})
({is a (packaged_part) (externally_defined_packaged_part) 
  (library_defined_packaged_part)} 
 {has a frame_of_reference that is an application_context_element.name = 
  'physical design usage'}).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall have exactly one items that is a 
descriptive_representation_item.name = ('approval date') ('manufacturers code')
('part number') ('revision identifier') ('marked message').
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} 
{is the used_representation of a property_definition_representation.definition 
that is a shape_aspect} 
{SELF.items[i] is a descriptive_representation_item.name = 'marked message'} 
THEN the value of descriptive_representation_item.description shall be 
identical to document_usage_constraint.subject_element_value.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} 
{is the used_representation of a property_definition_representation.definition 
that is a shape_aspect} THEN the shape_aspect shall be the 
designation.definitions[i] of a material_designation_relationship.description =
'marking material'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall be an items in a document_reference whose assigned_document 
{is a ee_specification} 
{whose source is a document_usage_constraint.subject_element = 
'marking specification'}
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall have exactly one items that is a 
(text_literal\representation_item.name = 'marking text') 
(annotation_text_occurrence\representation_item.name = 'marking text').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="material_composition_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The material_composition_relationship_constraint rule constrains the related
and relating product_definition of a product_material_composition_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE material_composition_relationship_constraint FOR 
( product_material_composition_relationship );
END_RULE; -- material_composition_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A product_material_composition_relationship shall have a 
related_product_definition that is the of_definition of a material_designation.
</Informal.propositions.rul>
<Informal.propositions.rul>
A product_material_composition_relationship shall have a 
relating_product_definition that is the of_definition of a material_designation.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="mating_connector_placement_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The mating_connector_placement_relationship_constraint rule constrains the use
of a shape_representation when it is a mating connector placement.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE mating_connector_placement_relationship_constraint FOR
( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'mating connector placement')
       AND (SIZEOF(QUERY(p <* sr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PLACEMENT' IN TYPEOF(p))
       AND (p\representation_item.name = 'connector placement'))) = 0))) = 0;
END_RULE; -- mating_connector_placement_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_representation\representation.name = 'mating connector placement' 
THEN items[i] shall be a placement.name = 'connector placement'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_representation\representation.name = 'mating connector placement' 
THEN SELF shall be one items.mapping_source.mapped_representation of a 
shape_representation.name = 'volume shape' that is the used_representation 
of a property_definition_representation that has a definition.definition
that is a specified_higher_usage_occurrence that has a 
relating_product_definition that is a component_definition.description = 
'mating connector'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_representation\representation.name = 'mating connector placement' 
THEN SELF shall be the used_representation of a 
property_definition_representation that has a definition.definition that 
is a component_definition.description = 'mating connector'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="mating_connector_termination_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The mating_connector_termination_constraint rule constrains the of_shape
and use of a shape_aspect when it is a mating connector termination.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE mating_connector_termination_constraint FOR ( shape_aspect );
WHERE
  WR1: SIZEOF(QUERY(sa <* shape_aspect |
       (sa\shape_aspect.description = 'mating connector termination')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_DEFINITION' IN TYPEOF(sa.of_shape.definition))
       AND (sa.of_shape.definition\product_definition.description = 
                                           'mating connector')))) = 0;
END_RULE; -- mating_connector_termination_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect.description = 'mating connector termination' THEN 
SELF.of_shape shall be a property_definition whose definition is a 
component_definition with a description = 'mating connector'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect.description = 'mating connector termination' THEN SELF 
shall be the related_shape_aspect of a shape_aspect_relationship 
{whose name = 'instantiated terminal'} 
{whose relating_shape_aspect is (a packaged_part_terminal) 
(a printed_part_template_terminal whose description = 
 ('interface terminal') 
 ('join terminal'))}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="mating_connector_termination_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The mating_connector_termination_unique_constraint rule constrains the
shape_aspect population members, that fill the role of ARM
mating_connector_termination, so that the combination of ARM definition
and ARM accessed_connector attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE mating_connector_termination_unique_constraint FOR
 ( shape_aspect );
LOCAL
  mct : BAG OF shape_aspect := QUERY( sa <* shape_aspect |
(sa\shape_aspect.description = 'mating connector termination') );
  cd_bag : BAG OF component_definition := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  ppt_bag : BAG OF packaged_part_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(mct) by 1;
  IF EXISTS( mct[i].of_shape.definition ) THEN
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN TYPEOF(mct[i].of_shape.definition)) AND
(mct[i].of_shape.definition\product_definition.description = 'mating connector') ) THEN
      IF( NOT( mct[i].of_shape.definition IN cd_bag ) ) THEN
        cd_bag := cd_bag + mct[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ppt_bag := [];
  sa_bag := QUERY( sa <* mct | (sa.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'instantiated terminal') AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ppt_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ppt_bag := ppt_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- mating_connector_termination_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of 'mating connector termination'
must have a unique combination of of_shape.definition attribute and
packaged_part_terminal entity related to the shape_aspect by a
shape_aspect_relationship with a name of 'instantiated terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="model_parameter_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The model_parameter_unique_constraint rule constrains the model_parameter
population members, that fill the role of ARM model_parameter, so that the
combination of ARM type_name and ARM reference_document attributes shall
be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE model_parameter_unique_constraint FOR
 ( model_parameter );
LOCAL
  name_bag : BAG OF STRING := [];
  mp_bag : BAG OF model_parameter;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  d_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(model_parameter) by 1;
  IF EXISTS( model_parameter[i]\representation_item.name ) THEN
    IF( NOT( model_parameter[i]\representation_item.name IN name_bag ) ) THEN
      name_bag := name_bag + model_parameter[i]\representation_item.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mp_bag := QUERY( mp <* model_parameter | (mp\representation_item.name = name_bag[i]) );
  d_bag := [];
  REPEAT j := 1 to SIZEOF(mp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := USEDIN( mp_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN d_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          d_bag := d_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- model_parameter_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of model_parameter must have a unique combination of name
attribute and document entity assigned to the model_parameter by an
applied_document_reference's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="next_higher_assembly_interface_requirement_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The next_higher_assembly_interface_requirement_constraint rule constrains the
use of a specified_higher_usage_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE next_higher_assembly_interface_requirement_constraint FOR 
( specified_higher_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(shuo <* specified_higher_usage_occurrence |
       NOT(SIZEOF(QUERY(pd <* USEDIN(shuo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))
       AND (pdr.used_representation\representation.name = '3d bound volume shape'))) = 0)
       )) = 0)
       )) = 0;
END_RULE; -- next_higher_assembly_interface_requirement_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each specified_higher_usage_occurrence shall be the definition.definition of a 
property_definition_representation that has a used_representation that
is a shape_representation.name = '3d bound volume shape'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="next_higher_assembly_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The next_higher_assembly_relationship_constraint rule constrains the use of
a next_assembly_usage_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE next_higher_assembly_relationship_constraint FOR
( next_assembly_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(nauo <* next_assembly_usage_occurrence|
       NOT(SIZEOF(QUERY(pd <* USEDIN(nauo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       ((SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))
       AND 
       (pdr.used_representation.context_of_items\geometric_representation_context.
       coordinate_space_dimension = 3)
       )) <= 1)
       AND
       (SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))
       AND 
       (pdr.used_representation.context_of_items\geometric_representation_context.
       coordinate_space_dimension = 2)
       )) <= 1))
       )) <= 1)
       )) = 0;
END_RULE; -- next_higher_assembly_relationship_constraint
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each next_assembly_usage_occurrence shall be the definition of not more than one property_definition which is the definition of not more than two property_definition_representation each of whose used_representation is a component_location which shall have either a 2 or 3d context, but there shall be no more than one of each context.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each next_assembly_usage_occurrence shall not be in a complex instance with both a quantity and a reference designation.
Each next_assembly_usage_occurrence shall have either a quantity or a reference designation,
which may require population of a complex instance of the supertype tree of next_assembly_usage_occurrence. 
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="next_higher_assembly_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The next_higher_assembly_relationship_unique_constraint rule constrains the
next_assembly_usage_occurrence population members, that fill the role of ARM
next_higher_assembly_relationship, so that the combination of ARM reference_designation
and the ARM assembly attribute inherited from the supertype
Assembly_composition_relationship shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE next_higher_assembly_relationship_unique_constraint FOR
 ( next_assembly_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  nauo_bag : BAG OF next_assembly_usage_occurrence;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(next_assembly_usage_occurrence) by 1;
  IF EXISTS( next_assembly_usage_occurrence[i].relating_product_definition )
                                                               THEN
    IF( 
(next_assembly_usage_occurrence[i].
                relating_product_definition.frame_of_reference.name 
                                                  = 'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' 
     IN TYPEOF(next_assembly_usage_occurrence[i].
                                relating_product_definition)) ) THEN
      IF ( NOT ( next_assembly_usage_occurrence[i].
                                  relating_product_definition 
                                              IN pu_bag )) THEN
        pu_bag := pu_bag + 
             next_assembly_usage_occurrence[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  nauo_bag := QUERY( nauo <* next_assembly_usage_occurrence | 
                  (nauo.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(nauo_bag) by 1;
    IF EXISTS( nauo_bag[j].reference_designator ) THEN
      IF ( nauo_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + nauo_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- next_higher_assembly_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of next_assembly_usage_occurrence that has a common
relating_prooduct_definition must have a unique reference_designator.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="no_shape_for_make_from">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The no_shape_for_make_from rule assures that for each instance
of make_from_usage_option, that a member of product_definition_shape
shall not be a part of it's property_definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE no_shape_for_make_from FOR
  (make_from_usage_option);
WHERE
  WR1: SIZEOF (QUERY (mfuo <* make_from_usage_option |
       NOT (SIZEOF (QUERY (pd <* USEDIN (mfuo, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE' IN 
       TYPEOF (pd))) = 0))) = 0;
END_RULE; -- no_shape_for_make_from
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
No design_make_from_relationship entities shall be referenced by the
definition attribute of a property_definition that is a
product_definition_shape.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="non_feature_shape_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The non_feature_shape_element_constraint rule constrains
the use of a shape_aspect when it is used to implement the ARM 
concept of Non_feature_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE non_feature_shape_element_constraint FOR
  (shape_aspect);
END_RULE; -- non_feature_shape_element_constraint
*)
(*
</EXPRESS.CODE>
<informal.propositions rule.types="IP"> 
<informal.propositions.rul>
Each shape_aspect that does not define a product shall be
a characterized_definition that is the definition of
a property_definition that is the definition of a 
property_definition_representation that has
a used_representation that is a shape_representation
with a name of 'element shape'.
</informal.propositions.rul>
</informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="operational_requirement_occurrence_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The operational_requirement_occurrence_relationship_constraint rule constrains
the related and relating property_definition of a 
property_definition_relationship when it is an
operational_requirement_occurrence_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE operational_requirement_occurrence_relationship_constraint FOR
( property_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* property_definition_relationship |
       ((pdr\property_definition_relationship.name = 'and operation')
        OR (pdr\property_definition_relationship.name = 'or operation'))
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'REQUIREMENTS_PROPERTY' IN 
                             TYPEOF(pdr.related_property_definition))
       )) = 0;
  WR2: SIZEOF(QUERY(pdr <* property_definition_relationship |
       ((pdr\property_definition_relationship.name = 'and operation')
        OR (pdr\property_definition_relationship.name = 'or operation'))
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'REQUIREMENTS_PROPERTY' IN 
                           TYPEOF(pdr.relating_property_definition))
       )) = 0;
END_RULE; -- operational_requirement_occurrence_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each property_definition_relationship whose name = ('and operation') 
('or operation') shall have a related_property_definition that is a 
requirements_property.
</formal.propositions.rul>
<formal.propositions.rul>
Each property_definition_relationship whose name = ('and operation') 
('or operation') shall have a relating_property_definition that is a 
requirements_property.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each property_definition_relationship whose name = ('and operation') 
('or operation') shall relate two property_definition each of which
shall have one property_definition_relationship whose 
name is 'requirements property composition' and the two 
property_definition_relationship shall relate to the
same property_definition that is a requirements_property as the composition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="opposing_boundary_set_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The opposing_boundary_set_size_characteristic_constraint rule constrains the use of a representation when it is used as an opposing boundary set size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE opposing_boundary_set_size_characteristic_constraint FOR
  (representation);
END_RULE; -- opposing_boundary_set_size_characteristic_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name of 'opposing boundary set size' shall represent at least one property_definition that has a description of 'boundary zone definition with specified size' and that property_definition shall be applied to either a tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="organization_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The organization_unique_constraint rule constrains the organization.id population members to satisfy the uniqueness requirement of the ARM application object Organization.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE organization_unique_constraint FOR (organization);

LOCAL
  r : BAG OF organization := QUERY (r <* organization | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\organization.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;
END_RULE; -- organization_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The id shall be unique within a population of organization.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="package_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_external_reference_constraint rule constrains the use of a representation when it is used as a package external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_external_reference_constraint FOR
  (representation);
WHERE
   WR1: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'design owner')))) = 1)))=0;
   WR2: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'part number')))) = 1)))=0;
   WR3: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'revision code')))) = 1)))=0;
   WR4: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'product definition id')))) = 1)))=0;
END_RULE; -- package_external_reference_constraint
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'design owner'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'part number'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'revision code'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'product definition id'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="package_terminal_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_terminal_external_reference_constraint rule constrains the use of a
descriptive_representation_item when it is used as a package terminal external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_terminal_external_reference_constraint FOR
  (descriptive_representation_item);
WHERE
  WR1: SIZEOF(QUERY(dri <* descriptive_representation_item |
       (dri\representation_item.name = 'package terminal external reference')
       AND (SIZEOF(QUERY(rep <* USEDIN(dri,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REPRESENTATION.ITEMS') |
       (rep\representation.name = 'package external reference'))) = 0)
       )) = 0;
END_RULE; -- package_terminal_external_reference_constraint
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each descriptive_representation_item with a name of 'package terminal external reference'
shall be a member of items for a representation with a name of 'package external reference'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="package_terminal_external_reference_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_terminal_external_reference_unique_constraint rule constrains the
descriptive_representation_item population members, that fill the role of ARM
package_terminal_external_reference, so that the combination of ARM name
and ARM associated_definition attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_terminal_external_reference_unique_constraint FOR
 ( descriptive_representation_item );
LOCAL
  pter : BAG OF descriptive_representation_item := 
                QUERY( dri <* descriptive_representation_item
| (dri\representation_item.name = 'package terminal external reference') );
  desc_bag : BAG OF STRING := [];
  dri_bag : BAG OF descriptive_representation_item;
  rep_bag : BAG OF representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  IF EXISTS( pter[i]\descriptive_representation_item.description ) THEN
    IF ( NOT ( pter[i]\descriptive_representation_item.description IN desc_bag )) THEN
      desc_bag := desc_bag + pter[i]\descriptive_representation_item.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(desc_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  r_bag := [];
  dri_bag := QUERY( dri <* pter | (dri\descriptive_representation_item.description = desc_bag[i]) );
  REPEAT j := 1 to SIZEOF(dri_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rep_bag := QUERY( r <* USEDIN( dri_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'REPRESENTATION.ITEMS' ) | (r\representation.name = 'package external reference') );
    REPEAT k := 1 to SIZEOF(rep_bag) by 1;
      IF EXISTS( rep_bag[k] ) THEN
        IF ( rep_bag[k] IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + rep_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- package_terminal_external_reference_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of descriptive_representation_item with a name of
'package terminal external reference' must have a unique combination of
description attributes and representation entities where the representations
have the descriptive_representation_items in their items attribute and the
representations have a name of 'package external reference'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="package_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_unique_constraint rule constrains the package population members, that
fill the role of ARM package, to have unique members in their ARM case_style attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_unique_constraint FOR
 ( package, externally_defined_package, library_defined_package );
LOCAL
  p : BAG OF physical_unit := QUERY( r <* package |
(r.frame_of_reference.name = 'physical design usage') );
  edp : BAG OF physical_unit := QUERY( r <* externally_defined_package |
(r.frame_of_reference.name = 'physical design usage') );
  ldp : BAG OF physical_unit := QUERY( r <* library_defined_package |
(r.frame_of_reference.name = 'physical design usage') );
  pu : BAG OF physical_unit;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation := [];
END_LOCAL;

pu := p + edp + ldp;

REPEAT i := 1 to SIZEOF(pu) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := USEDIN( pu[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION' );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( pd_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | 
(pdr.used_representation\representation.name =
'registered case style') );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].used_representation ) THEN
        IF ( pdr_bag[k].used_representation IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + pdr_bag[k].used_representation;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- package_unique_constraint 
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of package must have unique representation entities related
to the package where the representation has a name of 'registered case style'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="packaged_connector_terminal_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The packaged_connector_terminal_relationship_unique_constraint rule constrains the
packaged_connector_terminal_relationship population members, that fill the role of
ARM packaged_connector_terminal_relationship, to have unique combinations of ARM
connector and ARM join_terminal attributes and to have unique combinations of ARM
connector and ARM interface_terminal attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE packaged_connector_terminal_relationship_unique_constraint FOR
 ( packaged_connector_terminal_relationship );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  pctr_bag : BAG OF packaged_connector_terminal_relationship;
  it_bag : BAG OF packaged_part_terminal;
  jt_bag : BAG OF packaged_part_terminal;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(packaged_connector_terminal_relationship) by 1;
  IF EXISTS( packaged_connector_terminal_relationship[i].
                               of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' 
   IN TYPEOF(packaged_connector_terminal_relationship[i].
                               of_shape.definition) ) THEN
      IF ( NOT ( packaged_connector_terminal_relationship[i].
                               of_shape.definition 
                                           IN pu_bag )) THEN
        pu_bag := pu_bag + 
    packaged_connector_terminal_relationship[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  it_bag := [];
  jt_bag := [];
  pctr_bag := QUERY( r <* packaged_connector_terminal_relationship | 
                            (r.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pctr_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass1 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].relating_shape_aspect))
AND (pctr_bag[j].relating_shape_aspect\shape_aspect.description = 'join terminal') ) THEN
      IF EXISTS( pctr_bag[j].relating_shape_aspect ) THEN
        IF ( pctr_bag[j].relating_shape_aspect IN jt_bag ) THEN
          pass1 := FALSE;
          ESCAPE;
        ELSE
          jt_bag := jt_bag + pctr_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
    IF ( pass2 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].related_shape_aspect))
AND (pctr_bag[j].related_shape_aspect\shape_aspect.description = 
'interface terminal') ) THEN
      IF EXISTS( pctr_bag[j].related_shape_aspect ) THEN
        IF ( pctr_bag[j].related_shape_aspect IN it_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          it_bag := it_bag + pctr_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- packaged_connector_terminal_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of packaged_connector_terminal_relationship that references a common
physical_unit through an of_shape.definition attribute must have unique related_shape_aspect
attributes that point to packaged_part_terminal entities with a description of 'join terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of packaged_connector_terminal_relationship that references a common
physical_unit through an of_shape.definition attribute must have unique relating_shape_aspect
attributes that point to packaged_part_terminal entities with a description of 'interface terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="packaged_part_unique_constraint">
<RULE.DESCRIPTION>
The packaged_part_unique_constraint rule constrains the packaged_part,
externally_defined_packaged_part and library_defined_packaged_part population members, that
fill the role of ARM packaged_part, so the ARM used_package.version shall be unique within a population of ARM Packaged_part.  This constraint enforces a single used_package.version for any given Packaged_part even though there are multiple packages.
<note>
The uniqueness constraint is divided between this construct and the the constraint on implemented function cardinality implemented in the packaged_part entity.
</note>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE packaged_part_unique_constraint FOR
 ( packaged_part, externally_defined_packaged_part, 
   library_defined_packaged_part);
LOCAL
  pp : SET OF physical_unit := packaged_part +
                   externally_defined_packaged_part +
                    library_defined_packaged_part;
  pdr_bag : BAG OF product_definition_relationship;
  pdf_bag : BAG OF product_definition_formation := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pp) by 1;
  IF ( NOT pass ) THEN ESCAPE; END_IF;
    pdf_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN( pp[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
((pdr\product_definition_relationship.name = 'used package')
AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGE' IN TYPEOF(pdr.relating_product_definition)) OR
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EXTERNALLY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition)) OR
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LIBRARY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition)) ) ) );
    pdf_bag := pdf_bag + pdr_bag[1].relating_product_definition.formation;
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
     IF ( NOT pass ) THEN ESCAPE; END_IF;
      IF EXISTS( pdr_bag[k].relating_product_definition.formation ) THEN
        IF NOT( pdr_bag[k].relating_product_definition.formation IN pdf_bag ) THEN
          pass := FALSE;
        END_IF;
      END_IF;
    END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- packaged_part_unique_constraint 
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of packaged_part, externally_defined_packaged_part and library_defined_packaged_part
must have a single product_definition_formation of package related by a 'used package' relationship.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="parallel_shape_element_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The parallel_shape_element_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a parallel shape element relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE parallel_shape_element_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- parallel_shape_element_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'parallel' shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are parallel to themselves either directly or through intermediate shape_aspect_relationship with a name of 'parallel'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_constraint rule constrains the use of a 
product_definition_relationship when it is used as a part_device.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE part_device_constraint FOR ( product_definition_relationship );
END_RULE; -- part_device_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship which has a related_product_definition 
{which is a (bare_die) (externally_defined_bare_die) (library_defined_bare_die)}
{which has a frame_of_reference which is an application_context_element.name = 
 'physical design usage'} shall have 
{a SELF.description = 'part device'} 
{a relating_product_definition 
 {which is a (packaged_part) (externally_defined_packaged_part) 
  (library_defined_packaged_part)} 
 {which has a frame_of_reference which is an application_context_element.name = 
  'physical design usage'}}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship which has a related_product_definition 
{which is a (bare_die) (externally_defined_bare_die) (library_defined_bare_die)}
{which has a frame_of_reference which is an application_context_element.name = 
 'physical design usage'} shall 
{have a SELF.description = 'part device'} 
{be the definition of at most one property_definition_representation whose 
 used_representation 
 {has an items which is a mapped_item} 
 {has a name = 'planar projected shape'}}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship which has a related_product_definition 
{which is a (bare_die) (externally_defined_bare_die) (library_defined_bare_die)}
{which has a frame_of_reference which is an application_context_element.name = 
 'physical design usage'} shall 
{have a SELF.description = 'part device'} 
{be the definition of at most one property_definition_representation whose 
 used_representation 
 {has an items which is a mapped_item} 
 {has a name = '3d bound volume shape'}}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_terminal_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_terminal_constraint rule constrains the 
related_product_definition of a product_definition_relationship when it is a
part_device_terminal.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE part_device_terminal_constraint FOR ( shape_aspect );
END_RULE; -- part_device_terminal_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF a shape_aspect is the of_shape of a property_definition whose definition 
is a product_definition_relationship.description = 'part device' 
THEN the product_definition_relationship.related_product_definition shall 
be the of_shape.definition of a minimally_defined_bare_die_terminal.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_terminal_model_port_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_terminal_model_port_assignment_unique_constraint rule
constrains property_definition_representation population members, that
fill the role of ARM part_device_terminal_model_port_assignment, so
that the combination of ARM internal_connection and ARM internal_port
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_device_terminal_model_port_assignment_unique_constraint FOR
 ( property_definition_representation );
LOCAL
  amp_bag : BAG OF analytical_model_port := [];
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(property_definition_representation) by 1;
  IF EXISTS( property_definition_representation[i].used_representation )
                                                            THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ANALYTICAL_MODEL_PORT' IN TYPEOF(
property_definition_representation[i].used_representation) ) THEN
      IF( NOT( property_definition_representation[i].used_representation IN 
                                              amp_bag ) )
                                                               THEN
        amp_bag := amp_bag + 
              property_definition_representation[i].used_representation;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(amp_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  pdr_bag := QUERY( pdr <* property_definition_representation | 
                            (pdr.used_representation :=: amp_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].definition.definition ) THEN
      IF ( pdr_bag[j].definition.definition IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + pdr_bag[j].definition.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_device_terminal_model_port_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of property_definition_representation with a used_representation
attribute that references an analytical_model_port entity must have a unique
combination of used_representation and definition.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_terminal_unique_constraint rule constrains shape_aspect
population members, that fill the role of ARM part_device_terminal, so
that the combination of ARM terminated_device and ARM
used_bare_die_terminal shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_device_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  sa_bag : BAG OF shape_aspect;
  pd_bag : BAG OF property_definition;
  sa : BAG OF bare_die_terminal;
  pass : BOOLEAN := TRUE;
  bdt_bag : BAG OF bare_die_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect) by 1;
  IF EXISTS( shape_aspect[i].of_shape.definition ) THEN
    IF( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
TYPEOF(shape_aspect[i].of_shape.definition)) AND
(shape_aspect[i].of_shape.definition.description = 'part device') ) THEN
      IF( NOT( shape_aspect[i].of_shape.definition IN pdr_bag ) ) THEN
        pdr_bag := pdr_bag + shape_aspect[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  bdt_bag := [];
  sa_bag := QUERY( sa <* shape_aspect | (sa.of_shape.definition :=: 
                   pdr_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := QUERY( pd <* USEDIN(
sa_bag[j].of_shape.definition.related_product_definition,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF([
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'BARE_DIE','ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EXTERNALLY_DEFINED_BARE_DIE',
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LIBRARY_DEFINED_BARE_DIE'] * TYPEOF(pd.definition))>0) );
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      sa := QUERY( bdt <* USEDIN(pd_bag[k],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT.OF_SHAPE') |
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'BARE_DIE_TERMINAL' IN TYPEOF(bdt)) );
      REPEAT l := 1 to SIZEOF(sa) by 1;
        IF EXISTS( sa[l] ) THEN
          IF ( sa[l] IN bdt_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            bdt_bag := bdt_bag + sa[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_device_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect that has an
of_shape.definition.description of 'part device' shall have
a unique combination of of_shape.definition attribute and
bare_die_terminal entity where the bare_die_terminal's
of_shape.definition attribute references the same instance as
that referenced by the path through of_shape, definition, related_product_definition starting
at the shape_aspect instance.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_unique_constraint rule constrains product_definition_relationship
population members, that fill the role of ARM part_device, so that the
combination of ARM defined_packaged_part and ARM item_identification shall be
unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_device_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  pd : BAG OF product_definition_relationship := QUERY( pdr <*
product_definition_relationship | (pdr\product_definition_relationship.description = 'part device') );
  pu_bag : BAG OF physical_unit := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pd) by 1;
  IF EXISTS( pd[i].relating_product_definition ) THEN
    IF( (pd[i].relating_product_definition.frame_of_reference.name =
'physical design usage') AND (SIZEOF(
['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART',
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EXTERNALLY_DEFINED_PACKAGED_PART',
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LIBRARY_DEFINED_PACKAGED_PART'] * 
TYPEOF(pd[i].relating_product_definition))>0) ) THEN
      IF( NOT( pd[i].relating_product_definition IN pu_bag ) ) THEN
        pu_bag := pu_bag + pd[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  pdr_bag := QUERY( pdr <* pd | (pdr.relating_product_definition :=: 
                                                       pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j]\product_definition_relationship.name ) THEN
      IF ( pdr_bag[j]\product_definition_relationship.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + pdr_bag[j]\product_definition_relationship.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_device_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a description of
'part device' must have a unique combination of name and
relating_product_definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_feature_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_feature_constraint rule constrains the identification of a shape_aspect when it is used as an implementation of the ARM object Part_feature.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_feature_constraint FOR
  (shape_aspect, product_definition, shape_aspect_relationship);
LOCAL
pass : BOOLEAN := TRUE;
name_bag : BAG OF STRING := [];
sa : BAG OF shape_aspect := [];
pd : BAG OF product_definition := QUERY ( pd <* product_definition |
       pd.frame_of_reference\application_context_element.name
       = 'physical design usage');
END_LOCAL;
 REPEAT i := 1 to SIZEOF (pd) by 1;
name_bag := [];
sa := QUERY ( sa <* shape_aspect | (
(sa.of_shape\property_definition.definition = pd[i]) AND
(sa.product_definitional) AND
(NOT (sa\shape_aspect.description = 'connection zone'))
));
  REPEAT j := 1 to SIZEOF (sa) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
 IF sa[j]\shape_aspect.name in name_bag THEN pass := FALSE;
 ELSE
  name_bag := name_bag + sa[j]\shape_aspect.name;
 END_IF;
  END_REPEAT;
 END_REPEAT;
WHERE
 WR1: pass;
 WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
      (sar\shape_aspect_relationship.name = 'precedent feature') AND
      (sar.related_shape_aspect = sar.relating_shape_aspect))) = 0;
 WR3: SIZEOF(QUERY(sa <* shape_aspect | 
      ((sa\shape_aspect.description = 'part group feature') OR
      (sa\shape_aspect.description = 'part generic feature') OR
      (sa\shape_aspect.description = 'polarity indication feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 1))) = 0;
 WR4: SIZEOF(QUERY(sa <* shape_aspect |
      ((sa\shape_aspect.description = 'interconnect module edge segment surface') OR
      (sa\shape_aspect.description = 'interconnect module cavity surface') OR
      (sa\shape_aspect.description = 'interconnect module cutout surface') OR
      (sa\shape_aspect.description = 'interconnect module edge surface') OR
      (sa\shape_aspect.description = 'interconnect module primary surface') OR
      (sa\shape_aspect.description = 'interconnect module secondary surface') OR
      (sa\shape_aspect.description = 'interconnect module surface feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 0))) = 0;
END_RULE; -- part_feature_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">

<formal.propositions.rul>
Each shape_aspect that is product_definitional and that is not a connection zone and that is for a product_definition with a frame_of_reference that is an application_context_element
with a name of 'physical design usage' shall be uniquely identifiable using shape_aspect name attribute within the context of that product_definition. 
<note>
This implies that the shape_aspect.name is not necessarily unique within the entire product model or exchange file.
Reference shape_element_constraint, connection_zone_constraint, and physical_unit for related constraints.
</note>
</formal.propositions.rul>

<formal.propositions.rul>
Each shape_aspect_relationship with a name of 'precedent feature'
shall not have a related_shape_aspect that is the same
has its relating_shape_aspect.
</formal.propositions.rul>

<formal.propositions.rul>
Each shape_aspect with a description of
'part group feature' or
'part generic feature' or
'polarity indication feature' or
shall the related_shape_aspect for at most 
one shape_aspect_relationship with a name of 'precedent feature'.
</formal.propositions.rul>

<formal.propositions.rul>
Each shape_aspect with a description of
'interconnect module cavity surface' or
'interconnect module cutout surface' or
'interconnect module edge segment surface' or
'interconnect module edge surface' or
'interconnect module primary surface' or
'interconnect module secondary surface' or
'interconnect module surface feature'
shall not be the related_shape_aspect for a shape_aspect_relationship with a name of 'precedent feature'.
</formal.propositions.rul>

</formal.propositions>

<informal.propositions rule.types="IP">
<informal.propositions.rul>
Each shape_aspect with a description of 'part generic feature' shall
implement the Part_feature ARM concept and none of the subtypes
or any other ARM concept that maps to shape_aspect.
</informal.propositions.rul>

<informal.propositions.rul>
Each shape_aspect with a description of
'part group feature' or
'part generic feature' or
'polarity indication feature' or
'interconnect module cavity surface' or
'interconnect module cutout surface' or
'interconnect module edge segment surface' or
'interconnect module edge surface' or
'interconnect module primary surface' or
'interconnect module secondary surface' or
'interconnect module surface feature'
shall implement the corresponding subtypes of the Part_feature ARM concept and no other subtypes
or any other ARM concept that maps to shape_aspect.
</informal.propositions.rul>

</informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_feature_unique_constraint">
<RULE.DESCRIPTION>
The part_feature_unique_constraint rule constrains the composite_shape_aspect,
shape_aspect, primary_orientation_feature, secondary_orientation_feature,
tertiary_orientation_feature,
package_body, part_tooling_feature, thermal_feature, part_mounting_feature,
package_terminal, assembly_module_terminal, bare_die_terminal,
interconnect_module_terminal, minimally_defined_bare_die_terminal,
packaged_part_terminal and package_body_surface population members, that fill
the role of ARM part_feature, so that the combination of ARM name and ARM
associated_definition attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_feature_unique_constraint FOR
 ( composite_shape_aspect, shape_aspect, primary_orientation_feature,
tertiary_orientation_feature,
secondary_orientation_feature, package_body, part_tooling_feature,
thermal_feature, part_mounting_feature, package_terminal,
assembly_module_terminal, bare_die_terminal, interconnect_module_terminal,
minimally_defined_bare_die_terminal, packaged_part_terminal, 
package_body_surface );
LOCAL
  csa : BAG OF shape_aspect := QUERY( r <* composite_shape_aspect |
(r\shape_aspect.description = 'part group feature') );
  sa : BAG OF shape_aspect := QUERY( r <* shape_aspect |
(r\shape_aspect.description IN ['part generic feature','polarity indication feature',
'interconnect module edge segment surface',
'interconnect module cavity surface',
'interconnect module cutout surface',
'interconnect module edge surface',
'interconnect module primary surface',
'interconnect module secondary surface',
'interconnect module surface feature']) );
  pof : BAG OF shape_aspect := QUERY( r <* 
                  primary_orientation_feature | (TRUE) );
  sof : BAG OF shape_aspect := QUERY( r <* 
                 secondary_orientation_feature | (TRUE) );
  tof : BAG OF shape_aspect := QUERY( r <* 
                 tertiary_orientation_feature | (TRUE) );
  pb : BAG OF shape_aspect := QUERY( r <* 
                                package_body | (TRUE) );
  ptf : BAG OF shape_aspect := QUERY( r <* part_tooling_feature | (TRUE) );
  tf : BAG OF shape_aspect := QUERY( r <* thermal_feature | (TRUE) );
  pmf : BAG OF shape_aspect := QUERY( r <* part_mounting_feature | (TRUE) );
  pt : BAG OF shape_aspect := QUERY( r <* package_terminal | (TRUE) );
  amt : BAG OF shape_aspect := QUERY( r <* 
                            assembly_module_terminal | (TRUE) );
  bdt : BAG OF shape_aspect := QUERY( r <* bare_die_terminal | (TRUE) );
  imt : BAG OF shape_aspect := QUERY( r <* 
                          interconnect_module_terminal | (TRUE) );
  mdbdt : BAG OF shape_aspect := QUERY( r <* 
                    minimally_defined_bare_die_terminal | (TRUE) );
  ppt : BAG OF shape_aspect := QUERY( r <* 
                                  packaged_part_terminal | (TRUE) );
  pbs : BAG OF shape_aspect := QUERY( r <* 
                                       package_body_surface | (TRUE) );
  pf : BAG OF shape_aspect := [];
  pu_bag : BAG OF physical_unit := [];
  sa_bag : BAG OF shape_aspect;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

sa := csa + sa + pof + sof +tof + pb + ptf + tf + pmf + 
          pt + amt + bdt + imt + mdbdt + ppt + pbs;
REPEAT i := 1 to SIZEOF(sa) by 1;
  IF EXISTS( sa[i] ) THEN
    IF ( NOT ( sa[i] IN pf )) THEN
      pf := pf + sa[i];
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pf) by 1;
  IF EXISTS( pf[i].of_shape.definition ) THEN
    IF ( (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(pf[i].of_shape.definition)) AND
(pf[i].of_shape.definition.frame_of_reference.name = 
'physical design usage') ) THEN
      IF ( NOT ( pf[i].of_shape.definition IN pu_bag )) THEN
        pu_bag := pu_bag + pf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  sa_bag := QUERY( sa <* pf | (sa.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF EXISTS( sa_bag[j]\shape_aspect.name ) THEN
      IF ( sa_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sa_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_feature_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of primary_orientation_feature, secondary_orientation_feature,
package_body, part_tooling_feature, thermal_feature, part_mounting_feature,
package_terminal, assembly_module_terminal, bare_die_terminal,
interconnect_module_terminal, minimally_defined_bare_die_terminal,
packaged_part_terminal, package_body_surface, composite_shape_aspect with a
description of 'part group feature', and shape_aspect with a description of
'part generic feature', 'polarity indication feature',
'interconnect module edge segment surface', 'interconnect module edge surface',
'interconnect module cavity surface', 'interconnect module cutout surface',
'interconnect module primary surface', 'interconnect module secondary surface',
'interconnect module surface feature' shall have a unique combination of name
and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_template_non_planar_2d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_template_non_planar_2d_shape_constraint rule 
constrains manifold_surface_shape_representation
when it is used as a part template non planar 2d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_template_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'part template non planar 2d shape')
       AND NOT(SIZEOF(QUERY(a2p3d <* mssr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(a2p3d))
       )) = 1)
       )) = 0;
END_RULE; -- part_template_non_planar_2d_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall have exactly
one item that is a axis2_placement_3d.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall be the rep_1 for 
at most one representation_relationship with a rep_2 that is a
representation with a name of 'shape environment' with a 
item that is a descriptive_representation_item with a name 
of 'manufacturing' or 'end user application'.
</Informal.propositions.rul>

<Informal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall be the rep_1 for 
exactly one representation_relationship with a rep_2 that is a
representation with a name of 'shape material condition' with a 
item that is a descriptive_representation_item with a name 
of 'maximum material condition', 'minimum material condition',
or 'nominal material condition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall be the used_representation
for exactly one property_definition that shall also have a definition
that is a part_template_definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_template_planar_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_template_planar_shape_constraint rule constrains the items and the use
of a shape_representation when it is a part_template_planar_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE part_template_planar_shape_constraint FOR ( shape_representation );
END_RULE; -- part_template_planar_shape_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation 
that is the used_representation of a property_definition_representation that 
has a definition.definition that is a part_template_definition 
shall have one items that 
{is a descriptive_representation_item} {has a name = 'shape material condition'}
{has a description = ('maximum material condition') 
('minimum material condition') ('nominal material condition')}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="part_terminal_external_reference_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_terminal_external_reference_unique_constraint rule constrains the
representation population members, that fill the role of ARM part_terminal_external_reference,
to have unique ARM associated_definition attributes with each ARM feature_name
attribute and ARM feature_type attribute combination.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_terminal_external_reference_unique_constraint FOR
 ( representation );
LOCAL
  pter : BAG OF representation := QUERY( r <* representation |
(r\representation.name = 'part terminal external reference'));
  fn_bag : BAG OF STRING := [];
  ft_bag : BAG OF STRING := [];
  r_bag : BAG OF representation;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  REPEAT j := 1 to SIZEOF(pter[i].items) by 1;
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pter[i].items[j]) ) THEN
      IF ( (pter[i].items[j]\representation_item.name = 'feature name') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                                                  IN fn_bag )) ) THEN
        fn_bag := fn_bag + pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
      IF ( (pter[i].items[j]\representation_item.name = 'feature type') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                 IN ft_bag )) ) THEN
        ft_bag := ft_bag + 
        pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fn_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  REPEAT j := 1 to SIZEOF(ft_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    r_bag := QUERY( r <* pter | ((SIZEOF(
QUERY(ri <* r.items | ((ri\descriptive_representation_item.description =
ft_bag[j]) AND (ri\representation_item.name = 'feature type')) ) )>0) AND 
(SIZEOF(QUERY(ri <* r.items |
((ri\descriptive_representation_item.description = fn_bag[i]) AND 
         (ri\representation_item.name = 'feature name')) ) )>0)) );
    ptd_bag := [];
    REPEAT k := 1 to SIZEOF(r_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := USEDIN( r_bag[k], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION' );
      REPEAT l:= 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].definition.definition ) THEN
          IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF( pdr_bag[l].definition.definition ) ) THEN
            IF ( pdr_bag[l].definition.definition IN ptd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ptd_bag := ptd_bag + pdr_bag[l].definition.definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_terminal_external_reference_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of representation with a description of 'part terminal external reference'
that has a common pair of description attributes on descriptive_representation_items in
its set of items with name attributes of 'feature type' and 'feature name' must have 
unique physical_unit entities that are referenced by a property_definition_representation
definition.definition attribute and has one of said representations as the
property_definition_representation's used_representation attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="perpendicular_shape_element_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The perpendicular_shape_element_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a perpendicular shape element relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE perpendicular_shape_element_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- perpendicular_shape_element_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'perpendicular' shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are perpendicular to themselves either directly or through intermediate shape_aspect_relationship with a name of 'perpendicular'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="person_and_organization_unique_constraint">
<RULE.DESCRIPTION>
The person_and_organization_unique_constraint rule constrains the
person_and_organization population members, that fill the role of ARM
person_and_organization, to have unique ARM assigned_organization
attribute when combined with ARM assigned_person attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE person_and_organization_unique_constraint FOR
 ( person_and_organization );
LOCAL
  p_bag : BAG OF person := [];
  pao_bag : BAG OF person_and_organization;
  pass : BOOLEAN := TRUE;
  o_bag : BAG OF organization;
END_LOCAL;

REPEAT i := 1 to SIZEOF(person_and_organization) by 1;
  IF EXISTS( person_and_organization[i].the_person ) THEN
    IF ( NOT ( person_and_organization[i].the_person IN p_bag )) THEN
      p_bag := p_bag + person_and_organization[i].the_person;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(p_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  o_bag := [];
  pao_bag := QUERY( pao <* person_and_organization | 
                   (pao.the_person :=: p_bag[i]) );
  REPEAT j := 1 to SIZEOF(pao_bag) by 1;
    IF EXISTS( pao_bag[j].the_organization ) THEN
      IF ( pao_bag[j].the_organization IN o_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        o_bag := o_bag + pao_bag[j].the_organization;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- person_and_organization_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of person_and_organization that references a common person must reference a unique organization.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="physical_connectivity_abstraction_map_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_connectivity_abstraction_map_unique_constraint rule constrains the
shape_aspect_relationship population members, that fill the role of ARM
physical_connectivity_abstraction_map, to have unique ARM geometric_context_based_definition
attributes with each ARM name_space_context_based_definition attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE physical_connectivity_abstraction_map_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  pcam : BAG OF shape_aspect_relationship := 
        QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'physical to topological abstraction map') );
  pce_bag : BAG OF physical_connectivity_element := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  csa_bag : BAG OF component_shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pcam) by 1;
  IF EXISTS( pcam[i].related_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_CONNECTIVITY_ELEMENT' IN 
TYPEOF(pcam[i].related_shape_aspect) ) THEN
      IF ( NOT ( pcam[i].related_shape_aspect IN pce_bag )) THEN
        pce_bag := pce_bag + pcam[i].related_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pce_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  csa_bag := [];
  sar_bag := QUERY( sar <* pcam | (sar.related_shape_aspect :=: 
                 pce_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF ( (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_SHAPE_ASPECT' IN 
TYPEOF(sar_bag[j].relating_shape_aspect))
AND (sar_bag[j].relating_shape_aspect\shape_aspect.description IN [
'conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition']) )
                                                      THEN
      IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
        IF ( sar_bag[j].relating_shape_aspect IN csa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          csa_bag := csa_bag + sar_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- physical_connectivity_abstraction_map_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'physical to topological abstraction map' that references a common
physical_connectivity_element must reference a unique component_shape_aspect
with a description of either 'conductive interconnect element with pre defined transitions'
or 'conductive interconnect element with user defined single transition'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="physical_connectivity_definition_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_connectivity_definition_relationship_constraint rule constrains
the value of related and relating shape_aspect and the use of a
shape_aspect_relationship when it is a 
physical_connectivity_definition_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE physical_connectivity_definition_relationship_constraint FOR
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'physical connectivity definition change')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF(sar.related_shape_aspect))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'physical connectivity definition change')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF(sar.relating_shape_aspect))
       )) = 0;
  WR3: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'physical connectivity definition change')
       AND (SIZEOF(QUERY(rpd <* USEDIN(sar, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rpd))
       )) = 0)
       )) = 0;
  
END_RULE; -- physical_connectivity_definition_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'physical connectivity definition change' 
THEN the related_shape_aspect shall be a physical_connectivity_definition.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'physical connectivity definition change' 
THEN the relating_shape_aspect shall be a physical_connectivity_definition.
</formal.propositions.rul>
<formal.propositions.rul>
Each shape_aspect_relationship which has a name = 'physical connectivity 
definition change' shall be the definition of one requirements_property.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="physical_connectivity_element_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_connectivity_element_unique_constraint rule constrains the
physical_connectivity_element population members, that fill the role of
ARM physical_connectivity_element, to be have unique ARM
connectivity_context attributes with each ARM name attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE physical_connectivity_element_unique_constraint FOR
 ( physical_connectivity_element );
LOCAL
  name_bag : BAG OF STRING := [];
  pce_bag : BAG OF physical_connectivity_element;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pcd_bag : BAG OF physical_connectivity_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(physical_connectivity_element) by 1;
  IF EXISTS( physical_connectivity_element[i]\shape_aspect.name ) THEN
    IF( NOT( physical_connectivity_element[i]\shape_aspect.name IN 
         name_bag ) ) THEN
      name_bag := name_bag + 
                physical_connectivity_element[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pcd_bag := [];
  pce_bag := QUERY( pce <* physical_connectivity_element |
(pce\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(pce_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( pce_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'structure element') AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_CONNECTIVITY_DEFINITION' IN 
TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
        IF ( sar_bag[j].relating_shape_aspect IN pcd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pcd_bag := pcd_bag + sar_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- physical_connectivity_element_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For every instance of physical_connectivity_element that has a common name
attribute that is referenced by a shape_aspect_relationship with a name
of 'structure element', the shape_aspect_relationships must have unique
relating_shape_aspect attribute values.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="physical_unit_3d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_unit_3d_shape_constraint rule constrains the items and the usage
of a shape_representation when it is a physical_unit_3d_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE physical_unit_3d_shape_constraint FOR ( shape_representation );
END_RULE; -- physical_unit_3d_shape_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall be the 
used_representation of another property_definition_representation whose 
definition.definition is a physical_unit that has a frame_of_reference that 
is an application_context_element that has a name = ('physical design') 
('physical design usage').
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape environment' and that has a representation_item
with a name of 'manufacturing' or 'end user application'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape material condition' and that has a representation_item
with a name of 'maximum material condition' or
'minimum material condition' or 'nominal material condition'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
shall be related to one 
representation that has a name = 'externally defined shape purpose' 
or that has a name = 'predefined shape purpose'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
that is related to one 
representation that has a name = 'externally defined shape purpose' 
that shall have a representation_item that is an external_definition,
and that representation_item.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
that is related to one 
representation that has a name = 'predefined shape purpose' 
 shall have a representation_item
with a name of 'analysis' 
or 'shock analysis' 
or 'design'
or 'vibrational analysis'
or 'electromagnetic compatibility analysis'
or 'thermal analysis'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall have exactly 
one items that is a cartesian_point.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a physical_unit} shall be 
related through a 
property_definition_relationship {with a name = 'application technology constraint'}
to no more than one requirements_property, where the requirements_property is the relating_property_definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall
also be related to a package.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall
also be related to a package, where that package is referenced by the package_part as the 'used package'.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="physical_unit_planar_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_unit_planar_shape_constraint rule constrains the items and the usage
of a shape_representation when it is a physical_unit_planar_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE physical_unit_planar_shape_constraint FOR ( shape_representation );
END_RULE; -- physical_unit_planar_shape_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall be the 
used_representation of another property_definition_representation whose 
definition.definition is a physical_unit that has a frame_of_reference that 
is an application_context_element that has a name = ('physical design') 
('physical design usage').
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape environment' and that has a representation_item
with a name of 'manufacturing' or 'end user application'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape material condition' and that has a representation_item
with a name of 'maximum material condition' or
'minimum material condition' or 'nominal material condition'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
shall be related to one 
representation that has a name = 'predefined shape purpose' or that has a name
= 'externally defined purpose'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
and that is related to a
representation that has a name = 'predefined shape purpose' shall be related to a
representation that has a name = 'predefined shape purpose' where that
representation has a representation_item
with a name of 'design' or 'assembly symbol' or 'design profile'
or 'electromagnetic compatibility analysis'
or 'shock analysis'
or 'physical extent'
or 'thermal analysis'
or 'vibrational analysis'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
and that is related to a
representation that has a name = 'externally defined purpose' shall be related to a
representation that has a name = 'externally defined purpose' where that
representation has a representation_item
that is an external_definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall have exactly 
one items that is a cartesian_point.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall be the
used_representation of another property_definition_representation whose
definition is a requirements_property.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a physical_unit} shall be 
related through a 
property_definition_relationship {with a name = 'application technology constraint'}
to no more than one requirements_property, where the requirements_property is the relating_property_definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall 
also be related to a package.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall
also be related to a package, where that package is referenced by the package_part as the 'used package'.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="physical_unit_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_unit_relationship_constraint rule constrains the 
related_product_definition of a product_definition_relationship when it is a
physical_unit_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE physical_unit_relationship_constraint FOR 
( product_definition_relationship );
END_RULE; -- physical_unit_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship that has a related_product_definition that
is a physical_unit with a frame_of_reference that is a 
product_definition_context.name = ('physical design') ('physical design usage')
shall have a related_product_definition that is a physical_unit with a 
frame_of_reference that is a product_definition_context.name = 
('physical design') ('physical design usage').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="placement_group_area_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The placement_group_area_assignment_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is a
placement_group_area_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE placement_group_area_assignment_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(sar.related_shape_aspect))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GROUP_PRODUCT_DEFINITION'
       IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION_CONTEXT'
IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))
   AND 
     (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name
       = 'design requirement') 
       )))) = 0;
END_RULE; -- placement_group_area_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'area impacted group' THEN related_shape_aspect 
shall be a mounting_restriction_area.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'area impacted group' THEN relating_shape_aspect
shall be (a group_shape_aspect) (a shape_aspect whose of_shape.definition 
is a group_product_definition whose frame_of_reference is a 
product_definition_context.name = 'design requirement').
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="placement_group_volume_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The placement_group_volume_assignment_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is a
placement_group_volume_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE placement_group_volume_assignment_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(sar.related_shape_aspect))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GROUP_PRODUCT_DEFINITION'
       IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION_CONTEXT'
IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))
   AND 
     (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name
       = 'design requirement') 
       )))) = 0;
END_RULE; -- placement_group_volume_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'volume impacted group' THEN related_shape_aspect 
shall be a mounting_restriction_volume.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'volume impacted group' THEN relating_shape_aspect
shall be (a group_shape_aspect) (a shape_aspect whose of_shape.definition 
is a group_product_definition whose frame_of_reference is a 
product_definition_context.name = 'design requirement').
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="planar_curve_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The planar_curve_constraint rule constrains the dimensionality of a
shape_representation when it is only allowed to include planar curves.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE planar_curve_constraint FOR ( shape_representation );
WHERE
WR1: SIZEOF (QUERY (sr <* shape_representation | 
(
NOT(NOT ( sr\representation.name IN ['planar projected shape',
       'bevel edge feature shape',
       'step edge feature shape',
       'radius edge feature shape']) OR
(sr\representation.
context_of_items\geometric_representation_context.
coordinate_space_dimension = 2)
))
)) = 0;
END_RULE; -- planar_curve_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
If the name of a shape_representation is 'planar projected shape',
'bevel edge feature shape','step edge feature shape' or 
'radius edge feature shape' then dimensionality of the geometric
context shall be exactly 2.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="planned_effectivity_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The planned_effectivity_constraint rule constrains the usage of a
configuration_effectivity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE planned_effectivity_constraint FOR ( configuration_effectivity );
WHERE
  WR1: SIZEOF(QUERY(ce <* configuration_effectivity |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage))
       AND (ce.usage\product_definition_relationship.name = 'assembly composition'))
       )) = 0;
  WR2: SIZEOF(QUERY(ce <* configuration_effectivity |
       SIZEOF(USEDIN(ce,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0 
       )) = 0;

END_RULE; -- planned_effectivity_constrain
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each configuration_effectivity shall have a usage that
is an assembly_component_usage with a name = 'assembly composition'.
</formal.propositions.rul>
<formal.propositions.rul>
Each configuration_effectivity shall be an items in an 
applied_approval_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="planned_effectivity_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The planned_effectivity_unique_constraint rule constrains the configuration_effectivity population
members, that fill the role of ARM planned_effectivity, to be have unique ARM effective_assembly
entities on each ARM configuration entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE planned_effectivity_unique_constraint FOR
 ( configuration_effectivity );
LOCAL
  ce_bag : BAG OF configuration_effectivity;
  ci_bag : BAG OF configuration_item := [];
  pass : BOOLEAN := TRUE;
  acu_bag : BAG OF assembly_component_usage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_effectivity) by 1;
  IF EXISTS( configuration_effectivity[i].configuration.configuration ) THEN
    IF( NOT( configuration_effectivity[i].configuration.configuration IN 
                                                            ci_bag ) ) THEN
      ci_bag := ci_bag + 
               configuration_effectivity[i].configuration.configuration;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ci_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ce_bag := QUERY( r <* configuration_effectivity |
((r.configuration.configuration :=: ci_bag[i]) AND 
                              (r.usage\product_definition_relationship.name = 'assembly composition')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(r.usage)) ) );
  acu_bag := [];
  REPEAT j := 1 to SIZEOF(ce_bag) by 1;
    IF EXISTS( ce_bag[j].usage ) THEN
      IF ( ce_bag[j].usage IN acu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        acu_bag := acu_bag + ce_bag[j].usage;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- planned_effectivity_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of configuration_effectivity that has a common configuration.configuration
attribute must have a unique usage attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="plus_minus_tolerance_range_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The plus_minus_tolerance_range_representation_constraint rule constrains the use of a shape_dimension_representation and a plus_minus_tolerance when they are used as a plus minus tolerance range representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE plus_minus_tolerance_range_representation_constraint FOR
  (shape_dimension_representation, plus_minus_tolerance);
WHERE
  WR1: SIZEOF(QUERY(pmt <* plus_minus_tolerance |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'TOLERANCE_VALUE' IN TYPEOF (pmt.range))
       )) = 0;
END_RULE; -- plus_minus_tolerance_range_representation_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each plus_minus_tolerance shall have a range that is a tolerance_value.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value' shall contain exactly one measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value' shall be the representation of either a dimensional_size or dimensional_location that is also the toleranced_dimension of exactly one plus_minus_tolerance the range of which is a tolerance_value.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each plus_minus_tolerance shall have a toleranced_dimension that is either a dimensional_size or dimensional_location that is represented by exactly one shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each plus_minus_tolerance shall have a range that is a tolerance_value the upper_bound and lower_bound of which are measure_with_unit, the units of which shall be the same units as that of the measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value' and that is contained in the shape_dimension_representation that is a representation of the dimensional_size or dimensional_location that is the toleranced_dimension of the plus_minus_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="polarity_indication_feature_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The polarity_indication_feature_constraint rule constrains the body surfaces that may relate to it when the description is 'polarity indication feature'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE polarity_indication_feature_constraint FOR 
( shape_aspect);
WHERE
  WR1: SIZEOF (QUERY ( sa <* shape_aspect | NOT(
       NOT (sa\shape_aspect.description = 'polarity indication feature') OR 
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'associated body vertical extent')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1) 
       ))) = 0;
  WR2: SIZEOF (QUERY ( sa <* shape_aspect | NOT(
       NOT (sa\shape_aspect.description = 'polarity indication feature') OR 
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'associated body vertical extent')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect)) 
       )) <= 1)
       ))) = 0;
  WR3: SIZEOF (QUERY ( sa <* shape_aspect | NOT(
       NOT (sa\shape_aspect.description = 'polarity indication feature') OR 
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (sa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'associated terminal')
       ) |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL' IN
       TYPEOF (it.relating_shape_aspect))
       )) = 1)
       ))) = 0;
END_RULE; -- polarity_indication_feature_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
If the shape_aspect description is 'polarity indication feature', there shall be no more than one body_bottom_surface associated with it.
</formal.propositions.rul>
<formal.propositions.rul>
If the shape_aspect description is 'polarity indication feature', there shall be no more than one body_top_surface associated with it.
</formal.propositions.rul>
<formal.propositions.rul>
If the shape_aspect description is 'polarity indication feature', there shall be exactly one package_terminal associated with it.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="positional_boundary_and_profile_boundary_member_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The positional_boundary_and_profile_boundary_member_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a positional boundary and profile boundary member relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE positional_boundary_and_profile_boundary_member_relationship_constraint
FOR (shape_aspect_relationship);
END_RULE; -- positional_boundary_and_profile_boundary_member_-
          -- relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'positional boundary and profile boundary member' shall have a related_shape_aspect that has a description of 'tolerance zone boundary member' and is not on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'positional boundary and profile boundary member' shall have a relating_shape_aspect that is a positional_boundary with a description of 'profile related positional boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'positional boundary and profile boundary member' shall have exactly one property_definition with a description of 'positional boundary offset'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="positional_boundary_member_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The positional_boundary_member_definition_constraint rule constrains the use of a property_definition when it is used as a positional boundary member definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE positional_boundary_member_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition))))) = 0; 
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'DIMENSIONAL_SIZE_PROPERTY' IN 
       TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'boundary member associated dimension')
       )) = 1))) = 0; 
END_RULE; -- positional_boundary_member_definition_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be a property_definition of a positional_boundary_member.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall relate to exactly one dimensional_size_property to specify its 'boundary member associated dimension'.
</formal.propositions.rul>

</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be related as a 'defined boundary member property' to exactly one property_definition that has a description of 'dimension related positional boundary property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'positional boundary member value' and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the position_tolerance that has a name of 'boundary based position' and that relates to the instance of property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be related as a 'defined boundary member property' to exactly one property_definition that has a description of 'dimension related positional boundary property' and that is applied to a positional_boundary that has a description of 'dimension related positional boundary'. That positional_boundary shall be the same instance of positional_boundary to which the positional_boundary_member is related as a 'boundary member' and to which the instance of property_definition that has a description of 'positional boundary member property' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be related as a 'defined boundary' to exactly one position_tolerance that has a name of 'boundary based position'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="positional_boundary_offset_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The positional_boundary_offset_constraint rule constrains the use of a property_definition when it is used as a positional boundary offset.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE positional_boundary_offset_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF (pd.definition)) AND
 (pd.definition\shape_aspect_relationship.name = 'positional boundary and profile boundary member'))
       )) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'boundary offset') AND
       (pdr.relating_property_definition\property_definition.name =
       'profile related positional boundary property'))) = 1)
       )) = 0;
END_RULE; -- positional_boundary_offset_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary offset' shall be a property_definition of a shape_aspect_relationship that has a name of 'positional boundary and profile boundary member'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary offset' shall be related as a 'boundary offset' to exactly one property_definition that has a description of 'profile related positional boundary property'.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary offset' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'positional boundary offset value', and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the position_tolerance that has a name of 'boundary based position' and that relates to the instance of property_definition that has a description of 'profile related positional boundary property' to specify its 'defined boundary', that in turn relates to the instance of property_definition that has a description of 'positional boundary offset' to specify its 'boundary offset'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="pre_defined_dimension_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The pre_defined_dimension_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a pre defined dimension qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE pre_defined_dimension_qualifier_constraint FOR
  (measure_qualification);
END_RULE; -- pre_defined_dimension_qualifier_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'predefined dimension qualifier' shall have exactly zero qualifiers for the measure_qualification that are type_qualifier the name of which is not either 'average', or 'free state'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="pre_defined_geometric_tolerance_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The pre_defined_geometric_tolerance_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a pre-defined geometric tolerance qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE pre_defined_geometric_tolerance_qualifier_constraint FOR
  (measure_qualification);
END_RULE; -- pre_defined_geometric_tolerance_qualifier_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'predefined geometric
tolerance qualifier' shall have exactly zero qualifiers for the
measure_qualification that are type_qualifier the name of which is not among
'each element', 'each radial element', 'free state', 'major diameter',
'minor diameter', 'not concave', 'not convex', or 'pitch diameter'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="printed_connector_template_terminal_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The printed_connector_template_terminal_relationship_unique_constraint rule constrains the
printed_connector_template_terminal_relationship population members, that fill the role of
ARM printed_connector_template_terminal_relationship, to have unique combinations of ARM
connector and ARM join_terminal attributes and to have unique combinations of ARM connector
and ARM interface_terminal attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE printed_connector_template_terminal_relationship_unique_constraint FOR
 ( printed_connector_template_terminal_relationship );
LOCAL
  ptd_bag : BAG OF part_template_definition := [];
  pcttr_bag : BAG OF printed_connector_template_terminal_relationship;
  sar_bag : BAG OF shape_aspect_relationship;
  pass1 : BOOLEAN := TRUE;
  jt_bag : BAG OF printed_part_template_terminal;
  pass2 : BOOLEAN := TRUE;
  it_bag : BAG OF printed_part_template_terminal;
END_LOCAL;

REPEAT i := 1 to 
        SIZEOF(printed_connector_template_terminal_relationship) by 1;
  sar_bag := QUERY( sar <* 
          USEDIN( printed_connector_template_terminal_relationship[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
  ((sar\shape_aspect_relationship.name = 'connector') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND
(sar.relating_shape_aspect\shape_aspect.description = 'printed connector template')) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].relating_shape_aspect IN ptd_bag )) THEN
        ptd_bag := ptd_bag + sar_bag[j].relating_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ptd_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  it_bag := [];
  jt_bag := [];
  sar_bag := QUERY( sar <* USEDIN( ptd_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT' ) | 
  (sar\shape_aspect_relationship.name = 'connector') );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    pcttr_bag := 
   QUERY( pcttr <* printed_connector_template_terminal_relationship |
(pcttr :=: sar_bag[j].related_shape_aspect) );
    REPEAT k := 1 to SIZEOF(pcttr_bag) by 1;
      IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
      END_IF;
      IF ( pass1 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRINTED_PART_TEMPLATE_TERMINAL' IN 
TYPEOF(pcttr_bag[k].relating_shape_aspect))
AND (pcttr_bag[k].relating_shape_aspect\shape_aspect.description = 'join terminal') )
                                                    THEN
        IF EXISTS( pcttr_bag[k].relating_shape_aspect ) THEN
          IF ( pcttr_bag[k].relating_shape_aspect IN jt_bag ) THEN
            pass1 := FALSE;
            ESCAPE;
          ELSE
            jt_bag := jt_bag + pcttr_bag[k].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
      IF ( pass2 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PRINTED_PART_TEMPLATE_TERMINAL' IN 
TYPEOF(pcttr_bag[k].related_shape_aspect))
AND (pcttr_bag[k].related_shape_aspect\shape_aspect.description = 'interface terminal') )
                                                      THEN
        IF EXISTS( pcttr_bag[k].related_shape_aspect ) THEN
          IF ( pcttr_bag[k].related_shape_aspect IN it_bag ) THEN
            pass2 := FALSE;
            ESCAPE;
          ELSE
            it_bag := it_bag + pcttr_bag[k].related_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- printed_connector_template_terminal_relationship_unique_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of printed_connector_template_terminal_relationship that references a
common part_template_definition through a shape_aspect_relationship with a name of
'connector' must have a unique relating_shape_aspect attribute that points to a
printed_part_template_terminal with a description of 'join terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of printed_connector_template_terminal_relationship that references a
common part_template_definition through a shape_aspect_relationship with a name of
'connector' must have a unique related_shape_aspect attribute that points to a
printed_part_template_terminal with a description of 'interface terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="printed_part_template_terminal_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The printed_part_template_terminal_relationship_constraint rule constrains
the related and relating shape_aspect of a shape_aspect_relationship when it
is used as a printed part template terminal relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE printed_part_template_terminal_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'printed part template terminal relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRINTED_PART_TEMPLATE_TERMINAL' IN 
        TYPEOF(sar.related_shape_aspect)
       ))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'printed part template terminal relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF(sar.relating_shape_aspect)
       ))) = 0;
END_RULE; -- printed_part_template_terminal_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_aspect_relationship that has a name = 
'printed part template terminal relationship' shall have a 
related_shape_aspect that is a printed_part_template_terminal.
</formal.propositions.rul>
<formal.propositions.rul>
Each shape_aspect_relationship that has a name = 
'printed part template terminal relationship' shall have a 
relating_shape_aspect that is a printed_part_template_terminal.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="printed_part_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The printed_part_template_terminal_unique_constraint rule constrains the
printed_part_template_terminal population members, that fill the role of
ARM printed_part_template_terminal, to have unique names on each printed_part_template.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE printed_part_template_terminal_unique_constraint FOR
 ( printed_part_template_terminal );
LOCAL
  pptt : BAG OF printed_part_template_terminal := 
                QUERY( r <* printed_part_template_terminal |
(r\shape_aspect.description IN ['interface terminal','join terminal']) );
  name_bag : BAG OF STRING := [];
  sar_bag : BAG OF shape_aspect_relationship;
  sa_bag : BAG OF shape_aspect;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pptt) by 1;
  IF EXISTS( pptt[i]\shape_aspect.name ) THEN
    IF ( NOT ( pptt[i]\shape_aspect.name IN name_bag )) THEN
      name_bag := name_bag + pptt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ptd_bag := [];
  sa_bag := QUERY( sa <* pptt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'associated definition')
AND (sar.relating_shape_aspect\shape_aspect.description = 'printed part template')) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ptd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- printed_part_template_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of 'printed part template terminal'
that is referenced by a shape_aspect_relationship with a name of 'associated definition'
that references a common shape_aspect with a description of 'printed part template' must
have a unique name attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="product_association_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_association_constraint rule constrains the usage of a
product_definition_formation_relationship when it is a product association.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_association_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       (pdfr\product_definition_formation_relationship.name = 'product association')
       AND (SIZEOF(QUERY(adr <* USEDIN(pdfr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document))
       )) = 0))) = 0;
END_RULE; -- product_association_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_formation_relationship.name = 'product association' 
THEN SELF shall be an items of an applied_document_reference whose 
assigned_document is an ee_specification.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_association_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_association_unique_constraint rule constrains product_definition_formation_relationship
population members, that fill the role of ARM product_association, to have unique
ARM constraint_source attributes for each ARM relating_product attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_association_unique_constraint FOR
 ( product_definition_formation_relationship );
LOCAL
  pdfr : BAG OF product_definition_formation_relationship := QUERY( r <*
product_definition_formation_relationship | 
  (r\product_definition_formation_relationship.name = 'product association' ) );
  pdf_bag : BAG OF product_definition_formation := [];
  pdfr_bag : BAG OF product_definition_formation_relationship;
  pass : BOOLEAN := TRUE;
  adr_bag : BAG OF applied_document_reference;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pdfr) by 1;
  IF EXISTS( pdfr[i].relating_product_definition_formation ) THEN
    IF( NOT( pdfr[i].relating_product_definition_formation IN pdf_bag ) )
                                                              THEN
      pdf_bag := pdf_bag + pdfr[i].
                 relating_product_definition_formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdfr_bag := QUERY( r <* pdfr | 
             (r.relating_product_definition_formation :=: pdf_bag[i]) );
  es_bag := [];
  REPEAT j := 1 to SIZEOF(pdfr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( pdfr_bag[j], 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EE_SPECIFICATION') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- product_association_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_formation_relationship with a name of 'product
association' that has a common relating_product_definition_formation must have
unique ee_specification entities assigned to the product_definition_formation_relationship
by an applied_document_reference's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="product_concept_requires_configuration_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_concept_requires_configuration_item assures that
each instance of product_concept shall have a 
configuration_item which is a item_concept. 
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_concept_requires_configuration_item FOR
  (product_concept, configuration_item);
WHERE
  WR1: SIZEOF (QUERY (pc <* product_concept |
       NOT (SIZEOF (QUERY (ci <* configuration_item |
       pc :=: ci.item_concept)) >=1 ))) = 0;
END_RULE; -- product_concept_requires_configuration_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_concept, there shall be at least one 
instance of configuration_item that contains the instance of product_concept
as the value of its item_concept attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_formation_requires_approval">
<RULE.DESCRIPTION>
The product_definition_formation_requires_approval rule
assures that each instance of product_definition_formation that is an implementation of the Application Object Ee_product_version shall have an associated applied_approval_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_formation_requires_approval FOR
(product_definition,
  applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       pd.formation IN aaa.items )) = 1 )))) = 0;
END_RULE; -- product_definition_formation_requires_approval
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_definition_formation except for the instance referenced by an assembly_group_component_definition, there shall be exactly one instance of applied_approval_assignment that contains the instance of
product_definition_formation in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_formation_requires_person_organization">
<RULE.DESCRIPTION>
The product_definition_formation_requires_person_organization rule
assures that each instance of product_definition_formation that implements the Application Objec Ee_product_version shall
have either an applied_person_and_organization or an
applied_organization_assignment in the role of 'creator'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_formation_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition|
       (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       (pd.formation IN apaoa.items) AND (apaoa.role\person_and_organization_role.name = 'creator'))) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       (pd.formation IN aoa.items) AND (aoa.role\organization_role.name = 'creator'))) = 1 ))))) = 0;
END_RULE; -- product_definition_formation_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each product_definition that is not an implementation of Ee_product_version referenced by an implementation of Assembly_group_component_definition, exactly one instance of
applied_person_and_organization_assignment whose role.name is 'creator' or
exactly one instance of applied_organization_assignment whose role.name is
'creator' shall contain the instance of product_definition_formation in its
set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_definition_requires_date_or_date_and_time rule requires all
product_definition entities that implement the ARM concept of Ee_product_definition to be the items of exactly one
applied_date_and_time_assignment or applied_date_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_requires_date_or_date_and_time FOR
  (product_definition, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT 
       (NOT(is_ee_product_definition(pd)) OR 
       ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       pd IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       pd IN ada.items )) = 1 )))
       )) = 0;
END_RULE; -- product_definition_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_definition that implements the ARM concept of Ee_product_definition, exactly one instance of applied_date_and_time_assignment or exactly one instance of applied_date_assignment shall contain the instance of product_definition in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_definition_requires_person_organization rule requires all
product_definition entities to be an items of exactly one
applied_person_and_organization_assignment or applied_organization_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT
       (NOT(is_ee_product_definition(pd)) OR
       ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       pd IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       pd IN aoa.items )) = 1 )))
       )) = 0;
END_RULE; -- product_definition_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_definition, exactly one instance of
applied_person_and_organization_assignment or exactly one instance of
applied_organization_assignment shall contain the instance of
product_definition in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_requires_person_organization rule requires all product entities to be
the items of exactly one applied_person_and_organization_assignment or
applied_organization_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_requires_person_organization FOR
  (product, applied_person_and_organization_assignment,
   applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       prod IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       prod IN aoa.items )) = 1 )))) = 0;
END_RULE; -- product_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product, there shall be exactly one instance of
applied_person_and_organization_assignment or exactly one instance of
applied_organization_assignment that contains the instance of product
in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_requires_product_definition_formation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_requires_product_definition_formation rule requires all
product entities to be the of_product of at least one
product_definition_formation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_requires_product_definition_formation FOR
  (product, product_definition_formation);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT (SIZEOF (QUERY (pdf <* product_definition_formation |
       prod :=: pdf.of_product )) >= 1 ))) = 0;
END_RULE; -- product_requires_product_definition_formation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each product there shall be at least one instance of
product_definition_formation that contains the instance of product in its
set of of_product.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="profile_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The profile_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a profile boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE profile_boundary_definition_constraint FOR
  (property_definition);
END_RULE; -- profile_boundary_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets' shall be a property_definition of either a tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets' shall relate to exactly one property_definition that has a description of 'true profile' to specify its 'basic profile'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets' shall be a property_definition of a tolerance_zone_boundary and that tolerance_zone_boundary shall be specified as exactly one of the boundaries of a tolerance_zone_definition that specifies as its zone a tolerance_zone that has exactly one defining_tolerance that is either a linear_profile_tolerance or a surface_profile_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="profile_boundary_definition_with_offsets_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The profile_boundary_definition_with_offsets_constraint rule constrains the use of a property_definition when it is used as a profile boundary definition with offsets.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE profile_boundary_definition_with_offsets_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       ((pd\property_definition.description = 'boundary zone definition with specified size')
       AND (pd\property_definition.name = 'profile boundary with offsets'))
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN
       TYPEOF(pd.definition))
       )) = 0;
END_RULE; -- profile_boundary_definition_with_offsets_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall be a property_definition of a tolerance_zone_explicit_opposing_boundary_set.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset', and each of these shall have a representation that contains exactly one length_measure_with_unit that has a name of 'tolerance zone boundary member offset value' and the sum of these length_measure_with_unit shall equal the length_measure_with_unit that has a name of 'tolerance value' that is contained within the representation of the instance of property_definition that has a description of 'boundary zone definition with specified size' that has a name of 'opposing boundary set size'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset', and the name of one of those property_definition shall be 'away from material'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset', and the name of one of those property_definition shall be 'towards material'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="profile_related_positional_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The profile_related_positional_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a profile related positional boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE profile_related_positional_boundary_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition)) AND
       (pd.definition\shape_aspect.description = 'profile related positional boundary')
       ))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
(pdr.related_property_definition\property_definition.description = 'positional boundary offset')
       AND (pdr\property_definition_relationship.name = 'boundary offset'))) = 1))) = 0;
END_RULE; -- profile_related_positional_boundary_definition_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall be a property_definition of a positional_boundary that has a description of 'profile related positional boundary'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall relate to exactly one property_definition that has a description of 'positional boundary offset' to specify its 'boundary offset'.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall relate to exactly one property_definition that has a description of 'positional boundary offset' to specify its 'boundary offset' and that property_definition shall be applied to a shape_aspect_relationship that has a name of 'positional boundary and profile boundary member'. The relating_shape_aspect of that shape_aspect_relationship shall be the same instance of positional_boundary to which the instance of property_definition that has a description of 'profile related positional boundary property' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance and that physical_unit_geometric_tolerance shall be a position_tolerance that has a name of 'boundary based position'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="projected_tolerance_zone_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The projected_tolerance_zone_definition_constraint rule constrains the use of a projected_zone_definition when it is used as a projected tolerance zone definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE projected_tolerance_zone_definition_constraint FOR
  (projected_zone_definition);
END_RULE; -- projected_tolerance_zone_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each projected_zone_definition shall specify a tolerance_zone, as its zone, that specifies exactly one physical_unit_geometric_tolerance as its defining_tolerance, and that physical_unit_geometric_tolerance shall not be either a circular_runout_tolerance, a total_runout_tolerance, a linear_profile_tolerance, a surface_profile_tolerance; and shall not have a name of either 'boundary based position', 'circularity', 'cylindricity', 'flatness', or 'straightness'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each projected_zone_definition shall specify a tolerance_zone, as its zone, that 
specifies exactly one physical_unit_geometric_tolerance as its defining_tolerance, and 
that physical_unit_geometric_tolerance shall specify as its toleranced_shape_aspect a 
shape_aspect that is either a centre_of_symmetry that has a description of either 
'axis' or 'plane', or a composite_shape_aspect the 'composing' shape_aspects of which 
are all of type centre_of_symmetry and have the same description -- either 'axis' or 
'plane'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="projected_zone_and_base_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The projected_zone_and_base_relationship_constraint rule constrains the use of a projected_zone_definition when it is used as a projected zone and base relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE projected_zone_and_base_relationship_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end))
       OR (pzd.projection_end.product_definitional = TRUE)))) = 0;
END_RULE; -- projected_zone_and_base_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each projected_zone_definition shall have a projection_end that either is a part_template_definition or is on the boundary of the surface of the product.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="projected_zone_height_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The projected_zone_height_characteristic_constraint rule constrains the use of a projected_zone_definition when it is used as a projected zone height characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE projected_zone_height_characteristic_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length))
       )) = 0;
END_RULE; -- projected_zone_height_characteristic_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each projected_zone_definition shall have a projected_length that is a length_measure_with_unit.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="promissory_usage_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The promissory_usage_relationship_constraint rule constrains the related and
relating product_definition and the use of a promissory_usage_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE promissory_usage_relationship_constraint FOR 
( promissory_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT' IN TYPEOF (puo.relating_product_definition))
       AND (puo.relating_product_definition.frame_of_reference.name
       = 'physical design'))) = 0;
  WR2: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       SIZEOF(USEDIN(puo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 0)) = 0;
END_RULE; -- promissory_usage_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each promissory_usage_occurrence shall have a relating_product_definition 
that is a physical_unit that has a frame_of_reference name = 'physical design'.
</formal.propositions.rul>
<formal.propositions.rul>
Each promissory_usage_occurrence shall be an items in an 
applied_security_classification_assignment.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each promissory_usage_occurrence shall have a related_product_definition 
that is a (physical_unit) (externally_defined_physical_unit) 
(library_defined_physical_unit) that has a frame_of_reference name = 
('physical design') ('physical design usage').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="promissory_usage_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The promissory_usage_relationship_unique_constraint rule constrains promissory_usage_occurrence
population members, that fill the role of ARM promissory_usage_relationship, to have
unique ARM component attributes on each ARM assembly attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE promissory_usage_relationship_unique_constraint FOR
 ( promissory_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  puo_bag : BAG OF promissory_usage_occurrence;
  pass : BOOLEAN := TRUE;
  comp_bag : BAG OF physical_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(promissory_usage_occurrence) by 1;
  IF EXISTS( promissory_usage_occurrence[i].relating_product_definition ) 
                                                      THEN
    IF( (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_UNIT') IN
TYPEOF(promissory_usage_occurrence[i].relating_product_definition)) AND (
promissory_usage_occurrence[i].relating_product_definition.
frame_of_reference.name =
'physical design') ) THEN
      IF( NOT( promissory_usage_occurrence[i].
                                relating_product_definition IN pu_bag ) ) 
                                                                THEN
        pu_bag := pu_bag + promissory_usage_occurrence[i].
                                             relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  puo_bag := QUERY( puo <* promissory_usage_occurrence | 
      (puo.relating_product_definition :=: pu_bag[i]) );
  comp_bag := [];
  REPEAT j := 1 to SIZEOF(puo_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF ( ((
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_UNIT') IN
TYPEOF(puo_bag[j].related_product_definition)) AND (
puo_bag[j].related_product_definition.frame_of_reference.name IN [
'physical design',
'physical design usage']) ) THEN
      IF EXISTS( puo_bag[j].related_product_definition ) THEN
        IF ( puo_bag[j].related_product_definition IN comp_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          comp_bag := comp_bag + puo_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- promissory_usage_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of promissory_usage_occurrence that has a common relating_product_definition
must have a unique related_product_definition attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="radius_edge_feature_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The radius_edge_feature_shape_constraint rule constrains the items of a
shape_representation when it is a radius edge feature shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE radius_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum radius length')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum radius length')
       )) = 0))) = 0;
END_RULE; -- radius_edge_feature_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_representation whose name = 'radius edge feature shape' shall have 
one items that is a length_measure_with_unit.name = 'maximum radius length'.
</formal.propositions.rul>
<formal.propositions.rul>
Each shape_representation whose name = 'radius edge feature shape' shall have 
one items that is a length_measure_with_unit.name = 'minimum radius length'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="reference_composition_path_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The reference_composition_path_constraint rule constrains the related and
relating product_definition of a product_definition_relationship when it is
a reference composition path.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE reference_composition_path_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
           TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'reference definition path')
       AND (pdr.relating_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
  WR2: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
         TYPEOF(pdr.related_product_definition))
       AND (pdr.related_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
END_RULE; -- reference_composition_path_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_relationship.name = 'reference composition path' 
THEN SELF.relating_product_definition shall be a component_functional_unit 
whose {description = 'reference definition path'} 
{frame_of_reference.name = 'functional occurrence'}.
</formal.propositions.rul>
<formal.propositions.rul>
IF product_definition_relationship.name = 'reference composition path' 
THEN SELF.related_product_definition shall be a component_functional_unit 
whose frame_of_reference.name = 'functional occurrence'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="reference_functional_unit_assignment_to_part_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The reference_functional_unit_assignment_to_part_constraint rule constrains
the use of product_to_part_relationship when it is used as a reference 
functional unit assignment to part.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE reference_functional_unit_assignment_to_part_constraint FOR
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.related_product_definition))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLICATION_CONTEXT_ELEMENT' IN
       TYPEOF(pdr.related_product_definition.frame_of_reference))
       AND ((pdr.relating_product_definition.frame_of_reference.name
              = 'physical design')
       OR (pdr.relating_product_definition.frame_of_reference.name
              = 'physical design usage'))))) = 0; 
  WR2: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'design definition path')
       AND (pdr.relating_product_definition.id = 
         'reference composition path')
       ))) = 0; 
END_RULE; -- reference_functional_unit_assignment_to_part_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
If a product_to_part_relationship has a name of 
'reference functional unit assignment to part' then the 
related_product_definition shall be a product_definition with a 
frame_of_reference that is an application_context_element with a name 
of 'physical design', or 'physical design usage'.
</formal.propositions.rul>
<formal.propositions.rul>
If a product_to_part_relationship has a name of 
'reference functional unit assignment to part' then the 
relating_product_definition shall be a product_definition with a 
description of 'design definition path' and an id of 
'reference composition path'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="reference_functional_unit_assignment_to_part_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The reference_functional_unit_assignment_to_part_unique_constraint rule constrains shape_aspect_relationship
population members, that fill the role of ARM reference_functional_unit_assignment_to_part, to have
unique implementations on each path_alias.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE reference_functional_unit_assignment_to_part_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name =
'reference functional unit assignment to part' ) );
  d_bag : BAG OF STRING := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i]\shape_aspect_relationship.description ) THEN
    IF( NOT( sar[i]\shape_aspect_relationship.description IN d_bag ) ) THEN
      d_bag := d_bag + sar[i]\shape_aspect_relationship.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(d_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.description = d_bag[i]) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect.of_shape.definition ) THEN
      IF ( sar_bag[j].related_shape_aspect.of_shape.definition IN pd_bag )
                                                                    THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + 
                    sar_bag[j].related_shape_aspect.of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- reference_functional_unit_assignment_to_part_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'reference
functional unit assignment to part' that has a common description must have
unique related_shape_aspect.of_shape.definition attribute values.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="registered_font_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The registered_font_constraint rule constrains the usage of an
externally_defined_text_font.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE registered_font_constraint FOR ( externally_defined_text_font );
WHERE
  WR1: SIZEOF(QUERY(edtf <* externally_defined_text_font |
       (SIZEOF(QUERY(adr <* USEDIN(edtf,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adr.assigned_document.kind\document_type.product_data_type = 
                     'font registration document')
       )) = 0))) = 0;
END_RULE; -- registered_font_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each externally_defined_text_font shall be an items of an 
applied_document_reference whose assigned_document.kind.product_data_type = 
'font registration document'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="registered_font_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The registered_font_unique_constraint rule constrains the externally_defined_text_font
population members, that fill the role of ARM registered_font, to have unique
registration_documents on each font_code.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE registered_font_unique_constraint FOR
 ( externally_defined_text_font );
LOCAL
  ii_bag : BAG OF STRING := [];
  edtf_bag : BAG OF externally_defined_text_font;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(externally_defined_text_font) by 1;
  IF EXISTS( externally_defined_text_font[i].item_id ) THEN
    IF ( NOT ( externally_defined_text_font[i].item_id IN ii_bag ) ) THEN
      ii_bag := ii_bag + externally_defined_text_font[i].item_id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ii_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  edtf_bag := QUERY( edtf <* externally_defined_text_font | 
            (edtf.item_id = ii_bag[i]) );
  REPEAT j := 1 to SIZEOF(edtf_bag) by 1;
    adr_bag := QUERY( adr <* USEDIN( edtf_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) | 
         (adr.assigned_document.kind\document_type.product_data_type =
'font registration document') );
    es_bag := [];
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- registered_font_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of externally_defined_text_font that has a common item_id must
have unique ee_specifications that are referenced by an applied_document_reference
that has said externally_defined_text_fonts in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="requirement_composition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The requirement_composition_constraint rule constrains the related and
relating property_definition of a property_definition_relationship when it is
a requirement property composition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE requirement_composition_constraint FOR 
( property_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* property_definition_relationship |
       (pdr\property_definition_relationship.name = 'requirements property composition')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))
       )) = 0;
  WR2: SIZEOF(QUERY(pdr <* property_definition_relationship |
       (pdr\property_definition_relationship.name = 'requirements property composition')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REQUIREMENTS_PROPERTY_GROUP' IN 
           TYPEOF(pdr.relating_property_definition))
       )) = 0;
END_RULE; -- requirement_composition_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF property_definition_relationship name = 'requirements property composition' 
THEN the related_property_definition shall be a requirements_property.
</formal.propositions.rul>
<formal.propositions.rul>
IF property_definition_relationship name = 'requirements property composition' 
THEN the relating_property_definition shall be a requirements_property_group.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="requirements_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The requirements_property_constraint rule constrains the requirements_property population members to satisfy the requirements of the ARM object Ee_requirement_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE requirements_property_constraint FOR 
           (product_definition,
            descriptive_representation_item,
            requirements_property);
LOCAL
ri : BAG OF descriptive_representation_item := 
         QUERY (dri <* descriptive_representation_item 
                              | dri\representation_item.name = 
                                          'requirements name');
pd : BAG OF product_definition:=
         QUERY(tpd <* product_definition
               | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                  'APPLICATION_CONTEXT_ELEMENT' IN
                  TYPEOF(tpd.frame_of_reference)) AND
                  (tpd.frame_of_reference.name IN ['requirement',
                                                   'design requirement',
                                                   'assembly requirement'])
                  AND
                  (tpd.name = 'requirements model'));

r : BAG OF representation := [];
pdr : BAG OF property_definition_representation := [];
pass1 : BOOLEAN := TRUE;

rp : BAG OF property_definition := [];
pass2 : BOOLEAN := TRUE;

END_LOCAL;
  (* WR1 Test *)
  REPEAT i := 1 to SIZEOF (ri) by 1;
     r := [];
     pdr := [];
     r := (USEDIN(ri[i],
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REPRESENTATION.ITEMS'));
     pass1 := (SIZEOF(r) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pdr := (USEDIN(r[1],
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
     pass1 := (SIZEOF(pdr) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pass1 := ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr[1].definition));
     IF (NOT pass1) THEN ESCAPE; END_IF;
  END_REPEAT;
  (* WR2 Test *)
  REPEAT i := 1 to SIZEOF (pd) by 1;
     rp := [];
     IF (NOT pass2) THEN ESCAPE; END_IF;
     rp := QUERY(rp <* USEDIN(pd[i],
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION.DEFINITION') |
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
     pass2 := (SIZEOF(rp) = 1);
  END_REPEAT;
WHERE
 WR1: pass1;
 WR2: pass2;
END_RULE; -- requirements_property_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">

<Formal.propositions.rul>
Each descriptive_representation_item with a name of 'requirements name' shall be referenced exactly once by a property_definition_representation that shall reference a property_definition that is a requirements_property.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each product_definition with a name of 'requirements model' and a frame_of_reference which is an application_constraint_element with a name of 'requirement' or 'design requirement' or 'assembly requirement' shall be the definition of exactly one requirements_property.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="requirements_property_unique_constraint">
<RULE.DESCRIPTION>
The requirements_property_unique_constraint rule constrains the requirements_property population members to satisfy the uniqueness requirements of the ARM object Ee_requirement_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE requirements_property_unique_constraint FOR 
           (descriptive_representation_item,
            requirements_property);
LOCAL
desc_bag : BAG OF STRING := [];
pass1 : BOOLEAN := TRUE;
pdr : BAG OF property_definition_representation := [];
rep : BAG OF representation := [];
pd : BAG OF product_definition := [];

END_LOCAL;
  REPEAT i := 1 to SIZEOF (requirements_property) by 1;
     IF (NOT pass1) THEN ESCAPE; END_IF;
     IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PRODUCT_DEFINITION' IN TYPEOF(requirements_property[i].definition))
      THEN pd := pd + requirements_property[i].definition;
     END_IF;
  END_REPEAT;
  IF (instance_unique(pd) = FALSE ) THEN pass1 := FALSE; END_IF;
WHERE
 WR1: pass1;
END_RULE; -- requirements_property_unique_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each descriptive_representation_item with a name of 'requirements name' shall have a unique associated definition.
</Formal.propositions.rul>
</Formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="restraint_condition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restraint_condition_constraint rule constrains the use of a property_definition when it is used as a restraint condition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restraint_condition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       ((pd\property_definition.description = 'restraint') 
       OR (pd\property_definition.description = 'tolerance specific restraint'))
       AND (SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
    + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
    + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'restraint description'))) = 0))) = 0;
END_RULE; -- restraint_condition_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of either 'restraint' or 'tolerance specific restraint' shall relate to exactly one requirements_property to specify its 'restraint description'.
</formal.propositions.rul>

</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'restraint' or 'tolerance specific restraint' shall be a property_definition of either a shape_aspect_relationship with a name of 'datum feature usage in common datum' or 'datum feature usage in single datum', or a shape_aspect that is either on the boundary of the shape of the product or is a part_template_definition.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_action_request_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_action_request_status rule restricts the status value of all
action_request_status entities to be either:
<list>
<list.item>'proposed'</list.item>
<list.item>'in_work'</list.item>
<list.item>'issued'</list.item>
<list.item>'hold'</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_action_request_status FOR (action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ars <* action_request_status |
       NOT (ars\action_request_status.status IN
       ['proposed', 'in work', 'issued', 'hold']))) = 0;
END_RULE; -- restrict_action_request_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of the action_request_status entity, the status
attribute shall have a value of "proposed", "in work", "issued", or "hold".
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_approval_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_approval_status rule restricts the name value of all
approval_status entities to be either:
<list>
<list.item>'approved'</list.item>
<list.item>'not yet approved'</list.item>
<list.item>'disapproved'</list.item>
<list.item>'withdrawn'</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_approval_status FOR (approval_status);
WHERE
  WR1: SIZEOF (QUERY (ast <* approval_status |
       NOT (ast\approval_status.name IN
       ['approved', 'not yet approved', 'disapproved', 'withdrawn']))) = 0;
END_RULE; -- restrict_approval_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, the value of the name attribute shall 
be either "approved", "not yet approved", "disapproved" or "withdrawn".
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_date_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_date_role rule restricts the name value of all date_role entities
to be either:
<list>
<list.item>'creation date'</list.item>
<list.item>'request date'</list.item>
<list.item>'release date'</list.item>
<list.item>'start date'</list.item>
<list.item>'contract date'</list.item>
<list.item>'certification date'</list.item>
<list.item>'sign off date'</list.item>
<list.item>'classification date'</list.item>
<list.item>'declassification date'</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (dr\date_role.name IN ['creation date', 'request date', 'release date',
       'start date', 'contract date', 'certification date', 'sign off date',
       'classification date', 'declassification date']))) = 0;
END_RULE; -- restrict_date_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of date_role, the name attribute shall have the value of
"creation date", "request date", "release date", "start date", "contract date",
"certification date", "sign off date", "classification date", or
"declassification date".
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_manifold_surface_shape_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_manifold_surface_shape_representation rule 
requires each manifold_surface_shape_representation
to contain exactly one shell_based_surface_model that 
has exactly one shell that is an open_shell when the 
manifold_surface_shape_representation is implementing 
the arm concepts of 
<internal.ref linkend="Stratum_feature_non_planar_2d_shape">,
Design_intent_modification_non_planar_2d_shape,
and
<internal.ref linkend="Part_template_non_planar_2d_shape">,
and a non planar shape representation of the arm concept of
<internal.ref linkend="Stratum_feature_template_component">.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_manifold_surface_shape_representation FOR
  (manifold_surface_shape_representation);
  WHERE
    WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
         (mssr\representation.name IN ['stratum feature non planar 2d shape',
         'open shell based surface',
         'design intent modification non planar 2d shape', 
         'part template non planar 2d shape']) AND
         (NOT(SIZEOF(QUERY(sbsm <* mssr.items | 
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'SHELL_BASED_SURFACE_MODEL' IN TYPEOF(sbsm)) AND
         (SIZEOF(QUERY(os <* sbsm\shell_based_surface_model.sbsm_boundary |
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'OPEN_SHELL' IN TYPEOF(os))) = 1)
         )) = 1)))) = 0;
END_RULE; -- restrict_manifold_surface_shape_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each manifold_surface_shape_representation that has a name of
'stratum feature non planar 2d shape'
'open shell based surface',
'design intent modification non planar 2d shape', or
'part template non planar 2d shape'
shall have exactly one shell that is an open_shell that is in the role of sbsm_boundary for the
shell_based_surface_model that is in the items for the manifold_surface_shape_representation.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="rule_action_unique_constraint">
<RULE.DESCRIPTION>
The rule_action_unique_constraint rule constrains the rule_action population members, that
fill the role of ARM rule_action, to have unique product_definition_formation with a description of 'rule version' on each applied_date_and_time_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE rule_action_unique_constraint FOR
 ( rule_action );
LOCAL
  adta : BAG OF applied_date_and_time_assignment;
  adta_bag : BAG OF applied_date_and_time_assignment := [];
  ra_bag : BAG OF rule_action;
  aaa_bag : BAG OF applied_action_assignment;
  pass : BOOLEAN := TRUE;
  rd_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_action) by 1;
  adta := USEDIN( rule_action[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' );
  REPEAT j := 1 to SIZEOF(adta) by 1;
    IF EXISTS( adta[j] ) THEN
      IF( NOT( adta[j] IN adta_bag ) ) THEN
        adta_bag := adta_bag + adta[j];
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(adta_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ra_bag := QUERY( r <* rule_action | (r IN adta_bag[i].items) );
  rd_bag := [];
  REPEAT j := 1 to SIZEOF(ra_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aaa_bag := QUERY( aa <* USEDIN( ra_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ACTION_ASSIGNMENT.ASSIGNED_ACTION' ) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_ACTION_ASSIGNMENT') IN TYPEOF(aa) ) );
    REPEAT k := 1 to SIZEOF(aaa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(aaa_bag[k].items) by 1;
        IF EXISTS( aaa_bag[k].items[l] ) THEN
          IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_FORMATION'  IN TYPEOF(aaa_bag[k].items[l])) AND
(aaa_bag[k].items[l]\product_definition_formation.description = 'rule version') ) THEN
            IF ( aaa_bag[k].items[l] IN rd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              rd_bag := rd_bag + aaa_bag[k].items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- rule_action_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of rule_action that is referenced in the set of items of a common
applied_date_and_time_assignment must not be referenced by more than one
applied_action_assignment that references the same product_definition_formation with a description of 
'rule version' in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="rule_supersedence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The rule_supersedence_constraint rule requires that an action_relationship
relate the from and to rule replacements.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE rule_supersedence_constraint FOR ( action );
END_RULE; -- rule_supersedence_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each action that has a name = 'rule replacement from' shall be the
related_action of an action_relationship that [has a relating_action
with the name of 'rule replacement to'] [has a name of 'rule supersedence'].
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="runout_tolerance_zone_definition_with_specified_angle_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The runout_tolerance_zone_definition_with_specified_angle_constraint rule constrains the use of a runout_zone_definition when it is used as a runout tolerance zone definition with specified angle.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE runout_tolerance_zone_definition_with_specified_angle_constraint FOR
  (runout_zone_definition);
END_RULE; -- runout_tolerance_zone_definition_with_specified_angle_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each runout_zone_definition shall specify the same instance of tolerance_zone as its zone that is specified as the relating_shape_aspect by the shape_aspect_relationship that is the orientation_defining_relationship of the runout_zone_orientation_reference_direction that is specified as the orientation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_definition shall specify a tolerance_zone, as its zone, that specifies either exactly one circular_runout_tolerance or exactly one total_runout_tolerance as its defining_tolerance.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_definition shall specify a runout_zone_orientation_reference_direction, as its orientation, that specifies a shape_aspect_relationship, as its orientation_defining_relationship, that specifies a derived_shape_aspect with a description of 'directed axis', as its related_shape_aspect, and that derived_shape_aspect shall relate to a centre_of_symmetry with a description of 'axis' to specify its 'derived axis' and that centre_of_symmetry shall be a physical_unit_datum that is related, as the 'datum usage in datum system', to the datum_system that has a property_definition with a description of 'datum system property without material conditions' that is related, as the 'referenced datum system definition', to the physical_unit_geometric_tolerance that is specified as the defining_tolerance by the tolerance_zone that is specified as the zone.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="runout_tolerance_zone_orienting_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The runout_tolerance_zone_orienting_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a runout tolerance zone orienting relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE runout_tolerance_zone_orienting_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- runout_tolerance_zone_orienting_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'runout tolerance zone orienting' shall have a related_shape_aspect that is a derived_shape_aspect with a description of 'directed axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'runout tolerance zone orienting' shall have a relating_shape_aspect that is a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'runout tolerance zone orienting' shall be the  orientation_defining_relationship of exactly one runout_zone_orientation_reference_direction.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="runout_zone_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The runout_zone_orientation_constraint rule constrains the use of a runout_zone_orientation_reference_direction when it is used as a runout zone orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE runout_zone_orientation_constraint FOR
  (runout_zone_orientation_reference_direction);
END_RULE; -- runout_zone_orientation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each runout_zone_orientation_reference_direction shall have an orientation_defining_relationship that is a shape_aspect_relationship with a name of 'runout tolerance zone orienting'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_orientation_reference_direction shall specify a plane_angle_measure_with_unit as its angle.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_orientation_reference_direction shall be specified as the orientation of exactly one runout_zone_definition.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="security_classification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The security_classification_constraint rule constrains the usage of a
security_classification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE security_classification_constraint FOR (security_classification,
     applied_date_and_time_assignment, applied_date_assignment,
     applied_person_and_organization_assignment, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (sc IN adata.items) AND
       ('classification date' = adata.role\date_time_role.name))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (sc IN ada.items) AND
       ('classification date' = ada.role\date_role.name))) = 1 )))) = 0;
  WR2: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (apa <* applied_person_and_organization_assignment |
       (sc IN apa.items) AND
       (apa.role\person_and_organization_role.name = 'classification officer')
       )) = 0)) = 0;
  WR3: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (aaa <* applied_approval_assignment |
       (sc IN aaa.items))) = 0)) = 0;
END_RULE; -- security_classification_constraint
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each security_classification shall be an items of 
either an applied_date_assignment whose role name = 'classification date' or 
an applied_date_and_time_assignment whose role name = 'classification date'.
</FORMAL.PROPOSITIONS.RUL>

<formal.propositions.rul>
Each security_classification shall be an items of an applied_person_and_organization_assignment 
whose role name = 'classification officer'.
</formal.propositions.rul>
<formal.propositions.rul>
Each security_classification shall be an items of an 
applied_approval_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="shape_dimension_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_dimension_representation_constraint rule constrains the use of a shape_dimension_representation when it is used as a shape dimension representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_dimension_representation_constraint FOR
  (shape_dimension_representation);
WHERE
    wr1: SIZEOF (QUERY (sdr <* shape_dimension_representation | 
          NOT (SIZEOF (QUERY (i <* sdr.items |
            (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
            + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
             (SIZEOF (QUERY (mq <* USEDIN (i,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE') |
              mq\measure_qualification.name = 'dimension value qualifier')) <= 1))
            )) >= 1
         ))) = 0;
    wr2: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | (mq\measure_qualification.name = 'dimension value qualifier')
            AND             
              (SIZEOF (QUERY (q <* mq.qualifiers |
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                 + 'TYPE_QUALIFIER' IN TYPEOF (q))
               ) <> 1)
             )) > 0)
           )) > 0
         )) = 0;
    wr3: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | (mq\measure_qualification.name = 'dimension value qualifier')
            AND             
              (SIZEOF (QUERY (q <* mq.qualifiers |
                ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                 + 'TYPE_QUALIFIER' IN TYPEOF (q))
            AND
              (NOT (q\type_qualifier.name IN ['theoretically exact',
                               'maximum dimension',
                               'minumum dimersion',
                               'lower value',
                               'upper value',
                               'basic value']))
               )) > 0)
             )) > 0)
           )) > 0
         )) = 0;
    wr4: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | NOT (mq\measure_qualification.name IN ['dimension value qualifier',
                                   'predefined dimension qualifier',
                                   'user defined dimension qualifier'])
                )) > 0)
              )) > 0
            )) = 0;
     wr5: SIZEOF (QUERY (sdr <* shape_dimension_representation | NOT (
            SIZEOF (USEDIN (sdr, 
                   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                             + 'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.'
                                 + 'REPRESENTATION')) >= 1
           ))) = 0;
         

END_RULE; -- shape_dimension_representation_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each shape_dimension_representation shall contain measure_with_unit that shall be a qualified_measure of at most one measure_qualification that has the name of 'dimension value qualifier'.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation that contain measure_with_unit that are the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' shall have exactly one qualifier for the measure_qualification that is a type_qualifier.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation that contain measure_with_unit that are the qualified_measure of a measure_qualification that have the name of 'dimension value qualifier' shall have exactly zero qualifiers for the measure_qualification that are type_qualifier the name of which is not among 'theoretically exact', 'maximum dimension', 'minimum dimension', 'lower value', 'upper value', or 'basic value'.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation that contain measure_with_unit shall be the qualified_measure of exactly zero measure_qualification that have a name that is not among 'dimension value qualifier', 'predefined dimension qualifier', or 'user defined dimension qualifier'.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation shall be the representation of at least one dimensional_size or dimensional_location.
</Formal.propositions.rul>

</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_boundary_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_boundary_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element boundary relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE shape_element_boundary_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- shape_element_boundary_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'boundary' shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are on the boundary of themselves either directly or through intermediate shape_aspect_relationship with a name of 'boundary'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_composing_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_composing_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element composing relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_composing_relationship_constraint FOR
  (shape_aspect_relationship);
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'composing') AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       )) = 0;
END_RULE; -- shape_element_composing_relationship_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each shape_aspect_relationship with a name of 'composing' shall have a relating_shape_aspect that is a composite_shape_aspect.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_constituent_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_constituent_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element constituent relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE shape_element_constituent_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- shape_element_constituent_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'constituent' or 'composing' or 
'interconnect module terminal surface constituent relationship' or
'bare die terminal surface constituent relationship' or
'package terminal surface constituent relationship'
shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are constituents of themselves either directly or through intermediate shape_aspect_relationship with a name of either 'constituent' or 'composing'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'interconnect module terminal surface constituent relationship' shall specify a shape_aspect with a description of 
`interconnect module cavity surface' or
`interconnect module cutout surface' or
`interconnect module edge surface' or
`interconnect module edge segment surface' or
`interconnect module primary surface' or
`interconnect module secondary surface' or
`interconnect module surface feature' as the relating_shape_aspect and an interconnect_module_terminal as the related_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'bare die terminal surface constituent relationship' shall specify a bare_die_surface or bare_die_edge_segment_surface as the relating_shape_aspect and a bare_die_terminal as the related_shape_aspect.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'package terminal surface constituent relationship' shall specify a package_body_surface or package_body_edge_segment_surface as the relating_shape_aspect and a package_terminal as the related_shape_aspect.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_constituent_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_constituent_relationship_unique_constraint rule constrains shape_aspect_relationship 
population members, that fill the role of ARM shape_element_constituent_relationship, to have
unique related_shape_elements on each relating_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_constituent_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name IN [
'constituent', 'composing', 
'bare die terminal surface constituent relationship',
'interconnect module terminal surface constituent relationship',
'package terminal surface constituent relationship'] ) );
  sa_bag : BAG OF shape_aspect := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i].relating_shape_aspect ) THEN
    IF( NOT( sar[i].relating_shape_aspect IN sa_bag ) ) THEN
      sa_bag := sa_bag + sar[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- shape_element_constituent_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of either 'constituent'
or 'composing' or 'interconnect module terminal surface constituent relationship'
or 'bare die terminal surface constituent relationship'
or 'package terminal surface constituent relationship'
that has a common relating_shape_aspect shall have a unique
related_shape_aspect attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_deriving_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_deriving_relationship_constraint rule constrains the use of a shape_aspect_deriving_relationship when it is used as a shape element deriving relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE shape_element_deriving_relationship_constraint FOR
  (shape_aspect_deriving_relationship);
END_RULE; -- shape_element_deriving_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_deriving_relationship shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_deriving_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_deriving_relationship_unique_constraint rule constrains shape_aspect_deriving_relationship
population members, that fill the role of ARM shape_element_deriving_relationship, to have
unique related_shape_elements on each relating_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_deriving_relationship_unique_constraint FOR
 ( shape_aspect_deriving_relationship );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  sadr_bag : BAG OF shape_aspect_deriving_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect_deriving_relationship) by 1;
  IF EXISTS( shape_aspect_deriving_relationship[i].relating_shape_aspect )
                                                    THEN
    IF( NOT( shape_aspect_deriving_relationship[i].
                           relating_shape_aspect IN sa_bag ) ) 
                                                  THEN
      sa_bag := sa_bag + 
            shape_aspect_deriving_relationship[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sadr_bag := QUERY( r <* shape_aspect_deriving_relationship | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sadr_bag) by 1;
    IF EXISTS( sadr_bag[j].related_shape_aspect ) THEN
      IF ( sadr_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sadr_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- shape_element_deriving_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_deriving_relationship that has a common relating_shape_aspect
must have a unique related_shape_aspect attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_locating_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_locating_relationship_constraint rule constrains the use of a dimensional_location when it is used as a shape element locating relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE shape_element_locating_relationship_constraint FOR
  (dimensional_location);
END_RULE; -- shape_element_locating_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location shall not specify the same shape_aspect as both the related_shape_aspect and the relating_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_locating_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_locating_relationship_unique_constraint rule constrains dimensional_location
population members, that fill the role of ARM shape_element_locating_relationship, to have
unique located_shape_elements on each locating_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_locating_relationship_unique_constraint FOR
 ( dimensional_location );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  dl_bag : BAG OF dimensional_location;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location) by 1;
  IF EXISTS( dimensional_location[i].relating_shape_aspect ) THEN
    IF( NOT( dimensional_location[i].relating_shape_aspect IN sa_bag ) )
                                                              THEN
      sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  dl_bag := QUERY( r <* dimensional_location | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(dl_bag) by 1;
    IF EXISTS( dl_bag[j].related_shape_aspect ) THEN
      IF ( dl_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- shape_element_locating_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of dimensional_location that has a common relating_shape_aspect
must have a unique related_shape_aspect attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE shape_element_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- shape_element_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship shall have at most one property_definition that has a description of 'shape element relationship characterization' and that property_definition shall have at most one representation with a name of 'shape element relationship description' and that representation shall contain exactly one descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship shall have at most one property_definition that has a description of 'shape element relationship characterization' and that property_definition shall have at most one representation with a name of 'shape element relationship name' and that representation shall contain exactly one descriptive_representation_item.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_unique_constraint rule constrains the representation population members to satisfy the uniqueness requirements of the ARM object Shape_element when the representation is used to identify the Shape_element.
<note>
This constraint only applies when shape_aspect is used as an implementation of the ARM concept of Datum and its subtypes or when the shape_aspect is used as an implementation of the ARM concept of Join_relationship or its subtypes.  All other shape_aspect implementations of ARM concepts are population constrained using the name attribute of shape_aspect as a control.  The population constraints may be applied using other RULES in this part of ISO 10303 or may be applied in entity subtypes in this part of ISO 10303.
</note>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_unique_constraint FOR 
           (representation,representation_item,
              property_definition_representation);
LOCAL
r : BAG OF representation := 
         QUERY (r <* representation | r\representation.name = 
                                          'shape element name');
ri : BAG OF representation_item := [];
pass : BOOLEAN := TRUE;
description_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
      pass := SIZEOF(QUERY(pdr <* 
  	     (USEDIN(r[i],
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))| 
   (pdr.definition\property_definition.description = 'shape element characterization'))) = 1;
      IF (NOT pass) THEN ESCAPE; END_IF;
      ri := QUERY ( ri <* representation_item | ri IN r[i].items);
      pass := (SIZEOF(ri) = 1);
      IF (NOT pass) THEN ESCAPE; END_IF;
      IF (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                     'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (ri)))
        THEN
         pass := FALSE;
         ESCAPE;
      END_IF;
      REPEAT j := 1 to SIZEOF (ri) by 1;
        IF EXISTS( ri[j]\descriptive_representation_item.description ) THEN
          IF (ri[j]\descriptive_representation_item.description IN 
                                               description_bag) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            description_bag := description_bag + 
                 ri[j]\descriptive_representation_item.description;
          END_IF;
        END_IF;
      END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE; -- shape_element_unique_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each representation with a name of 'shape element name' shall be referenced no more than 
once by a property_definition_representation that shall reference a property_definition
with a name of 'shape element characterization' and each descriptive_representation_item 
description shall be used as a name by no more than one representation with a name of 
'shape element name', and each representation with a name of 'shape element name' shall 
have only one representation_item which shall be a descriptive_representation_item.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_representation_requires_origin">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_representation_requires_origin rule assures that each instance of shape_representation has exactly one associated axis2_placement_2d or axis2_placement_3d with a name of 'origin' or 'orientation' or assures that the representation contains at least one styled_item or assures that the representation that has a name of 'zone shape' does not include an origin or orientation. 
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_representation_requires_origin FOR (shape_representation);
WHERE
  WR1: 
(* 
pseudocode
co:FOREACH (sr <* shape_representation |c1);
c1:EXACTLYONE(it <* sr\representation.items |c2) 
   or ATLEASTONE(it <* sr\representation.items |c3)
   or EXACTLYNONE(it <* sr\representation.items |c4);
c2:((it.name = 'origin') or (it.name = 'orientation')) and 
   (AXIS2_PLACEMENT_2D in TYPEOF(it)  OR
    AXIS2_PLACEMENT_3D in TYPEOF(it));
c3:STYLED_ITEM in TYPEOF(it);
c4:((it.name = 'origin') or (it.name = 'orientation')) and
   ((sr.name = 'zone shape') or 
   (sr.context_of_items.context_type = 'connection zone colour'));
*)
SIZEOF(QUERY ( sr <* shape_representation |  NOT(
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and 
   (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it))  OR
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it)))
))) = 1
) 
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'STYLED_ITEM' in TYPEOF(it))
))) >= 1
)
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and
   ((sr\representation.name = 'zone shape') or 
   (sr.context_of_items\representation_context.context_type = 'connection zone colour'))
))) = 0
)
))) = 0;
END_RULE; -- shape_representation_requires_origin
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of shape_representation, there shall be exactly one instance of placement in the role of items that contains the attribute value 'origin' for the name of that axis_placement or there shall be at least one instance of placement in the role of items that contains the attribute value 'orientation' for the name of that axis_placement or ther shall be at least one instance of styled_item in the role of items.  The instance of placement shall be either an axis2_placement_2d or an axis2_placement_3d.  There shall be no instance of placement with name of origin or orientation in a shape_representation with a name of 'zone shape' or with a context type of 'connection zone colour'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="shield_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shield_allocation_constraint rule constrains the related and relating
product_definition of a product_definition_relationship when it is a
shield allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE shield_allocation_constraint FOR ( product_definition_relationship );
END_RULE; -- shield_allocation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship whose 
{name = 'assembly requirements allocation'} 
{description = 'shield allocation'} shall have a related_product_definition that
{is a shield} {is the related_product_definition of a 
product_definition_relationship whose name = 'shield group member'} 
{has a frame_of_reference that is a product_definition_context whose name = 
'physical occurrence'}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship whose 
{name = 'assembly requirements allocation'} 
{description = 'shield allocation'} shall have a relating_product_definition that
{is the relating_product_definition of a product_definition_relationship whose 
 name = 'shield group member'} 
{is the definition of a requirement_property whose name = 
 'electromagnetic requirement'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="signal_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The signal_property_constraint rule constrains the definition and usage of
a property_definition when it is a signal property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE signal_property_constraint FOR ( property_definition );
END_RULE; -- signal_property_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF a property_definition.name = 'signal property' THEN SELF.definition shall 
be a signal.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF a property_definition.name = 'signal property' THEN (SELF.definition shall 
be a signal which is an items of an applied_classification_assignment whose 
assigned_group is a signal_category.description = 'signal property category') 
(SELF shall be an items of an applied_document_reference whose 
assigned_document is the source of a document_usage_constraint whose 
subject_element = 'signal property category').
</Informal.propositions.rul>
<Informal.propositions.rul>
IF a property_definition.name = 'signal property' THEN SELF shall be the 
definition of exactly one property_definition_representation.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="signal_specification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The signal_specification_constraint rule constrains the items and usage of a
representation when it is a signal specification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE signal_specification_constraint FOR ( representation );
END_RULE; -- signal_specification_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall be the used_representation of a 
property_definition_representation whose definition.definition is a functional_unit.frame_of_reference.name = 
'functional network design'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification'
shall be the used_representation of a 
property_definition_representation whose whose definition.definition is a 
component_functional_unit.frame_of_reference.name = 'functional occurrence'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall have exactly one items.name = 'maximum characteristic'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall have exactly one items.name = 
'measurement access mechanism'
and whose definition.definition is a 
component_functional_terminal.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall have exactly one items.name = 
'reference access mechanism'
and whose definition.definition is a 
component_functional_terminal.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall be an items of an 
applied_document_reference whose assigned_document is an ee_specification 
whose kind.product_data_type = 'test specification'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification'
shall have exactly one items.name equal to  
'minimum characteristic' and shall be the used_representation of a 
property_definition_representation whose definition.name = 'signal property'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="singular_dimension_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The singular_dimension_representation_constraint rule constrains the use of a shape_dimension_representation when it is used as a singular dimension representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE singular_dimension_representation_constraint FOR
  (shape_dimension_representation);
END_RULE; -- singular_dimension_representation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'theoretically exact', 'maximum dimension', or 'minimum dimension' shall contain exactly one measure_with_unit.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="step_edge_feature_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The step_edge_feature_shape_constraint rule constrains the items of a
shape_representation when it is a step edge feature shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE step_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step depth')
       )) = 1))) = 0; 
 WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step width')
       )) = 1))) = 0; 
 WR3: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step depth')
       )) = 1))) = 0; 
 WR4: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step width')
       )) = 1))) = 0; 
END_RULE; -- step_edge_feature_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'maximum step depth'.
</formal.propositions.rul>
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'maximum step width'.
</formal.propositions.rul>
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'minimum step depth'.
</formal.propositions.rul>
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'minimum step width'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_3d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_3d_shape_constraint rule constrains the usage of a
shape_representation when it is a stratum_3d_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE stratum_3d_shape_constraint FOR ( shape_representation );
END_RULE; -- stratum_3d_shape_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation {whose name = '3d bound volume shape'} 
{whose context_of_items is a 
geometric_representation_context.coordinate_space_dimension = 3} 
{is the used_representation of a property_definition_representation whose 
definition.definition is a stratum} shall be the used_representation of
exactly one property_definition_shape whose definition is a stratum.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_average_surface_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_average_surface_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a stratum average surface shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_average_surface_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum average surface shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'STRATUM_SURFACE' IN TYPEOF(pdr.definition.definition))
       AND (pdr.definition.definition\shape_aspect.description = 
                                            'average surface'))) = 1
       ))) = 0;

END_RULE; -- stratum_average_surface_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'stratum average surface shape' shall be
the used_representation for exactly one property_definition_representation
that shall also have a definition that is a property_definition that shall also have a definition that is a stratum_surface with a 
description of 'average surface'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_concept_to_physical_usage_view_assignment_constraint">
<RULE.DESCRIPTION>
The stratum_concept_to_physical_usage_view_assignment_constraint rule
constrains the related_shape_aspect of a shape_aspect_relationship of a
shape_aspect_relationship when it is a 
stratum_concept_to_physical_usage_view_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE stratum_concept_to_physical_usage_view_assignment_constraint FOR
( shape_aspect_relationship );
END_RULE; -- stratum_concept_to_physical_usage_view_assignment_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship whose name = 'stratum concept to physical usage view assignment' shall have a 
related_shape_aspect (which is a stratum_feature) (which is an 
inter_stratum_feature) (which is a component_shape_aspect whose description = 
'laminate component') (whose of_shape.definition {is a component_definition} 
{has a frame_of_reference.name = 'physical occurrence'} 
{has a name = 'laminate component'}).
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_in_stratum_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_in_stratum_3d_position_constraint rule constrains the
mapping_source, mapping_target, and usage of a mapped_item when it is a
stratum_feature_in_stratum_3d_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE stratum_feature_in_stratum_3d_position_constraint FOR ( mapped_item );
END_RULE; -- stratum_feature_in_stratum_3d_position_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and
has a mapping_target that is a axis2_placement_3d shall 
have a mapping_source.mapped_representation that is the used_representation 
of a property_definition_representation.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and 
has a mapping_target that is a axis2_placement_3d shall 
be an items of a shape_representation {whose name = '3d bound volume shape'} 
{is the used_representation of a 
property_definition_representation whose {definition is a 
product_definition_shape} 
{definition.definition is a stratum} }.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_in_stratum_planar_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_in_stratum_planar_position_constraint rule constrains the
mapping_source, mapping_target, and usage of a mapped_item when it is a
stratum_feature_in_stratum_planar_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE stratum_feature_in_stratum_planar_position_constraint FOR 
            ( mapped_item );
END_RULE; -- stratum_feature_in_stratum_planar_position_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and 
has a mapping_target that is an axis2_placement_2d shall
have a mapping_source.mapped_representation that is the used_representation 
of a property_definition_representation.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and 
has a mapping_target that is an axis2_placement_2d shall
be an items of a shape_representation {whose name = 'planar projected shape'} 
{is the used_representation of a property_definition_representation whose 
{definition is a product_definition_shape} 
{definition.definition is a stratum} }.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_non_planar_2d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_non_planar_2d_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a stratum feature non planar 2d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_feature_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum feature non planar 2d shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'STRATUM_FEATURE' IN TYPEOF(pdr.definition.definition))
       )) = 1
       ))) = 0;
END_RULE; -- stratum_feature_non_planar_2d_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'stratum feature non planar 2d shape' shall be
the used_representation for exactly one property_definition_representation
that shall also have a definition that is a property_definition that shall
also have a definition that is a stratum_feature.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_shape_stratum_average_surface_shape_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_shape_stratum_average_surface_shape_relationship_constraint rule 
constrains representation_relationship when it is used as a stratum
feature shape stratum average surface shape relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE 
stratum_feature_shape_stratum_average_surface_shape_relationship_constraint
 FOR 
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum average surface shape')
       ))) = 0;
END_RULE; -- stratum_feature_shape_stratum_average_surface_-
          -- shape_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum average surface shape relationship' shall have
a rep_2 that is a manifold_surface_shape_representation with a name of 
'stratum feature non planar 2d shape'.
</formal.propositions.rul>

<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum average surface shape relationship' shall have
a rep_1 that is a manifold_surface_shape_representation with a name of 
'stratum average surface shape'.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_shape_stratum_surface_shape_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_shape_stratum_surface_shape_relationship_constraint rule 
constrains representation_relationship when it is used as a stratum
feature shape stratum surface shape relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
        'stratum feature shape stratum surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
            'stratum feature shape stratum surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum surface shape')
       ))) = 0;
END_RULE; -- stratum_feature_shape_stratum_surface_shape_relationship_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum surface shape relationship' shall have
a rep_2 that is a manifold_surface_shape_representation with a name of 
'stratum feature non planar 2d shape'.
</formal.propositions.rul>

<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum surface shape relationship' shall have
a rep_1 that is a manifold_surface_shape_representation with a name of 
'stratum surface shape'.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_unique_constraint rule constrains the stratum_feature population members,
that fill the role of ARM stratum_feature, to be have unique names on each stratum.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_feature_unique_constraint FOR
 ( stratum_feature );
LOCAL
  sf_bag : BAG OF stratum_feature;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_feature) by 1;
  IF EXISTS( stratum_feature[i].of_shape.definition ) THEN
    IF( NOT( stratum_feature[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_feature[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sf_bag := QUERY( r <* stratum_feature | 
             (r.of_shape.definition :=: s_bag[i]) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sf_bag) by 1;
    IF EXISTS( sf_bag[j]\shape_aspect.name ) THEN
      IF ( sf_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sf_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- stratum_feature_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of stratum_feature that has a common stratum
must have a unique name attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_interconnect_module_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_interconnect_module_3d_position_constraint rule constrains the
mapping_target, mapping_source and use of a mapped_item when it is a
3d positioned stratum shape in interconnect module.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = '3d positioned stratum shape in interconnect module')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE; -- stratum_interconnect_module_3d_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect
module' shall have a mapping_target that is an axis2_placement_3d.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect
module' shall be an items in exactly one representation that is related to an
assembly_component_usage that has a name = 'interconnect module stratum
assembly relationship'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect
module' shall have a mapping_target that is an items of exactly one
representation [that has a name = '3d bound volume shape'] [that is a
shape_representation] [is related to a product that is an interconnect
module].
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect module' shall have a mapping_source.mapped_representation that [is a
shape_representation] [has a name = '3d bound volume shape'] [is related to
a stratum].
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_interconnect_module_planar_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_interconnect_module_planar_position_constraint rule constrains the
mapping_target, mapping_source and use of a mapped_item when it is a
planar positioned stratum shape in interconnect module.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_interconnect_module_planar_position_constraint FOR 
          (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 
          'planar positioned stratum shape in interconnect module')
    AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE; -- stratum_interconnect_module_planar_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall have a mapping_target that is an axis2_placement_2d.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall be an items in exactly one representation that is 
related to an assembly_component_usage that has a name = 'interconnect module 
stratum assembly relationship'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall have a mapping_target that is an items of exactly one
representation [that has a name = 'planar projected shape'] [that is a
shape_representation] [is related to a product that is an interconnect
module].
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall have a mapping_source.mapped_representation that 
[is a shape_representation] [has a name = 'planar projected shape'] 
[is related to a stratum].
</Informal.propositions.rul>
<Informal.propositions.rul>
The interconnect referenced by the assembly shape shall be the same interconnect that is referenced by the interconnect to stratum assembly relationship.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_make_from_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_make_from_relationship_constraint rule constrains the related
and relating product_definition for a make_from_usage_option when it is a
stratum make from relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_make_from_relationship_constraint FOR
(make_from_usage_option);
WHERE
  WR1: SIZEOF(QUERY(mfuo <* make_from_usage_option |
       (mfuo\product_definition_relationship.name = 'stratum make from')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(mfuo.related_product_definition)
       ))) = 0;
  WR2: SIZEOF(QUERY(mfuo <* make_from_usage_option |
       (mfuo\product_definition_relationship.name = 'stratum make from')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(mfuo.relating_product_definition)
       ))) = 0;
END_RULE; -- stratum_make_from_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each make_from_usage_option that has a name = 'stratum make from' shall
have its related_product_definition satisfied by a stratum.
</formal.propositions.rul>
<formal.propositions.rul>
Each make_from_usage_option that has a name = 'stratum make from' shall 
have its relating_product_definition satisfied by a stratum.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_planar_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_planar_shape_constraint rule requires each shape_representation
to be related to an axis2_placement_2d and a product_definition_shape
when it is implementing the arm concept
of <internal.ref linkend="Stratum_planar_shape">.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_planar_shape_constraint FOR (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       NOT( NOT ((sr\representation.name = 'planar projected shape') AND 
       (SIZEOF(QUERY(pdr <* USEDIN(sr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.definition.definition))
       )) = 1))
       OR (SIZEOF(QUERY(a2p2d <* sr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(a2p2d))
       )) >= 0)))) = 0;
END_RULE; -- stratum_planar_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_representation that [has a name = 'planar projected shape']
[is related to a stratum through a property_definition_representation] shall
have at least one items satisfied by an axis2_placement_2d.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_surface_in_stratum_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_surface_in_stratum_3d_position_constraint
rule constrains mapped_item when it is used as a
stratum surface in stratum 3d position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_surface_in_stratum_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'stratum surface in stratum 3d position')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE; -- stratum_surface_in_stratum_3d_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item with a name of
'stratum surface in stratum 3d position' shall
have a mapping_target that is a axis2_placement_3d.
</formal.propositions.rul>

</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item with a name of
'stratum surface in stratum 3d position' shall
be an item for a shape_representation with a name of
'3d bound volume shape' that is the used_representation
of a property_definiton_representation with a definition
that is a product_definition_shape with a definition
that is a stratum.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each mapped_item with a name of
'stratum surface in stratum 3d position' shall
have a mapping_source that has a mapped_representation
that is a manifold_surface_shape_representation with
a name of 'stratum surface shape' or 'stratum average surface shape'.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_surface_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_surface_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a stratum surface shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE stratum_surface_shape_constraint FOR 
( manifold_surface_shape_representation );
END_RULE; -- stratum_surface_shape_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'stratum surface shape' shall be
the used_representation for exactly one property_definition
that shall have a definition that is a stratum_surface with a 
description of 'primary surface' or 'secondary surface'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_surface_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_surface_unique_constraint rule constrains the stratum_surface population members,
that fill the role of ARM stratum_surface, to be have unique descriptions on each stratum.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_surface_unique_constraint FOR
 ( stratum_surface );
LOCAL
  ss_bag : BAG OF stratum_surface;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_surface) by 1;
  IF EXISTS( stratum_surface[i].of_shape.definition ) THEN
    IF( NOT( stratum_surface[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_surface[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ss_bag := QUERY( r <* stratum_surface | 
               (r.of_shape.definition :=: s_bag[i]) );
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(ss_bag) by 1;
    IF EXISTS( ss_bag[j]\shape_aspect.description ) THEN
      IF ( ss_bag[j]\shape_aspect.description IN desc_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        desc_bag := desc_bag + ss_bag[j]\shape_aspect.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- stratum_surface_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of stratum_surface that has a common stratum
must have a unique description attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_technology_line_width_tolerance_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_technology_line_width_tolerance_assignment_constraint rule
constrains the items and use of a representation when it is a
stratum technology line width tolerance assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_technology_line_width_tolerance_assignment_constraint FOR
(representation);
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(lmwu <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum positive deviation')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(si <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STYLED_ITEM' IN TYPEOF (si))
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(lmwu <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum negative deviation')
       )) = 1))) = 0;
END_RULE; -- stratum_technology_line_width_tolerance_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each representation that has a name = 'stratum technology line width
tolerance assignment' shall have exactly one items {that is a
length_measure_with_unit} {has a name = 'maximum positive deviation'}.
</formal.propositions.rul> 
<formal.propositions.rul> 
Each representation that has a name = 'stratum technology line width 
tolerance assignment' shall have exactly one items that is a styled_item.
</formal.propositions.rul>  
<formal.propositions.rul>  
Each representation that has a name = 'stratum technology line width  
tolerance assignment' shall have exactly one items {that is a
length_measure_with_unit} {has a name = 'maximum negative deviation'}.
</formal.propositions.rul>   
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation that has a name = 'stratum technology line width
tolerance assignment' shall be related to exactly one stratum_technology.
</Informal.propositions.rul>
<Informal.propositions.rul>   
Each representation that has a name = 'stratum technology line width   
tolerance assignment' shall be related to a physical_unit that {has
a frame_of_reference.name = 'physical design'} {has a
formation.of_product that is a product that is part of a product_category
with a name = 'interconnect module'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="substitute_product_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The substitute_product_constraint rule requires all product entities that
are base products to be related to a substitute product and that all
assembly_component_usage entities in the role of a substitute in
an assembly_component_usage_substitute have no reference_designator 
attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE substitute_product_constraint FOR (product,
assembly_component_usage_substitute);
WHERE
  WR1: SIZEOF(QUERY(acus <* assembly_component_usage_substitute |
       EXISTS(acus.substitute.reference_designator))) = 0;
END_RULE; -- substitute_product_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">

<formal.propositions.rul>
Each assembly_component_usage_substitute shall have a substitute that
does not have a reference_designator.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product that is the formation.of_product of a product_definition that
is related to an assembly_component_usage as a base shall be related to
another product that is the formation.of_product of a product_definition
that is related to an assembly_component_usage as a substitute.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_combination_action_assignment">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_combination_action_assignment rule requires that only the
following combinations of action_assignment entities are allowed:
<list>
<list.item>applied_action_assignment by itself</list.item>
<list.item>applied_action_assignment in conjunction with change</list.item>
<list.item>applied_action_assignment in conjunction with start_work</list.item>
<list.item>change by itself</list.item>
<list.item>start_work by itself</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE subtype_combination_action_assignment FOR (action_assignment);
END_RULE; -- subtype_combination_action_assignment
*)
(*
</EXPRESS.CODE>

<Informal.Propositions rule.types = "IP">
<Informal.Propositions.rul>
An action_assignment must be an applied_action_assignment, change, start_work,
applied_action_assignment in conjunction with change, or
applied_action_assignment in conjunction with start_work.
</Informal.Propositions.rul>
</Informal.Propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<!--
*)
(*

WR1: An instance of action_assignment shall be at most one of type change,
start_work.  This allows for an applied_action_assignment to be a change
or a start_work.

*)
(*
-->

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_combination_shape_aspect">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_combination_shape_aspect rule requires all shape_aspect entities to 
be at most one of the following:
<list>
<list.item>assembly_bond_definition</list.item>
<list.item>assembly_joint</list.item>
<list.item>assembly_module_terminal</list.item>
<list.item>minimally_defined_bare_die_terminal</list.item>
<list.item>component_functional_terminal</list.item>
<list.item>component_interface_terminal</list.item>
<list.item>component_shape_aspect</list.item>
<list.item>component_terminal</list.item>
<list.item>datum_reference_frame</list.item>
<list.item>datum_system</list.item>
<list.item>derived_shape_aspect</list.item>
<list.item>device_terminal_map</list.item>
<list.item>fabrication_joint</list.item>
<list.item>functional_unit_terminal_definition</list.item>
<list.item>group_shape_aspect</list.item>
<list.item>interconnect_module_terminal</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>join_shape_aspect</list.item>
<list.item>land_template_terminal</list.item>
<list.item>layer</list.item>
<list.item>layer_connection_point</list.item>
<list.item>mounting_restriction_area</list.item>
<list.item>package_body</list.item>
<list.item>package_terminal</list.item>
<list.item>packaged_connector_terminal_relationship</list.item>
<list.item>packaged_part_terminal</list.item>
<list.item>part_connected_terminals_definition</list.item>
<list.item>part_template_definition</list.item>
<list.item>passage_technology</list.item>
<list.item>physical_connectivity_definition</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>physical_network</list.item>
<list.item>positional_boundary</list.item>
<list.item>positional_boundary_member</list.item>
<list.item>printed_part_cross_section_template_terminal</list.item>
<list.item>printed_part_template_connected_terminals_definition</list.item>
<list.item>printed_part_template_terminal</list.item>
<list.item>sequential_laminate_passage_based_fabrication_joint</list.item>
<list.item>shape_modification</list.item>
<list.item>stratum_concept_relationship</list.item>
<list.item>stratum_feature</list.item>
<list.item>stratum_surface</list.item>
<list.item>tolerance_zone</list.item>
<list.item>tolerance_zone_boundary</list.item>
<list.item>viewing_plane</list.item>
</list>

The subtype_combination_shape_aspect rule also requires all shape_aspect entities to be at most one of the following:
<list>
<list.item>assembly_bond_definition</list.item>
<list.item>assembly_joint</list.item>
<list.item>assembly_module_terminal</list.item>
<list.item>minimally_defined_bare_die_terminal</list.item>
<list.item>component_functional_terminal</list.item>
<list.item>component_interface_terminal</list.item>
<list.item>component_shape_aspect</list.item>
<list.item>component_terminal</list.item>
<list.item>datum_reference_frame</list.item>
<list.item>datum_system</list.item>
<list.item>device_terminal_map</list.item>
<list.item>fabrication_joint</list.item>
<list.item>functional_unit_terminal_definition</list.item>
<list.item>group_shape_aspect</list.item>
<list.item>interconnect_module_terminal</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>join_shape_aspect</list.item>
<list.item>land_template_terminal</list.item>
<list.item>layer</list.item>
<list.item>layer_connection_point</list.item>
<list.item>mounting_restriction_area</list.item>
<list.item>package_body</list.item>
<list.item>package_terminal</list.item>
<list.item>packaged_connector_terminal_relationship</list.item>
<list.item>packaged_part_terminal</list.item>
<list.item>part_connected_terminals_definition</list.item>
<list.item>part_template_definition</list.item>
<list.item>passage_technology</list.item>
<list.item>physical_connectivity_definition</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>physical_network</list.item>
<list.item>physical_unit_datum</list.item>
<list.item>positional_boundary</list.item>
<list.item>positional_boundary_member</list.item>
<list.item>printed_part_cross_section_template_terminal</list.item>
<list.item>printed_part_template_connected_terminals_definition</list.item>
<list.item>printed_part_template_terminal</list.item>
<list.item>sequential_laminate_passage_based_fabrication_joint</list.item>
<list.item>shape_modification</list.item>
<list.item>stratum_concept_relationship</list.item>
<list.item>stratum_feature</list.item>
<list.item>stratum_surface</list.item>
<list.item>tolerance_zone</list.item>
<list.item>tolerance_zone_boundary</list.item>
<list.item>viewing_plane</list.item>
</list>

Additionally, the subtype_combination_shape_aspect rule requires all 
shape_aspect entities to be at most one of the following:
<list>
<list.item>assembly_bond_definition</list.item>
<list.item>assembly_joint</list.item>
<list.item>component_functional_terminal</list.item>
<list.item>component_interface_terminal</list.item>
<list.item>component_shape_aspect</list.item>
<list.item>component_terminal</list.item>
<list.item>datum_reference_frame</list.item>
<list.item>datum_system</list.item>
<list.item>derived_shape_aspect</list.item>
<list.item>device_terminal_map</list.item>
<list.item>fabrication_joint</list.item>
<list.item>functional_unit_terminal_definition</list.item>
<list.item>group_shape_aspect</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>join_shape_aspect</list.item>
<list.item>land_template_terminal</list.item>
<list.item>layer</list.item>
<list.item>layer_connection_point</list.item>
<list.item>mounting_restriction_area</list.item>
<list.item>package_body</list.item>
<list.item>part_connected_terminals_definition</list.item>
<list.item>part_template_definition</list.item>
<list.item>passage_technology</list.item>
<list.item>physical_connectivity_definition</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>physical_network</list.item>
<list.item>physical_unit_datum_feature</list.item>
<list.item>physical_unit_datum_target</list.item>
<list.item>positional_boundary</list.item>
<list.item>positional_boundary_member</list.item>
<list.item>printed_part_cross_section_template_terminal</list.item>
<list.item>printed_part_template_connected_terminals_definition</list.item>
<list.item>printed_part_template_terminal</list.item>
<list.item>sequential_laminate_passage_based_fabrication_joint</list.item>
<list.item>shape_modification</list.item>
<list.item>stratum_concept_relationship</list.item>
<list.item>stratum_feature</list.item>
<list.item>stratum_surface</list.item>
<list.item>tolerance_zone</list.item>
<list.item>tolerance_zone_boundary</list.item>
<list.item>viewing_plane</list.item>
</list>

Finally, the subtype_combination_shape_aspect rule requires each 
shape_aspect entity to be at most one of the following:
<list>
<list.item>physical_unit_datum_feature</list.item>
<list.item>physical_unit_datum_target</list.item>
<list.item>physical_unit_datum</list.item>
</list>
<note>
The inclusion of a subtype of shape_aspect in three conjuctive subclauses of this rule should 
only be interpreted as an additional degree of freedom for those subtypes that
are not repeated.  A logically equivalent formulation of this rule would include all
repeated subtypes only in a fifth conjuctive subclause.
</note>
<example>
A shape_aspect subtype may be exchanged that is a combination of stratum_surface
and physical_unit_datum_feature, but not one that is a combination of
stratum_surface, physical_unit_datum_feature and physical_unit_datum.
</example>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_combination_shape_aspect FOR (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_SYSTEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DERIVED_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR2: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_SYSTEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR3: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_SYSTEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DERIVED_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR4: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PHYSICAL_UNIT_DATUM']
       * TYPEOF(sa)) <= 1))) = 0;

END_RULE; -- subtype_combination_shape_aspect
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system, derived_shape_aspect, 
device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interconnect_module_terminal, 
interface_mounted_join, join_shape_aspect, land_template_terminal, layer, layer_connection_point, 
mounting_restriction_area, package_body, package_terminal, packaged_connector_terminal_relationship, 
packaged_part_terminal, part_connected_terminals_definition, part_template_definition, 
passage_technology, physical_connectivity_definition, physical_connectivity_element, physical_network, 
positional_boundary, positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.
</formal.propositions.rul>

<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system,
device_terminal_map, fabrication_joint, functional_unit_terminal_definition, group_shape_aspect, 
interconnect_module_terminal, interface_mounted_join, join_shape_aspect, land_template_terminal, 
layer, layer_connection_point, mounting_restriction_area, package_body, package_terminal, 
packaged_connector_terminal_relationship, packaged_part_terminal, part_connected_terminals_definition, 
part_template_definition, passage_technology, physical_connectivity_definition, 
physical_connectivity_element, physical_network, physical_unit_datum, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.
</formal.propositions.rul>

<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, component_functional_terminal, component_interface_terminal, 
component_shape_aspect, component_terminal, datum_reference_frame, 
datum_system, derived_shape_aspect, device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interface_mounted_join, join_shape_aspect, 
land_template_terminal, layer, layer_connection_point, mounting_restriction_area, package_body, 
part_connected_terminals_definition, part_template_definition, passage_technology, 
physical_connectivity_definition, physical_connectivity_element, physical_network, 
physical_unit_datum_feature, physical_unit_datum_target, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.
</formal.propositions.rul>

<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of physical_unit_datum_feature, 
physical_unit_datum_target, or physical_unit_datum.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<!--
*)
(*

WR1: Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system, derived_shape_aspect,
device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interconnect_module_terminal, 
interface_mounted_join, join_shape_aspect, land_template_terminal, layer, layer_connection_point, 
mounting_restriction_area, package_body, package_terminal, packaged_connector_terminal_relationship, 
packaged_part_terminal, part_connected_terminals_definition, part_template_definition, 
passage_technology, physical_connectivity_definition, physical_connectivity_element, physical_network, 
positional_boundary, positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.

WR2: Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system,
device_terminal_map, fabrication_joint, functional_unit_terminal_definition, group_shape_aspect, 
interconnect_module_terminal, interface_mounted_join, join_shape_aspect, land_template_terminal, 
layer, layer_connection_point, mounting_restriction_area, package_body, package_terminal, 
packaged_connector_terminal_relationship, packaged_part_terminal, part_connected_terminals_definition, 
part_template_definition, passage_technology, physical_connectivity_definition, 
physical_connectivity_element, physical_network, physical_unit_datum, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.

WR3: Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, component_functional_terminal, component_interface_terminal, 
component_shape_aspect, component_terminal, datum_reference_frame, 
datum_system, derived_shape_aspect, device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interface_mounted_join, join_shape_aspect, 
land_template_terminal, layer, layer_connection_point, mounting_restriction_area, package_body, 
part_connected_terminals_definition, part_template_definition, passage_technology, 
physical_connectivity_definition, physical_connectivity_element, physical_network, 
physical_unit_datum_feature, physical_unit_datum_target, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.

WR4: Every instance of shape_aspect shall be at most one of physical_unit_datum_feature, 
physical_unit_datum_target, or physical_unit_datum.

*)
(*
-->

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_action_request_assignment">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_action_request_assignment rule requires all
action_request_assignment entities to be at most one of change_request or
start_request.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_action_request_assignment FOR 
  (action_request_assignment);
WHERE
  WR1: SIZEOF (QUERY (ara <* action_request_assignment |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHANGE_REQUEST',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'START_REQUEST']
       * TYPEOF(ara)) <= 1))) = 0;
END_RULE;  -- subtype_exclusive_action_request_assignment
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
An instance of action_request_assignment shall be at most one of type
change_request, or start_request.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_dimensional_location">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_dimensional_location rule requires all 
dimensional_location entities to be at most one of the following:
<list>
<list.item>angular_dimension_with_orientation</list.item>
<list.item>dimensional_location_with_direction</list.item>
<list.item>dimensional_location_with_path</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_dimensional_location FOR
  (dimensional_location);
WHERE  
  WR1: SIZEOF (QUERY (dl <* dimensional_location |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANGULAR_DIMENSION_WITH_ORIENTATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION_WITH_DIRECTION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION_WITH_PATH']
       * TYPEOF(dl)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_dimensional_location
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of dimensional_location shall be at most one of 
angular_dimension_with_orientation, dimensional_location_with_direction, or 
dimensional_location_with_path.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_dimensional_size">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_dimensional_size rule requires all dimensional_size 
entities to be at most one of curve_dimension, or angular_size; and at most 
one of curve_dimension, or opposing_boundary_dimensional_size.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_dimensional_size FOR
  (dimensional_size);
WHERE  
  WR1: SIZEOF (QUERY (ds <* dimensional_size |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CURVE_DIMENSION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANGULAR_SIZE']
       * TYPEOF(ds)) <= 1) OR
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CURVE_DIMENSION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE']
       * TYPEOF(ds)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_dimensional_size
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of dimensional_size shall be at most one of
curve_dimension, or angular_size and at most one of curve_dimension,
or opposing_boundary_dimensional_size.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_mapped_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_mapped_item rule requires all mapped_item entities to
be at most one of annotation_text or assembly_module_usage_view_connector_relationship or annotation_symbol.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_mapped_item FOR (mapped_item);
WHERE
  WR1: SIZEOF (QUERY (mi <* mapped_item |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANNOTATION_TEXT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_USAGE_VIEW_CONNECTOR_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANNOTATION_SYMBOL'] *
       TYPEOF(mi)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_mapped_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of mapped_item shall be at most one of type annotation_text
or assembly_module_usage_view_connector_relationship or annotation_symbol.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_product_definition">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_product_definition rule requires all product_definition
entities to be at most one of the following:
<list>
<list.item>component_definition</list.item>
<list.item>component_functional_unit</list.item>
<list.item>functional_unit</list.item>
<list.item>network_node_definition</list.item>
<list.item>physical_unit or stratum</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_product_definition FOR (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NETWORK_NODE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_product_definition
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of product_definition shall be at most one of type
bus_structural_definition, component_definition,
component_functional_unit, functional_unit, network_node_definition,
physical_unit or stratum.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_product_definition_relationship">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_product_definition_relationship rule requires all
product_definition_relationship entities be at most one of the following:
<list>
<list.item>product_definition-usage</list.item>
<list.item>material_composition_relationship</list.item>
<list.item>supplied_part_relationship</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_product_definition_relationship FOR
  (product_definition_relationship);
WHERE
  WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_USAGE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SUPPLIED_PART_RELATIONSHIP']
       * TYPEOF(pdr)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_product_definition_relationship
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of product_definition_relationship shall be at most one of
type product_definition_usage, product_material_composition_relationship, or
supplied_part_relationship.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_property_definition">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_property_definition rule requires all 
property_definition entities to be at most one of the following:
<list>
<list.item>dimensional_size_property</list.item>
<list.item>geometric_tolerance_group</list.item>
<list.item>material_property</list.item>
<list.item>physical_unit_geometric_tolerance</list.item>
<list.item>product_definition_shape</list.item>
<list.item>requirements_property</list.item>
<list.item>signal</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_property_definition FOR
  (property_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* property_definition |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_SIZE_PROPERTY',   
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_GROUP', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_PROPERTY', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SIGNAL']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_property_definition
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of property_definition shall be at most one of
dimensional_size_property, geometric_tolerance_group, material_property,
physical_unit_geometric_tolerance,
product_definition_shape, requirements_property, or signal.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_property_definition_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_property_definition_representation rule requires all
property_definition_representation entities to be at most one of
shape_definition_representation or material_property_representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_property_definition_representation FOR 
  (property_definition_representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* property_definition_representation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_DEFINITION_REPRESENTATION',   
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_PROPERTY_REPRESENTATION']
       * TYPEOF(pdr)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_property_definition_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of property_definition_representation shall be at most one of
type shape_definition_representation or material_property_representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_representation rule requires all representation
entities to be at most one of the following:
<list>
<list.item>analytical_model_port</list.item>
<list.item>component_location</list.item>
<list.item>rule_function_definition</list.item>
<list.item>structured_text_representation_item</list.item>
<list.item>text_string_representation</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_representation FOR 
  (representation);
WHERE
  WR1: SIZEOF (QUERY (rep <* representation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'ANALYTICAL_MODEL_PORT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_FUNCTION_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_STRING_REPRESENTATION']
       * TYPEOF(rep)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of representation shall be at most one of type
analytical_model_port, component_location, rule_function_definition,
structured_text_representation_item, or text_string_representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_representation_context">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_representation_context rule requires all
representation_context entities to be at most two of 
geometric_representation_context or parametric_representation_context or
one of structured_text_representation_context.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_representation_context FOR 
  (representation_context);
LOCAL
 pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(representation_context) by 1;
  pass := (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_CONTEXT' IN 
                          TYPEOF(representation_context[i]))
          OR (SIZEOF (TYPEOF(representation_context[i])) <= 2 )) 
       AND 
          (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
         * TYPEOF(representation_context[i])) <= 2 )) 
      AND
          (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT' IN 
                        TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
        * TYPEOF(representation_context[i])) <= 2 ));
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- subtype_exclusive_representation_context
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of representation_context shall be at most one of type
geometric_representation_context or parametric_representation_context or
structured_text_representation_context. 
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_shape_aspect_relationship">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_shape_aspect_relationship rule requires all 
shape_aspect_relationship entities to be at most one of the following:
<list>
<list.item>assembly_joint</list.item>
<list.item>device_terminal_map</list.item>
<list.item>dimensional_location</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>make_from_connectivity_relationship</list.item>
<list.item>make_from_feature_relationship</list.item>
<list.item>packaged_connector_terminal_relationship</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>shape_aspect_deriving_relationship</list.item>
<list.item>stratum_concept_relationship</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_shape_aspect_relationship FOR 
  (shape_aspect_relationship);
WHERE
  WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_CONNECTIVITY_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_FEATURE_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_DERIVING_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP']
       * TYPEOF(sar)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_shape_aspect_relationship
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of shape_aspect_relationship shall be at most one of
assembly_joint, device_terminal_map, dimensional_location,
interface_mounted_join, make_from_connectivity_relationship,
make_from_feature_relationship, packaged_connector_terminal_relationship, 
physical_connectivity_element, shape_aspect_deriving_relationship,
or stratum_concept_relationship.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_action">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_action requires all action entities to be either:
<list>
<list.item>directed_action</list.item>
<list.item>executed_action</list.item>
<list.item>rule_action</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_action FOR (action);
WHERE
  WR1: SIZEOF (QUERY (act <* action |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIRECTED_ACTION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXECUTED_ACTION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_ACTION'] * 
       TYPEOF(act)) = 1))) = 0;
END_RULE; -- subtype_mandatory_action
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of action shall be of type directed_action, executed_action or a
rule_action.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_address">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_address rule requires all address entities to be either
personal_address or organizational_address.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_address FOR (address);
WHERE
  WR1: SIZEOF (QUERY (add <* address |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PERSONAL_ADDRESS',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ORGANIZATIONAL_ADDRESS'] * 
       TYPEOF (add)) = 1))) = 0;
END_RULE; -- subtype_mandatory_address
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of address shall be of type personal_address or
organizational_address.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_colour">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_colour rule requires all colour entities to be colour_rgb.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_colour FOR (colour);
WHERE
  WR1: SIZEOF (QUERY (c <* colour |
       NOT (
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COLOUR_RGB'
       IN TYPEOF (c)))) = 0;
END_RULE; -- subtype_mandatory_colour
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of colour shall be of type colour_rgb.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_compound_representation_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_compound_representation_item rule requires all compound_representation_item entities
to be data_set_representation_item or table_representation_item.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_compound_representation_item FOR (compound_representation_item);
WHERE
  WR1: SIZEOF (QUERY (tl <* compound_representation_item |
       NOT ((
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATA_SET_REPRESENTATION_ITEM' IN TYPEOF (tl)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TABLE_REPRESENTATION_ITEM' IN
       TYPEOF(tl))))) = 0;
END_RULE; -- subtype_mandatory_compound_representation_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of compound_representation_item shall be of type data_set_representation_item or of type table_representation_item.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_composite_shape_aspect">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_composite_shape_aspect rule requires all composite_shape_aspect entities to 
be either composite_group_shape_aspect, or composite_unit_shape_aspect.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_composite_shape_aspect FOR
  (composite_shape_aspect);
WHERE  
  WR1: SIZEOF (QUERY (csa <* composite_shape_aspect |
       NOT (SIZEOF
       (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPOSITE_GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPOSITE_UNIT_SHAPE_ASPECT']
       * TYPEOF(csa)) = 1))) = 0;
END_RULE; -- subtype_mandatory_composite_shape_aspect
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of composite_shape_aspect shall be either a
composite_group_shape_aspect or a composite_unit_shape_aspect.
<note>
Other subtypes of composite_shape_aspect will form a complex instance with one of the above
designated subtypes.
</note>
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_date">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_date rule requires all date entities to be calendar_date.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       NOT (
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CALENDAR_DATE'
       IN TYPEOF (d)))) = 0;
END_RULE; -- subtype_mandatory_date
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of date shall be of type calendar_date.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_externally_defined_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_externally_defined_item rule requires all
externally_defined_item entities to be either:
<list>
<list.item>bond_category</list.item>
<list.item>external_definition</list.item>
<list.item>externally_defined_curve_font</list.item>
<list.item>externally_defined_functional_unit</list.item>
<list.item>externally_defined_hatch_style</list.item>
<list.item>externally_defined_physical_unit</list.item>
<list.item>externally_defined_representation_item</list.item>
<list.item>externally_defined_symbol</list.item>
<list.item>externally_defined_text_font</list.item>
<list.item>externally_defined_tile</list.item>
<list.item>externally_defined_tile_style</list.item>
<list.item>part_template_definition</list.item>
<list.item>rule_definition</list.item>
<list.item>signal_category</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_externally_defined_item FOR 
                                       (externally_defined_item);
WHERE
  WR1: SIZEOF (QUERY (edi <* externally_defined_item |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BOND_CATEGORY',  
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_CURVE_FONT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_HATCH_STYLE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_PHYSICAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'EXTERNALLY_DEFINED_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_SYMBOL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TEXT_FONT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TILE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TILE_STYLE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SIGNAL_CATEGORY'] * 
       TYPEOF (edi)) = 1))) = 0;
END_RULE; -- subtype_mandatory_externally_defined_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of externally_defined_item shall be of a type identified in the list in the description of this rule. 
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_geometric_tolerance">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_geometric_tolerance rule requires all geometric_tolerance entities to be 
physical_unit_geometric_tolerance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_geometric_tolerance FOR
  (geometric_tolerance);
WHERE  
  WR1: SIZEOF (QUERY (gt <* geometric_tolerance |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE'] *
       TYPEOF (gt)) = 1))) = 0;
END_RULE; -- subtype_mandatory_geometric_tolerance
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of geometric_tolerance shall be a
physical_unit_geometric_tolerance.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_pre_defined_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_pre_defined_item rule requires all pre_defined_item
entities to be either pre_defined_text_font or pre_defined_curve_font.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item);
WHERE
  WR1: SIZEOF (QUERY (pdi <* pre_defined_item |
       NOT (SIZEOF 
       (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_TEXT_FONT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_CURVE_FONT'] *
       TYPEOF(pdi)) = 1))) = 0;
END_RULE; -- subtype_mandatory_pre_defined_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of pre_defined_item shall be of type pre_defined_text_font
or pre_defined_curve_font.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_product_definition_usage">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_product_definition_usage rule requires all
product_definition_usage entities to be either assembly_component_usage or make_from_usage_option.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_product_definition_usage FOR
  (product_definition_usage);
WHERE
  WR1: SIZEOF (QUERY (pdu <* product_definition_usage |
       NOT (SIZEOF([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_USAGE_OPTION'] * 
       TYPEOF(pdu)) = 1))) = 0;
END_RULE; -- subtype_mandatory_product_definition_usage
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of product_definition_usage shall be of type
assembly_component_usage or make_from_usage_option.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_runout_zone_orientation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_runout_zone_orientation rule requires all runout_zone_orientation entities to 
be runout_zone_orientation_reference_direction.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_runout_zone_orientation FOR
  (runout_zone_orientation);
WHERE  
  WR1: SIZEOF (QUERY (rzo <* runout_zone_orientation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION'] *
       TYPEOF (rzo)) = 1))) = 0;
END_RULE; -- subtype_mandatory_runout_zone_orientation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of runout_zone_orientation shall be a 
runout_zone_orientation_reference_direction.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_text_literal">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_text_literal rule requires all text_literal entities
to be text_literal_with_extent or text_literal_with_associated_curves.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_text_literal FOR (text_literal);
WHERE
  WR1: SIZEOF (QUERY (tl <* text_literal |
       NOT ((
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL_WITH_EXTENT' IN TYPEOF (tl)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN
       TYPEOF(tl))))) = 0;
END_RULE; -- subtype_mandatory_text_literal
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of text_literal shall be of type text_literal_with_extent or of type text_literal_with associated_curves.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="supplied_product_version_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The supplied_product_version_unique_constraint rule constrains the
product_definition_formation_with_specified_source population members, that fill
the role of ARM supplied_product_version, to have unique supplier_part_numbers on
each supplier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE supplied_product_version_unique_constraint FOR
 ( product_definition_formation_with_specified_source );
LOCAL
  spv : BAG OF product_definition_formation_with_specified_source := 
QUERY( r <*
product_definition_formation_with_specified_source | 
(SIZEOF(QUERY( pd <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PRODUCT_DEFINITION.FORMATION') |
(SIZEOF(QUERY( pdr <* USEDIN(pd, 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'SUPPLIED_PART_RELATIONSHIP')
IN TYPEOF(pdr))))>0)))>0));
  aoa_bag : BAG OF applied_organization_assignment;
  o_bag : BAG OF organization := [];
  pdf_bag : BAG OF product_definition_formation_with_specified_source;
  spn_bag : BAG OF STRING;
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(spv) by 1;
  aoa_bag := QUERY( aoa <* USEDIN( spv[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (aoa.role\organization_role.name = 'supplier') );
  REPEAT j := 1 to SIZEOF(aoa_bag) by 1;
    IF EXISTS( aoa_bag[j].assigned_organization ) THEN
      IF ( NOT ( aoa_bag[j].assigned_organization IN o_bag ) ) THEN
        o_bag := o_bag + aoa_bag[j].assigned_organization;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(o_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdf_bag := QUERY( pdf <* spv | (SIZEOF(QUERY( aoa <* USEDIN(pdf,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|
((aoa.role\organization_role.name = 'supplier') AND (aoa.assigned_organization :=: 
                                              o_bag[i])) ) )>0) );
  spn_bag := [];
  REPEAT j := 1 to SIZEOF(pdf_bag) by 1;
    IF EXISTS( pdf_bag[j].of_product.id ) THEN
      IF ( pdf_bag[j].of_product.id IN spn_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        spn_bag := spn_bag + pdf_bag[j].of_product.id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- supplied_product_version_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_formation_with_specified_source that is referenced
by a product_definition that is referenced in a supplied_part_relationship that share a
common supplier must have a unique of_product.id attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="technology_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The technology_constraint rule constrains the definition and the use of a
property_definition when it is a technology.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE technology_constraint FOR ( property_definition );
END_RULE; -- technology_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each property_definition whose name = 'unit technology' shall be related to exactly one 
characterized_object that is an external definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF property_definition name = 'unit technology' THEN 
property_definition shall be the definition for exactly one 
material_designation.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each property_definition whose name = 'unit technology' shall be the 
definition of exactly one property_definition_representation whose
used_representation is an items of an applied_document_reference whose 
assigned_document is a ee_specification.kind.product_data_type = 
'process specification'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="terminal_pair_port_equivalence_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The terminal_pair_port_equivalence_relationship_constraint rule constrains
the rep_1 and rep_2 of a representation_relationship when it is a terminal
pair port equivalence relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE terminal_pair_port_equivalence_relationship_constraint FOR
(representation_relationship);
END_RULE; -- terminal_pair_port_equivalence_relationship_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation_relationship that has a name = 'terminal pair port
equivalence relationship' shall have its rep_2 satisfied by an
analytical_model_port that is a (shape_aspect) (characterized_object).
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation_relationship that has a name = 'terminal pair port 
equivalence relationship' shall have its rep_1 satisfied by an
analytical_model_port that [is an items of a 
group_assignment.assigned_group.name = ('scalar port') ('digital scalar port')]
[has a name = 'analytical model scalar port'] [is the rep_1 of a
representation_relationship whose name is 'scalar port list' and whose
rep_2 points to a representation.name = 'analytical model scalar port'].
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="thermal_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The thermal_requirement_allocation_constraint rule constrains the related
and relating product_definition of a product_definition_relationship when it
is a thermal requirement allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE thermal_requirement_allocation_constraint FOR
(product_definition_relationship);
END_RULE; -- thermal_requirement_allocation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship whose {name = 'assembly requirement
allocation} {description = 'thermal requirement allocation'} shall have its
related_product_definition satisfied by a component_definition that {has
a description = 'thermal component'} {is the of_shape of a
component_shape_aspect}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship whose {name = 'assembly requirement 
allocation} {description = 'thermal requirement allocation'} shall have its 
relating_product_definition satisfied by a product_definition that {has a
frame_of_reference.name = 'design requirement'} {is the definition of
a thermal requirement}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_specific_restraint_condition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_specific_restraint_condition_constraint rule constrains the use of a property_definition when it is used as a tolerance specific restraint condition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_specific_restraint_condition_constraint FOR
  (property_definition);
END_RULE; -- tolerance_specific_restraint_condition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance specific restraint' shall relate, to specify its 'affected tolerance', to at least one property_definition that is either a physical_unit_geometric_tolerance, a dimensional_size_property, or is a property_definition of a dimensional_location and has a description of 'dimensional location property'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_and_viewing_plane_orienting_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_and_viewing_plane_orienting_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a tolerance zone and viewing plane orienting relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_and_viewing_plane_orienting_relationship_constraint FOR
  (shape_aspect_relationship);
END_RULE; -- tolerance_zone_and_viewing_plane_orienting_relationship_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall have a related_shape_aspect that is a viewing_plane.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall have a relating_shape_aspect that is a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall have exactly one property_definition with a description of 'viewing plane based orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a tolerance zone boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_boundary_definition_constraint FOR
  (property_definition);
END_RULE; -- tolerance_zone_boundary_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'boundary zone definition with specified size' or 'conical tolerance zone boundary' shall be a property_definition of a tolerance_zone_boundary and that tolerance_zone_boundary shall be specified as one of the boundaries of exactly one tolerance_zone_definition.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_boundary_member_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_boundary_member_constraint rule constrains the use of a shape_aspect when it is used as a tolerance zone boundary member.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_boundary_member_constraint FOR
  (shape_aspect);
END_RULE; -- tolerance_zone_boundary_member_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect that has a description of 'tolerance zone boundary member' shall not be on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect that has a description of 'tolerance zone boundary member' shall be related to exactly one tolerance_zone_explicit_opposing_boundary_set as a 'zone boundary member'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect with a description of 'tolerance zone boundary member' shall have at most one property_definition with a description of 'tolerance zone boundary member offset'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_boundary_member_offset_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_boundary_member_offset_constraint rule constrains the use of a property_definition when it is used as a tolerance zone boundary member offset.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_boundary_member_offset_constraint FOR
  (property_definition);
END_RULE; -- tolerance_zone_boundary_member_offset_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall be a property_definition of a shape_aspect that is not on the boundary of the shape of the product and has a description of 'tolerance zone boundary member'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall be related as a 'profile tolerance zone boundary member offset' to exactly one property_definition that has a description boundary zone definition with specified size and a name of 'profile boundary with offsets'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'tolerance zone boundary member offset value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall have a name of either 'towards material' or 'away from material'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall be related as a 'profile tolerance zone boundary member offset' to exactly one property_definition that has a description of 'boundary zone definition with specified size', a name of 'profile boundary with offsets', and is applied to a tolerance_zone_explicit_opposing_boundary_set, and that tolerance_zone_explicit_opposing_boundary_set shall be the same instance of tolerance_zone_explicit_opposing_boundary_set that is related as a 'zone boundary member' to the shape_aspect to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_constraint rule constrains the use of a tolerance_zone when it is used as a tolerance zone.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_constraint FOR
  (tolerance_zone);
END_RULE; -- tolerance_zone_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone shall be the zone of exactly one tolerance_zone_definition and that tolerance_zone_definition shall have exactly one boundary and that boundary shall be a tolerance_zone_boundary.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_definition_constraint rule constrains the use of a tolerance_zone_definition when it is used as a tolerance zone definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_definition_constraint FOR
  (tolerance_zone_definition);
END_RULE; -- tolerance_zone_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_definition shall have exactly one boundary that is a tolerance_zone_boundary and that tolerance_zone_boundary shall have exactly one property_definition that has a description of either 'boundary zone definition with specified size' or 'conical tolerance zone boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each tolerance_zone_definition that specifies a tolerance_zone with a description that is not 'conical', shall have that tolerance_zone specify exactly one physical_unit_geometric_tolerance, as its defining_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_definition_with_per_unit_size_specification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_definition_with_per_unit_size_specification_constraint rule constrains the use of a tolerance_zone_definition when it is used as a tolerance zone definition with per unit size specification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_definition_with_per_unit_size_specification_constraint
   FOR  (tolerance_zone_definition);
END_RULE; -- tolerance_zone_definition_with_per_unit_size_specification_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_definition shall specify a tolerance_zone as its zone and that tolerance_zone shall have at most one property_definition that has a description of 'tolerance zone per unit size'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each tolerance_zone_definition in which the tolerance_zone, specified as its zone, has a property_definition with a description of 'tolerance zone per unit size', shall have that tolerance_zone specify a physical_unit_geometric_tolerance, as its defining_tolerance, and that physical_unit_geometric_tolerance either shall have a name of 'flatness' or 'straightness'; or shall be an angularity_tolerance, parallelism_tolerance, or perpendicularity_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_definition_with_specified_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_definition_with_specified_orientation_constraint rule constrains the use of a property_definition when it is used as a tolerance zone definition with specified orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_definition_with_specified_orientation_constraint FOR
  (property_definition);
END_RULE; -- tolerance_zone_definition_with_specified_orientation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' shall be a property_definition of a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' shall relate to exactly one property_definition that has a description of either 'datum axis related orientation', 'viewing plane based orientation', or 'datum based vector orientation' to specify its 'zone orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' and that relates to exactly one property_definition that has a description of 'viewing plane based orientation', shall be applied to the same instance of tolerance_zone that is specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'tolerance zone and viewing plane' and to which the property_definition that has a description of 'viewing plane based orientation' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' and that relates to exactly one property_definition that has a description of 'datum axis related orientation', shall be applied to the same instance of tolerance_zone that is specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'datum axis and tolerance zone' and to which the property_definition that has a description of 'datum axis related orientation' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' shall be a property_definition of a tolerance_zone and that tolerance_zone shall not specify as one of its defining_tolerance either a circular_runout_tolerance, a concentricity_tolerance, a surface_profile_tolerance, a symmetry_tolerance, a total_runout_tolerance, or a physical_unit_geometric_tolerance that has a name of either 'circularity', 'cylindricity', or 'flatness'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_form_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_form_constraint rule constrains the use of a tolerance_zone_form when it is used as a tolerance zone form.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_form_constraint FOR
  (tolerance_zone_form);
END_RULE; -- tolerance_zone_form_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_form shall be the form of at least one tolerance_zone.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_per_unit_size_specification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_per_unit_size_specification_constraint rule constrains the use of a property_definition when it is used as a tolerance zone per unit size specification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE tolerance_zone_per_unit_size_specification_constraint FOR
  (property_definition);
END_RULE; -- tolerance_zone_per_unit_size_specification_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone per unit size' shall be a property_definition of a tolerance_zone and that tolerance_zone shall be specified as the zone by exactly one tolerance_zone_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone per unit size' shall have a representation that contains exactly one or two length_measure_with_unit that have a name of 'per unit size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="topological_junction_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The topological_junction_constraint rule constrains the use of a shape_aspect
when it is a topological junction.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE topological_junction_constraint FOR ( shape_aspect );
END_RULE; -- topological_junction_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of a shape_aspect whose {description = 'topological junction'} 
shall be the related_shape_aspect of 
exactly one shape_aspect_relationship whose {name = 'topological junction 
scope'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="topological_junction_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The topological_junction_unique_constraint rule constrains the shape_aspect population members, that
fill the role of ARM topological_junction, to have unique names on each scope.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE topological_junction_unique_constraint FOR
 ( shape_aspect );
LOCAL
  tj : BAG OF shape_aspect := 
   QUERY( r <* shape_aspect | (r\shape_aspect.description = 'topological junction'));
  sar_bag : BAG OF shape_aspect_relationship;
  s_bag : BAG OF shape_aspect := [];
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(tj) by 1;
  sar_bag := QUERY( sar <* USEDIN( tj[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
((sar\shape_aspect_relationship.name = 'topological junction scope') AND
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_CONNECTIVITY_DEFINITION') IN
TYPEOF(sar.relating_shape_aspect)) ) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].relating_shape_aspect IN s_bag ) ) THEN
        s_bag := s_bag + sar_bag[j].relating_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* USEDIN( s_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT' ) | 
(sar\shape_aspect_relationship.name = 'topological junction scope') );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect\shape_aspect.name ) THEN
      IF ( sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- topological_junction_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of 'topological junction' that
is referenced by a shape_aspect_relationship with a name of 'topological junction scope'
that references a common physical_connectivity_definition must have a unique name
attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="transmission_line_functional_unit_terminal_allocation_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The transmission_line_functional_unit_terminal_allocation_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
transmission_line_functional_unit_terminal_allocation, to have unique implementations on each
transmission_line_functional_unit_terminal.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE transmission_line_functional_unit_terminal_allocation_unique_constraint
 FOR ( shape_aspect_relationship );
LOCAL
  tlfuta : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'transmission line functional terminal allocation'));
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  ut_bag : BAG OF shape_aspect := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(tlfuta) by 1;
  IF EXISTS( tlfuta[i].relating_shape_aspect ) THEN
    IF ( tlfuta[i].relating_shape_aspect\shape_aspect.description = 'unit terminal' )
                                                              THEN
      IF ( NOT ( tlfuta[i].relating_shape_aspect IN ut_bag ) ) THEN
        ut_bag := ut_bag + tlfuta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ut_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* tlfuta | 
((sar.related_shape_aspect\shape_aspect.description =
'printed component join terminal') AND 
(sar.relating_shape_aspect :=: ut_bag[i])) );
  sa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- transmission_line_functional_unit_terminal_allocation_unique_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'unit terminal' that
is references a common shape_aspect with a name of 'unit terminal' must have a unique
reference to a shape_aspect with a description of 'printed component join terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="transmission_line_functional_unit_terminal_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The transmission_line_functional_unit_terminal_allocation_constraint rule
constrains the related and relating shape_aspect of a shape_aspect_relationship
when it is a transmission line functional unit terminal allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE transmission_line_functional_unit_terminal_allocation_constraint FOR
(shape_aspect_relationship);
END_RULE; -- transmission_line_functional_unit_terminal_allocation_-
          -- constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship that has a name = 'transmission line functional
unit terminal allocation' shall have its relating_shape_aspect satisfied by a
component_functional_terminal that has a description = 'unit terminal'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect_relationship that has a name = 'transmission line functional
unit terminal allocation' shall have its related_shape_aspect satisfied by a
component_terminal [that has a description = 'printed component join
terminal'] [that is the relating_shape_aspect of a shape_aspect_relationship
that has a name = 'terminal in component' and has a related_shape_aspect
that is a routed_printed_component that is related to a
product_definition_relationship that has a name = 'design functional unit
allocation' and a description = 'transmission line to routed printed
component allocation'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="transmission_line_functional_unit_to_routed_printed_component_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The
transmission_line_functional_unit_to_routed_printed_component_allocation_constraint
rule requires all product_definition_relationship entities that are used as
a transmission_line_functional_unit_to_routed_printed_component_allocation
entity to be related to a routed_printed_component.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE transmission_line_functional_unit_to_routed_printed_component_allocation_constraint
FOR (product_definition_relationship);
END_RULE; -- transmission_line_functional_unit_to_routed_printed_component_allocation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship that has a name = 'design functional unit
allocation' and a description = 'transmission line to routed printed
component' shall participate as the definition of a property_definition
that is the relating_property_definition of a property_definition_relationship
that has a related_property_definition.definition that is a
routed_printed_component.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="true_profile_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The true_profile_constraint rule constrains the use of a property_definition when it is used as a true profile.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE true_profile_constraint FOR
  (property_definition);
END_RULE; -- true_profile_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'true profile' shall be a property_definition of a shape_aspect that is either on the boundary of the shape of the product or is a part_template_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'true profile' shall either relate to exactly one property_definition that has a description of 'dimension set' to specify its 'true profile specification', have exactly one document_reference where the assigned_document is an ee_specification, be represented by exactly one rule_function_definition, or have exactly one shape_representation with a name of '3d bound volume shape'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'true profile' shall be related as a 'basic profile' to at least one property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="user_defined_dimension_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The user_defined_dimension_qualifier_constraint rule constrains the use of a measure_qualification when it is used as an user defined dimension qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE user_defined_dimension_qualifier_constraint FOR
  (measure_qualification);
END_RULE; -- user_defined_dimension_qualifier_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'user defined dimension qualifier' shall have exactly one qualifier and that qualifier shall be a type_qualifier.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="user_defined_geometric_tolerance_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The user_defined_geometric_tolerance_qualifier_constraint rule constrains the use of a measure_qualification when it is used as an user defined geometric tolerance qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE user_defined_geometric_tolerance_qualifier_constraint FOR
  (measure_qualification);
END_RULE; -- user_defined_geometric_tolerance_qualifier_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'user defined geometric tolerance qualifier' shall have exactly one qualifier and that qualifier shall be a type_qualifier.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_approval">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The versioned_action_request_requires_approval rule specifies that each 
instance of versioned_action_request shall have exactly one approval.
An approval for a versioned_action_request is defined by the
applied_approval_assignment entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_approval FOR
  (versioned_action_request, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       varq IN aaa.items )) = 1 ))) = 0;
END_RULE; -- versioned_action_request_requires_approval
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request there shall be exactly
one instance of applied_approval_assignment that contains the instance of
versioned_action_request in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The versioned_action_request_requires_date_or_date_and_time rule specifies that
each instance of versioned_action_request shall have exactly one date or
date_and_time for it.  A date for a versioned_action_request is defined by the
applied_date_assignment entity and a date_and_time is defined by the
applied_date_and_time_assignment entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_date_or_date_and_time FOR
  (versioned_action_request, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       varq IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       varq IN ada.items )) = 1 )))) = 0;
END_RULE; -- versioned_action_request_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request, exactly one instance of
applied_date_and_time_assignment or exactly one instance of
applied_date_assignment shall contain the instance of versioned_action_request
in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The versioned_action_request_requires_person_organization rule specifies
that each instance of versioned_action_request shall have one or more
organizations or person_and_organizations assigned to it.  An
organization for a versioned_action_request is defined by the
applied_organization_assignment entity and a person_and_organization is defined 
by the applied_person_and_organization_assignment entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_person_organization FOR
  (versioned_action_request,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       varq IN apaoa.items )) >= 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       varq IN aoa.items )) >= 1 )))) = 0;
END_RULE; -- versioned_request_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request, there shall be at least one
instance of applied_person_and_organization_assignment or at least one
instance of applied_organization_assignment that contains the instance of
versioned_action_request in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

A versioned_action_request_requires_status rule specifies that each instance
of versioned_action_request shall have exactly one status.  The status of a
versioned_action_request is defined by the action_request_status entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_status FOR
  (versioned_action_request, action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ar <* versioned_action_request |
       NOT (SIZEOF (QUERY (ars <* action_request_status |
       ar :=: ars.assigned_request)) = 1))) = 0;
END_RULE; -- versioned_action_request_requires_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request there shall be exactly
one instance of action_request_status that contains an
assigned_request attribute value equal to that instance of
versioned_action_request.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="via_template_terminal_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The via_template_terminal_constraint rule requires all shape_aspect entities
that are via template terminals to be related to a via template and a
connection zone.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE via_template_terminal_constraint FOR (shape_aspect);
END_RULE; -- via_template_terminal_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect that has a description = 'via template terminal' shall 
participate as a related_shape_aspect for a shape_aspect_relationship with 
a name = 'access mechanism' that has a relating_shape_aspect that is a 
part_template_definition that has a description = 'via template' and has an 
of_shape that is a product_definition_shape that has a definition that is a 
characterized_object.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect that has a description = 'via template terminal' shall 
participate as a relating_shape_aspect for a shape_aspect_relationship that 
has a related_shape_aspect that has a name = 'connection zone'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="via_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The via_template_terminal_unique_constraint rule constrains the shape_aspect population members, that
fill the role of ARM via_template_terminal, to have unique terminal names on each via_template.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE via_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  vt : BAG OF shape_aspect := 
         QUERY( r <* shape_aspect | (r\shape_aspect.description = 'via template'));
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(vt) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* USEDIN( vt[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
 + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'access mechanism') AND 
(sar.related_shape_aspect\shape_aspect.description = 
'via template terminal' )) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect\shape_aspect.name ) THEN
      IF ( sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- via_template_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of 'via template terminal' that
is referenced by a shape_aspect_relationship with a name of 'access mechanism'
that references a common shape_aspect with a description of 'via template' must
have a unique name attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="viewing_plane_based_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The viewing_plane_based_orientation_constraint rule constrains the use of a property_definition when it is used as a viewing plane based orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE viewing_plane_based_orientation_constraint FOR
  (property_definition);
END_RULE; -- viewing_plane_based_orientation_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'viewing plane based orientation' shall be a property_definition of a shape_aspect_relationship that has a name of 'tolerance zone and viewing plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'viewing plane based orientation' shall relate to exactly one property_definition that has a description of 'viewing plane property' to specify its 'viewing plane specification'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'viewing plane based orientation' shall be related as a 'zone orientation' to exactly one property_definition that has a description of 'tolerance zone orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'viewing plane based orientation' shall relate to exactly one property_definition that has a description of 'viewing plane property' and that property_definition shall be applied to the same instance of viewing_plane that is specified as the related_shape_aspect by the shape_aspect_relationship that has a name of 'tolerance zone and viewing plane' and to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="viewing_plane_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The viewing_plane_definition_constraint rule constrains the use of a property_definition when it is used as a viewing plane definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE viewing_plane_definition_constraint FOR
  (property_definition);
END_RULE; -- viewing_plane_definition_constraint
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'viewing plane property' shall be a property_definition of a viewing_plane.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'viewing plane property' shall be related as a 'viewing plane specification' to exactly one property_definition that has a description of 'viewing plane based orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'viewing plane property' shall have a representation that contains exactly one axis1_placement that has a name of 'orientation'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="work_order_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The work_order_constraint rule requires all directed_action entities that are
used as a work_order to have a release date, start date, initiator,
approval, and at least one referenced_product.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE work_order_constraint FOR (directed_action);
END_RULE; -- work_order_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
For each directed_action that is the assigned_action for a (change) 
(start_order) SELF shall participate as an items in 
(a date_assignment {whose role.name = 'release date'} 
 {whose assigned_date is a calendar_date}) 
(a date_and_time_assignment whose role.name = 'release date').
</Informal.propositions.rul>
<Informal.propositions.rul>
For each directed_action that is the assigned_action for a (change) 
(start_order) SELF shall participate as an items in (a date_assignment 
{whose role.name = 'start date'} {whose assigned_date is a calendar_date}) 
(a date_and_time_assignment whose role.name = 'start date').
</Informal.propositions.rul>
<Informal.propositions.rul>
For each directed_action that is the assigned_action for a (change) 
(start_order) SELF shall participate as an items of at least one 
(organization_assignment whose role.name = 'initiator') 
(person_and_organization_assignment whose role.name = 'initiator').
</Informal.propositions.rul>
<Informal.propositions.rul>
For each directed_action that is the assigned_action for a (change) 
(start_order) the (change) (start_order) shall be an item of an 
approval_assignment.
</Informal.propositions.rul>
<Informal.propositions.rul>
For each directed_action that is the assigned_action for a (change) 
(start_order) the (change) (start_order) shall have at least one items that 
is a product_definition_formation.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="work_order_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The work_order_unique_constraint rule constrains the directed_action population members, that
fill the role of ARM work_order, to be uniquely identifiable.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE work_order_unique_constraint FOR
 ( directed_action );
LOCAL
  r : BAG OF directed_action := 
    QUERY( r <* directed_action | (SIZEOF(QUERY( aa <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'ACTION_ASSIGNMENT.ASSIGNED_ACTION' ) |
((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'CHANGE') IN TYPEOF(aa)) OR
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'START_WORK') IN TYPEOF(aa))))) > 0 ) );
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(r) by 1;
  IF EXISTS( r[i].directive\action_directive.name ) THEN
    IF ( r[i].directive\action_directive.name IN name_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i].directive\action_directive.name;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- work_order_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of directed_action that is an assigned_action
of either a change or a start_work must have a unique name
attribute value.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="work_request_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The work_request_constraint rule constrains the use of a directed_action
when it is used as a work_request.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE work_request_constraint FOR (versioned_action_request);
END_RULE; -- work_request_constraint
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
For each versioned_action_request that participates as an
assigned_action_request for a (change_request) (start_request) SELF shall
participate as an items for an (applied_date_assignment {whose role is a
date_role.name = 'request date'} {has an assigned_date that is a
calendar_date}).
</Informal.propositions.rul>
<Informal.propositions.rul>
For each versioned_action_request that participates as an
assigned_action_request for a (change_request) (start_request) SELF shall
participate as an items of at least one (organization_assignment whose
role.name = 'initiator') (person_and_organization_assignment whose
role.name = 'initiator').
</Informal.propositions.rul>
<Informal.propositions.rul>
For each versioned_action_request that participates as an
assigned_action_request for a (change_request) (start_request) SELF shall
participate as an assigned_request for an action_request_status.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each versioned_action_request that participates as an 
assigned_action_request for a (change_request) (start_request) shall 
participate in an approval.
</Informal.propositions.rul>
<Informal.propositions.rul>
For each versioned_action_request that participates as an 
assigned_action_request for a (change_request) (start_request) SELF shall
have at least one product_definition_formation as an item.
</Informal.propositions.rul>
<Informal.propositions.rul>
For each versioned_action_request that participates as an 
assigned_action_request for a (change_request) (start_request) SELF shall
participate as an items in at least one 
(applied_person_and_organization_assignment whose role.name = 'request
recipient') (applied_organization_assignment whose role.name = 'request
recipient').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="work_request_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The work_request_unique_constraint rule constrains the versioned_action_request population members, that
fill the role of ARM work_request, to be uniquely identifiable.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE work_request_unique_constraint FOR
 ( versioned_action_request );
LOCAL
  r : BAG OF versioned_action_request := 
QUERY( r <* versioned_action_request | 
(SIZEOF(QUERY( ara <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST' ) |
((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'CHANGE_REQUEST') IN TYPEOF(ara)) OR
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'START_REQUEST') IN TYPEOF(ara))))) > 0 ) );
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF ( r[i].id IN id_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- work_request_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of versioned_action_request that is an assigned_action_request
of either a change_request or a start_request must have a unique id
attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

</MULTI.RULE.DEFS.CL3>
</RULE.DEFS.SECTION>
<FUNCTION.DEFS.SECTION>
<MULTI.FUNCTION.DEFS.CL3>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="applied_date_correlation">
<FUNCTION.DESCRIPTION>
The applied_date_correlation function returns true if the
applied_date_assignment has the appropriate entities referenced in the set
of items for the role of the date_assignment.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION applied_date_correlation
  (e : applied_date_assignment;
  schema_name : STRING) : BOOLEAN;
  LOCAL
    d_role : STRING;
  END_LOCAL;
    d_role := e\date_assignment.role\date_role.name;
  CASE d_role OF
    'creation date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                (SIZEOF( [schema_name +
                                '.PRODUCT_DEFINITION',
                                schema_name +
                                '.DOCUMENT'] *
                                TYPEOF (x)) >= 1 )))
                                THEN RETURN(FALSE);
                              END_IF;
    'request date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.VERSIONED_ACTION_REQUEST'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'release date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign off date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification date'    : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification date'   : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification date' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="applied_date_time_correlation">
<FUNCTION.DESCRIPTION>
The applied_date_time_correlation function returns true if the
applied_date_and_time_assignment has the appropriate entities referenced in
the set of items for the role of the date_and_time_assignment.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION applied_date_time_correlation
  (e : applied_date_and_time_assignment;
  schema_name : STRING) : BOOLEAN;
  LOCAL
    dt_role : STRING;
  END_LOCAL;
    dt_role := e\date_and_time_assignment.role\date_time_role.name;
  CASE dt_role OF
    'creation date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                               (SIZEOF( [schema_name +
                                '.PRODUCT_DEFINITION',
                                schema_name +
                                '.DOCUMENT'] *
                                TYPEOF (x)) >= 1 )))
                                THEN RETURN(FALSE);
                              END_IF;
    'request date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.VERSIONED_ACTION_REQUEST'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'release date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign off date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification date'    : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification date'   : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification date' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'participant date and time' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.RULE_ACTION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="bag_to_set">
<FUNCTION.DESCRIPTION>
The bag_to_set function returns a set that is the subset of the bag which is the input.
<note>
This function is used in uniqueness tests.
</note>
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION  bag_to_set

      ( the_bag : BAG OF GENERIC : intype ) : SET OF GENERIC : intype ;

LOCAL

      the_set : SET OF GENERIC : intype := [];
      i : INTEGER ;

END_LOCAL ;

      IF SIZEOF (the_bag) > 0 THEN
            REPEAT i := 1 TO HIINDEX (the_bag);
                  the_set := the_set + the_bag[i];
            END_REPEAT ;
      END_IF ;
      RETURN (the_set);

END_FUNCTION ;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="component_definition_located_by_component_location">
<FUNCTION.DESCRIPTION>
The component_definition_located_by_component_location function returns the first component_definition located by the component_location passed to the function or returns the first member of an empty BAG if none is found.
<note>
The first component_definition should be the only component_definition located.
</note>
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION component_definition_located_by_component_location 
                   (cl : component_location) : component_definition; 
LOCAL
  pdr : BAG OF property_definition_representation := USEDIN (cl,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
END_LOCAL;
   REPEAT i := 1 TO HIINDEX(pdr) BY 1;
    IF(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN 
                                  TYPEOF (pdr[i].definition.definition))
        AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_DEFINITION' IN 
        TYPEOF (pdr[i].definition.definition\product_definition_relationship.
                                                  related_product_definition)))
     THEN 
      RETURN(pdr[i].definition.definition\product_definition_relationship.
                                                   related_product_definition);
    END_IF;
   END_REPEAT;
 RETURN (?);
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_ee_product_definition">
<FUNCTION.DESCRIPTION>
The consistent_bus_structural_definition function returns true if the set of bus_element_link form a valid graph structure, meeting the requirements for vertices being connected, the number of vertices being 1 greater than the number of edges, and no vertex degree greater than 2.
<note>
A bus_element_link is input_rel.related_product_definition.
</note> 
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION consistent_bus_structural_definition
     (input_rel : SET [1:?] OF product_definition_relationship) : BOOLEAN;    

LOCAL  
        input : SET OF product_definition := [];
       vertex : SET OF product_definition := []; 
         edge : INTEGER := SIZEOF(input);
           vc : INTEGER := 0;
vertex_degree : INTEGER := 0;    
END_LOCAL;    

REPEAT i := 1 to SIZEOF(input_rel) BY 1;
      input := input + input_rel[i].related_product_definition;
END_REPEAT;

REPEAT i := 1 TO SIZEOF(input) BY 1;
      vertex := vertex + input[i]\product_definition_relationship.relating_product_definition;
      vertex := vertex + input[i]\product_definition_relationship.related_product_definition;
END_REPEAT;
     vc := SIZEOF(vertex);
    IF ( vc <> ( edge + 1 )) THEN 
      RETURN(FALSE);
    END_IF;
REPEAT i := 1 TO vc BY 1;
      vertex_degree := 0;
      REPEAT j := 1 to SIZEOF(input) BY 1;
        IF input[j]\product_definition_relationship.relating_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
        IF input[j]\product_definition_relationship.related_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
      END_REPEAT;
      IF (vertex_degree > 2) THEN
        RETURN(FALSE);
      END_IF;
END_REPEAT;    
RETURN(TRUE);  
END_FUNCTION; -- consistent_bus_structural_definition
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="cto2d_determinant_test">
<FUNCTION.DESCRIPTION>
The cto2d_determinant_test function returns true if the expected_value is within the bounds defined by the delta value.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION cto2d_determinant_test (cto2d: cartesian_transformation_operator_2d;
                             expected_value: REAL; delta: REAL ) : BOOLEAN;

LOCAL
  det : REAL := 0.0;
  DRs : LIST [4:4] OF REAL := [];
END_LOCAL;
     DRs[1] := cto2d.u[1].direction_ratios[1];
     DRs[2] := cto2d.u[1].direction_ratios[2];
     DRs[3] := cto2d.u[2].direction_ratios[1];
     DRs[4] := cto2d.u[2].direction_ratios[2];
     det  :=  (DRs[1] * DRs[4]) - (DRs[2] * DRs[3]);
IF (Abs(expected_value - det) < Abs(delta) ) THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_assembly_module_design">
<FUNCTION.DESCRIPTION>
The is_assembly_module_design function returns true if the product_definition is an implementation of the ARM concept of Assembly_module.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_assembly_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_assembly_module_macro_occurrence">
<FUNCTION.DESCRIPTION>
The is_assembly_module_macro_occurrence function returns true if the product_definition is an implementation of the ARM concept of Assembly_module_macro_component.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_assembly_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_assembly_module_occurrence">
<FUNCTION.DESCRIPTION>
The is_assembly_module_occurrence function returns true if the product_definition is an implementation of the ARM concept of Assembly_module_component.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_assembly_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_assembly_module_usage">
<FUNCTION.DESCRIPTION>
The is_assembly_module_usage function returns true if the product_definition is an implementation of the ARM concept of Assembly_module_usage_view.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_assembly_module_usage ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design usage'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_ee_product_definition">
<FUNCTION.DESCRIPTION>
The is_ee_product_definition function returns true if the product_definition is an implementation of the ARM concept of Ee_product_definition.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_ee_product_definition ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (NOT(is_laminate_component(pd)) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF(pd))) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'STRATUM' IN TYPEOF(pd))) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NETWORK_NODE_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd)))
   ) 
THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_interconnect_module_component_location">
<FUNCTION.DESCRIPTION>
The is_interconnect_module_component_location function returns true if the component_location is the location of an implementation of the ARM concept of Interconnect_module_component.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_interconnect_module_component_location ( cl: component_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_interconnect_module_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_interconnect_module_design">
<FUNCTION.DESCRIPTION>
The is_interconnect_module_design function returns true if the product_definition is an implementation of the ARM concept of Interconnect_module.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_interconnect_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_interconnect_module_macro_occurrence">
<FUNCTION.DESCRIPTION>
The is_interconnect_module_macro_occurrence function returns true if the product_definition is an implementation of the ARM concept of Interconnect_module_macro_component.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_interconnect_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_interconnect_module_occurrence">
<FUNCTION.DESCRIPTION>
The is_interconnect_module_occurrence function returns true if the product_definition is an implementation of the ARM concept of Interconnect_module_component.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_interconnect_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_interconnect_module_usage">
<FUNCTION.DESCRIPTION>
The is_interconnect_module_usage function returns true if the product_definition is an implementation of the ARM concept of Interconnect_module_usage_view.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_interconnect_module_usage ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design usage'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_laminate_component">
<FUNCTION.DESCRIPTION>
The is_laminate_component function returns true if the product_definition is an implementation of the ARM concept of Laminate_component or of the ARM concept of Printed_component.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_laminate_component ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (pd\product_definition.description = 'laminate component') THEN
    RETURN (TRUE);
ELSE
  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PRINTED_COMPONENT' IN TYPEOF(pd)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;
RETURN (pass);
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="is_laminate_component_location">
<FUNCTION.DESCRIPTION>
The is_laminate_component_location function returns true if the component_location is the location of an implementation of the ARM concept of Laminate_component.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION is_laminate_component_location ( cl: component_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_laminate_component(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="instance_unique">
<FUNCTION.DESCRIPTION>
The instance_unique function returns TRUE when all elements in the given aggregate C are unique instances, else FALSE is returned.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION instance_unique 

      ( the_bag : BAG OF GENERIC : intype ) : BOOLEAN;

LOCAL

      the_set : SET OF GENERIC : intype := [];
      i : INTEGER ;
      pass : BOOLEAN := TRUE;
END_LOCAL ;

      IF SIZEOF (the_bag) > 0 THEN
                  the_set := bag_to_set(the_bag);
      END_IF ;
      IF NOT(SIZEOF(the_set) = SIZEOF(the_bag)) THEN
       pass := FALSE;
      END_IF;

      RETURN (pass);

END_FUNCTION ;
(*
</EXPRESS.CODE>

</FUNCTION.DEF>
</FUNCTION.DEF.CL4>
<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="unique_version_change_order">
<FUNCTION.DESCRIPTION>
The unique_version_change_order boolean function accepts an action
as input and returns true if the ordered_action invoked by the
action incorporates requested_action entities which reference
different product_definition_formation entities and those
product_definition_formation entities reference different product entities.
This function will return false if the requested_action entities reference
product_definition_formation entities that are incorporated by an
action and those product_definition_formation entities reference the
same product.  This function will be true if a change modifies one version 
for each product considered, where multiple products are considered.  A
single change shall not modify different versions of a single product.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION unique_version_change_order (c : action;
  schema_name : STRING) : BOOLEAN;
LOCAL ords       : action_directive := c\directed_action.directive; 
assign     : SET OF action_request_assignment := []; 
versions   : SET OF product_definition_formation := []; 
END_LOCAL;
  -- build the set of change_requests that are the assigned
  -- versioned_action_requests incorporated by the action_directive

  REPEAT i := 1 TO SIZEOF(ords.requests);
  assign := assign + QUERY (ara <* bag_to_set (USEDIN (ords.requests[i],
            schema_name + '.ACTION_REQUEST_ASSIGNMENT.' +
            'ASSIGNED_ACTION_REQUEST')) | 
            schema_name + '.CHANGE_REQUEST'
             IN TYPEOF (ara));
  END_REPEAT;

  -- gather the product_definition_formations that are referenced by the
  -- change_requests

  REPEAT k := 1 TO SIZEOF(assign);
    versions := versions + assign[k]\change_request.items;
  END_REPEAT;

  -- check that no more than one product_definition_formation 
  -- references the same
  -- instance of product

  RETURN (SIZEOF (QUERY (vers <* versions |
          NOT (SIZEOF (QUERY (other_vers <* versions - vers |
          vers.of_product :=: other_vers.of_product)) = 0))) = 0);
END_FUNCTION;
(*
</EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

<FUNCTION.DEF.CL4>
<FUNCTION.DEF NAME="valid_2d_wireframe_edge_curve">
<FUNCTION.DESCRIPTION>
The valid_2d_wireframe_edge_curve function determines whether or not an input
curve is valid for use in representing a shape defined by a two-dimensional
topologically bounded wireframe.
</FUNCTION.DESCRIPTION>
<EXPRESS.CODE>
*)
FUNCTION valid_2d_wireframe_edge_curve
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- recursively check for valid basic curve types
  IF SIZEOF ([schma + '.LINE',
              schma + '.B_SPLINE_CURVE',
              schma + '.CIRCLE',
              schma + '.HYPERBOLA',
              schma + '.ELLIPSE',
              schma + '.PARABOLA',
              schma + '.POLYLINE'] * TYPEOF (crv)) = 1
      THEN RETURN (TRUE);
  ELSE
    -- recursively check for valid basic curves for curve_replicas
    IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\curve_replica.parent_curve, schma));
    -- recursively check for valid basis curves for offset_curves
    ELSE
      IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF (crv)
        THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\offset_curve_2d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
(*
</EXPRESS.CODE>


<ARGUMENT.DEF.GROUP>

<DEF.GROUP>

<FORMAL.DEFINITION>
<TERM>crv</TERM>
<DESCRIPTION> the input curve that is to be examined.
</DESCRIPTION>
</FORMAL.DEFINITION>
<FORMAL.DEFINITION>
<TERM>schma</TERM>
<DESCRIPTION> the input string that defines the schema in which the crv is defined
to be used for type checking.
</DESCRIPTION>
</FORMAL.DEFINITION>
</DEF.GROUP>
</ARGUMENT.DEF.GROUP>

<!--valid_wireframe_vertex_point

The valid_wireframe_vertex_point function determines whether or not an input
point is valid for use in representing a shape defined by a topologically
bounded wireframe.

EXPRESS specification:


-->
<END.SCHEMA.EXPRESS.CODE>
*)
END_SCHEMA;
(*
</END.SCHEMA.EXPRESS.CODE>
</FUNCTION.DEF>
</FUNCTION.DEF.CL4>

</MULTI.FUNCTION.DEFS.CL3>
</FUNCTION.DEFS.SECTION>
</AIM.EXP.SHORT.LISTING.SUBC>
*)
(*

	WG12 N525 								2000-05-30

	EXPRESS Declarations for ISO 10303-41: 2nd Edition
*)

SCHEMA application_context_schema;
REFERENCE FROM basic_attribute_schema                   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   id_attribute);
REFERENCE FROM date_time_schema                         -- ISO 10303-41
  (year_number);
REFERENCE FROM support_resource_schema                  -- ISO 10303-41
  (identifier,
   label,
   text);

ENTITY application_context;
  application      : label;
DERIVE
  description      : text := get_description_value (SELF);
  id               : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET [1:?] OF application_context_element
                               FOR frame_of_reference;
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- application_context

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (library_context,
                       product_concept_context,
                       product_context,
                       product_definition_context));
  name               : label;
  frame_of_reference : application_context;
END_ENTITY; -- application_context_element

ENTITY application_context_relationship;
  name             : label;
  description      : OPTIONAL text;
  relating_context : application_context;
  related_context  : application_context;
END_ENTITY; -- application_context_relationship;

ENTITY application_protocol_definition;
  status                                    : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year                 : year_number;
  application                               : application_context;
END_ENTITY; -- application_protocol_definition;

ENTITY library_context
  SUBTYPE OF (application_context_element);
  library_reference : label;
END_ENTITY; -- library_context

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY; -- product_concept_context

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY; -- product_context

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY; -- product_definition_context

END_SCHEMA; -- application_context_schema

SCHEMA product_definition_schema;
REFERENCE FROM application_context_schema              -- ISO 10303-41
  (product_context,
   product_definition_context);
REFERENCE FROM basic_attribute_schema                  -- ISO 10303-41
  (get_id_value,
   get_name_value,
   name_attribute);
REFERENCE FROM document_schema                         -- ISO 10303-41
  (document);
REFERENCE FROM effectivity_schema                      -- ISO 10303-41
  (effectivity);
REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE source = ENUMERATION OF
  (made,
   bought,
   not_known);
END_TYPE; -- source

ENTITY product;
  id                 : identifier;
  name               : label;
  description        : OPTIONAL text;
  frame_of_reference : SET [1:?] OF product_context;
END_ENTITY; -- product

ENTITY product_category;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- product_category

ENTITY product_category_relationship;
  name          : label;
  description   : OPTIONAL text;
  category      : product_category;
  sub_category  : product_category;
WHERE
  WR1: acyclic_product_category_relationship
      (SELF, [SELF.sub_category]);
END_ENTITY; -- product_category_relationship

ENTITY product_definition;
  id                 : identifier;
  description        : OPTIONAL text;
  formation          : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name               : label := get_name_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- product_definition

ENTITY product_definition_context_association;
  definition         : product_definition;
  frame_of_reference : product_definition_context;
  role               : product_definition_context_role;
END_ENTITY; -- product_definition_context_association

ENTITY product_definition_context_role;
 name        : label;
 description : OPTIONAL text ;
END_ENTITY; -- product_definition_context_role

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' +
               'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY; -- product_definition_effectivity

ENTITY product_definition_formation;
  id          : identifier;
  description : OPTIONAL text;
  of_product  : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY; -- product_definition_formation

ENTITY product_definition_formation_relationship;
  id                                    : identifier;
  name                                  : label;
  description                           : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation  : product_definition_formation;
END_ENTITY; -- product_definition_formation_relationship

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY; -- product_definition_formation_with_specified_source

ENTITY product_definition_relationship;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition  : product_definition;
END_ENTITY; -- product_definition_relationship

ENTITY product_definition_substitute;
  description           : OPTIONAL text;
  context_relationship  : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name                  : label := get_name_value (SELF);
WHERE
  WR1 : context_relationship.related_product_definition :<>:
        substitute_definition;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- product_definition_substitute

ENTITY product_definition_with_associated_documents
  SUBTYPE OF(product_definition);
  documentation_ids : SET[1:?] OF document;
END_ENTITY; -- product_definition_with_associated_documents

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET [1:?] OF product;
END_ENTITY; -- product_related_product_category

ENTITY product_relationship;
  id               : identifier;
  name             : label;
  description      : OPTIONAL text;
  relating_product : product;
  related_product  : product;
END_ENTITY; -- product_relationship

FUNCTION acyclic_product_category_relationship
  (relation : product_category_relationship;
   children : SET of product_category): BOOLEAN;
  LOCAL 
    x              : SET OF product_category_relationship;
    local_children : SET OF product_category;
  END_LOCAL;
  REPEAT i := 1 to HIINDEX(children);
    IF relation.category :=: children [i] THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  x := bag_to_set(USEDIN (relation.category,
                          'PRODUCT_DEFINITION_SCHEMA.' + 
                          'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
  local_children := children + relation.category;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 to HIINDEX(x);
      IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_category_relationship

FUNCTION acyclic_product_definition_formation_relationship
  (relation          : product_definition_formation_relationship;
   relatives         : SET [1:?] OF product_definition_formation;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF product_definition_formation_relationship;
  END_LOCAL;
  IF relation.relating_product_definition_formation IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (pdf <* bag_to_set 
             (USEDIN (relation.relating_product_definition_formation,
             'PRODUCT_DEFINITION_SCHEMA.' + 
             'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' +
             'RELATED_PRODUCT_DEFINITION_FORMATION')) |
              specific_relation IN TYPEOF (pdf));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_formation_relationship
      (x[i], 
       relatives + relation.relating_product_definition_formation, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_definition_formation_relationship

FUNCTION acyclic_product_definition_relationship
  (relation          : product_definition_relationship;
   relatives         : SET [1:?] OF product_definition;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF product_definition_relationship;
  END_LOCAL;
  IF relation.relating_product_definition IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (pd <* bag_to_set 
             (USEDIN (relation.relating_product_definition,
             'PRODUCT_DEFINITION_SCHEMA.' + 
             'PRODUCT_DEFINITION_RELATIONSHIP.' +
             'RELATED_PRODUCT_DEFINITION')) |
              specific_relation IN TYPEOF (pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_relationship
      (x[i], 
       relatives + relation.relating_product_definition, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_definition_relationship

FUNCTION acyclic_product_relationship
  (relation          : product_relationship;
   relatives         : SET [1:?] OF product;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF product_relationship;
  END_LOCAL;
  IF relation.relating_product IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (prod <* bag_to_set 
             (USEDIN (relation.relating_product,
             'PRODUCT_DEFINITION_SCHEMA.' + 
             'PRODUCT_RELATIONSHIP.' +
             'RELATED_PRODUCT')) |
              specific_relation IN TYPEOF (prod));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_relationship
      (x[i], 
       relatives + relation.relating_product, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_relationship

FUNCTION get_product_definitions 
      ( c_def_instance : product ) : SET OF product_definition;
      
      LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
      END_LOCAL;
      
 pd_set := bag_to_set (USEDIN (c_def_instance,
  'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
 IF (SIZEOF (pd_set) < 1 ) THEN RETURN (pdr_set);
 END_IF;

 REPEAT i:= 1 to HIINDEX (pd_set);
    pdr_set := pdr_set + bag_to_set (USEDIN (pd_set[i],
    'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
 END_REPEAT;
 RETURN (pdr_set);
END_FUNCTION;

END_SCHEMA; -- product_definition_schema

SCHEMA product_property_definition_schema;
REFERENCE FROM process_property_schema                   -- ISO 10303-49
  (action_property,
   resource_property);
REFERENCE FROM product_definition_schema                 -- ISO 10303-41
  (product_definition,
   product_definition_relationship);
REFERENCE FROM support_resource_schema                   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);
REFERENCE FROM basic_attribute_schema                    -- ISO 10303-41
       (get_id_value,
       id_attribute);

TYPE characterized_definition = SELECT
  (characterized_object,
   characterized_product_definition,
   shape_definition);
END_TYPE; -- characterized_definition

TYPE characterized_product_definition = SELECT
  (product_definition,
   product_definition_relationship);
END_TYPE; -- characterized_product_definition

TYPE derived_property_select = SELECT
  (property_definition,
   action_property,
   resource_property);
END_TYPE; -- derived_property_select

TYPE shape_definition = SELECT
  (product_definition_shape,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE; -- shape_definition

ENTITY characterized_object;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- characterized_object

ENTITY characterized_object_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_object : characterized_object;
  related_object  : characterized_object;
END_ENTITY; -- characterized_object_relationship

ENTITY general_property;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- general_property

ENTITY general_property_association;
  name               : label;
  description        : OPTIONAL text;
  base_definition    : general_property;
  derived_definition : derived_property_select;
 WHERE
  WR1: SIZEOF( USEDIN( derived_definition,
                       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
                       'GENERAL_PROPERTY_ASSOCIATION.' + 
                       'DERIVED_DEFINITION')) = 1;
  WR2: derived_definition.name = base_definition.name;
END_ENTITY; -- general_property_association

ENTITY general_property_relationship; 
  name              : label;
  description       : OPTIONAL text;
  relating_property : general_property;
  related_property  : general_property;
END_ENTITY; -- general_property_relationship

ENTITY product_definition_shape
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.definition;
WHERE
     WR1: SIZEOF
     (['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION',  
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] *
        TYPEOF (SELF\property_definition.definition))>0;
END_ENTITY; -- product_definition_shape

ENTITY property_definition;
  name        : label;
  description : OPTIONAL text;
  definition  : characterized_definition;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- property_definition

ENTITY shape_aspect;
  name                 : label;
  description          : OPTIONAL text;
  of_shape             : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- shape_aspect

ENTITY shape_aspect_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect  : shape_aspect;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- shape_aspect_relationship

FUNCTION acyclic_characterized_object_relationship
  (relation          : characterized_object_relationship;
   relatives         : SET [1:?] OF characterized_object;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF characterized_object_relationship;
  END_LOCAL;
  IF relation.relating_object IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ca <* bag_to_set 
             (USEDIN (relation.relating_object,
             'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
             'CHARACTERIZED_OBJECT_RELATIONSHIP.' +
             'RELATED_OBJECT')) |
              specific_relation IN TYPEOF (ca));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_characterized_object_relationship
      (x[i], 
       relatives + relation.relating_object, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_characterized_object_relationship

FUNCTION acyclic_general_property_relationship
  (relation          : general_property_relationship;
   relatives         : SET [1:?] OF general_property;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF general_property_relationship;
  END_LOCAL;
  IF relation.relating_property IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (genp <* bag_to_set 
             (USEDIN (relation.relating_property,
             'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
             'GENERAL_PROPERTY_RELATIONSHIP.' +
             'RELATED_PROPERTY')) |
              specific_relation IN TYPEOF (genp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_general_property_relationship
      (x[i], 
       relatives + relation.relating_property, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_general_property_relationship

FUNCTION acyclic_shape_aspect_relationship
  (relation          : shape_aspect_relationship;
   relatives         : SET [1:?] OF shape_aspect;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF shape_aspect_relationship;
  END_LOCAL;
  IF relation.relating_shape_aspect IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (sa <* bag_to_set 
             (USEDIN (relation.relating_shape_aspect,
             'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
             'SHAPE_ASPECT_RELATIONSHIP.' +
             'RELATED_SHAPE_ASPECT')) |
              specific_relation IN TYPEOF (sa));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_shape_aspect_relationship
      (x[i], 
       relatives + relation.relating_shape_aspect, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_shape_aspect_relationship

FUNCTION get_shape_aspects 
      ( c_def_instance : characterized_definition ) : SET OF shape_aspect;
      
      LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
      END_LOCAL;
  pd_set := bag_to_set (QUERY(pd <* USEDIN (c_def_instance,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
      | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF(pd)));
 IF (SIZEOF (pd_set) < 1 ) THEN RETURN (pdr_set);
 END_IF;

 REPEAT i:= 1 to HIINDEX (pd_set);
    pdr_set := pdr_set + bag_to_set (USEDIN (pd_set[i],
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
 END_REPEAT;
 RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA; -- product_property_definition_schema

SCHEMA product_property_representation_schema;
REFERENCE FROM basic_attribute_schema                    -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute);
REFERENCE FROM material_property_definition_schema       -- ISO 10303-45
  (property_definition_relationship);
REFERENCE FROM product_definition_schema                 -- ISO 10303-41
  (product_definition,
   product_definition_relationship);
REFERENCE FROM product_property_definition_schema        -- ISO 10303-41
  (characterized_definition,
   general_property,
   product_definition_shape,
   property_definition,
   shape_aspect,
   shape_aspect_relationship);
REFERENCE FROM representation_schema                     -- ISO 10303-43
  (representation,
   representation_item,
   representation_relationship,
   using_representations);
REFERENCE FROM support_resource_schema                   -- ISO 10303-41
  (bag_to_set,
   label,
   text);

TYPE represented_definition = SELECT
  (general_property,
   property_definition,
   property_definition_relationship,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE; -- represented_definition

ENTITY context_dependent_shape_representation;
  representation_relation      : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description                  : text := get_description_value (SELF);
  name                         : label := get_name_value (SELF);
WHERE
  WR1 : 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP'
         IN TYPEOF (SELF.represented_product_relation.definition);
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- context_dependent_shape_representation

ENTITY item_identified_representation_usage;
  name                : label;
  description         : OPTIONAL text;
  definition          : represented_definition;  
  used_representation : representation;    
  identified_item     : representation_item;
WHERE
  WR1: SELF.used_representation IN 
       using_representations(SELF.identified_item);
END_ENTITY; -- item_identified_representation_usage

ENTITY property_definition_representation;
  definition          : represented_definition;
  used_representation : representation;
DERIVE
  description         : text := get_description_value (SELF);
  name                : label := get_name_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- property_definition_representation

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
       TYPEOF (SELF.definition))
       OR
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN
       TYPEOF (SELF.definition.definition));
  WR2: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN
       TYPEOF(SELF.used_representation);
END_ENTITY; -- shape_definition_representation

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY; -- shape_representation

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN
       (TYPEOF(SELF\representation_relationship.rep_1) +
        TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY; -- shape_representation_relationship

FUNCTION relatives_of_product_definitions
  (definition_set   : SET OF product_definition;
   relation_subtype : STRING) : SET OF product_definition;
  FUNCTION local_relatives_of_product_definitions
    (definition_set    : SET OF product_definition;
     total_definitions : SET OF product_definition;
     relation_subtype  : STRING) : SET OF product_definition;
  LOCAL
    local_def   : SET OF product_definition := [];
    local_pdr   : SET OF product_definition_relationship := [];
    local_total : SET OF product_definition := [];
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(definition_set);
    local_pdr := local_pdr +
                 bag_to_set(USEDIN
                   (definition_set[i],
                    relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(local_pdr);
    local_def := local_def + local_pdr[i].related_product_definition;
  END_REPEAT;
  IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
    RETURN (local_def);
  ELSE
    local_total := total_definitions + local_def;
    RETURN(local_def +
          (local_relatives_of_product_definitions
          (local_def - total_definitions, local_total, relation_subtype)));
  END_IF;
  END_FUNCTION; -- local_relatives_of_product_definitions
RETURN (local_relatives_of_product_definitions
       (definition_set, definition_set, relation_subtype));
END_FUNCTION; -- relatives_of_product_definitions

FUNCTION relatives_of_shape_representations
   (shape_representation_set : SET OF shape_representation) :
    SET OF shape_representation;
  FUNCTION local_relatives_of_shape_representations
     (shape_representation_set : SET OF shape_representation;
      total_reps    : SET OF shape_representation) : SET OF
      shape_representation;
    LOCAL
      local_shape_rep : SET OF shape_representation := [];
      local_srr       : SET OF shape_representation_relationship := [];
      local_total     : SET OF shape_representation := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(shape_representation_set);
      local_srr := local_srr + QUERY (rr <* bag_to_set
      (USEDIN(shape_representation_set[i],
       'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1'))|
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP'
      IN TYPEOF (rr));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(local_srr);
      IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+
                  'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i])
      THEN
         local_shape_rep := local_shape_rep + local_srr[i].rep_2;
      END_IF;
    END_REPEAT;
    IF SIZEOF (local_shape_rep - total_reps) = 0 THEN
      RETURN (shape_representation_set);
    ELSE
      local_total := total_reps + local_shape_rep;
      RETURN(local_shape_rep + (local_relatives_of_shape_representations
                               (local_shape_rep - total_reps, local_total)));
    END_IF;
  END_FUNCTION;
  RETURN (local_relatives_of_shape_representations
          (shape_representation_set, shape_representation_set));
END_FUNCTION; -- relatives_of_shape_representations

FUNCTION get_property_definition_representations 
      ( c_def_instance : characterized_definition ) : SET OF property_definition_representation;
      
      LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
      END_LOCAL;
      
 pd_set := bag_to_set (USEDIN (c_def_instance,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
 IF (SIZEOF (pd_set) < 1 ) THEN RETURN (pdr_set);
 END_IF;

 REPEAT i:= 1 to HIINDEX (pd_set);
    pdr_set := pdr_set + bag_to_set (USEDIN (pd_set[i],
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
 END_REPEAT;
 RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA; -- product_property_representation_schema

SCHEMA management_resources_schema;
REFERENCE FROM action_schema;                      -- ISO 10303-41
REFERENCE FROM application_context_schema          -- ISO 10303-41
  (library_context);
REFERENCE FROM approval_schema;                    -- ISO 10303-41
REFERENCE FROM basic_attribute_schema              -- ISO 10303-41
  (get_role,
  object_role,
  role_association);
REFERENCE FROM certification_schema;               -- ISO 10303-41
REFERENCE FROM contract_schema;                    -- ISO 10303-41
REFERENCE FROM date_time_schema;                   -- ISO 10303-41
REFERENCE FROM document_schema;                    -- ISO 10303-41
REFERENCE FROM effectivity_schema;                 -- ISO 10303-41
REFERENCE FROM external_reference_schema           -- ISO 10303-41
  (external_source);
REFERENCE FROM group_schema;                       -- ISO 10303-41
REFERENCE FROM person_organization_schema;         -- ISO 10303-41
REFERENCE FROM security_classification_schema;     -- ISO 10303-41
REFERENCE FROM support_resource_schema;            -- ISO 10303-41

TYPE attribute_type = SELECT
  (label,
   text);
END_TYPE; -- attribute_type

ENTITY action_assignment
  ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role            : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- action_assignment

ENTITY action_method_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_method : action_method;
  role                   : action_method_role;
END_ENTITY; -- action_method_assignment

ENTITY action_method_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- action_method_role

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role                    : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- action_request_assignment

ENTITY approval_assignment
  ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role              : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- approval_assignment

ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class          : group;
  attribute_name          : label;
  role                    : classification_role;
END_ENTITY; -- attribute_classification_assignment

ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE;
  attribute_name  : label;
  attribute_value : attribute_type;
  role            : attribute_value_role;
END_ENTITY; -- attribute_value_assignment

ENTITY attribute_value_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- attribute_value_role

ENTITY certification_assignment
  ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role                   : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- certification_assignment

ENTITY classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class          : group;
  role                    : classification_role;
END_ENTITY; -- classification_assignment

ENTITY classification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- classification_role

ENTITY contract_assignment
  ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role              : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; --  contract_assignment

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role                   : date_time_role;
END_ENTITY; -- date_and_time_assignment

ENTITY date_assignment
  ABSTRACT SUPERTYPE;
  assigned_date : date;
  role          : date_role;
END_ENTITY; -- date_assignment

ENTITY document_reference
  ABSTRACT SUPERTYPE;
  assigned_document : document;
  source            : label;
DERIVE
  role              : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- document_reference

ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role                    : document_usage_role;
END_ENTITY; -- document_usage_constraint_assignment

ENTITY document_usage_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- document_usage_role

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role                 : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- effectivity_assignment

ENTITY effectivity_context_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity_assignment : effectivity_assignment;
  role                            : effectivity_context_role;
END_ENTITY; -- effectivity_context_assignment

ENTITY effectivity_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- effectivity_context_role

ENTITY event_occurrence_assignment
  ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role                      : event_occurrence_role;
END_ENTITY; -- event_occurrence_assignment

ENTITY event_occurrence_context_assignment
  ABSTRACT SUPERTYPE;
  assigned_event_occurrence_assignment : event_occurrence_assignment;
  role                                 : event_occurrence_context_role;
END_ENTITY; -- event_occurrence_context_assignment

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY; -- external_identification_assignment

ENTITY external_referent_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role          : object_role := get_role (SELF);
UNIQUE
  UR1 : assigned_name;
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- external_referent_assignment

ENTITY group_assignment
  ABSTRACT SUPERTYPE;
  assigned_group : group;
DERIVE
  role           : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- group_assignment

ENTITY identification_assignment
  ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role        : identification_role;
END_ENTITY; -- identification_assignment

ENTITY identification_assignment_relationship;
  name                               : label;
  description                        : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment  : identification_assignment;
END_ENTITY; -- identification_assignment_relationship

ENTITY identification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- identification_role

ENTITY library_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (external_referent_assignment);
  frame_of_reference : library_context;
UNIQUE
  UR1: frame_of_reference;
END_ENTITY; -- library_assignment

ENTITY name_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role          : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- name_assignment

ENTITY organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role                  : organization_role;
END_ENTITY; -- organization_assignment

ENTITY organizational_project_assignment
ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role                            : organizational_project_role;
END_ENTITY; -- organizational_project_assignment

ENTITY organizational_project_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- organizational_project_role

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role                             : person_and_organization_role;
END_ENTITY; -- person_and_organization_assignment

ENTITY person_assignment
  ABSTRACT SUPERTYPE;
  assigned_person : person;
  role            : person_role;
END_ENTITY; -- person_assignment

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role                             : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- security_classification_assignment

ENTITY time_assignment
  ABSTRACT SUPERTYPE;
  assigned_time : local_time;
  role          : time_role;
END_ENTITY; -- time_assignment

ENTITY time_interval_assignment
  ABSTRACT SUPERTYPE;
  assigned_time_interval : time_interval;
  role                   : time_interval_role;
END_ENTITY; -- time_interval_assignment

FUNCTION acyclic_identification_assignment_relationship
  (relation          : identification_assignment_relationship;
   relatives         : SET [1:?] OF identification_assignment;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF identification_assignment_relationship;
  END_LOCAL;
  IF relation.relating_identification_assignment IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ia <* bag_to_set 
             (USEDIN (relation.relating_identification_assignment,
             'MANAGEMENT_RESOURCES_SCHEMA.' + 
             'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' +
             'RELATED_IDENTIFICATION_ASSIGNMENT')) |
              specific_relation IN TYPEOF (ia));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_identification_assignment_relationship
      (x[i], 
       relatives + relation.relating_identification_assignment, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_identification_assignment_relationship

END_SCHEMA; -- management_resources_schema

SCHEMA document_schema;
REFERENCE FROM product_definition_schema           -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation);
REFERENCE FROM support_resource_schema             -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE product_or_formation_or_definition = SELECT
  (product,
   product_definition_formation,
   product_definition);
END_TYPE; -- product_or_formation_or_definition

ENTITY document;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  kind                : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type
                          FOR represented_document; 
END_ENTITY; -- document

ENTITY document_product_association;
  name              : label;
  description       : OPTIONAL text;
  relating_document : document;
  related_product   : product_or_formation_or_definition;
END_ENTITY; -- document_product_association

ENTITY document_relationship;
  name                : label;
  description         : OPTIONAL text;
  relating_document   : document;
  related_document    : document;
END_ENTITY; -- document_relationship

ENTITY document_representation_type;
  name                 : label;
  represented_document : document;
END_ENTITY; -- document_representation_type

ENTITY document_type;
  product_data_type : label;
END_ENTITY; -- document_type

ENTITY document_usage_constraint;
  source                : document;
  subject_element       : label;
  subject_element_value : text;
END_ENTITY; -- document_usage_constraint

ENTITY document_with_class
  SUBTYPE OF (document);
  class : identifier;
END_ENTITY; -- document_with_class

FUNCTION acyclic_document_relationship
  (relation          : document_relationship;
   relatives         : SET [1:?] OF document;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF document_relationship;
  END_LOCAL;
  IF relation.relating_document IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (doc <* bag_to_set 
             (USEDIN (relation.relating_document,
             'DOCUMENT_SCHEMA.' + 
             'DOCUMENT_RELATIONSHIP.' +
             'RELATED_DOCUMENT')) |
              specific_relation IN TYPEOF (doc));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_document_relationship
      (x[i], 
       relatives + relation.relating_document, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_document_relationship

END_SCHEMA; -- document_schema

SCHEMA action_schema;
REFERENCE FROM basic_attribute_schema                  -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   id_attribute,
   name_attribute);
REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE supported_item = SELECT
  (action_directive,
   action,
   action_method);
END_TYPE; -- supported_item

ENTITY action;
  name          : label;
  description   : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- action

ENTITY action_directive;
  name        : label;
  description : OPTIONAL text;
  analysis    : text;
  comment     : text;
  requests    : SET[1:?] OF versioned_action_request;
END_ENTITY; -- action_directive

ENTITY action_method;
  name        : label;
  description : OPTIONAL text;
  consequence : text;
  purpose     : text;
END_ENTITY; -- action_method

ENTITY action_method_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_method : action_method;
  related_method  : action_method;
END_ENTITY; -- action_method_relationship

ENTITY action_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_action : action;
  related_action  : action;
END_ENTITY; -- action_relationship

ENTITY action_request_solution;
  method      : action_method;
  request     : versioned_action_request;
DERIVE
  description : text := get_description_value (SELF);
  name        : label := get_name_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- action_request_solution

ENTITY action_request_status;
  status           : label;
  assigned_request : versioned_action_request;
END_ENTITY; -- action_request_status

ENTITY action_resource;
  name        : label;
  description : OPTIONAL text;
  usage       : SET [1:?] OF supported_item;
  kind        : action_resource_type;
END_ENTITY; -- action_resource

ENTITY action_resource_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_resource : action_resource;
  related_resource  : action_resource;
END_ENTITY; -- action_resource_relationship

ENTITY action_resource_type;
  name : label;
END_ENTITY; -- action_resource_type

ENTITY action_status;
  status          : label;
  assigned_action : executed_action;
END_ENTITY; -- action_status

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY; -- directed_action

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY; -- executed_action

ENTITY versioned_action_request;
  id          : identifier;
  version     : label;
  purpose     : text;
  description : OPTIONAL text;
END_ENTITY; -- versioned_action_request

FUNCTION acyclic_action_method_relationship
  (relation          : action_method_relationship;
   relatives         : SET [1:?] OF action_method;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF action_method_relationship;
  END_LOCAL;
  IF relation.relating_method IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (am <* bag_to_set 
             (USEDIN (relation.relating_method,
             'ACTION_SCHEMA.' + 
             'ACTION_METHOD_RELATIONSHIP.' +
             'RELATED_METHOD')) |
              specific_relation IN TYPEOF (am));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_method_relationship
      (x[i], 
       relatives + relation.relating_method, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_action_method_relationship

FUNCTION acyclic_action_relationship
  (relation          : action_relationship;
   relatives         : SET [1:?] OF action;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF action_relationship;
  END_LOCAL;
  IF relation.relating_action IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (actn <* bag_to_set 
             (USEDIN (relation.relating_action,
             'ACTION_SCHEMA.' + 
             'ACTION_RELATIONSHIP.' +
             'RELATED_ACTION')) |
              specific_relation IN TYPEOF (actn));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_relationship
      (x[i], 
       relatives + relation.relating_action, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_action_relationship

FUNCTION acyclic_action_resource_relationship
  (relation          : action_resource_relationship;
   relatives         : SET [1:?] OF action_resource;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF action_resource_relationship;
  END_LOCAL;
  IF relation.relating_resource IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ar <* bag_to_set 
             (USEDIN (relation.relating_resource,
             'ACTION_SCHEMA.' + 
             'ACTION_RESOURCE_RELATIONSHIP.' +
             'RELATED_RESOURCE')) |
              specific_relation IN TYPEOF (ar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_resource_relationship
      (x[i], 
       relatives + relation.relating_resource, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_action_resource_relationship

END_SCHEMA; -- action_schema

SCHEMA certification_schema;
REFERENCE FROM support_resource_schema
  (label,
   text);

ENTITY certification;
  name    : label;
  purpose : text;
  kind    : certification_type;
END_ENTITY; -- certification

ENTITY certification_type;
  description : label;
END_ENTITY; -- certification_type

END_SCHEMA; -- certification_schema

SCHEMA approval_schema;
REFERENCE FROM basic_attribute_schema                -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_role,
   object_role,
   role_association);
REFERENCE FROM date_time_schema                      -- ISO 10303-41
  (date_time_select);
REFERENCE FROM person_organization_schema            -- ISO 10303-41
  (person_organization_select);
REFERENCE FROM support_resource_schema               -- ISO 10303-41
  (bag_to_set,
   label,
   text);

ENTITY approval;
  status : approval_status;
  level  : label;
END_ENTITY; -- approval

ENTITY approval_date_time;
  date_time      : date_time_select;
  dated_approval : approval;
DERIVE
  role           : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- approval_date_time

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role                : approval_role;
END_ENTITY; -- approval_person_organization

ENTITY approval_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_approval : approval;
  related_approval  : approval;
END_ENTITY; -- approval_relationship

ENTITY approval_role;
  role        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- approval_role

ENTITY approval_status;
  name : label;
END_ENTITY; -- approval_status

FUNCTION acyclic_approval_relationship
  (relation          : approval_relationship;
   relatives         : SET [1:?] OF approval;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF approval_relationship;
  END_LOCAL;
  IF relation.relating_approval IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (app <* bag_to_set 
             (USEDIN (relation.relating_approval,
             'APPROVAL_SCHEMA.' + 
             'APPROVAL_RELATIONSHIP.' +
             'RELATED_APPROVAL')) |
              specific_relation IN TYPEOF (app));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_approval_relationship
      (x[i], 
       relatives + relation.relating_approval, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_approval_relationship

END_SCHEMA; -- approval_schema

SCHEMA contract_schema;
REFERENCE FROM support_resource_schema              -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

ENTITY contract;
  name    : label;
  purpose : text;
  kind    : contract_type;
END_ENTITY; -- contract

ENTITY contract_relationship;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  relating_contract : contract;
  related_contract  : contract;
END_ENTITY; -- contract_relationship

ENTITY contract_type;
  description : label;
END_ENTITY; -- contract_type

FUNCTION acyclic_contract_relationship
  (relation          : contract_relationship;
   relatives         : SET [1:?] OF contract;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF contract_relationship;
  END_LOCAL;
  IF relation.relating_contract IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (cont <* bag_to_set 
             (USEDIN (relation.relating_contract,
             'CONTRACT_SCHEMA.' + 
             'CONTRACT_RELATIONSHIP.' +
             'RELATED_CONTRACT')) |
              specific_relation IN TYPEOF (cont));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_contract_relationship
      (x[i], 
       relatives + relation.relating_contract, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_contract_relationship

END_SCHEMA; -- contract_schema

SCHEMA security_classification_schema;
REFERENCE FROM support_resource_schema
    (label,
     text);

ENTITY security_classification;
  name           : label;
  purpose        : text;
  security_level : security_classification_level;
END_ENTITY; -- security_classification

ENTITY security_classification_level;
  name : label;
END_ENTITY; -- security_classification_level

END_SCHEMA; -- security_classification_schema

SCHEMA person_organization_schema;
REFERENCE FROM basic_attribute_schema                  -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   get_role,
   id_attribute,
   name_attribute,
   object_role,
   role_association);
REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE person_organization_select = SELECT
  (person,
   organization,
   person_and_organization);
END_TYPE; -- person_organization_select

ENTITY address;
  internal_location       : OPTIONAL label;
  street_number           : OPTIONAL label;
  street                  : OPTIONAL label;
  postal_box              : OPTIONAL label;
  town                    : OPTIONAL label;
  region                  : OPTIONAL label;
  postal_code             : OPTIONAL label;
  country                 : OPTIONAL label;
  facsimile_number        : OPTIONAL label;
  telephone_number        : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number            : OPTIONAL label;
DERIVE
  name          : label := get_name_value (SELF);
  url           : identifier := get_id_value (SELF);
WHERE
  WR1: EXISTS(internal_location)       OR
       EXISTS(street_number)           OR
       EXISTS(street)                  OR
       EXISTS(postal_box)              OR
       EXISTS(town)                    OR
       EXISTS(region)                  OR
       EXISTS(postal_code)             OR
       EXISTS(country)                 OR
       EXISTS(facsimile_number)        OR
       EXISTS(telephone_number)        OR
       EXISTS(electronic_mail_address) OR
       EXISTS(telex_number);
END_ENTITY; -- address

ENTITY organization;
  id          : OPTIONAL identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- organization

ENTITY organization_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_organization : organization;
  related_organization  : organization;
END_ENTITY; -- organization_relationship

ENTITY organization_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- organization_role

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET [1:?] OF organization;
  description   : OPTIONAL text;
END_ENTITY; -- organizational_address

ENTITY organizational_project;
  name                      : label;
  description               : OPTIONAL text;
  responsible_organizations : SET[1:?] OF organization;
DERIVE
  id                        : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- organizational_project

ENTITY organizational_project_relationship;
  name                            : label;
  description                     : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project  : organizational_project;
END_ENTITY; -- organizational_project_relationship

ENTITY person;
  id            : identifier;
  last_name     : OPTIONAL label;
  first_name    : OPTIONAL label;
  middle_names  : OPTIONAL LIST [1:?] OF label;
  prefix_titles : OPTIONAL LIST [1:?] OF label;
  suffix_titles : OPTIONAL LIST [1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY; -- person

ENTITY person_and_organization;
  the_person       : person;
  the_organization : organization;
DERIVE
  name             : label := get_name_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- person_and_organization

ENTITY person_and_organization_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- person_and_organization_role

ENTITY person_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- person_role

ENTITY personal_address
  SUBTYPE OF (address);
  people      : SET [1:?] OF person;
  description : OPTIONAL text;
END_ENTITY; -- personal_address

FUNCTION acyclic_organization_relationship
  (relation          : organization_relationship;
   relatives         : SET [1:?] OF organization;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF organization_relationship;
  END_LOCAL;
  IF relation.relating_organization IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY (org <* bag_to_set
             (USEDIN (relation.relating_organization,
             'PERSON_ORGANIZATION_SCHEMA.' +
             'ORGANIZATION_RELATIONSHIP.' +
             'RELATED_ORGANIZATION')) |
              specific_relation IN TYPEOF (org));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organization_relationship
      (x[i], 
       relatives + relation.relating_organization, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_organization_relationship

FUNCTION acyclic_organizational_project_relationship
  (relation          : organizational_project_relationship;
   relatives         : SET [1:?] OF organizational_project;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF organizational_project_relationship;
  END_LOCAL;
  IF relation.relating_organizational_project IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (op <* bag_to_set 
             (USEDIN (relation.relating_organizational_project,
             'PERSON_ORGANIZATION_SCHEMA.' + 
             'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' +
             'RELATED_ORGANIZATIONAL_PROJECT')) |
              specific_relation IN TYPEOF (op));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organizational_project_relationship
      (x[i], 
       relatives + relation.relating_organizational_project, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_organizational_project_relationship

END_SCHEMA; -- person_organization_schema

SCHEMA date_time_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (description_attribute,
   get_description_value);
  
REFERENCE FROM measure_schema                   -- ISO 10303-41
  (time_measure_with_unit);
REFERENCE FROM support_resource_schema          -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE ahead_or_behind = ENUMERATION OF
  (ahead,
   exact,
   behind);
END_TYPE; -- ahead_or_behind

TYPE date_time_or_event_occurrence = SELECT 
  (date_time_select,
   event_occurrence);
END_TYPE; -- date_time_or_event_occurrence

TYPE date_time_select = SELECT
  (date,
   local_time,
   date_and_time);
END_TYPE; -- date_time_select

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE; -- day_in_month_number

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE; -- day_in_week_number

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE; -- day_in_year_number

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE; -- hour_in_day

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE; -- minute_in_hour 

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE; -- month_in_year_number

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE; -- second_in_minute 

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE; -- week_in_year_number

TYPE year_number = INTEGER;
END_TYPE; -- year_number

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component   : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY; -- calendar_date

ENTITY coordinated_universal_time_offset;
hour_offset : INTEGER;
minute_offset : OPTIONAL INTEGER;
sense : ahead_or_behind; 
DERIVE 
actual_minute_offset: INTEGER := NVL(minute_offset,0);
WHERE
WR1: { 0 <= hour_offset < 24 };
WR2: { 0 <= actual_minute_offset <= 59 };
WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY; -- coordinated_universal_time_offset


ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date));
  year_component : year_number;
END_ENTITY; -- date

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY; -- date_and_time

ENTITY date_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- date_role

ENTITY date_time_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- date_time_role

ENTITY event_occurrence;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- event_occurrence

ENTITY event_occurrence_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- event_occurrence_context_role

ENTITY event_occurrence_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_event : event_occurrence;
  related_event  : event_occurrence;
END_ENTITY; -- event_occurrence_relationship

ENTITY event_occurrence_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- event_occurrence_role

ENTITY local_time;
  hour_component   : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone             : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY; -- local_time

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 })
       OR
       (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY; -- ordinal_date

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset     : time_measure_with_unit;
END_ENTITY; -- relative_event_occurrence

ENTITY time_interval;
  id              : identifier;
  name            : label;
  description     : OPTIONAL text;
END_ENTITY; -- time_interval

ENTITY time_interval_relationship;
  name                   : label;
  description            : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval  : time_interval;
END_ENTITY; -- time_interval_relationship

ENTITY time_interval_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- time_interval_role

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound   : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration        : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY; -- time_interval_with_bounds

ENTITY time_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- time_role

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component  : OPTIONAL day_in_week_number;
END_ENTITY; -- week_of_year_and_day_date

FUNCTION acyclic_event_occurrence_relationship
  (relation          : event_occurrence_relationship;
   relatives         : SET [1:?] OF event_occurrence;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF event_occurrence_relationship;
  END_LOCAL;
  IF relation.relating_event IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (evnt <* bag_to_set 
             (USEDIN (relation.relating_event,
             'DATE_TIME_SCHEMA.' + 
             'EVENT_OCCURRENCE_RELATIONSHIP.' +
             'RELATED_EVENT')) |
              specific_relation IN TYPEOF (evnt));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_event_occurrence_relationship
      (x[i], 
       relatives + relation.relating_event, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_event_occurrence_relationship

FUNCTION acyclic_time_interval_relationship
  (relation          : time_interval_relationship;
   relatives         : SET [1:?] OF time_interval;
   specific_relation : STRING) : BOOLEAN;
  LOCAL    x                : SET OF time_interval_relationship;
  END_LOCAL;
  IF relation.relating_time_interval IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ti <* bag_to_set 
             (USEDIN (relation.relating_time_interval,
             'DATE_TIME_SCHEMA.' + 
             'TIME_INTERVAL_RELATIONSHIP.' +
             'RELATED_TIME_INTERVAL')) |
              specific_relation IN TYPEOF (ti));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_time_interval_relationship
      (x[i], 
       relatives + relation.relating_time_interval, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_time_interval_relationship

FUNCTION leap_year (year : year_number) : BOOLEAN;
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR
       ((year MOD 400) = 0)) THEN
    RETURN(TRUE);
  ELSE
    RETURN(FALSE);
  END_IF;
END_FUNCTION; -- leap_year

FUNCTION valid_calendar_date (date : calendar_date) : LOGICAL;
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
       RETURN (FALSE);
END_FUNCTION; -- valid_calendar_date

FUNCTION valid_time (time: local_time) : BOOLEAN;
  IF EXISTS (time.second_component) THEN
    RETURN (EXISTS (time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION; -- valid_time

END_SCHEMA; -- date_time_schema

SCHEMA group_schema;
REFERENCE FROM support_resource_schema           -- ISO 10303-41
    (label,
     bag_to_set,
     identifier,
     text);
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
    (get_id_value,
     id_attribute);

ENTITY group;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- group

ENTITY group_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_group : group;
  related_group  : group;
END_ENTITY; -- group_relationship

FUNCTION acyclic_group_relationship
  (relation          : group_relationship;
   relatives         : SET [1:?] OF group;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF group_relationship;
  END_LOCAL;
  IF relation.relating_group IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (grp <* bag_to_set 
             (USEDIN (relation.relating_group,
             'GROUP_SCHEMA.' + 
             'GROUP_RELATIONSHIP.' +
             'RELATED_GROUP')) |
              specific_relation IN TYPEOF (grp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_group_relationship
      (x[i], 
       relatives + relation.relating_group, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_group_relationship

END_SCHEMA; -- group_schema

SCHEMA effectivity_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute);
REFERENCE FROM date_time_schema                 -- ISO 10303-41
  (date_time_or_event_occurrence,
   time_interval);
REFERENCE FROM measure_schema                   -- ISO 10303-41
  (measure_with_unit);
REFERENCE FROM support_resource_schema      -- ISO 10303-41
 (bag_to_set,
  identifier,
  label,
  text);

ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date   : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY; -- dated_effectivity

ENTITY effectivity
  SUPERTYPE OF (ONEOF (serial_numbered_effectivity,
                       dated_effectivity,
                       lot_effectivity,
                       time_interval_based_effectivity));
  id          : identifier;
DERIVE
  name        : label := get_name_value (SELF);
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- effectivity

ENTITY effectivity_relationship;
  name                 : label;
  description          : OPTIONAL text;
  related_effectivity  : effectivity;
  relating_effectivity : effectivity;
END_ENTITY; -- effectivity_relationship

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id    : identifier;
  effectivity_lot_size  : measure_with_unit;
END_ENTITY; -- lot_effectivity

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id :  identifier;
  effectivity_end_id   :  OPTIONAL identifier;
END_ENTITY; -- serial_numbered_effectivity

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY; -- time_interval_based_effectivity

FUNCTION acyclic_effectivity_relationship
  (relation          : effectivity_relationship;
   relatives         : SET [1:?] OF effectivity;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF effectivity_relationship;
  END_LOCAL;
  IF relation.relating_effectivity IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (eff <* bag_to_set 
             (USEDIN (relation.relating_effectivity,
             'EFFECTIVITY_SCHEMA.' + 
             'EFFECTIVITY_RELATIONSHIP.' +
             'RELATED_EFFECTIVITY')) |
              specific_relation IN TYPEOF (eff));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_effectivity_relationship
      (x[i], 
       relatives + relation.relating_effectivity, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_effectivity_relationship

END_SCHEMA; -- effectivity_schema

SCHEMA external_reference_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (description_attribute,
   get_description_value);
REFERENCE FROM support_resource_schema          -- ISO 10303-41
  (label,
   text,
   identifier,
   bag_to_set);

TYPE message = STRING;
END_TYPE; -- message

TYPE source_item = SELECT 
  (identifier, 
   message);
END_TYPE; -- source_item

ENTITY external_source;
  source_id   : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- external_source

ENTITY external_source_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_source : external_source;
  related_source  : external_source;
END_ENTITY; -- external_source_relationship

ENTITY externally_defined_item;
  item_id : source_item;
  source  : external_source;
END_ENTITY; -- externally_defined_item

ENTITY externally_defined_item_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_item   : externally_defined_item;
  related_item    : externally_defined_item;
END_ENTITY; -- externally_defined_item_relationship

ENTITY pre_defined_item;
  name : label;
END_ENTITY; -- pre_defined_item

FUNCTION acyclic_external_source_relationship
  (relation          : external_source_relationship;
   relatives         : SET [1:?] OF external_source;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF external_source_relationship;
  END_LOCAL;
  IF relation.relating_source IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (es <* bag_to_set 
             (USEDIN (relation.relating_source,
             'EXTERNAL_REFERENCE_SCHEMA.' + 
             'EXTERNAL_SOURCE_RELATIONSHIP.' +
             'RELATED_SOURCE')) |
              specific_relation IN TYPEOF (es));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_external_source_relationship
      (x[i], 
       relatives + relation.relating_source, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_external_source_relationship

FUNCTION acyclic_externally_defined_item_relationship
  (relation          : externally_defined_item_relationship;
   relatives         : SET [1:?] OF externally_defined_item;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF externally_defined_item_relationship;
  END_LOCAL;
  IF relation.relating_item IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (edi <* bag_to_set 
             (USEDIN (relation.relating_item,
             'EXTERNAL_REFERENCE_SCHEMA.' + 
             'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' +
             'RELATED_ITEM')) |
              specific_relation IN TYPEOF (edi));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_externally_defined_item_relationship
      (x[i], 
       relatives + relation.relating_item, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_externally_defined_item_relationship

END_SCHEMA; -- external_reference_schema

SCHEMA support_resource_schema;

TYPE identifier = STRING;
END_TYPE; -- identifier

TYPE label = STRING;
END_TYPE; -- label

TYPE text = STRING;
END_TYPE; -- text

FUNCTION bag_to_set 
  (the_bag : BAG OF GENERIC : intype) : SET OF GENERIC : intype;
  LOCAL
    the_set: SET OF GENERIC : intype := [];
  END_LOCAL;
  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);
END_FUNCTION; -- bag_to_set

FUNCTION  type_check_function 
      ( the_type : GENERIC; 
        sub_names: SET OF STRING;
        criterion: INTEGER ): LOGICAL;

--first, check the correctness of function arguments
IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
  END_CASE;
END_IF;
END_FUNCTION;

END_SCHEMA; -- support_resource_schema

SCHEMA measure_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (name_attribute,
   get_name_value);
REFERENCE FROM representation_schema            -- ISO 10303-43
  (representation_context);
REFERENCE FROM support_resource_schema;         -- ISO 10303-41

TYPE amount_of_substance_measure = REAL;
END_TYPE; -- amount_of_substance_measure

TYPE area_measure = REAL;
END_TYPE; -- area_measure

TYPE celsius_temperature_measure = REAL;
END_TYPE; -- celsius_temperature_measure

TYPE context_dependent_measure = REAL;
END_TYPE; -- context_dependent_measure

TYPE count_measure = NUMBER;
END_TYPE; -- count_measure

TYPE descriptive_measure= STRING;
END_TYPE; -- descriptive_measure

TYPE electric_current_measure= REAL;
END_TYPE; -- electric_current_measure

TYPE length_measure = REAL;
END_TYPE; -- length_measure

TYPE luminous_intensity_measure = REAL;
END_TYPE; -- luminous_intensity_measure

TYPE mass_measure = REAL;
END_TYPE; -- mass_measure

TYPE measure_value = SELECT
  (length_measure,
   mass_measure,
   time_measure,
   electric_current_measure,
   thermodynamic_temperature_measure,
   celsius_temperature_measure,
   amount_of_substance_measure,
   luminous_intensity_measure,
   plane_angle_measure,
   solid_angle_measure,
   area_measure,
   volume_measure,
   ratio_measure,
   parameter_value,
   numeric_measure,
   context_dependent_measure,
   descriptive_measure,
   positive_length_measure,
   positive_plane_angle_measure,
   positive_ratio_measure,
   count_measure);
END_TYPE; -- measure_value

TYPE numeric_measure = NUMBER;
END_TYPE; -- numeric_measure

TYPE parameter_value = REAL;
END_TYPE; -- parameter_value

TYPE plane_angle_measure = REAL;
END_TYPE; -- plane_angle_measure

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; -- positive_length_measure

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; -- positive_plane_angle_measure

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; -- positive_ratio_measure

TYPE ratio_measure = REAL;
END_TYPE; -- ratio_measure

TYPE si_prefix = ENUMERATION OF
  (exa,
   peta,
   tera,
   giga,
   mega,
   kilo,
   hecto,
   deca,
   deci,
   centi,
   milli,
   micro,
   nano,
   pico,
   femto,
   atto);
END_TYPE; -- si_prefix

TYPE si_unit_name = ENUMERATION OF
  (metre,
   gram,
   second,
   ampere,
   kelvin,
   mole,
   candela,
   radian,
   steradian,
   hertz,
   newton,
   pascal,
   joule,
   watt,
   coulomb,
   volt,
   farad,
   ohm,
   siemens,
   weber,
   tesla,
   henry,
   degree_Celsius,
   lumen,
   lux,
   becquerel,
   gray,
   sievert);
END_TYPE; -- si_unit_name

TYPE solid_angle_measure = REAL;
END_TYPE; -- solid_angle_measure 

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; -- thermodynamic_temperature_measure

TYPE time_measure = REAL;
END_TYPE; -- time_measure

TYPE unit = SELECT
  (named_unit,
   derived_unit);
END_TYPE; -- unit

TYPE volume_measure = REAL;
END_TYPE; -- volume_measure

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- amount_of_substance_measure_with_unit

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- amount_of_substance_unit

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- area_measure_with_unit

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 2.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- area_unit

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- celsius_temperature_measure_with_unit

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY; -- context_dependent_unit

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
END_ENTITY; -- conversion_based_unit

ENTITY derived_unit;
  elements : SET [1:?] OF derived_unit_element;
DERIVE
  name     : label := get_name_value (SELF);
WHERE
  WR1 : (SIZEOF (elements) > 1) OR
        ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- derived_unit

ENTITY derived_unit_element;
  unit     : named_unit;
  exponent : REAL;
END_ENTITY; -- derived_unit_element

ENTITY dimensional_exponents;
  length_exponent                    : REAL;
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY; -- dimensional_exponents

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- electric_current_measure_with_unit

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- electric_current_unit

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY; -- global_unit_assigned_context

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- length_measure_with_unit

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 1.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- length_unit

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- luminous_intensity_measure_with_unit

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY; -- luminous_intensity_unit

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- mass_measure_with_unit

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 1.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- mass_unit

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (length_measure_with_unit,
                      mass_measure_with_unit,
                      time_measure_with_unit,
                      electric_current_measure_with_unit,
                      thermodynamic_temperature_measure_with_unit,
                      celsius_temperature_measure_with_unit,
                      amount_of_substance_measure_with_unit,
                      luminous_intensity_measure_with_unit,
                      plane_angle_measure_with_unit,
                      solid_angle_measure_with_unit,
                      area_measure_with_unit,
                      volume_measure_with_unit,
                      ratio_measure_with_unit ));
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY; -- measure_with_unit

ENTITY named_unit
  SUPERTYPE OF (ONEOF (si_unit,
                       conversion_based_unit,
                       context_dependent_unit)
               ANDOR
               ONEOF  (length_unit,
                       mass_unit,
                       time_unit,
                       electric_current_unit,
                       thermodynamic_temperature_unit,
                       amount_of_substance_unit,
                       luminous_intensity_unit,
                       plane_angle_unit,
                       solid_angle_unit,
                       area_unit,
                       volume_unit,
                       ratio_unit ));
  dimensions : dimensional_exponents;
END_ENTITY; -- named_unit

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- plane_angle_measure_with_unit

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- plane_angle_unit

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF
           (SELF\measure_with_unit.unit_component);
END_ENTITY; -- ratio_measure_with_unit

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- ratio_unit

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix     : OPTIONAL si_prefix;
  name       : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents
                            := dimensions_for_si_unit (name);
END_ENTITY; -- si_unit

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- solid_angle_measure_with_unit

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- solid_angle_unit

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- thermodynamic_temperature_measure_with_unit

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- thermodynamic_temperature_unit

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1:'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF
        (SELF\measure_with_unit.unit_component);
END_ENTITY; -- time_measure_with_unit

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 1.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- time_unit

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF
           (SELF\measure_with_unit.unit_component);
END_ENTITY; -- volume_measure_with_unit

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 3.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- volume_unit

FUNCTION derive_dimensional_exponents (x : unit) : dimensional_exponents;
  LOCAL
    result : dimensional_exponents :=
            dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;
  IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN -- x is a derived unit
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent                   :=
        result.length_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent                     :=
        result.mass_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.mass_exponent);
     result.time_exponent :=
        result.time_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent         :=
        result.electric_current_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent :=
        result.thermodynamic_temperature_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent       :=
        result.amount_of_substance_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent        :=
        result.luminous_intensity_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE -- x is a unitless or a named unit
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION; -- derive_dimensional_exponents 

FUNCTION dimensions_for_si_unit (n : si_unit_name) : dimensional_exponents;
  CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;
END_FUNCTION; -- dimensions_for_si_unit

FUNCTION valid_units ( m : measure_with_unit ) : BOOLEAN ;
  IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION; -- valid_units

END_SCHEMA; -- measure_schema

SCHEMA basic_attribute_schema;
REFERENCE FROM action_schema                         -- ISO 10303-41
  (action,
   action_request_solution);
REFERENCE FROM application_context_schema            -- ISO 10303-41
  (application_context);
REFERENCE FROM approval_schema                       -- ISO 10303-41
  (approval_date_time,
   approval_role);
REFERENCE FROM configuration_management_schema       -- ISO 10303-44
  (configuration_design);
REFERENCE FROM date_time_schema                      -- ISO 10303-41
  (date_role,
   date_time_role,
   time_role);
REFERENCE FROM effectivity_schema                    -- ISO 10303-41
  (effectivity);
REFERENCE FROM external_reference_schema             -- ISO 10303-41
  (external_source);
REFERENCE FROM management_resources_schema           -- ISO 10303-41
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   external_referent_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment);
REFERENCE FROM measure_schema                         -- ISO 10303-41
  (derived_unit);
REFERENCE FROM person_organization_schema             -- ISO 10303-41
  (address,
   person_and_organization_role,
   person_and_organization,
   person_role,
   organization_role,
   organizational_project);
REFERENCE FROM product_definition_schema              -- ISO 10303-41
  (product_category,
   product_definition,
   product_definition_substitute);
REFERENCE FROM product_property_definition_schema       -- ISO 10303-41
  (property_definition,
   shape_aspect,
   shape_aspect_relationship);
REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (context_dependent_shape_representation,
   property_definition_representation);
REFERENCE FROM group_schema                             -- ISO 10303-41
  (group);
REFERENCE FROM representation_schema                    -- ISO 10303-43
  (representation);
REFERENCE FROM support_resource_schema                  -- ISO 10303-41
  (identifier,
   label,
   text);

TYPE description_attribute_select = SELECT
  (action_request_solution,
   application_context,
   approval_role,
   configuration_design,
   date_role,
   date_time_role,
   context_dependent_shape_representation,
   effectivity,
   external_source,
   organization_role,
   person_and_organization_role,
   person_and_organization,
   person_role,
   property_definition_representation,
   representation,
   time_role);
END_TYPE; -- description_attribute_select

TYPE id_attribute_select = SELECT
  (action,
   address,
   product_category,
   property_definition,
   shape_aspect,
   shape_aspect_relationship,
   application_context,
   group,
   organizational_project,
   representation);
END_TYPE; -- id_attribute_select

TYPE name_attribute_select = SELECT
  (action_request_solution,
   address,
   configuration_design,
   context_dependent_shape_representation,
   derived_unit,
   effectivity,
   person_and_organization,
   product_definition,
   product_definition_substitute,
   property_definition_representation);
END_TYPE; -- name_attribute_select

TYPE role_select = SELECT
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   approval_date_time,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   external_referent_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment);
END_TYPE; -- role_select

ENTITY description_attribute;
  attribute_value : text;
  described_item  : description_attribute_select;
END_ENTITY; -- description_attribute

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY; -- id_attribute

ENTITY name_attribute;
  attribute_value : label;
  named_item      : name_attribute_select;
END_ENTITY; -- name_attribute

ENTITY object_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- object_role

ENTITY role_association;
  role           : object_role;
  item_with_role : role_select;
END_ENTITY; -- role_association

FUNCTION get_description_value 
  (obj : description_attribute_select) : text;
  LOCAL
    description_bag : BAG OF description_attribute := 
                      (USEDIN (obj,
                      'BASIC_ATTRIBUTE_SCHEMA.' +
                      'DESCRIPTION_ATTRIBUTE.' +
                      'DESCRIBED_ITEM'));
  END_LOCAL;
  IF SIZEOF (description_bag) = 1 
    THEN RETURN (description_bag[1].attribute_value);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_description_value

FUNCTION get_id_value 
  (obj : id_attribute_select) : identifier;
  LOCAL
    id_bag : BAG OF id_attribute :=
             (USEDIN (obj,
             'BASIC_ATTRIBUTE_SCHEMA.' +
             'ID_ATTRIBUTE.' +
             'IDENTIFIED_ITEM'));
  END_LOCAL;
  IF SIZEOF (id_bag) = 1
    THEN RETURN (id_bag[1].attribute_value);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_id_value

FUNCTION get_name_value 
  (obj : name_attribute_select) : label;
  LOCAL
    name_bag : BAG OF name_attribute :=
               (USEDIN (obj,
               'BASIC_ATTRIBUTE_SCHEMA.' +
               'NAME_ATTRIBUTE.' +
               'NAMED_ITEM'));
  END_LOCAL;
  IF SIZEOF (name_bag) = 1
    THEN RETURN (name_bag[1].attribute_value);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_name_value

FUNCTION get_role
  (obj : role_select) : object_role;
  LOCAL
  role_bag : BAG OF role_association:=
             (USEDIN (obj,
             'BASIC_ATTRIBUTE_SCHEMA.' +
             'ROLE_ASSOCIATION.' +
             'ITEM_WITH_ROLE'));
  END_LOCAL;
  IF SIZEOF (role_bag) = 1
    THEN RETURN (role_bag[1].role);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_role

END_SCHEMA; -- basic_attribute_schema
 (* WG12 N976 August 2001 - Formally document WG12 N934 date 2001-04-25. EXPRESS listing
    corresponding to part 42 edition IS WG12 N536, as modified by TC1 WG12 N608 and N616
    revolved_area_sold, revolved_face_solid corrected August 2001 to match TC1 *)
 SCHEMA geometry_schema;
   REFERENCE FROM representation_schema
     (definitional_representation,
      founded_item,
      functionally_defined_transformation,
      item_in_context,
      representation,
      representation_item,
      representation_context,
      using_representations);
   REFERENCE FROM measure_schema
     (global_unit_assigned_context,
      length_measure,
      parameter_value,
      plane_angle_measure,
      plane_angle_unit,
      positive_length_measure,
      positive_plane_angle_measure);
   REFERENCE FROM topology_schema
     (edge_curve,
      face_surface,
      poly_loop,
      vertex_point);
    REFERENCE FROM geometric_model_schema
      (block,
       boolean_result,
       cyclide_segment_solid,
       eccentric_cone,
       edge_based_wireframe_model,
       ellipsoid,
       face_based_surface_model,
       faceted_primitive,
       geometric_set,
       half_space_solid,
       half_space_2d,
       primitive_2d,
       rectangular_pyramid,
       right_angular_wedge,
       right_circular_cone,
       right_circular_cylinder,
       shell_based_surface_model,
       shell_based_wireframe_model,
       solid_model,
       sphere,
       torus);

 CONSTANT
  dummy_gri : geometric_representation_item :=  representation_item('')||
                                   geometric_representation_item();
 END_CONSTANT;

 TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
 END_TYPE;

 TYPE b_spline_curve_form = ENUMERATION OF
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
 END_TYPE;

 TYPE b_spline_surface_form = ENUMERATION OF
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
 END_TYPE;

 TYPE curve_on_surface = SELECT
   (pcurve, 
    surface_curve, 
    composite_curve_on_surface);
 END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

 TYPE extent_enumeration = ENUMERATION OF 
   (invalid,
    zero,
    finite_non_zero,
    infinite);
 END_TYPE;

 TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
 END_TYPE;

 TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
 END_TYPE;

 TYPE preferred_surface_curve_representation = ENUMERATION OF 
   (curve_3d,
    pcurve_s1, 
    pcurve_s2);
 END_TYPE;

TYPE surface_boundary = SELECT
   (boundary_curve,
    degenerate_pcurve);
END_TYPE;

 TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
 END_TYPE;

 TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
 END_TYPE;

 TYPE trimming_select = SELECT 
   (cartesian_point, 
    parameter_value);
 END_TYPE;

 TYPE vector_or_direction = SELECT
   (vector, 
    direction);
 END_TYPE;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

 ENTITY axis1_placement
 SUBTYPE OF (placement);
   axis     : OPTIONAL direction;
 DERIVE
   z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
 WHERE
   WR1: SELF\geometric_representation_item.dim  = 3;
 END_ENTITY;

 ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
   axis          : OPTIONAL direction;
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [3:3] OF direction := build_axes(axis,ref_direction);
 WHERE
   WR1: SELF\placement.location.dim = 3;
   WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
   WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
   WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;

 ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF(uniform_curve, b_spline_curve_with_knots,
                       quasi_uniform_curve, bezier_curve)
                         ANDOR rational_b_spline_curve)
   SUBTYPE OF (bounded_curve);
   degree               : INTEGER;
   control_points_list  : LIST [2:?] OF cartesian_point;
   curve_form           : b_spline_curve_form;
   closed_curve         : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   upper_index_on_control_points  : INTEGER 
                                  := (SIZEOF(control_points_list) - 1);
   control_points       : ARRAY [0:upper_index_on_control_points]
                                                         OF cartesian_point 
                                  := list_to_array(control_points_list,0,
                                             upper_index_on_control_points);
 WHERE
   WR1: ('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR
        ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
 END_ENTITY;

 ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
   knot_multiplicities  : LIST [2:?] OF INTEGER;
   knots                : LIST [2:?] OF parameter_value;
   knot_spec            : knot_type;
 DERIVE
   upper_index_on_knots : INTEGER := SIZEOF(knots);
 WHERE
   WR1: constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
    WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

 ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF(b_spline_surface_with_knots, uniform_surface,
                       quasi_uniform_surface, bezier_surface)
                         ANDOR rational_b_spline_surface)
   SUBTYPE OF (bounded_surface);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF cartesian_point;
   surface_form         : b_spline_surface_form;
   u_closed             : LOGICAL;
   v_closed             : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF 
                         cartesian_point 
                       := make_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper);
 WHERE
   WR1: ('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
 END_ENTITY;

 ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   knot_spec         : knot_type;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
                   knot_u_upper, SELF\b_spline_surface.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
                   knot_v_upper, SELF\b_spline_surface.v_upper,
                               v_multiplicities, v_knots);
    WR3: SIZEOF(u_multiplicities) = knot_u_upper;
    WR4: SIZEOF(v_multiplicities) = knot_v_upper;
 END_ENTITY;

 ENTITY b_spline_volume
   SUPERTYPE OF (ONEOF(b_spline_volume_with_knots, uniform_volume,
                      quasi_uniform_volume,bezier_volume) ANDOR
                       rational_b_spline_volume)
   SUBTYPE OF (volume);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   w_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF
                              LIST [2:?] OF cartesian_point;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   w_upper             : INTEGER := SIZEOF(control_points_list[1][1]) - 1;

   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper]
                         OF ARRAY [0:w_upper] OF  cartesian_point
                       := make_array_of_array_of_array (control_points_list,
                                              0,u_upper,0,v_upper,
                                              0,w_upper );
 WHERE
   WR1: ('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF)) ;
 END_ENTITY;

 ENTITY b_spline_volume_with_knots
   SUBTYPE OF (b_spline_volume);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   w_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   w_knots           : LIST [2:?] OF parameter_value;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
   knot_w_upper      : INTEGER := SIZEOF(w_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_volume.u_degree,
                   knot_u_upper, SELF\b_spline_volume.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_volume.v_degree,
                   knot_v_upper, SELF\b_spline_volume.v_upper,
                               v_multiplicities, v_knots);
    WR3: constraints_param_b_spline(SELF\b_spline_volume.w_degree,
                   knot_w_upper, SELF\b_spline_volume.w_upper,
                               w_multiplicities, w_knots);
    WR4: SIZEOF(u_multiplicities) = knot_u_upper;
    WR5: SIZEOF(v_multiplicities) = knot_v_upper;
    WR6: SIZEOF(w_multiplicities) = knot_w_upper;
 END_ENTITY;

 ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY bezier_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY block_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
 END_ENTITY;

 ENTITY boundary_curve
   SUBTYPE OF (composite_curve_on_surface);
 WHERE
   WR1: SELF\composite_curve.closed_curve;
 END_ENTITY;

 ENTITY bounded_curve
   SUPERTYPE OF (ONEOF(polyline, b_spline_curve, trimmed_curve,
                      bounded_pcurve, bounded_surface_curve, composite_curve))
   SUBTYPE OF (curve);
 END_ENTITY;

 ENTITY bounded_pcurve
   SUBTYPE OF (pcurve, bounded_curve);
  WHERE
    WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN
                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
  END_ENTITY;

 ENTITY bounded_surface
   SUPERTYPE OF (ONEOF(b_spline_surface, rectangular_trimmed_surface,
                       curve_bounded_surface, rectangular_composite_surface))
   SUBTYPE OF (surface);
 END_ENTITY;

 ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve, bounded_curve);
 WHERE
   WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN
             TYPEOF(SELF\surface_curve.curve_3d));
 END_ENTITY;

 ENTITY cartesian_point
   SUPERTYPE OF (ONEOF(cylindrical_point, polar_point, spherical_point))
   SUBTYPE OF (point);
    coordinates  : LIST [1:3] OF length_measure;
 END_ENTITY;

 ENTITY cartesian_transformation_operator
   SUPERTYPE OF(ONEOF(cartesian_transformation_operator_2d,
                               cartesian_transformation_operator_3d))
   SUBTYPE OF (geometric_representation_item,
                            functionally_defined_transformation);
   axis1        : OPTIONAL direction;
   axis2        : OPTIONAL direction;
   local_origin : cartesian_point;
   scale        : OPTIONAL REAL;
 DERIVE
   scl          : REAL := NVL(scale, 1.0);
 WHERE
   WR1: scl > 0.0;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_2d
   SUBTYPE OF (cartesian_transformation_operator);
 DERIVE
   u : LIST[2:2] OF direction := 
       base_axis(2,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,?);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
   axis3 : OPTIONAL direction;
 DERIVE
   u     : LIST[3:3] OF direction 
         := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                        SELF\cartesian_transformation_operator.axis2,axis3);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY circle
   SUBTYPE OF (conic);
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY clothoid
   SUBTYPE OF (curve);
     position          : axis2_placement;
     clothoid_constant : length_measure;
  END_ENTITY;

 ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
   segments       : LIST [1:?] OF composite_curve_segment;
   self_intersect : LOGICAL;
 DERIVE
   n_segments     : INTEGER := SIZEOF(segments);
   closed_curve   : LOGICAL 
                  := segments[n_segments].transition <> discontinuous;
 WHERE
   WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous)) = 0));
 END_ENTITY;

 ENTITY composite_curve_on_surface
   SUPERTYPE OF(boundary_curve)
   SUBTYPE OF (composite_curve);

 DERIVE
   basis_surface : SET[0:2] OF surface :=
                get_basis_surface(SELF);
 WHERE
   WR1: SIZEOF(basis_surface) > 0;
   WR2: constraints_composite_curve_on_surface(SELF);
 END_ENTITY;

 ENTITY composite_curve_segment
 SUBTYPE OF (founded_item);
   transition    : transition_code;
   same_sense    : BOOLEAN;
   parent_curve  : curve;
 INVERSE
   using_curves  : BAG[1:?] OF composite_curve FOR segments;
 WHERE
   WR1 : ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
 END_ENTITY;

 ENTITY conic
   SUPERTYPE OF (ONEOF(circle, ellipse, hyperbola, parabola))
   SUBTYPE OF (curve);
   position: axis2_placement;
 END_ENTITY;

 ENTITY
 conical_surface
   SUBTYPE OF (elementary_surface);
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;

 ENTITY curve
   SUPERTYPE OF (ONEOF(line, conic, clothoid, pcurve, surface_curve,
                       offset_curve_2d, offset_curve_3d, curve_replica))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
    basis_surface    : surface;
    boundaries       : SET [1:?] OF boundary_curve;
    implicit_outer   : BOOLEAN;
  WHERE
    WR1: (NOT implicit_outer) OR
         (SIZEOF (QUERY (temp <* boundaries |
           'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
    WR2: (NOT(implicit_outer)) OR
                ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
    WR3: SIZEOF(QUERY(temp <* boundaries |
                  'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN
                                         TYPEOF(temp))) <= 1;
    WR4: SIZEOF(QUERY(temp <* boundaries |
            (temp\composite_curve_on_surface.basis_surface [1] <>
                                         SELF.basis_surface))) = 0;
 END_ENTITY;

 ENTITY curve_replica
   SUBTYPE OF (curve);
   parent_curve   : curve;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_curve.dim;
   WR2: acyclic_curve_replica (SELF, parent_curve);
 END_ENTITY;

 ENTITY cylindrical_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
     z     : length_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
                     [r*cos(theta), r*sin(theta), z];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

 ENTITY cylindrical_surface
   SUBTYPE OF (elementary_surface);
   radius : positive_length_measure;
 END_ENTITY;

 ENTITY  cylindrical_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   radius   : positive_length_measure;
   height   : positive_length_measure;
 END_ENTITY;

 ENTITY degenerate_pcurve
   SUBTYPE OF (point);
   basis_surface:  surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.
                   items[1]\geometric_representation_item.dim =2;
 END_ENTITY;

 ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
   select_outer : BOOLEAN;
 WHERE
  WR1: major_radius <   minor_radius;
 END_ENTITY;

 ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;

ENTITY dupin_cyclide_surface
   SUBTYPE OF (elementary_surface);
   generalised_major_radius : positive_length_measure;
   generalised_minor_radius : positive_length_measure;
   skewness                 : length_measure;
WHERE
  WR1: skewness >= 0.0;
END_ENTITY;

 ENTITY eccentric_conical_volume
  SUBTYPE OF (volume);
   position    : axis2_placement_3d;
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
   height      : positive_length_measure;
   x_offset    : length_measure;
   y_offset    : length_measure;
   ratio       : REAL;
 WHERE
  WR1 : ratio >= 0.0;
 END_ENTITY;

 ENTITY elementary_surface
   SUPERTYPE OF (ONEOF(plane, cylindrical_surface, conical_surface,
                       spherical_surface, toroidal_surface))
   SUBTYPE OF (surface);
   position : axis2_placement_3d;
 END_ENTITY;

 ENTITY ellipse
   SUBTYPE OF (conic);
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
 END_ENTITY;

 ENTITY ellipsoid_volume
   SUBTYPE OF (volume);
     position      : axis2_placement_3d;
     semi_axis_1 : positive_length_measure;
     semi_axis_2 : positive_length_measure;
     semi_axis_3 : positive_length_measure;
 END_ENTITY;

 ENTITY evaluated_degenerate_pcurve
   SUBTYPE OF (degenerate_pcurve);
   equivalent_point : cartesian_point;
 END_ENTITY;

 ENTITY fixed_reference_swept_surface
   SUBTYPE OF (swept_surface);
      directrix       : curve;
      fixed_reference : direction;
 END_ENTITY;

  ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF(point, direction, vector, placement,
                 cartesian_transformation_operator, curve, surface,
                 edge_curve, face_surface, poly_loop, vertex_point,
                 solid_model, boolean_result, sphere, right_circular_cone,
                 right_circular_cylinder, torus, block, primitive_2d,
                 right_angular_wedge, ellipsoid, faceted_primitive,
                 rectangular_pyramid, cyclide_segment_solid, volume,
                 half_space_solid, half_space_2d,
                 shell_based_surface_model, face_based_surface_model,
                 shell_based_wireframe_model, edge_based_wireframe_model,
                 geometric_set))
  SUBTYPE OF (representation_item);
  DERIVE
    dim : dimension_count := dimension_of(SELF);
  WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
      NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
      TYPEOF (using_rep.context_of_items)))) = 0;
  END_ENTITY;

 ENTITY line
   SUBTYPE OF (curve);
   pnt : cartesian_point;
   dir : vector;
 WHERE
   WR1: dir.dim  = pnt.dim;
 END_ENTITY;

 ENTITY hexahedron_volume
   SUBTYPE OF (volume);
   points  : LIST[8:8] OF cartesian_point;
  WHERE
    WR1: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
    WR2: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
    WR3: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
    WR4: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
    WR5: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
    WR6: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
    WR7: same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
    WR8: same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
    WR9:  same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
    WR10: same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
    WR11: same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
    WR12: same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
    WR13: points[1].dim = 3;
  END_ENTITY;

 ENTITY hyperbola
   SUBTYPE OF (conic);
   semi_axis      : positive_length_measure;
   semi_imag_axis : positive_length_measure;
 END_ENTITY;

 ENTITY intersection_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <>
             associated_surface(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;

 ENTITY offset_curve_2d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
 WHERE
   WR1: basis_curve.dim = 2;
 END_ENTITY;

 ENTITY offset_curve_3d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
   ref_direction  : direction;
 WHERE
   WR1 : (basis_curve.dim = 3) AND (ref_direction.dim = 3);
 END_ENTITY;

 ENTITY offset_surface
   SUBTYPE OF (surface);
   basis_surface  : surface;
   distance       : length_measure;
   self_intersect : LOGICAL;
 END_ENTITY;

 ENTITY oriented_surface
   SUBTYPE OF (surface);
   orientation : BOOLEAN;
 END_ENTITY;

 ENTITY outer_boundary_curve
   SUBTYPE OF (boundary_curve);
 END_ENTITY;

 ENTITY parabola
   SUBTYPE OF (conic);
   focal_dist : length_measure;
 WHERE
   WR1: focal_dist <> 0.0;
 END_ENTITY;

 ENTITY pcurve
   SUBTYPE OF (curve);
   basis_surface      : surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.items[1]\
                               geometric_representation_item.dim =2;
 END_ENTITY;

 ENTITY placement
   SUPERTYPE OF (ONEOF(axis1_placement,axis2_placement_2d,axis2_placement_3d))
   SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
 END_ENTITY;

 ENTITY plane
 SUBTYPE OF (elementary_surface);
 END_ENTITY;

 ENTITY polar_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
                   [r*cos(theta), r*sin(theta)];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

ENTITY point
   SUPERTYPE OF (ONEOF(cartesian_point, point_on_curve, point_on_surface,
                        point_in_volume, point_replica, degenerate_pcurve))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY point_in_volume
   SUBTYPE OF (point);
   basis_volume     : volume;
   point_parameter_u : parameter_value;
   point_parameter_v : parameter_value;
   point_parameter_w : parameter_value;
 END_ENTITY;

 ENTITY point_on_curve
   SUBTYPE OF (point);
   basis_curve     : curve;
   point_parameter : parameter_value;
 END_ENTITY;

 ENTITY point_on_surface
   SUBTYPE OF (point);
   basis_surface     : surface;
   point_parameter_u : parameter_value;
   point_parameter_v : parameter_value;
 END_ENTITY;

 ENTITY point_replica
   SUBTYPE OF (point);
   parent_pt      : point;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_pt.dim;
   WR2: acyclic_point_replica (SELF,parent_pt);
 END_ENTITY;

 ENTITY polyline
   SUBTYPE OF (bounded_curve);
   points : LIST [2:?] OF cartesian_point;
 END_ENTITY;

 ENTITY pyramid_volume
   SUBTYPE OF (volume);
   position       : axis2_placement_3d;
   xlength        : positive_length_measure;
   ylength          : positive_length_measure;
   height         : positive_length_measure;
 END_ENTITY;

 ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY quasi_uniform_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
   weights_data : LIST [2:?] OF REAL;
                                
 DERIVE
   weights           : ARRAY [0:upper_index_on_control_points] OF REAL
                               := list_to_array(weights_data,0,
                                      upper_index_on_control_points);
 WHERE
   WR1:  SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
                                           control_points_list);
   WR2:  curve_weights_positive(SELF);
 END_ENTITY;

 ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
   weights_data : LIST [2:?] OF
                    LIST [2:?] OF REAL;
                                
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                      ARRAY [0:v_upper] OF REAL
                 := make_array_of_array(weights_data,0,u_upper,0,v_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                     SIZEOF(SELF\b_spline_surface.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                  SIZEOF(SELF\b_spline_surface.control_points_list[1]));
   WR2: surface_weights_positive(SELF);
 END_ENTITY;

 ENTITY rational_b_spline_volume
   SUBTYPE OF (b_spline_volume);
   weights_data : LIST [2:?] OF
                   LIST [2:?] OF
                    LIST [2:?] OF REAL;
                                
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                    ARRAY [0:v_upper] OF
                     ARRAY [0:w_upper] OF REAL
                 := make_array_of_array_of_array
                             (weights_data,0,u_upper,0,v_upper,0,w_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                         SIZEOF(SELF\b_spline_volume.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))
            AND (SIZEOF(weights_data[1][1]) =
                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
   WR2: volume_weights_positive(SELF);
 END_ENTITY;

 ENTITY rectangular_composite_surface
   SUBTYPE OF (bounded_surface);
   segments      : LIST [1:?] OF LIST [1:?] OF surface_patch;
 DERIVE
   n_u : INTEGER := SIZEOF(segments);
   n_v : INTEGER := SIZEOF(segments[1]);
 WHERE
   WR1: SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
   WR2: constraints_rectangular_composite_surface(SELF);
 END_ENTITY;

 ENTITY rectangular_trimmed_surface
   SUBTYPE OF (bounded_surface);
   basis_surface : surface;
   u1            : parameter_value;
   u2            : parameter_value;
   v1            : parameter_value;
   v2            : parameter_value;
   usense        : BOOLEAN;
   vsense        : BOOLEAN;
 WHERE
   WR1: u1 <> u2;
   WR2: v1 <> v2;
   WR3: (('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))
       AND  (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR
      ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))
          OR (usense = (u2 > u1));
   WR4: (('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))
          OR
         ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))
          OR (vsense = (v2 > v1));
 END_ENTITY;

 ENTITY reparametrised_composite_curve_segment
   SUBTYPE OF (composite_curve_segment);
   param_length : parameter_value;
 WHERE
   WR1: param_length > 0.0;
 END_ENTITY;

 ENTITY seam_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
           associated_surface(SELF\surface_curve.associated_geometry[2]);
   WR3: 'GEOMETRY_SCHEMA.PCURVE' IN
           TYPEOF(SELF\surface_curve.associated_geometry[1]);
   WR4: 'GEOMETRY_SCHEMA.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;

 ENTITY spherical_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
     phi   : plane_angle_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
       [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

 ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY spherical_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY surface
   SUPERTYPE OF (ONEOF(elementary_surface, swept_surface, bounded_surface,
                       offset_surface, surface_replica))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY surface_curve
   SUPERTYPE OF (ONEOF(intersection_curve, seam_curve) ANDOR
                                            bounded_surface_curve)
   SUBTYPE OF (curve);
   curve_3d              : curve;
   associated_geometry   : LIST[1:2] OF pcurve_or_surface;
   master_representation : preferred_surface_curve_representation;
 DERIVE
   basis_surface         : SET[1:2] OF surface
                         := get_basis_surface(SELF);
 WHERE
   WR1: curve_3d.dim = 3;
   WR2: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR
                        (master_representation <> pcurve_s1);
   WR3: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR
                        (master_representation <> pcurve_s2);
   WR4: NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
 END_ENTITY;

 ENTITY surface_curve_swept_surface
   SUBTYPE OF (swept_surface);
      directrix  : curve;
      reference_surface : surface;
   WHERE
     WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
   extrusion_axis      : vector;
 END_ENTITY;

 ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
   axis_position       : axis1_placement;
 DERIVE
   axis_line : line := representation_item('')||
                     geometric_representation_item()|| curve()||
                     line(axis_position.location, representation_item('')||
                     geometric_representation_item()||
                     vector(axis_position.z, 1.0));
 END_ENTITY;

 ENTITY surface_patch
 SUBTYPE OF (founded_item);
   parent_surface : bounded_surface;
   u_transition   : transition_code;
   v_transition   : transition_code;
   u_sense        : BOOLEAN;
   v_sense        : BOOLEAN;
 INVERSE
   using_surfaces : BAG[1:?] OF rectangular_composite_surface FOR segments;
 WHERE
   WR1: (NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' 
                 IN TYPEOF(parent_surface)));
 END_ENTITY;

 ENTITY surface_replica
   SUBTYPE OF (surface);
   parent_surface : surface;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_surface_replica(SELF, parent_surface);
 END_ENTITY;

 ENTITY swept_surface
   SUPERTYPE OF (ONEOF(surface_of_linear_extrusion, surface_of_revolution,
                 surface_curve_swept_surface, fixed_reference_swept_surface))
   SUBTYPE OF (surface);
   swept_curve : curve;
 END_ENTITY;

 ENTITY tetrahedron_volume
   SUBTYPE OF (volume);
     point_1 : cartesian_point ;
     point_2 : cartesian_point ;
     point_3 : cartesian_point ;
     point_4 : cartesian_point ;
  WHERE
    WR1: point_1.dim = 3 ;
    WR2: above_plane(point_1, point_2, point_3, point_4) <> 0.0 ;
  END_ENTITY;

 ENTITY toroidal_volume
   SUBTYPE OF (volume);
   position     : axis2_placement_3d;
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 WHERE
   WR1 : minor_radius < major_radius;
 END_ENTITY;

 ENTITY trimmed_curve
   SUBTYPE OF (bounded_curve);
   basis_curve           : curve;
   trim_1                : SET[1:2] OF trimming_select;
   trim_2                : SET[1:2] OF trimming_select;
   sense_agreement       : BOOLEAN;
   master_representation : trimming_preference;
 WHERE
   WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
   WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
 END_ENTITY;

 ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 END_ENTITY;

 ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY uniform_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
 END_ENTITY;

 ENTITY volume
   SUPERTYPE OF (ONEOF(block_volume, wedge_volume, spherical_volume,
                    cylindrical_volume, eccentric_conical_volume,
                    toroidal_volume, pyramid_volume, b_spline_volume,
                    ellipsoid_volume, tetrahedron_volume, hexahedron_volume))
   SUBTYPE OF (geometric_representation_item);
   WHERE
     WR1 : SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

  ENTITY wedge_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
   ltx      : length_measure;
 WHERE
   WR1: ((0.0 <= ltx) AND (ltx < x));
 END_ENTITY;

RULE compatible_dimension FOR 
  (cartesian_point,
  direction,
  representation_context,
  geometric_representation_context);
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

 FUNCTION above_plane(p1, p2, p3, p4 : cartesian_point) : REAL;
   LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim <> 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);
 END_FUNCTION;

 FUNCTION acyclic_curve_replica(rep : curve_replica; parent : curve)
                                              : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_point_replica(rep : point_replica; parent : point)
                                              : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_surface_replica(rep : surface_replica; parent : surface)
                                              : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;
  END_FUNCTION;

 FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
   LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
 END_FUNCTION;

FUNCTION base_axis(dim : INTEGER; axis1, axis2, axis3 : direction) :
                                                 LIST [2:3] OF 
direction;
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
 END_FUNCTION;

 FUNCTION build_axes(axis, ref_direction : direction) :
                                          LIST [3:3] OF direction;
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
 END_FUNCTION;

 FUNCTION constraints_composite_curve_on_surface
               (c: composite_curve_on_surface) : BOOLEAN;
   LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

 FUNCTION constraints_param_b_spline(degree, up_knots, up_cp : INTEGER;
                                               knot_mult : LIST OF INTEGER;
                        knots : LIST OF parameter_value) : BOOLEAN;
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

   FUNCTION constraints_rectangular_composite_surface
           (s : rectangular_composite_surface) : BOOLEAN;

   (* Check the surface types *)
     REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

FUNCTION cross_product (arg1, arg2 : direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;

 FUNCTION curve_weights_positive(b: rational_b_spline_curve) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION default_b_spline_curve_weights(up_cp : INTEGER)
                                          : ARRAY [0:up_cp] OF REAL;
   RETURN([1:up_cp + 1]);
 END_FUNCTION;

 FUNCTION default_b_spline_surface_weights(u_upper, v_upper: INTEGER)
                                      : ARRAY [0:u_upper] OF 
                                        ARRAY [0:v_upper] OF REAL;
    RETURN([[1:v_upper + 1]:u_upper +1]);
 END_FUNCTION;

 FUNCTION default_b_spline_knot_mult(degree, up_knots : INTEGER;
                                          uniform : knot_type) 
                                                  : LIST [2:?] OF INTEGER;
   LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);
 END_FUNCTION;

 FUNCTION default_b_spline_knots(degree,up_knots : INTEGER;
                              uniform : knot_type)
                                      : LIST [2:?] OF parameter_value;
  LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);
 END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);

END_FUNCTION;

 FUNCTION dot_product(arg1, arg2 : direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
 END_FUNCTION;

 FUNCTION first_proj_axis(z_axis, arg : direction) : direction;
   LOCAL
     x_axis : direction;
     v      : direction;
     z      : direction;
     x_vec  : vector;
   END_LOCAL;
   
   IF (NOT EXISTS(z_axis)) THEN
     RETURN (?) ;
   ELSE
     z := normalise(z_axis);
     IF NOT EXISTS(arg) THEN
       IF (z.direction_ratios <> [1.0,0.0,0.0]) THEN
         v :=  dummy_gri || direction([1.0,0.0,0.0]);
       ELSE
         v := dummy_gri || direction([0.0,1.0,0.0]);
       END_IF;
     ELSE
       IF  (arg.dim <> 3) THEN
         RETURN (?) ;
       END_IF;
       IF ((cross_product(arg,z).magnitude) = 0.0) THEN
         RETURN (?);
       ELSE
         v := normalise(arg);
       END_IF;
     END_IF;
     x_vec := scalar_times_vector(dot_product(v, z), z);
     x_axis := vector_difference(v, x_vec).orientation;
     x_axis := normalise(x_axis);
   END_IF;
   RETURN(x_axis);
 END_FUNCTION;

FUNCTION get_basis_surface (c : curve_on_surface) : SET[0:2] OF surface;
  LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);
END_FUNCTION;

 FUNCTION list_to_array(lis : LIST [0:?] OF GENERIC : T;
                      low,u : INTEGER) : ARRAY OF GENERIC : T;
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
 END_FUNCTION;

 FUNCTION make_array_of_array(lis : LIST[1:?] OF LIST [1:?] OF GENERIC : T;
                              low1, u1, low2, u2 : INTEGER):
                 ARRAY OF ARRAY OF GENERIC : T;
   LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);
 END_FUNCTION;

 FUNCTION make_array_of_array_of_array(lis : LIST[1:?] OF
              LIST [1:?] OF LIST [1:?] OF GENERIC : T;
              low1, u1, low2, u2, low3, u3 : INTEGER):
              ARRAY OF ARRAY OF ARRAY OF GENERIC : T;
 LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) <> SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);
 END_FUNCTION;

 FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
 (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION orthogonal_complement(vec : direction) : direction;
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;
 END_FUNCTION;

 FUNCTION same_side(plane_pts : LIST [3:3] of cartesian_point;
                    test_points : LIST [2:?] of cartesian_point) : BOOLEAN;
   LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 <= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

 FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)
                                      : vector;
   LOCAL
     v      : direction;
     mag    : REAL;
     result : vector;
   END_LOCAL;

   IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
     RETURN (?) ;
    ELSE
     IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);
       mag := scalar * vec.magnitude;
     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);
       mag := scalar;
     END_IF;
     IF (mag < 0.0 ) THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);
         v.direction_ratios[i] := -v.direction_ratios[i];
       END_REPEAT;
       mag := -mag;
     END_IF;
     result := dummy_gri || vector(normalise(v), mag);
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION second_proj_axis(z_axis, x_axis, arg: direction) : direction;
   LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);
 END_FUNCTION;

 FUNCTION surface_weights_positive(b: rational_b_spline_surface) : BOOLEAN;
   LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;
    ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION vector_sum(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION volume_weights_positive(b: rational_b_spline_volume): BOOLEAN;
     LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] <= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);
   END_FUNCTION;

 END_SCHEMA; -- end GEOMETRY schema

 SCHEMA topology_schema;
   REFERENCE FROM geometry_schema;
   REFERENCE FROM representation_schema(representation_item);

 CONSTANT
    dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();        
 END_CONSTANT;

 TYPE list_of_reversible_topology_item =
                               LIST [0:?] of reversible_topology_item;
 END_TYPE;

 TYPE reversible_topology = SELECT
           (reversible_topology_item,
            list_of_reversible_topology_item,
            set_of_reversible_topology_item);
 END_TYPE;

 TYPE reversible_topology_item = SELECT
   (edge, 
    path, 
    face, 
    face_bound,
    closed_shell, 
    open_shell);
 END_TYPE;

  TYPE set_of_reversible_topology_item =
                       SET [0:?] of reversible_topology_item;
  END_TYPE;

 TYPE shell = SELECT
   (vertex_shell,
    wire_shell,
    open_shell,
    closed_shell);
 END_TYPE;

 ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
   ces_edges : SET [1:?] OF edge;
 END_ENTITY;

 ENTITY connected_face_set
   SUPERTYPE OF (ONEOF (closed_shell, open_shell))
   SUBTYPE OF (topological_representation_item);
   cfs_faces : SET [1:?] OF face;
 END_ENTITY;

 ENTITY connected_face_sub_set
   SUBTYPE OF (connected_face_set);
   parent_face_set   :  connected_face_set;
 END_ENTITY;

 ENTITY edge
   SUPERTYPE OF(ONEOF(edge_curve, oriented_edge, subedge))
   SUBTYPE OF (topological_representation_item);
   edge_start : vertex;
   edge_end   : vertex;
 END_ENTITY;

 ENTITY edge_curve
   SUBTYPE OF(edge,geometric_representation_item);
   edge_geometry : curve;
   same_sense    : BOOLEAN;
 END_ENTITY;

 ENTITY edge_loop
   SUBTYPE OF (loop,path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
 END_ENTITY;

 ENTITY face
   SUPERTYPE OF(ONEOF(face_surface, subface, oriented_face))
   SUBTYPE OF (topological_representation_item);
   bounds : SET[1:?] OF face_bound;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
   WR2: SIZEOF(QUERY(temp <* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp))) <= 1;
 END_ENTITY;

 ENTITY face_bound
   SUBTYPE OF(topological_representation_item);
   bound       :  loop;
   orientation :  BOOLEAN;
 END_ENTITY;

    ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
    END_ENTITY;

 ENTITY face_surface
   SUBTYPE OF(face,geometric_representation_item);
   face_geometry :  surface;
   same_sense    :  BOOLEAN;
 WHERE
   WR1: NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
 END_ENTITY;

 ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY open_path
   SUBTYPE OF (path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_element.edge_start) :<>:
                       (SELF\path.edge_list[ne].edge_element.edge_end);
 END_ENTITY;

 ENTITY open_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
   closed_shell_element : closed_shell;
   orientation          : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
 END_ENTITY;

 ENTITY oriented_edge
   SUBTYPE OF (edge);
   edge_element : edge;
   orientation  : BOOLEAN;
 DERIVE
   SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
   SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
 END_ENTITY;

 ENTITY oriented_face
   SUBTYPE OF (face);
   face_element : face;
   orientation  : BOOLEAN;
 DERIVE
   SELF\face.bounds : SET[1:?] OF face_bound
          := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
 END_ENTITY;

 ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
   open_shell_element : open_shell;
   orientation        : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
 END_ENTITY;

 ENTITY oriented_path
   SUBTYPE OF (path);
   path_element : path;
   orientation  : BOOLEAN;
 DERIVE
   SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge
                           := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
 END_ENTITY;

 ENTITY path
   SUPERTYPE OF (ONEOF(open_path, edge_loop, oriented_path))
   SUBTYPE OF (topological_representation_item);
   edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
 WHERE
   WR1: path_head_to_tail(SELF);
 END_ENTITY;

 ENTITY poly_loop
   SUBTYPE OF (loop,geometric_representation_item);
   polygon : LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY seam_edge
   SUBTYPE OF (oriented_edge);
     pcurve_reference : pcurve ; 
 WHERE
    WR1 : ( 'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element) )  AND
                ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF
                       (edge_element\edge_curve.edge_geometry)) ;
   WR2 :  pcurve_reference IN edge_element\edge_curve.edge_geometry\
                                 surface_curve.associated_geometry ;
 END_ENTITY;

 ENTITY subedge
   SUBTYPE OF (edge);
   parent_edge   :  edge;
 END_ENTITY;

 ENTITY subface
   SUBTYPE OF (face);
   parent_face   :  face;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
              list_to_set(list_face_loops(parent_face))));
 END_ENTITY;

 ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell,
                   wire_shell, connected_edge_set, connected_face_set,
                    (loop ANDOR path)))
   SUBTYPE OF (representation_item);
 END_ENTITY;

 ENTITY vertex
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY vertex_point
 SUBTYPE OF(vertex,geometric_representation_item);
   vertex_geometry : point;
 END_ENTITY;

 ENTITY vertex_loop
   SUBTYPE OF (loop);
   loop_vertex : vertex;
 END_ENTITY;

 ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
   vertex_shell_extent : vertex_loop;
 END_ENTITY;

 ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
   wire_shell_extent : SET [1:?] OF loop;
 WHERE
   WR1: NOT mixed_loop_type_set(wire_shell_extent);
 END_ENTITY;

   FUNCTION boolean_choose (b : boolean;
            choice1, choice2 : generic : item)  : generic : item;
 
     IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;
   END_FUNCTION;

 FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                       oriented_closed_shell;
  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION conditional_reverse (p       : BOOLEAN;
                               an_item : reversible_topology)
                                       : reversible_topology;
   IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
 END_FUNCTION;

FUNCTION edge_curve_pcurves (an_edge  : edge_curve;
                       the_surface_curves : SET OF surface_curve)
      : SET OF pcurve;
LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
         IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];
         END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;

  RETURN (RESULT);
END_FUNCTION;

 FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
   LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
   LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_reversed (a_face : face) : oriented_face;
   LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_loop_edges(l: loop): LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);
       edges := edges + (l\path.edge_list[i].edge_element);
     END_REPEAT;
   END_IF;

   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_of_topology_reversed (a_list
                                  : list_of_reversible_topology_item)
                                  : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_shell_edges(s : shell) : LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
     edges := edges + list_loop_edges(list_shell_loops(s)[i]);
   END_REPEAT;
   
   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_shell_faces(s : shell) : LIST[0:?] OF face;
   LOCAL
     faces : LIST[0:?] OF face := [];
   END_LOCAL;
   
   IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
       faces := faces + s\connected_face_set.cfs_faces[i];
     END_REPEAT;
   END_IF;
      
   RETURN(faces);
 END_FUNCTION;

 FUNCTION list_shell_loops(s : shell) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
     loops := loops + s.vertex_shell_extent;
   END_IF;
      
   IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
     REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
       loops := loops + s.wire_shell_extent[i];
     END_REPEAT;
   END_IF;
      
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);
       loops := loops + list_face_loops(s.cfs_faces[i]);
     END_REPEAT;
   END_IF;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);
 END_FUNCTION;

 FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
    LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) <= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION;

 FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                         oriented_open_shell;
   LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION path_head_to_tail(a_path : path) : BOOLEAN;
   LOCAL
     n : INTEGER;
     p : BOOLEAN := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);
 END_FUNCTION;

FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

 FUNCTION set_of_topology_reversed (a_set : set_of_reversible_topology_item)
                                          : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION shell_reversed (a_shell : shell) : shell;
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;
 END_FUNCTION;

 FUNCTION topology_reversed (an_item : reversible_topology)
                                     : reversible_topology;

   IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);
 END_FUNCTION;


FUNCTION vertex_point_pcurves (a_vertex  : vertex_point; 
      the_degenerates : SET OF evaluated_degenerate_pcurve)
      : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
    result := result + a_point;
  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);
         IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
            result := result + the_degenerates[j];
         END_IF;
      END_REPEAT;
  END_IF;

  RETURN (RESULT);
END_FUNCTION;

 END_SCHEMA; -- end TOPOLOGY schema

SCHEMA geometric_model_schema;
   REFERENCE FROM geometry_schema;
   REFERENCE FROM topology_schema;
   REFERENCE FROM measure_schema(length_measure,
                                 parameter_value,
                                 plane_angle_measure,
                                 plane_angle_unit,
                                 positive_length_measure,
                                 positive_plane_angle_measure);

 TYPE boolean_operand = SELECT
   (solid_model, 
    half_space_solid,
    csg_primitive,
    boolean_result,
    half_space_2d);
 END_TYPE;

 TYPE boolean_operator = ENUMERATION OF 
   (union, 
    intersection, 
    difference);
 END_TYPE;

 TYPE csg_select = SELECT
   (boolean_result,
    csg_primitive);
 END_TYPE;

 TYPE csg_primitive = SELECT
   (sphere,
    ellipsoid,
    block,
    right_angular_wedge,
    faceted_primitive,
    rectangular_pyramid,
    torus,
    right_circular_cone,
    eccentric_cone,
    right_circular_cylinder,
    cyclide_segment_solid,
    primitive_2d);
 END_TYPE;

 TYPE geometric_set_select = SELECT
   (point,
    curve,
    surface);
 END_TYPE;

 TYPE surface_model = SELECT
   (shell_based_surface_model, 
    face_based_surface_model);
 END_TYPE;

 TYPE wireframe_model = SELECT
   (shell_based_wireframe_model,
    edge_based_wireframe_model);
 END_TYPE;

 ENTITY block
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
 END_ENTITY;

 ENTITY boolean_result
   SUBTYPE OF (geometric_representation_item);
   operator        : boolean_operator;
   first_operand   :  boolean_operand;
   second_operand  :  boolean_operand;
 END_ENTITY;

 ENTITY box_domain;
   corner  : cartesian_point;
   xlength : positive_length_measure;
   ylength : positive_length_measure;
   zlength : positive_length_measure;
 WHERE
   WR1: SIZEOF(QUERY(item <* USEDIN(SELF,'')|
             NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE'
                    IN TYPEOF(item)))) = 0;
 END_ENTITY;

 ENTITY boxed_half_space
   SUBTYPE OF(half_space_solid);
   enclosure : box_domain;
 END_ENTITY;

 ENTITY brep_2d
  SUBTYPE OF (solid_model);
  extent : face;
  WHERE
    WR1:  SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE',
          'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] *
              TYPEOF (SELF.extent)) = 0;
   WR2 : SIZEOF (QUERY (bnds <* extent.bounds |
         NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) ) = 0;
   WR3 : SIZEOF (QUERY (bnds <* extent.bounds |
         'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
   WR4 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
          NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list | NOT
          (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND
         (oe.edge_element\geometric_representation_item.dim = 2)))) =
                0))) = 0;
 END_ENTITY;

 ENTITY brep_with_voids
   SUBTYPE OF (manifold_solid_brep);
   voids : SET [1:?] OF oriented_closed_shell;
 END_ENTITY;

ENTITY  circular_area
  SUBTYPE OF (primitive_2d);
    centre: cartesian_point;
    radius: positive_length_measure;
END_ENTITY;

 ENTITY convex_hexahedron
   SUBTYPE OF (faceted_primitive);
  WHERE
    WR1: SIZEOF(points) = 8 ;
    WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
    WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
    WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
    WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
    WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
    WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
    WR8: same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
    WR9: same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
    WR10: same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
    WR11: same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
    WR12: same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
    WR13: same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
  END_ENTITY;

 ENTITY csg_solid
   SUBTYPE OF (solid_model);
   tree_root_expression : csg_select;
 END_ENTITY;

ENTITY cyclide_segment_solid
   SUBTYPE OF (geometric_representation_item);
   position    : axis2_placement_3d;
   radius1     : positive_length_measure;
   radius2     : positive_length_measure;
   cone_angle1 : plane_angle_measure;
   cone_angle2 : plane_angle_measure;
   turn_angle  : plane_angle_measure;
END_ENTITY;

 ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
   position    : axis2_placement_3d;
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
   height      : positive_length_measure;
   x_offset    : length_measure;
   y_offset    : length_measure;
   ratio       : REAL;
 WHERE
  WR1 : ratio >= 0.0;
 END_ENTITY;

 ENTITY edge_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   ebwm_boundary  : SET [1:?] OF connected_edge_set;
 END_ENTITY;

 ENTITY face_based_surface_model
   SUBTYPE OF (geometric_representation_item);
   fbsm_faces : SET [1:?] OF connected_face_set;
 END_ENTITY;

 ENTITY geometric_curve_set
   SUBTYPE OF (geometric_set);
 WHERE
   WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
                            'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp))) = 0;
 END_ENTITY;

 ENTITY geometric_set
   SUPERTYPE OF (ONEOF(geometric_curve_set,
                       geometric_set_replica))
   SUBTYPE OF (geometric_representation_item);
   elements :  SET [1:?] OF geometric_set_select;
 END_ENTITY;

 ENTITY ellipsoid
   SUBTYPE OF (geometric_representation_item);
     position      : axis2_placement_3d;
     semi_axis_1 : positive_length_measure;
     semi_axis_2 : positive_length_measure;
     semi_axis_3 : positive_length_measure;
 END_ENTITY;

ENTITY  elliptic_area
  SUBTYPE OF (primitive_2d);
    position : axis2_placement_2d;
    semi_axis_1 : positive_length_measure;
    semi_axis_2 : positive_length_measure;
END_ENTITY;

 ENTITY extruded_area_solid
   SUBTYPE OF (swept_area_solid);
   extruded_direction : direction;
   depth              : positive_length_measure;
 WHERE
   WR1: dot_product(
        (SELF\swept_area_solid.swept_area.basis_surface\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
 END_ENTITY;

 ENTITY extruded_face_solid
   SUBTYPE OF (swept_face_solid);
   extruded_direction : direction;
   depth              : positive_length_measure;
 WHERE
   WR1: dot_product(
        (SELF\swept_face_solid.swept_face.face_geometry\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
 END_ENTITY;

 ENTITY faceted_brep
   SUBTYPE OF (manifold_solid_brep);
 END_ENTITY;

 ENTITY faceted_primitive
   SUPERTYPE OF (ONEOF(tetrahedron, convex_hexahedron))
   SUBTYPE OF (geometric_representation_item) ;
     points : LIST[4:?] OF UNIQUE cartesian_point ;
  WHERE
    WR1: points[1].dim = 3 ;
  END_ENTITY;

  ENTITY geometric_set_replica
   SUBTYPE OF (geometric_set); 
     parent_set     : geometric_set; 
     transformation : cartesian_transformation_operator; 
   DERIVE 
     SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := 
           build_transformed_set(transformation, parent_set); 
   WHERE
     WR1: acyclic_set_replica(SELF, parent_set);
   END_ENTITY;

ENTITY  half_space_2d
  SUBTYPE OF (geometric_representation_item);
    base_curve:  curve;
    agreement_flag: BOOLEAN;
END_ENTITY;

 ENTITY half_space_solid
   SUBTYPE OF(geometric_representation_item);
   base_surface   : surface;
   agreement_flag : BOOLEAN;
 END_ENTITY;

 ENTITY manifold_solid_brep
   SUBTYPE OF (solid_model);
   outer : closed_shell;
 END_ENTITY;

 ENTITY polygonal_area
   SUBTYPE OF (primitive_2d);
   bounds:  LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY primitive_2d
   SUPERTYPE  OF (ONEOF (circular_area, elliptic_area, rectangular_area,
                            polygonal_area))
   SUBTYPE OF (geometric_representation_item);
   WHERE
     WR1 : SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY rectangle_domain;
   corner: cartesian_point;
   xlength: positive_length_measure;
   ylength: positive_length_measure;
 WHERE
   WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT
   ('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
 END_ENTITY;

ENTITY rectangled_half_space
  SUBTYPE OF (half_space_2d);
    enclosure: rectangle_domain;
END_ENTITY;

ENTITY rectangular_area
  SUBTYPE OF (primitive_2d);
    position: axis2_placement_2d;
    x: positive_length_measure;
    y: positive_length_measure;
END_ENTITY;

 ENTITY rectangular_pyramid
   SUBTYPE OF (geometric_representation_item);
   position       : axis2_placement_3d;
   xlength        : positive_length_measure;
   ylength        : positive_length_measure;
   height         : positive_length_measure;
 END_ENTITY;

 ENTITY revolved_area_solid
   SUBTYPE OF (swept_area_solid);
   axis  : axis1_placement;
   angle : plane_angle_measure;
 DERIVE
   axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
 END_ENTITY;

 ENTITY revolved_face_solid  SUBTYPE OF (swept_face_solid);
   axis  : axis1_placement;
   angle : plane_angle_measure;
 DERIVE
   axis_line : line := representation_item('')||
                     geometric_representation_item()|| curve()||
                     line(axis.location, representation_item('')||
                     geometric_representation_item()||
                     vector(axis.z, 1.0));
 END_ENTITY;

 ENTITY right_angular_wedge
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
   ltx      : length_measure;
 WHERE
   WR1: ((0.0 <= ltx) AND (ltx < x));
 END_ENTITY;

 ENTITY right_circular_cone
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;

 ENTITY right_circular_cylinder
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : positive_length_measure;
 END_ENTITY;

 ENTITY sectioned_spine
   SUBTYPE OF (geometric_curve_set);
      cross_sections   : LIST[2:?] OF curve;
      spine_points     : LIST[2:?] OF point;
   WHERE
     WR1 : SIZEOF(SELF\geometric_set.elements) = 1;
     WR2 : 'GEOMETRY_SCHEMA.CURVE' IN
                     TYPEOF(SELF\geometric_set.elements[1]);
     WR3 : SIZEOF(cross_sections) = SIZEOF(spine_points);
     WR4 : SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY shell_based_surface_model
   SUBTYPE OF (geometric_representation_item);
   sbsm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_surface_model(SELF);
 END_ENTITY;

 ENTITY shell_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   sbwm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_wireframe_model(SELF);
 END_ENTITY;

 ENTITY solid_replica
   SUBTYPE OF (solid_model);
   parent_solid   : solid_model;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_solid_replica(SELF, parent_solid);
   WR2: parent_solid\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY solid_model
   SUPERTYPE OF (ONEOF( csg_solid, manifold_solid_brep, swept_face_solid,
                        swept_area_solid, solid_replica,
                        brep_2d, trimmed_volume))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY sphere
   SUBTYPE OF (geometric_representation_item);
   radius : positive_length_measure;
   centre : point;
 END_ENTITY;

 ENTITY surface_curve_swept_area_solid
   SUBTYPE OF (swept_area_solid);
      directrix          : curve;
      start_param        : REAL;
      end_param          : REAL;
      reference_surface  : surface;
   WHERE
     WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY surface_curve_swept_face_solid
   SUBTYPE OF (swept_face_solid);
      directrix          : curve;
      start_param        : REAL;
      end_param          : REAL;
      reference_surface  : surface;
   WHERE
     WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY swept_area_solid
   SUPERTYPE OF (ONEOF(revolved_area_solid, extruded_area_solid,
                       surface_curve_swept_area_solid))
   SUBTYPE OF (solid_model);
   swept_area :  curve_bounded_surface;
 WHERE
   WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
 END_ENTITY;

 ENTITY swept_face_solid
   SUPERTYPE OF (ONEOF(extruded_face_solid, revolved_face_solid,
                 surface_curve_swept_face_solid))
   SUBTYPE OF (solid_model);
   swept_face :  face_surface;
 WHERE
   WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
 END_ENTITY;

 ENTITY tetrahedron
   SUBTYPE OF (faceted_primitive);
  WHERE
    WR1: SIZEOF(points) = 4 ;
    WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
  END_ENTITY;

 ENTITY torus
   SUBTYPE OF (geometric_representation_item);
   position     : axis1_placement;
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 WHERE
   WR1: major_radius > minor_radius;
 END_ENTITY;

 ENTITY trimmed_volume
   SUBTYPE OF (solid_model);
   basis_volume :  volume;
     u1         :  parameter_value;
     u2         :  parameter_value;
     v1         :  parameter_value;
     v2         :  parameter_value;
     w1         :  parameter_value;
     w2         :  parameter_value;
   WHERE
     WR1 : u1 <> u2;
     WR2 : v1 <> v2;
     WR3 : w1 <> w2;
 END_ENTITY;

 
 FUNCTION acyclic_set_replica(rep : geometric_set_replica;
                           parent : geometric_set) : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
        THEN  RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type geometric_set_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same geometric_set_replica,
     otherwise, call function again with the parents own parent_set.  *)
    ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_solid_replica(rep : solid_replica; parent :
                    solid_model) : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;
  END_FUNCTION;

  FUNCTION build_transformed_set(tr: cartesian_transformation_operator;
           gset : geometric_set) : SET [0:?] OF geometric_set_select;
    LOCAL
     s          : SET [1:?] OF geometric_set_select := gset.elements;
     trset      : SET [0:?] OF geometric_set_select := [];
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(s);
      IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j])) THEN
         trset := trset + curve_replica(s[j],tr); ELSE
         IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j])) THEN
           trset := trset + point_replica(s[j],tr); ELSE
           IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j])) THEN
             trset := trset + surface_replica(s[j],
                tr || cartesian_transformation_operator_3d (?));
           END_IF;
         END_IF;
      END_IF;
    END_REPEAT;
    RETURN(trset);
   END_FUNCTION;

 FUNCTION constraints_geometry_shell_based_surface_model
             (m: shell_based_surface_model): BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION constraints_geometry_shell_based_wireframe_model
                       (m : shell_based_wireframe_model) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION msb_shells (brep: manifold_solid_brep) :
                          SET [1:?] OF  closed_shell;
 
     IF SIZEOF (QUERY (msbtype <* TYPEOF (brep) |
       msbtype LIKE '*BREP_WITH_VOIDS')) >= 1 THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
 END_FUNCTION;

 END_SCHEMA; -- end GEOMETRIC MODEL schema
(* wg12n458.exp, p43e2 *)
SCHEMA representation_schema;

REFERENCE FROM basic_attribute_schema
  (get_description_value,
   get_id_value);

REFERENCE FROM measure_schema
  (measure_value,
   measure_with_unit);

REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;

TYPE transformation = SELECT
  (item_defined_transformation,
   functionally_defined_transformation);
END_TYPE;

ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF (SELF\representation.context_of_items );
END_ENTITY;

ENTITY founded_item;
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;

ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item : representation_item;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1:
   SELF\representation_relationship.rep_1.context_of_items
   :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;

ENTITY uncertainty_assigned_representation
  SUBTYPE OF (representation);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
       NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
       IN TYPEOF (rep.context_of_items)
       ))) = 0;
END_ENTITY;

FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z <* children_set | 'REPRESENTATION_SCHEMA.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);
END_FUNCTION;

FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN (item , '') |
           'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Ensure that the bag is not empty
      IF SIZEOF(y) > 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);
END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);
END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);
END_FUNCTION;

FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;

END_SCHEMA; -- representation_schema

(*
EXPRESS: wg12n529 part 44 e2
*)
SCHEMA product_structure_schema;

  REFERENCE FROM product_definition_schema
    (product,
     product_definition,
     product_definition_relationship,
     acyclic_product_definition_relationship);

  REFERENCE FROM measure_schema
     (measure_with_unit);

  REFERENCE FROM support_resource_schema
     (identifier, label, text);

ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
                       specified_higher_usage_occurrence,
                       promissory_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF (QUERY (example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition)) =SIZEOF(members);
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: 
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>: 
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (make_from_usage_option,
                       assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;

END_SCHEMA; -- product_structure

SCHEMA product_concept_schema;

  REFERENCE FROM support_resource_schema
    (text, label, identifier);

  REFERENCE FROM application_context_schema
    (product_concept_context);

ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY concept_feature_relationship;
  name                              : label;
  description                       : OPTIONAL text;
  relating_product_concept_feature  : product_concept_feature;
  related_product_concept_feature   : product_concept_feature;
END_ENTITY;

ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;

END_SCHEMA; -- product_concept_schema

SCHEMA configuration_management_schema;

  REFERENCE FROM product_definition_schema
    (product_definition,
     product_definition_formation,
     product_definition_effectivity);

  REFERENCE FROM product_structure_schema
    (product_definition_usage);

  REFERENCE FROM product_concept_schema
    (product_concept,
     product_concept_feature_association);

  REFERENCE FROM basic_attribute_schema
    (get_description_value,
     get_name_value);

  REFERENCE FROM support_resource_schema
    (text, label, identifier, bag_to_set);

TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation);
END_TYPE;

ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET[1:?] OF product_concept_feature_association;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       usage,
       id;
WHERE
  WR1: 'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;

ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;

END_SCHEMA; -- configuration_management_schema
(*

The following EXPRESS incorporates ISO 10303-45 
   Technical Corrigendum 1 into the IS version of the
   EXPRESS.  This document is ISO TC 184/SC4/WG12 N256

*)
SCHEMA material_property_definition_schema;

REFERENCE FROM product_definition_schema
      (product_definition_relationship);

REFERENCE FROM product_property_definition_schema
      (characterized_definition,
      property_definition);

REFERENCE FROM support_resource_schema
     (label,
      text,
      bag_to_set);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM material_property_representation_schema
     (material_property_representation);

TYPE characterized_material_property = SELECT
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;

ENTITY property_definition_relationship;
  name                       : label;
  description                 : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;

ENTITY material_designation;
  name       : label;
  definitions : SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name       : label;
  description : text;
  designation : material_designation;
  property    : characterized_material_property;
END_ENTITY;

ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class               : label;
  constituent_amount   : SET [1:?] OF measure_with_unit;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
   relatives         : SET [1:?] OF property_definition;
   specific_relation : STRING) : LOGICAL;

  LOCAL
    x                : SET OF property_definition_relationship;
  END_LOCAL;

  IF relation.relating_property_definition IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality

  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_property_definition,
        'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION')) |
         specific_relation IN TYPEOF (pd));

  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
      (x[i],
       relatives + relation.relating_property_definition,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;

  RETURN(TRUE);
END_FUNCTION;  -- acyclic_property_definition_relationship

END_SCHEMA;    -- material_property_definition_schema

SCHEMA material_property_representation_schema;

REFERENCE FROM product_property_representation_schema
     (property_definition_representation);

REFERENCE FROM support_resource_schema
     (label,
      text);

ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;

ENTITY data_environment;
  name       : label;
  description : text;
  elements    : SET [1:?] OF property_definition_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                    : label;
  description              : text;
  relating_data_environment : data_environment;
  related_data_environment  : data_environment;
END_ENTITY;

END_SCHEMA;    -- material_property_representation_schema

SCHEMA qualified_measure_schema;

REFERENCE FROM support_resource_schema
     (label,
      text);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM representation_schema
     (representation_item);

TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier);
END_TYPE;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF (standard_uncertainty,
                     qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY measure_qualification;
  name : label;
  description : text;
  qualified_measure : measure_with_unit;
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

END_SCHEMA;  -- qualified_measure_schema
(*  
    The following EXPRESS is for ISO 10303-46:1994 Technical Corrigendum 2

    This is document ISO TC184/SC4/WG12 N953
*)

SCHEMA presentation_organization_schema;

REFERENCE FROM presentation_resource_schema
   (colour,
    planar_box,
    planar_extent,
    presentation_scaled_placement);

REFERENCE FROM presentation_definition_schema
    (annotation_occurrence,
     symbol_representation,
     symbol_representation_relationship);

REFERENCE FROM presentation_appearance_schema
    (styled_item);

REFERENCE FROM geometry_schema
    (axis2_placement_2d,
     axis2_placement_3d,
     cartesian_point,
     curve,
     direction,
     dot_product,
     geometric_representation_context,
     geometric_representation_item,
     plane
     );
 
REFERENCE FROM representation_schema
    (founded_item,
     item_defined_transformation,
     item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation);
 
REFERENCE FROM measure_schema
   (length_measure,
    positive_ratio_measure,
    positive_plane_angle_measure);
 
REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text,
     bag_to_set);

TYPE presentation_size_assignment_select = SELECT 
  (presentation_view,
   presentation_area,
   area_in_set);
END_TYPE;

TYPE area_or_view = SELECT 
  (presentation_area,
   presentation_view);
END_TYPE;

TYPE central_or_parallel = ENUMERATION OF 
  (central, 
   parallel);
END_TYPE;

TYPE layered_item = SELECT 
  (presentation_representation,
   representation_item);
END_TYPE;

TYPE presentation_representation_select = SELECT 
  (presentation_representation,
   presentation_set);
END_TYPE;

ENTITY presentation_set;
INVERSE
  areas : SET [1:?] OF area_in_set FOR in_set;
END_ENTITY;

ENTITY presentation_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SELF\representation.
            context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT'
       IN TYPEOF (SELF\representation.context_of_items);
END_ENTITY;

ENTITY presentation_area
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: ((SIZEOF (QUERY (ais <* USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                             'AREA_IN_SET.AREA') | 
           SIZEOF (USEDIN (ais, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
         (SIZEOF (USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                'PRESENTATION_SIZE.UNIT')) =1));
END_ENTITY;

ENTITY area_in_set;
  area   : presentation_area;
  in_set : presentation_set;
END_ENTITY;

ENTITY presentation_view
  SUBTYPE OF (presentation_representation);
END_ENTITY;

ENTITY area_dependent_annotation_representation
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.' +
                     'ANNOTATION_OCCURRENCE',
                     'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] * 
            TYPEOF(item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items | 
       ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
         TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY product_data_representation_view
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_IMAGE',
                     'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] *
                    TYPEOF (item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items | 
       ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_IMAGE' IN
        TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY view_dependent_annotation_representation
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.' +
                     'ANNOTATION_OCCURRENCE',
                     'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] * 
            TYPEOF(item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items |
       ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
        TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY presentation_size;
  unit : presentation_size_assignment_select;
  size : planar_box;
WHERE
  WR1: (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
         IN TYPEOF (SELF.unit)) AND
         item_in_context (SELF.size, 
                          SELF.unit\representation.context_of_items)
       )
            OR
       (
        ('PRESENTATION_ORGANIZATION_SCHEMA.AREA_IN_SET'
          IN TYPEOF (SELF.unit)) AND
        (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
                NOT item_in_context (SELF.size, ais.area\representation.
                                                context_of_items) )) = 0)
       ); 
END_ENTITY;

ENTITY background_colour
  SUBTYPE OF (colour);
  presentation : area_or_view;
UNIQUE
  UR1:  presentation;
END_ENTITY;

ENTITY presentation_representation_relationship
  SUBTYPE OF (representation_relationship_with_transformation);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.PRESENTATION_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.PRESENTATION_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2);
  WR3: acyclic_presentation_representation_relationship (SELF,
         [SELF\representation_relationship.rep_2]);
  WR4: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
         TYPEOF (SELF\representation_relationship.rep_1)) 
                 AND
         NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                       'PRODUCT_DATA_REPRESENTATION_VIEW',
                       'PRESENTATION_ORGANIZATION_SCHEMA.' +
                       'VIEW_DEPENDENT_ANNOTATION_REPRESENTATION'] *
         TYPEOF (SELF\representation_relationship.rep_2)) = 0));
  WR5: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW'
         IN TYPEOF (SELF\representation_relationship.rep_1))
                 AND
       NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                     'PRESENTATION_AREA',
                     'PRESENTATION_ORGANIZATION_SCHEMA.' +
                     'PRESENTATION_VIEW',
                     'PRESENTATION_ORGANIZATION_SCHEMA.' +
                     'AREA_DEPENDENT_ANNOTATION_REPRESENTATION'] *
              TYPEOF (SELF\representation_relationship.rep_2))=0));
  WR6: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_2)))
              XOR
         ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA'IN
         TYPEOF(SELF\representation_relationship.rep_1));
  WR7: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.' +
             'PRODUCT_DATA_REPRESENTATION_VIEW' IN
         (TYPEOF(SELF\representation_relationship.rep_1) +
          TYPEOF(SELF\representation_relationship.rep_2))))
              XOR
       ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_1))
                AND
       ('PRESENTATION_ORGANIZATION_SCHEMA.PRODUCT_DATA_REPRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_2));
  WR8: 'PRESENTATION_ORGANIZATION_SCHEMA.GRAPHICAL_TRANSFORMATION' IN
         TYPEOF(SELF\representation_relationship_with_transformation.
                     transformation_operator);
END_ENTITY;

ENTITY graphical_transformation
  SUBTYPE OF (item_defined_transformation);
WHERE
  WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D' IN
         TYPEOF (SELF\item_defined_transformation.transform_item_1);
  WR2: 'PRESENTATION_RESOURCE_SCHEMA.PRESENTATION_SCALED_PLACEMENT' IN
         TYPEOF (SELF\item_defined_transformation.transform_item_2);
END_ENTITY;

ENTITY camera_model
  SUPERTYPE OF (ONEOF(camera_model_d2, camera_model_d3))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: (SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                              'ITEM_DEFINED_TRANSFORMATION.' +
                              'TRANSFORM_ITEM_1')) +
        SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                              'REPRESENTATION_MAP.MAPPING_ORIGIN'))
       ) > 0;
  WR2: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                          'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY camera_model_d2
  SUBTYPE OF (camera_model);
  view_window          : planar_box;
  view_window_clipping : BOOLEAN;
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY camera_model_d2_shape_clipping
  SUBTYPE OF (camera_model_d2);
  shape_clipping : curve;
END_ENTITY;

ENTITY camera_model_d3
  SUBTYPE OF (camera_model);
  view_reference_system : axis2_placement_3d;
  perspective_of_volume : view_volume;
WHERE
  WR1: (dot_product (SELF.view_reference_system.p[3],
         SELF.perspective_of_volume.view_window.placement.p[3]) = 1.0)
         AND
       (SELF.view_reference_system.location.coordinates[3] =
        SELF.perspective_of_volume.view_window.
             placement.location.coordinates[3]);
  WR2: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY view_volume
  SUBTYPE OF (founded_item);
  projection_type            : central_or_parallel;
  projection_point           : cartesian_point;
  view_plane_distance        : length_measure;
  front_plane_distance       : length_measure;
  front_plane_clipping       : BOOLEAN;
  back_plane_distance        : length_measure;
  back_plane_clipping        : BOOLEAN;
  view_volume_sides_clipping : BOOLEAN;
  view_window                : planar_box;
END_ENTITY;

ENTITY camera_model_d3_with_hlhsr
  SUBTYPE OF (camera_model_d3);
  hidden_line_surface_removal : BOOLEAN;
END_ENTITY;

ENTITY camera_model_d3_multi_clipping
  SUBTYPE OF (camera_model_d3);
  shape_clipping : SET [1:?] OF plane;
END_ENTITY;

ENTITY camera_model_with_light_sources
  SUBTYPE OF (camera_model_d3);
  sources : SET [1:?] OF light_source;
END_ENTITY;

ENTITY light_source
  SUPERTYPE OF (ONEOF(light_source_ambient,
                      light_source_directional,
                      light_source_positional,
                      light_source_spot))
  SUBTYPE OF (geometric_representation_item);
  light_colour : colour;
WHERE
  WR1: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                         'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY light_source_ambient
  SUBTYPE OF (light_source);
END_ENTITY;

ENTITY light_source_directional
  SUBTYPE OF (light_source);
  orientation : direction;
END_ENTITY;

ENTITY light_source_positional
  SUBTYPE OF (light_source);
  position             : cartesian_point;
  constant_attenuation : REAL;
  distance_attenuation : REAL;
END_ENTITY;

ENTITY light_source_spot
  SUBTYPE OF (light_source);
  position               : cartesian_point;
  orientation            : direction;
  concentration_exponent : REAL;
  constant_attenuation   : REAL;
  distance_attenuation   : REAL;
  spread_angle           : positive_plane_angle_measure;
END_ENTITY;

ENTITY camera_image
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_USAGE'
       IN TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'PRESENTATION_RESOURCE_SCHEMA.PLANAR_BOX'
       IN TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'
       IN TYPEOF (SELF);
END_ENTITY;

ENTITY camera_usage
  SUBTYPE OF (representation_map);
WHERE
  WR1: NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
       IN TYPEOF(SELF\representation_map.mapped_representation));
  WR2: 'PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL'
       IN TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY camera_image_3d_with_scale
  SUBTYPE OF (camera_image);
DERIVE
  scale: positive_ratio_measure := ((SELF\mapped_item.mapping_target\
         planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.
         mapping_origin\camera_model_d3.perspective_of_volume.view_window.
         size_in_x));
WHERE
  WR1: ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL_D3'
       IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin));
  WR2: aspect_ratio(SELF\mapped_item.mapping_target) =
       aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\
       camera_model_d3.perspective_of_volume.view_window);
  WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.front_plane_clipping
       AND
       SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_volume_sides_clipping;
  WR4: (SELF\mapped_item.mapping_target\planar_extent.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_target\planar_extent.size_in_y > 0);
  WR5: (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_y > 0);
  WR6: ('GEOMETRY_SCHEMA.' +
       'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement))
       AND NOT ('GEOMETRY_SCHEMA.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement));
END_ENTITY;

ENTITY presentation_layer_assignment;
  name           : label;
  description    : text;
  assigned_items : SET [1:?] OF layered_item;
END_ENTITY;

ENTITY representation_item_dependent_layer_assignment
  SUBTYPE OF (presentation_layer_assignment);
  item_context : representation_item;
END_ENTITY;

ENTITY presentation_layer_usage;
  assignment   : presentation_layer_assignment;
  presentation : presentation_representation;
UNIQUE
  UR1: assignment, presentation;
END_ENTITY;

ENTITY presented_item_representation;
  presentation : presentation_representation_select;
  item         : presented_item;
END_ENTITY;

ENTITY presented_item
  ABSTRACT SUPERTYPE;
END_ENTITY;

RULE symbol_representation_rule
  FOR (presentation_representation_relationship);
WHERE
  WR1: SIZEOF(QUERY(each_1 <* presentation_representation_relationship  |
              NOT ('PRESENTATION_DEFINITION_SCHEMA.'+
              'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(each_1)) AND
         (SIZEOF(QUERY(each_2 <* [each_1\representation_relationship.rep_1,
                                  each_1\representation_relationship.rep_2] |
         'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN TYPEOF(each_2)
         )) > 0)
       )) = 0;
END_RULE;

FUNCTION acyclic_presentation_representation_relationship
  ( relation : presentation_representation_relationship;
    children : SET OF presentation_representation ) : BOOLEAN;

  LOCAL
    x : SET OF presentation_representation_relationship;
    local_children : SET OF presentation_representation;
  END_LOCAL;

  REPEAT i:=1 TO HIINDEX(children);
    IF relation\representation_relationship.rep_1 :=: children[i] THEN
       RETURN(FALSE);
    END_IF;
  END_REPEAT;

  x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                  'REPRESENTATION_SCHEMA.'+
                  'REPRESENTATION_RELATIONSHIP.REP_2'));
  local_children := children + relation\representation_relationship.rep_1;

  IF SIZEOF (x) > 0 THEN
    REPEAT i:=1 TO HIINDEX (x);
       IF NOT acyclic_presentation_representation_relationship
              (x[i] , local_children) THEN
         RETURN (FALSE);
       END_IF;
    END_REPEAT;
  END_IF;

  RETURN (TRUE);

END_FUNCTION;

FUNCTION aspect_ratio (p : planar_box) : positive_ratio_measure;
(* if the dimensions of the planar_box are greater than zero,
      compute the aspect ratio and return the resulting value. *)
   IF (p.size_in_x > 0.) AND (p.size_in_y > 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
   ELSE
      RETURN (?);
   END_IF;
END_FUNCTION; 

END_SCHEMA; -- presentation_organization_schema 

SCHEMA presentation_definition_schema;
 
REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);
 
REFERENCE FROM geometry_schema
    (axis2_placement,
     curve,
     geometric_representation_item,
     point
     );
 
REFERENCE FROM measure_schema
    (positive_ratio_measure);
 
REFERENCE FROM presentation_appearance_schema
    (styled_item);
 
REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol,
     planar_box,
     planar_extent,
     font_select,
     presentable_text,
     text_font);
 
REFERENCE FROM representation_schema
    (item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     text,
     bag_to_set);

TYPE text_delineation = label;
END_TYPE;

TYPE defined_symbol_select = SELECT
  (pre_defined_symbol,
   externally_defined_symbol);
END_TYPE;

TYPE text_or_character = SELECT
  (annotation_text,
   annotation_text_character,
   defined_character_glyph,
   composite_text,
   text_literal);
END_TYPE;

TYPE text_alignment = label;
END_TYPE;

TYPE defined_glyph_select = SELECT
  (pre_defined_character_glyph,
   externally_defined_character_glyph);
END_TYPE;

TYPE text_path = ENUMERATION OF
  (left,
   right,
   up,
   down);
END_TYPE;

ENTITY annotation_fill_area
  SUBTYPE OF (geometric_representation_item);
  boundaries : SET [1:?] OF curve;
END_ENTITY;

ENTITY defined_symbol
  SUBTYPE OF(geometric_representation_item);
  definition : defined_symbol_select;
  target     : symbol_target;
END_ENTITY;

ENTITY defined_table
  SUBTYPE OF(defined_symbol);
END_ENTITY;

ENTITY symbol_target
  SUBTYPE OF (geometric_representation_item);
  placement         : axis2_placement;
  x_scale           : positive_ratio_measure;
  y_scale           : positive_ratio_measure;
END_ENTITY;

ENTITY pre_defined_symbol
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_symbol
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY annotation_symbol
  SUBTYPE OF(mapped_item);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION_MAP' IN
         TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_TARGET' IN
         TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_table
  SUBTYPE OF(annotation_symbol);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
END_ENTITY;

ENTITY symbol_representation_map
  SUBTYPE OF (representation_map);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN
         TYPEOF (SELF\representation_map.mapped_representation);
  WR2: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN
         TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY symbol_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY symbol_representation_with_blanking_box
  SUBTYPE OF (symbol_representation);
  blanking : planar_box;
WHERE
  WR1: item_in_context (SELF.blanking, SELF\representation.context_of_items);
END_ENTITY;

ENTITY table_representation
  SUBTYPE OF (symbol_representation);
END_ENTITY;

ENTITY table_record_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                            'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
       (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                               'REPRESENTATION_MAP.'+ 
                                               'MAPPED_REPRESENTATION') | 
         SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                              'MAPPED_ITEM.'+
                                              'MAPPING_SOURCE') |   
                                              'PRESENTATION_DEFINITION_SCHEMA.'+
                                              'TABLE_REPRESENTATION' IN 
             TYPEOF (using_representations (mi)) )) > 0))  
                    > 0);
END_ENTITY;

ENTITY table_record_field_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                            'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
       (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                               'REPRESENTATION_MAP.'+ 
                                               'MAPPED_REPRESENTATION') | 
         SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                              'MAPPED_ITEM.'+
                                              'MAPPING_SOURCE') |   
                                         'PRESENTATION_DEFINITION_SCHEMA.'+
                                           'TABLE_RECORD_REPRESENTATION' IN 
             TYPEOF (using_representations (mi)) )) > 0))  
                    > 0);
END_ENTITY;

ENTITY table_record_field_representation_with_clipping_box
  SUBTYPE OF (table_record_field_representation);
  clipping_box : planar_box;
WHERE
   WR1: item_in_context (SELF.clipping_box, 
                         SELF\representation.context_of_items);
END_ENTITY;

ENTITY symbol_representation_relationship
  SUBTYPE OF (representation_relationship_with_transformation);
WHERE
  WR1: acyclic_symbol_representation_relationship (SELF,
                                                   [SELF\representation_relationship.
                                                         rep_2]);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1);
  WR3: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION'IN
          TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY table_representation_relationship
  SUBTYPE OF (symbol_representation_relationship);
WHERE
  WR1: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1))   
         XOR
       ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
  WR2: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
             TYPEOF (SELF\representation_relationship.rep_1))   
         XOR
       ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
  WR3: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1)) 
         XOR
       ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
END_ENTITY;

ENTITY annotation_text
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN
       TYPEOF( SELF\mapped_item.mapping_target);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.TEXT_STRING_REPRESENTATION' IN
       TYPEOF( SELF\mapped_item.mapping_source.mapped_representation);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
       TYPEOF( SELF);
END_ENTITY;

ENTITY annotation_text_with_extent
  SUBTYPE OF (annotation_text);
  extent : planar_extent;
END_ENTITY;

ENTITY annotation_text_with_delineation
  SUBTYPE OF (annotation_text);
  delineation : text_delineation;
END_ENTITY;

ENTITY annotation_text_with_blanking_box
  SUBTYPE OF (annotation_text);
  blanking : planar_box;
END_ENTITY;

ENTITY annotation_text_with_associated_curves
  SUBTYPE OF (annotation_text);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY text_string_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (
         QUERY (item <* SELF\representation.items |
           SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
                    'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                    'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
                    'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
                    'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT',
                    'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] * TYPEOF (item)) = 0
         )) = 0;
  WR2: SIZEOF (
         QUERY (item <* SELF\representation.items |
           NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
                         'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
                         'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                 TYPEOF (item)) = 0)
         )) >= 1;
  WR3: SIZEOF (
         QUERY (a2p <* 
           QUERY (item <* SELF\representation.items | 
             'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF (item)) |
           NOT ((SIZEOF (
             QUERY (at <* 
               QUERY (item <* SELF\representation.items | 
                  'PRESENTATION_DEFINITION_SCHEMA.' + 
                  'ANNOTATION_TEXT' IN TYPEOF (item)) | 
               (at\mapped_item.mapping_target :=: a2p))) >= 1) OR
           (SIZEOF (
             QUERY (atc <* 
               QUERY (item <* SELF\representation.items |
                 'PRESENTATION_DEFINITION_SCHEMA.' + 
                 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF (item)) | 
               (atc\mapped_item.mapping_target :=: a2p))) >= 1)
          ))) = 0;
END_ENTITY;

ENTITY annotation_text_character
  SUBTYPE OF (mapped_item);
  alignment : text_alignment;
WHERE
  WR1: 'PRESENTATION_RESOURCE_SCHEMA.CHARACTER_GLYPH_SYMBOL' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  WR2: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN
         TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
END_ENTITY;

ENTITY defined_character_glyph
  SUBTYPE OF(geometric_representation_item);
  definition : defined_glyph_select;
  placement  : axis2_placement;
END_ENTITY;

ENTITY externally_defined_character_glyph
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY pre_defined_character_glyph
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY text_literal
  SUBTYPE OF (geometric_representation_item);
  literal   : presentable_text;
  placement : axis2_placement;
  alignment : text_alignment;
  path      : text_path;
  font      : font_select;
END_ENTITY;

ENTITY text_literal_with_extent
  SUBTYPE OF (text_literal);
  extent : planar_extent;
END_ENTITY;

ENTITY text_literal_with_delineation
  SUBTYPE OF (text_literal);
  delineation : text_delineation;
END_ENTITY;

ENTITY text_literal_with_blanking_box
  SUBTYPE OF (text_literal);
  blanking : planar_box;
END_ENTITY;

ENTITY text_literal_with_associated_curves
  SUBTYPE OF (text_literal);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY composite_text
  SUBTYPE OF (geometric_representation_item);
  collected_text : SET[2:?] of text_or_character;
WHERE
  WR1: acyclic_composite_text( SELF, SELF.collected_text);
END_ENTITY;

ENTITY composite_text_with_extent
  SUBTYPE OF (composite_text);
  extent : planar_extent;
END_ENTITY;

ENTITY composite_text_with_delineation
  SUBTYPE OF (composite_text);
  delineation : text_delineation;
END_ENTITY;

ENTITY composite_text_with_blanking_box
  SUBTYPE OF (composite_text);
  blanking : planar_box;
END_ENTITY;

ENTITY composite_text_with_associated_curves
  SUBTYPE OF (composite_text);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY annotation_occurrence
  SUPERTYPE OF (ONEOF(annotation_point_occurrence,
                      annotation_curve_occurrence,
                      annotation_fill_area_occurrence,
                      annotation_text_occurrence,
                      annotation_symbol_occurrence))
  SUBTYPE OF (styled_item);
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
          TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_point_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: 'GEOMETRY_SCHEMA.POINT' IN TYPEOF (SELF\styled_item.item);
END_ENTITY;

ENTITY annotation_curve_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (SELF\styled_item.item);
END_ENTITY;

ENTITY annotation_fill_area_occurrence
  SUBTYPE OF (annotation_occurrence);
  fill_style_target : point;
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_FILL_AREA' IN
         TYPEOF (SELF.item);
END_ENTITY;

ENTITY annotation_text_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF (
         ['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
          'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
          'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
          'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
          'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
         TYPEOF (SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_symbol_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF(
         ['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_SYMBOL',
          'PRESENTATION_DEFINITION_SCHEMA.DEFINED_SYMBOL'] *
         TYPEOF(SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_table_occurrence
  SUBTYPE OF (annotation_symbol_occurrence);
WHERE
  WR1: SIZEOF (
         ['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE',
          'PRESENTATION_DEFINITION_SCHEMA.DEFINED_TABLE'] *
         TYPEOF (SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_occurrence_relationship;
  name                           : label;
  description                    : text;
  relating_annotation_occurrence : annotation_occurrence;
  related_annotation_occurrence  : annotation_occurrence;
END_ENTITY;

ENTITY table_text_relationship
  SUBTYPE OF (annotation_occurrence_relationship);
  field : table_record_field_representation;
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE_OCCURRENCE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence\styled_item.item);
  WR3: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_OCCURRENCE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  related_annotation_occurrence);
  WR4: field_in_table (SELF.field,
                       SELF\annotation_occurrence_relationship.
                       relating_annotation_occurrence);
END_ENTITY;

FUNCTION acyclic_composite_text(start_composite : composite_text;
                                child_text : SET [1:?] OF
                                text_or_character) : LOGICAL;

  LOCAL
   i : INTEGER;
   local_composite_text : SET [0:?] OF composite_text;
   local_annotation_text : SET [0:?] OF annotation_text;
   local_children : SET [0:?] OF text_or_character;
  END_LOCAL;

  local_composite_text := QUERY (child <* child_text |
                          ('PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_composite_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      IF (start_composite :=: local_composite_text[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;

  local_children := child_text;

  IF (SIZEOF (local_composite_text)) > 0 THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      local_children := local_children +
                        local_composite_text[i].collected_text;
    END_REPEAT;
  END_IF;


  local_annotation_text := QUERY (child <* child_text |
                          ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_annotation_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_annotation_text);
      local_children := local_children +
      QUERY (item <* local_annotation_text[i]\mapped_item.
                     mapping_source.mapped_representation.items |
        SIZEOF(['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                TYPEOF(item)) > 0);
    END_REPEAT;
  END_IF;

  IF (local_children :<>: child_text) THEN
    RETURN (acyclic_composite_text (start_composite, local_children));
  ELSE
    RETURN (TRUE);
  END_IF;

 END_FUNCTION;

FUNCTION acyclic_symbol_representation_relationship
  (relation : symbol_representation_relationship;
   children : SET OF symbol_representation ) : BOOLEAN;
  LOCAL
    x : SET OF symbol_representation_relationship;
    local_children : SET OF symbol_representation;
  END_LOCAL;
 
  REPEAT i:=1 TO HIINDEX(children);
    IF relation\representation_relationship.rep_1 :=: children[i] THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
 
  x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                'REPRESENTATION_SCHEMA.'+
                'REPRESENTATION_RELATIONSHIP.'+ 'REP_2'));
  local_children := children + relation\representation_relationship.rep_1;
 
  IF SIZEOF (x) > 0 THEN
    REPEAT i:=1 TO HIINDEX (x);
      IF NOT acyclic_symbol_representation_relationship(x[i] , 
                                                local_children) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
 
  RETURN (TRUE);
 
END_FUNCTION;

FUNCTION field_in_table (field : table_record_field_representation;
                         table : annotation_table_occurrence): BOOLEAN;
  LOCAL
    table_rep : table_representation;
    symbol_rep_rel_set : SET OF symbol_representation_relationship;
    mapped_item_set : SET OF mapped_item;
    table_record_rep_set : SET OF table_record_representation := [];
  END_LOCAL;
 
  table_rep := table\styled_item.item\mapped_item.mapping_source.
    mapped_representation;
  mapped_item_set := QUERY(item <* table_rep.items |
                       ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                        TYPEOF(item))
                                 AND
                       ('PRESENTATION_DEFINITION_SCHEMA.'+
                        'TABLE_RECORD_REPRESENTATION' IN
                         TYPEOF(item\mapped_item.mapping_source.
                                    mapped_representation ))
                     );
 
  REPEAT i := 1 TO HIINDEX(mapped_item_set);
    table_record_rep_set := table_record_rep_set +
           mapped_item_set[i].mapping_source.mapped_representation;
  END_REPEAT;
 
  symbol_rep_rel_set := bag_to_set (USEDIN(table_rep, 
                               'REPRESENTATION_SCHEMA.'+
                               'REPRESENTATION_RELATIONSHIP.REP_1'));
 
  REPEAT i := 1 TO HIINDEX(symbol_rep_rel_set);
     table_record_rep_set := table_record_rep_set +
              symbol_rep_rel_set[i]\representation_relationship.rep_2;
  END_REPEAT;
 
  IF SIZEOF(QUERY( table_record_rep <* table_record_rep_set |
--              (SIZEOF(QUERY( symbol_rep_rel <* USEDIN(table_record_rep,
--                            'PRESENTATION_DEFINITION_SCHEMA.'+
--                            'SYMBOL_REPRESENTATION_RELATIONSHIP.REP_1') |
--                       symbol_rep_rel\representation_relationship.rep_2 :=: field
              (SIZEOF(QUERY( rep_rel <* USEDIN(table_record_rep,
                            'REPRESENTATION_SCHEMA.'+
                            'REPRESENTATION_RELATIONSHIP.REP_1') |
                       ('PRESENTATION_DEFINITION_SCHEMA.' +
                       'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rep_rel)) AND  
                       (rep_rel.rep_2 :=: field)
                       )) > 0)
                       OR
              (SIZEOF(QUERY(item <* table_record_rep.items |
                        ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                         TYPEOF(item))
                                 AND
                        (field :=: item\mapped_item.mapping_source.
                                    mapped_representation )
                         )) > 0)
             )) = 0 THEN
    RETURN(FALSE);
  END_IF;
 
  RETURN(TRUE);
 
END_FUNCTION;

END_SCHEMA; -- presentation_definition_schema

SCHEMA presentation_appearance_schema;
 
REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     cartesian_point,
     curve,
     geometric_representation_item,
     point,
     vector);

REFERENCE FROM group_schema
  (group);

REFERENCE FROM measure_schema
    (descriptive_measure,
     length_measure,
     measure_with_unit,
     plane_angle_measure,
     positive_length_measure,
     ratio_measure,
     positive_ratio_measure);

REFERENCE FROM presentation_organization_schema
     (area_dependent_annotation_representation,
      presentation_area,
      presentation_layer_assignment,
      presentation_layer_usage,
      presentation_representation,
      presentation_set,
      presentation_view,
      product_data_representation_view,
      view_dependent_annotation_representation);

REFERENCE FROM presentation_definition_schema
    (annotation_curve_occurrence,
     annotation_fill_area,
     annotation_symbol_occurrence,
     annotation_text_with_delineation,
     symbol_representation_with_blanking_box);

REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol_outline,
     character_glyph_symbol_stroke,
     colour);

REFERENCE FROM representation_schema
    (mapped_item,
     representation,
     representation_item,
     representation_map,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     bag_to_set);
 

TYPE style_context_select = SELECT
  (group,
   presentation_layer_assignment,
   representation,
   representation_item,
   presentation_set);
END_TYPE;

TYPE presentation_style_select = SELECT
  (pre_defined_presentation_style,
   point_style,
   curve_style,
   surface_style_usage,
   symbol_style,
   fill_area_style,
   text_style,
   approximation_tolerance,
   externally_defined_style,
   null_style);
END_TYPE;

TYPE null_style = ENUMERATION OF
  (null);
END_TYPE;

TYPE marker_select = SELECT
  (marker_type,
   pre_defined_marker);
END_TYPE;

TYPE marker_type = ENUMERATION OF
  (dot,
   x,
   plus,
   asterisk,
   ring,
   square,
   triangle);
END_TYPE;

TYPE size_select  = SELECT
  (positive_length_measure,
   measure_with_unit,
   descriptive_measure,
   pre_defined_size);
END_TYPE;

TYPE curve_font_or_scaled_curve_font_select = SELECT
  (curve_style_font_select,
   curve_style_font_and_scaling);
END_TYPE;

TYPE curve_style_font_select = SELECT
  (curve_style_font,
   pre_defined_curve_font,
   externally_defined_curve_font);
END_TYPE;

TYPE squared_or_rounded = ENUMERATION OF
  (squared,
   rounded);
END_TYPE;

TYPE fill_style_select = SELECT
  (fill_area_style_colour,
   pre_defined_tile_style,
   externally_defined_tile_style,
   fill_area_style_tiles,
   pre_defined_hatch_style,
   externally_defined_hatch_style,
   fill_area_style_hatching);
END_TYPE;

TYPE fill_area_style_tile_shape_select = SELECT
  (fill_area_style_tile_curve_with_style,
   fill_area_style_tile_coloured_region,
   fill_area_style_tile_symbol_with_style,
   pre_defined_tile,
   externally_defined_tile);
END_TYPE;

TYPE curve_or_annotation_curve_occurrence = SELECT
  (curve,
   annotation_curve_occurrence);
END_TYPE;

TYPE surface_side = ENUMERATION OF
  (positive,
   negative,
   both);
END_TYPE;

TYPE surface_side_style_select = SELECT
  (surface_side_style,
   pre_defined_surface_side_style);
END_TYPE;

TYPE surface_style_element_select = SELECT
  (surface_style_fill_area,
   surface_style_boundary,
   surface_style_silhouette,
   surface_style_segmentation_curve,
   surface_style_control_grid,
   surface_style_parameter_line,
   surface_style_rendering);
END_TYPE;

TYPE curve_or_render = SELECT
  (curve_style,
   curve_style_rendering);
END_TYPE;

TYPE shading_curve_method = ENUMERATION OF
  (constant_colour,
   linear_colour);
END_TYPE;

TYPE direction_count_select = SELECT
  (u_direction_count,
   v_direction_count);
END_TYPE;

TYPE u_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;

TYPE v_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;

TYPE shading_surface_method = ENUMERATION OF
  (constant_shading,
   colour_shading,
   dot_shading,
   normal_shading);
END_TYPE;

TYPE rendering_properties_select = SELECT
  (surface_style_reflectance_ambient,
   surface_style_transparent);
END_TYPE;

TYPE character_style_select = SELECT
  (character_glyph_style_stroke,
   character_glyph_style_outline,
   text_style_for_defined_font);
END_TYPE;

TYPE text_justification = label;
END_TYPE;

TYPE box_characteristic_select = SELECT
  (box_height,
   box_width,
   box_slant_angle,
   box_rotate_angle);
END_TYPE;

TYPE box_height = positive_ratio_measure;
END_TYPE;

TYPE box_width = positive_ratio_measure;
END_TYPE;

TYPE  box_slant_angle = plane_angle_measure;
END_TYPE;

TYPE box_rotate_angle = plane_angle_measure;
END_TYPE;

TYPE character_spacing_select = SELECT
  (length_measure,
   ratio_measure,
   measure_with_unit,
   descriptive_measure,
   pre_defined_character_spacing);
END_TYPE;

TYPE symbol_style_select= SELECT
  (symbol_element_style,
   symbol_colour);
END_TYPE;

TYPE tolerance_select = SELECT
  (approximation_tolerance_deviation,
   approximation_tolerance_parameter);
END_TYPE;

TYPE approximation_method = ENUMERATION OF
  (chordal_deviation,
   chordal_length);
END_TYPE;

TYPE tolerance_deviation_select = SELECT
  (curve_tolerance_deviation,
   surface_tolerance_deviation);
END_TYPE;

TYPE curve_tolerance_deviation = positive_length_measure;
END_TYPE;

TYPE surface_tolerance_deviation = positive_length_measure;
END_TYPE;

TYPE product_or_presentation_space = ENUMERATION OF
  (product_shape_space,
   presentation_area_space);
END_TYPE;

TYPE tolerance_parameter_select = SELECT
  (curve_tolerance_parameter,
   surface_tolerance_parameter);
END_TYPE;

TYPE curve_tolerance_parameter = REAL;
END_TYPE;

TYPE surface_tolerance_parameter = REAL;
END_TYPE;

TYPE hiding_or_blanking_select = SELECT
  (presentation_area,
   presentation_view,
   product_data_representation_view,
   annotation_fill_area,
   area_dependent_annotation_representation,
   view_dependent_annotation_representation,
   annotation_text_with_delineation,
   character_glyph_symbol_stroke,
   character_glyph_symbol_outline,
   symbol_representation_with_blanking_box);
END_TYPE;

TYPE invisibility_context= SELECT 
  (presentation_layer_usage,
   presentation_representation,
   presentation_set);
END_TYPE;

TYPE invisible_item = SELECT 
  (styled_item,
   presentation_layer_assignment,
   representation);
END_TYPE;

ENTITY styled_item
  SUBTYPE OF (representation_item);
  styles :  SET [1:?] OF presentation_style_assignment;
  item   :  representation_item;
WHERE
  WR1: (SIZEOF(SELF.styles) = 1)
               XOR
       (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
END_ENTITY;

ENTITY over_riding_styled_item
  SUBTYPE OF (styled_item);
  over_ridden_style : styled_item;
END_ENTITY;

ENTITY context_dependent_over_riding_styled_item
  SUBTYPE OF(over_riding_styled_item);
  style_context : SET[1:2] OF style_context_select;
WHERE
  WR1: (SIZEOF(QUERY( sc <* SELF.style_context |
       'REPRESENTATION_SCHEMA.REPRESENTATION' IN
         TYPEOF(sc))) = 1 )
                 AND
       (SIZEOF(QUERY( sc <* SELF.style_context |
       'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN
         TYPEOF(sc))) = 1);
END_ENTITY;

ENTITY presentation_style_assignment;
  styles : SET [1:?] OF presentation_style_select;
WHERE
  WR1: SIZEOF (QUERY (style1 <* SELF.styles |
         NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['PRESENTATION_APPEARANCE_SCHEMA.' +
                       'SURFACE_STYLE_USAGE',
                       'PRESENTATION_APPEARANCE_SCHEMA.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
  WR2: SIZEOF (QUERY (style1 <* SELF.styles |
         'PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN
         TYPEOF(style1)
         )) <= 2;
END_ENTITY;

ENTITY presentation_style_by_context
  SUBTYPE OF (presentation_style_assignment);
  style_context : style_context_select;
END_ENTITY;

ENTITY pre_defined_presentation_style
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_style
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY point_style;
  name          : label;
  marker        : marker_select;
  marker_size   : size_select;
  marker_colour : colour;
END_ENTITY;

ENTITY pre_defined_marker
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_size
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY curve_style;
  name         : label;
  curve_font   : curve_font_or_scaled_curve_font_select;
  curve_width  : size_select;
  curve_colour : colour;
END_ENTITY;

ENTITY curve_style_with_ends_and_corners
  SUBTYPE OF (curve_style);
  curve_ends    : squared_or_rounded;
  curve_corners : squared_or_rounded;
END_ENTITY;

ENTITY curve_style_with_extension
  SUBTYPE OF (curve_style);
  curve_extensions   : length_measure;
END_ENTITY;

ENTITY pre_defined_curve_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_curve_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY curve_style_font;
  name         : label;
  pattern_list : LIST [1:?] OF curve_style_font_pattern;
END_ENTITY;

ENTITY curve_style_font_pattern;
  visible_segment_length   : positive_length_measure;
  invisible_segment_length : positive_length_measure;
END_ENTITY;

ENTITY curve_style_wide
  SUBTYPE OF (curve_style_font);
  interior_style : fill_area_style;
END_ENTITY;

ENTITY curve_style_curve_pattern_set
  SUBTYPE OF (curve_style_font, 
              geometric_representation_item);
  pattern_set : SET [1:?] OF curve_style_curve_pattern;
END_ENTITY;

ENTITY curve_style_curve_pattern
  SUBTYPE OF (geometric_representation_item);
  pattern        : annotation_curve_occurrence;
  pattern_length : positive_length_measure;
END_ENTITY;

ENTITY curve_style_font_and_scaling;
  name               : label;
  curve_font         : curve_style_font_select;
  curve_font_scaling : REAL;
END_ENTITY;

ENTITY draughting_pre_defined_curve_font
  SUBTYPE OF (pre_defined_curve_font);
WHERE
  WR1: SELF.name IN
       ['continuous',
        'chain',
        'chain double dash',
        'dashed',
        'dotted'];
END_ENTITY;

ENTITY fill_area_style;
  name       : label;
  fill_styles : SET [1:?] OF fill_style_select;
WHERE
  WR1: SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'PRESENTATION_APPEARANCE_SCHEMA.'+
         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
END_ENTITY;

ENTITY fill_area_style_colour;
  name        : label;
  fill_colour : colour;
END_ENTITY;

ENTITY pre_defined_hatch_style
  SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY externally_defined_hatch_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY fill_area_style_hatching
  SUBTYPE OF (geometric_representation_item);
  hatch_line_appearance         : curve_style;
  start_of_next_hatch_line      : one_direction_repeat_factor;
  point_of_reference_hatch_line : cartesian_point;
  pattern_start                 : cartesian_point;
  hatch_line_angle              : plane_angle_measure;
END_ENTITY;

ENTITY pre_defined_tile_style
  SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY externally_defined_tile_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY fill_area_style_tiles
  SUBTYPE OF (geometric_representation_item);
  tiling_pattern : two_direction_repeat_factor;
  tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
  tiling_scale   : positive_ratio_measure;
END_ENTITY;

ENTITY fill_area_style_tile_curve_with_style
  SUBTYPE OF (geometric_representation_item);
  styled_curve : annotation_curve_occurrence;
END_ENTITY;

ENTITY fill_area_style_tile_coloured_region
  SUBTYPE OF (geometric_representation_item);
  closed_curve  : curve_or_annotation_curve_occurrence;
  region_colour : colour;
END_ENTITY;

ENTITY fill_area_style_tile_symbol_with_style
  SUBTYPE OF (geometric_representation_item);
  symbol : annotation_symbol_occurrence;
END_ENTITY;

ENTITY pre_defined_tile
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_tile
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY one_direction_repeat_factor
  SUBTYPE OF (geometric_representation_item);
  repeat_factor : vector;
END_ENTITY;

ENTITY two_direction_repeat_factor
  SUBTYPE OF (one_direction_repeat_factor);
  second_repeat_factor : vector;
END_ENTITY;

ENTITY surface_style_usage;
  side  : surface_side;
  style : surface_side_style_select;
END_ENTITY;

ENTITY pre_defined_surface_side_style
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY surface_side_style;
  name   : label;
  styles : SET [1:7] OF surface_style_element_select;
WHERE
  WR1: SIZEOF(QUERY( style1 <* SELF.styles |
         SIZEOF(QUERY( style2 <* SELF.styles - style1 |
           TYPEOF(style1) = TYPEOF(style2)
           )) > 0
         )) = 0;
END_ENTITY;

ENTITY surface_style_fill_area;
  fill_area : fill_area_style;
END_ENTITY;

ENTITY surface_style_boundary;
  style_of_boundary : curve_or_render;
END_ENTITY;

ENTITY curve_style_rendering;
  rendering_method     : shading_curve_method;
  rendering_properties : surface_rendering_properties;
END_ENTITY;

ENTITY surface_rendering_properties;
  rendered_colour : colour;
END_ENTITY;

ENTITY surface_style_silhouette;
  style_of_silhouette : curve_or_render;
END_ENTITY;

ENTITY surface_style_segmentation_curve;
  style_of_segmentation_curve : curve_or_render;
END_ENTITY;

ENTITY surface_style_control_grid;
  style_of_control_grid : curve_or_render;
END_ENTITY;

ENTITY surface_style_parameter_line;
  style_of_parameter_lines : curve_or_render;
  direction_counts         : SET [1:2] OF direction_count_select;
WHERE
  WR1: (HIINDEX(SELF.direction_counts) = 1)
                        XOR
       (TYPEOF(SELF.direction_counts[1]) <>
          TYPEOF(SELF.direction_counts[2]));
END_ENTITY;

ENTITY surface_style_rendering;
  rendering_method : shading_surface_method;
  surface_colour   : colour;
END_ENTITY;

ENTITY surface_style_rendering_with_properties
  SUBTYPE OF (surface_style_rendering);
  properties : SET [1:2] OF rendering_properties_select;
WHERE
  WR1: (HIINDEX(SELF.properties) = 1)
                   XOR
       (TYPEOF(SELF.properties[1]) <> TYPEOF(SELF.properties[2]));
END_ENTITY;

ENTITY surface_style_reflectance_ambient;
  ambient_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse
  SUBTYPE OF (surface_style_reflectance_ambient);
  diffuse_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse_specular
  SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
  specular_reflectance : REAL;
  specular_exponent    : REAL;
  specular_colour      : colour;
END_ENTITY;

ENTITY surface_style_transparent;
  transparency : REAL;
WHERE
  WR1: {0.0 <= transparency <= 1.0};
END_ENTITY;

ENTITY text_style;
  name                 : label;
  character_appearance : character_style_select;
END_ENTITY;

ENTITY character_glyph_style_stroke;
  stroke_style : curve_style;
END_ENTITY;

ENTITY character_glyph_style_outline;
  outline_style : curve_style;
END_ENTITY;

ENTITY character_glyph_style_outline_with_characteristics
  SUBTYPE OF (character_glyph_style_outline);
  characteristics : fill_area_style;
END_ENTITY;

ENTITY text_style_for_defined_font;
  text_colour : colour;
END_ENTITY;

ENTITY text_style_with_justification
  SUBTYPE OF (text_style);
  justification : text_justification;
END_ENTITY;

ENTITY text_style_with_box_characteristics
  SUBTYPE OF (text_style);
  characteristics : SET [1:4] OF box_characteristic_select;
WHERE
  WR1: SIZEOF( QUERY( c1 <* SELF.characteristics |
         SIZEOF( QUERY( c2 <* SELF.characteristics - c1 |
           TYPEOF (c1) = TYPEOF (c2)
           )) > 0
       )) = 0;
END_ENTITY;

ENTITY text_style_with_spacing
  SUBTYPE OF (text_style);
  character_spacing : character_spacing_select;
END_ENTITY;

ENTITY pre_defined_character_spacing
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY text_style_with_mirror
  SUBTYPE OF (text_style);
  mirror_placement : axis2_placement;
END_ENTITY;

ENTITY symbol_style;
  name            : label; 
  style_of_symbol : symbol_style_select;
END_ENTITY;

ENTITY symbol_element_style;
  style_of_symbol : presentation_style_assignment;
WHERE
  WR1: SIZEOF (QUERY ( style <* SELF.style_of_symbol.styles |
         'PRESENTATION_APPEARANCE_SCHEMA.SYMBOL_STYLE' IN
         TYPEOF (style))) = 0;
  WR2: NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
            'PRESENTATION_STYLE_BY_CONTEXT' IN
            TYPEOF (SELF.style_of_symbol)
           );
END_ENTITY;

ENTITY symbol_colour;
  colour_of_symbol : colour;
END_ENTITY;

ENTITY approximation_tolerance;
  tolerance : tolerance_select;
END_ENTITY;

ENTITY approximation_tolerance_deviation;
  tessellation_type : approximation_method;
  tolerances        : SET [1:2] OF tolerance_deviation_select;
  definition_space  : product_or_presentation_space;
WHERE
  WR1: (HIINDEX(SELF.tolerances) = 1)
                XOR
       (TYPEOF(SELF.tolerances[1]) <> TYPEOF(SELF.tolerances[2]));
END_ENTITY;

ENTITY approximation_tolerance_parameter;
  tolerances : SET [1:2] OF tolerance_parameter_select;
WHERE
  WR1: (HIINDEX (SELF.tolerances) = 1 )
               XOR
       (TYPEOF (SELF.tolerances[1]) <> TYPEOF (SELF.tolerances[2]));
END_ENTITY;

ENTITY occlusion_precedence;
  higher_precedence : hiding_or_blanking_select;
  lower_precedence  : hiding_or_blanking_select;
  occlusion_context : representation;
WHERE
  WR1: acyclic_occlusion_precedence (SELF, [SELF.lower_precedence]);
END_ENTITY;

ENTITY invisibility;
  invisible_items : SET [1:?] OF invisible_item;
END_ENTITY;

ENTITY context_dependent_invisibility
  SUBTYPE OF (invisibility);
  presentation_context : invisibility_context;
END_ENTITY;

FUNCTION acyclic_occlusion_precedence
   ( relation : occlusion_precedence;
     set_of_lower : SET OF hiding_or_blanking_select ) : BOOLEAN;
   LOCAL
      x : SET OF occlusion_precedence;
      local_set_of_lower : SET OF hiding_or_blanking_select;
   END_LOCAL;
   REPEAT i:=1 TO HIINDEX(set_of_lower);
      IF relation.higher_precedence :=: set_of_lower[i] THEN
         RETURN(FALSE);
      END_IF;
   END_REPEAT;
   x := bag_to_set (USEDIN ( relation.higher_precedence,
                   'PRESENTATION_APPEARANCE_SCHEMA.'+
           'OCCLUSION_PRECEDENCE.LOWER_PRECEDENCE'));
   local_set_of_lower := set_of_lower + relation.higher_precedence;
   IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
         If NOT acyclic_occlusion_precedence(x[i] ,
 
                                     local_set_of_lower) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
   END_IF;
   RETURN (TRUE);
END_FUNCTION;

END_SCHEMA; -- presentation_appearance_schema

SCHEMA presentation_resource_schema;

REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     curve,
     geometric_representation_item
     );

REFERENCE FROM measure_schema
    (length_measure,
     positive_length_measure,
     positive_ratio_measure,
     ratio_measure);

REFERENCE FROM presentation_definition_schema
    (annotation_fill_area,
     symbol_representation);

REFERENCE FROM representation_schema
    (item_in_context,
     representation);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);
 

TYPE staircase_or_linear = ENUMERATION OF 
  (staircase, 
   linear);
END_TYPE;

TYPE presentable_text = STRING;
END_TYPE;

TYPE font_select = SELECT
  (pre_defined_text_font,
   externally_defined_text_font);
END_TYPE;

ENTITY character_glyph_symbol
  SUBTYPE OF (symbol_representation);
  character_box  : planar_extent;
  baseline_ratio : ratio_measure;
DERIVE
  box_height : length_measure := character_box.size_in_y;
WHERE
  WR1: {0.0 <= baseline_ratio <= 1.0};
  WR2: item_in_context(SELF.character_box, 
                       SELF\representation.context_of_items);
  WR3: 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (SELF.box_height);
END_ENTITY;

ENTITY character_glyph_symbol_stroke
  SUBTYPE OF (character_glyph_symbol);
  strokes : SET [1:?] OF curve;
WHERE
  WR1: SELF.strokes <= SELF\representation.items;
END_ENTITY;

ENTITY character_glyph_symbol_outline
  SUBTYPE OF (character_glyph_symbol);
  outlines : SET [1:?] OF annotation_fill_area;
WHERE
  WR1: SELF.outlines <= SELF\representation.items;
END_ENTITY;

ENTITY character_glyph_font_usage;
  character : character_glyph_symbol;
  font      : text_font;
END_ENTITY;

ENTITY text_font;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
END_ENTITY;

ENTITY text_font_family;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  fonts       : SET [1:?] OF text_font_in_family FOR family;
END_ENTITY;

ENTITY text_font_in_family;
  font   : text_font;
  family : text_font_family;
END_ENTITY;

ENTITY externally_defined_text_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY pre_defined_text_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY colour;
END_ENTITY;

ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

ENTITY colour_associated
  SUBTYPE OF (colour);
  name : label;
  variable_to_be_shown : SET [1:?] OF REAL;
  mapping              : colour_association_table;
END_ENTITY;

ENTITY colour_association_table;
  discrete_states_with_colours : LIST [1:?] OF state_variable_with_colour;
  interpolation_type           : staircase_or_linear;
END_ENTITY;

ENTITY state_variable_with_colour;
  state_variable    : REAL;
  associated_colour : colour_specification;
END_ENTITY;

ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;

ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement:  axis2_placement;
END_ENTITY;

ENTITY presentation_scaled_placement 
  SUBTYPE OF (geometric_representation_item);
  placement : axis2_placement;
  scaling   : positive_ratio_measure;
END_ENTITY;

ENTITY draughting_pre_defined_colour
  SUBTYPE OF (pre_defined_colour);
WHERE
  WR1: SELF.name IN
      ['red',
       'green',
       'blue',
       'yellow',
       'magenta',
       'cyan',
       'black',
       'white'];
END_ENTITY;

ENTITY draughting_pre_defined_text_font
   SUBTYPE of (pre_defined_text_font);
WHERE
   WR1: SELF.name IN ['ISO 3098-1 font A', 'ISO 3098-1 font B'];
END_ENTITY;

END_SCHEMA; -- presentation_resource_schema







SCHEMA shape_aspect_definition_schema;

REFERENCE FROM product_property_definition_schema
    (shape_aspect,
     shape_aspect_relationship);

REFERENCE FROM measure_schema
    (measure_with_unit);
REFERENCE FROM support_resource_schema
    (bag_to_set, label, identifier);

TYPE limit_condition = ENUMERATION OF
  (maximum_material_condition,
   least_material_condition,
   regardless_of_feature_size);
END_TYPE;

ENTITY datum
  SUBTYPE OF (shape_aspect);
  identification               :identifier;
INVERSE
  established_by_relationships : SET [1:?] OF shape_aspect_relationship
                                 FOR related_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (X<*SELF.established_by_relationships |
       SIZEOF (TYPEOF(X.relating_shape_aspect)* 
       ['SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE', 
       'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_TARGET_FEATURE']) <> 1))=0;

END_ENTITY;

ENTITY datum_feature
  SUBTYPE OF (shape_aspect);
INVERSE
  feature_basis_relationship : shape_aspect_relationship
                               FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' +
        'RELATING_SHAPE_ASPECT'))
      | NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF 
      (sar.related_shape_aspect))))=0;
  WR2: SELF.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_target
  SUBTYPE OF (shape_aspect);
  target_id             : identifier; 
  INVERSE
  target_basis_relationship : shape_aspect_relationship FOR
                              relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' +
        'RELATING_SHAPE_ASPECT'))
      | NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF 
      (sar.related_shape_aspect))))=0;
   WR2: SELF.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_reference;
  precedence       : INTEGER;
  referenced_datum : datum;
WHERE
  WR1: precedence > 0;
END_ENTITY;

ENTITY referenced_modified_datum
  SUBTYPE OF (datum_reference);
  modifier : limit_condition;
END_ENTITY;

ENTITY composite_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  component_relationships : SET [2:?] OF shape_aspect_relationship
                            FOR relating_shape_aspect;
END_ENTITY;

ENTITY derived_shape_aspect
  SUPERTYPE OF (ONEOF (apex,
                       centre_of_symmetry,
                       geometric_alignment,
                       geometric_intersection,
                       parallel_offset,
                       perpendicular_to,
                       extension,
                       tangent))
  SUBTYPE OF (shape_aspect);
INVERSE
  deriving_relationships : SET [1:?] OF shape_aspect_relationship
                           FOR relating_shape_aspect;
END_ENTITY;

ENTITY apex
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;

ENTITY centre_of_symmetry
  SUBTYPE OF (derived_shape_aspect);
WHERE
        WR1: SIZEOF (QUERY(sadr<*deriving_relationships| 
        NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.SYMMETRIC_SHAPE_ASPECT'
         IN TYPEOF 
         (sadr.related_shape_aspect))))=0; 
END_ENTITY;

ENTITY geometric_alignment
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY geometric_intersection
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY parallel_offset
  SUBTYPE OF (derived_shape_aspect);
  offset               : measure_with_unit;
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;

END_ENTITY;

ENTITY perpendicular_to
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY extension
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY tangent
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY shape_aspect_deriving_relationship
       SUBTYPE OF (shape_aspect_relationship);
     WHERE
       WR1: 'SHAPE_ASPECT_DEFINITION_SCHEMA.DERIVED_SHAPE_ASPECT' IN TYPEOF
            (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
     END_ENTITY;

ENTITY symmetric_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  basis_relationships : SET [1:?] OF shape_aspect_relationship
                        FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (X<*SELF.basis_relationships |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.CENTRE_OF_SYMMETRY' IN TYPEOF 
       (X.related_shape_aspect)))>=1;
END_ENTITY;

END_SCHEMA;  -- shape_aspect_definition_schema

SCHEMA shape_dimension_schema;

REFERENCE FROM qualified_measure_schema

    (measure_representation_item, 
          qualified_representation_item);

REFERENCE FROM product_property_representation_schema
    (shape_representation);

REFERENCE FROM product_property_definition_schema
    (shape_aspect,
     shape_aspect_relationship);

REFERENCE FROM support_resource_schema
    (label,
     text);

TYPE angle_relator = ENUMERATION OF
  (equal,
   large,
   small);
END_TYPE;

TYPE dimensional_characteristic = SELECT (dimensional_location,
                                          dimensional_size);
END_TYPE;

ENTITY angular_location
  SUBTYPE OF (dimensional_location);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY angular_size



  SUBTYPE OF (dimensional_size);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY dimensional_characteristic_representation;
  dimension      : dimensional_characteristic; 
  representation : shape_dimension_representation;
END_ENTITY;

ENTITY dimensional_location
  SUPERTYPE OF (ONEOF (angular_location,
                       dimensional_location_with_path))
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;

ENTITY dimensional_location_with_path
  SUBTYPE OF (dimensional_location);
  path : shape_aspect;
END_ENTITY;

ENTITY dimensional_size
  SUPERTYPE OF (ONEOF (angular_size,
                       dimensional_size_with_path));
  applies_to : shape_aspect;
  name       : label;
WHERE
  WR1: applies_to.product_definitional = TRUE;
END_ENTITY;

ENTITY dimensional_size_with_path
  SUBTYPE OF (dimensional_size);
  path : shape_aspect;
END_ENTITY;

ENTITY shape_dimension_representation
                SUBTYPE OF (shape_representation);
  WHERE
   WR1: SIZEOF (QUERY (temp <* SELF.items | 
    NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF (temp)))) = 0;
   WR2: SIZEOF (SELF.items) <= 2;
   WR3: SIZEOF (QUERY (pos_mri <* QUERY (real_mri <* SELF.items |
        'REAL' IN TYPEOF
        (real_mri\measure_with_unit.value_component) ) |        
     NOT  (pos_mri\measure_with_unit.value_component > 0.0 ))) = 0;
END_ENTITY;

END_SCHEMA;   -- shape_dimension_schema

SCHEMA shape_tolerance_schema;

REFERENCE FROM product_property_definition_schema
    (shape_aspect,
     shape_aspect_relationship);

REFERENCE FROM measure_schema
    (measure_with_unit, measure_value);

REFERENCE FROM representation_schema
    (representation);

REFERENCE FROM support_resource_schema
    (label,
     text);

REFERENCE FROM shape_aspect_definition_schema
    (datum_reference,
     limit_condition);

REFERENCE FROM shape_dimension_schema
    (dimensional_characteristic,
     dimensional_location);

TYPE tolerance_method_definition = SELECT
  (tolerance_value,
   limits_and_fits);
END_TYPE;

TYPE tolerance_select =SELECT
    (geometric_tolerance,
     plus_minus_tolerance);
END_TYPE;

ENTITY dimension_related_tolerance_zone_element;
  related_dimension : dimensional_location; 
  related_element   : tolerance_zone_definition;
END_ENTITY;

ENTITY geometric_tolerance;
  name                    : label;
  description             : text;
  magnitude               : measure_with_unit; 
  toleranced_shape_aspect : shape_aspect; 
WHERE
  WR1: magnitude.value_component >= 0.0;
END_ENTITY;

ENTITY geometric_tolerance_relationship;
   name                       :label;
   description                :text;
   relating_geometric_tolerance    : geometric_tolerance; 
   related_geometric_tolerance     : geometric_tolerance; 
END_ENTITY;

ENTITY geometric_tolerance_with_datum_reference
   SUBTYPE OF (geometric_tolerance);
   datum_system : SET [1:?] OF  datum_reference;
END_ENTITY;

ENTITY geometric_tolerance_with_defined_unit
  SUBTYPE OF (geometric_tolerance);
  unit_size : measure_with_unit;
WHERE
  WR1: unit_size.value_component > 0.0;
END_ENTITY;

ENTITY modified_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  modifier : limit_condition;
END_ENTITY;

ENTITY projected_zone_definition
  SUBTYPE OF (tolerance_zone_definition); 
  projection_end   : shape_aspect;
  projected_length : measure_with_unit;
WHERE
  WR1: projected_length.value_component > 0.0; 
END_ENTITY;

ENTITY runout_zone_definition
  SUBTYPE OF (tolerance_zone_definition); 
  orientation  : runout_zone_orientation;
END_ENTITY;

ENTITY runout_zone_orientation;
  angle : measure_with_unit;
END_ENTITY;

ENTITY runout_zone_orientation_reference_direction
  SUBTYPE OF (runout_zone_orientation); 
  orientation_defining_relationship: shape_aspect_relationship;
END_ENTITY;

ENTITY statistical_distribution_for_tolerance
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (item)))) = 0;
END_ENTITY;

ENTITY tolerance_with_statistical_distribution;
  associated_tolerance : tolerance_select;
  tolerance_allocation : statistical_distribution_for_tolerance;
END_ENTITY;

ENTITY tolerance_zone
  SUBTYPE OF (shape_aspect);
  defining_tolerance : SET [1:?] OF geometric_tolerance; 
  form               : tolerance_zone_form;
END_ENTITY;

ENTITY tolerance_zone_form;
  name : label;
END_ENTITY;

ENTITY tolerance_zone_definition
  SUPERTYPE OF (ONEOF (projected_zone_definition,
                       runout_zone_definition));
  zone : tolerance_zone;
  boundaries: SET [1:?] OF shape_aspect;
END_ENTITY;

ENTITY limits_and_fits;
  form_variance   : label;
  zone_variance   : label;
  grade           : label;
  source          : text;
END_ENTITY;

ENTITY  plus_minus_tolerance;
  range                : tolerance_method_definition; 
  toleranced_dimension : dimensional_characteristic;
UNIQUE
  UR1: toleranced_dimension;
END_ENTITY;

ENTITY tolerance_value;
  lower_bound : measure_with_unit;
  upper_bound : measure_with_unit;
WHERE
  WR1: upper_bound.value_component > lower_bound.value_component; 
  WR2: upper_bound.unit_component = lower_bound.unit_component;
END_ENTITY;

END_SCHEMA;   --End of shape_tolerance_schema
SCHEMA method_definition_schema;

REFERENCE FROM action_schema
    (action_method, 
     action_method_relationship, 
     action_relationship);

REFERENCE FROM document_schema
    (document, 
     document_usage_constraint);

REFERENCE FROM effectivity_schema
    (effectivity);

REFERENCE FROM measure_schema
    (count_measure);

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM process_property_schema
    (product_definition_process,
     property_process);

TYPE relationship_with_condition = SELECT
  (action_method_relationship,
   action_relationship,
   context_dependent_action_method_relationship,
   context_dependent_action_relationship);
END_TYPE;

TYPE process_or_process_relationship = SELECT
  (product_definition_process,
   property_process,
   relationship_with_condition);
END_TYPE;

ENTITY action_method_with_associated_documents
  SUBTYPE OF (action_method);
  documents : SET [1:?] of document;
END_ENTITY;

ENTITY action_method_with_associated_documents_constrained
  SUBTYPE OF (action_method_with_associated_documents);
  usage_constraints : SET [1:?] OF document_usage_constraint;
WHERE
  WR1: SIZEOF (QUERY (item <* usage_constraints | 
       NOT (item.source 
       IN SELF\action_method_with_associated_documents.documents))) = 0;
END_ENTITY;

ENTITY action_method_to_select_from
  SUBTYPE OF (action_method);
  number_of_elements : count_measure;
WHERE
  WR1: number_of_elements >=1;
  WR2: SIZEOF (USEDIN (SELF, 
       'ACTION_SCHEMA.ACTION_METHOD_RELATIONSHIP.RELATING_METHOD')) >= 
       number_of_elements;
END_ENTITY;

ENTITY process_or_process_relationship_effectivity
  SUBTYPE OF (effectivity);
  effective_process_or_process_relationship : process_or_process_relationship;
END_ENTITY;

ENTITY serial_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY sequential_method
  SUBTYPE OF (serial_action_method);
  sequence_position : count_measure;
END_ENTITY;

ENTITY concurrent_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY context_dependent_action_method_relationship;
  name                  : label;
  relating_relationship : action_method_relationship;
  related_relationship  : action_method_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_method :=:
       related_relationship.relating_method;
END_ENTITY;

ENTITY context_dependent_action_relationship;
  name                  : label;
  relating_relationship : action_relationship;
  related_relationship  : action_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_action :=:
       related_relationship.relating_action;
END_ENTITY;

ENTITY relationship_condition;
  name                     : label;
  applicable_relationships : SET [1:?] OF relationship_with_condition;
  condition_description    : text;
END_ENTITY;

END_SCHEMA;  -- method_definition_schema

SCHEMA process_property_schema;

REFERENCE FROM action_schema
    (action, 
     action_method,
     action_method_relationship,
     action_relationship,
     action_resource,
     action_resource_relationship,
     acyclic_action_relationship);

REFERENCE FROM product_property_definition_schema
    (characterized_product_definition,
     property_definition, 
     shape_definition);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);

TYPE characterized_action_definition = SELECT
   (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT
     (property_definition,
      shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE 
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship (SELF,
       [SELF\action_relationship.related_action],
       'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;

END_SCHEMA; -- process_property_schema

SCHEMA process_property_representation_schema;

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM representation_schema
    (representation);

REFERENCE FROM process_property_schema
    (action_property, 
     resource_property);

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;

END_SCHEMA; -- process_property_representation_schema
SCHEMA aic_edge_based_wireframe;
USE FROM geometric_model_schema                   -- ISO 10303-42
  (edge_based_wireframe_model);
USE FROM geometry_schema                          -- ISO 10303-42
  (axis2_placement_3d,
   b_spline_curve_with_knots,
   bezier_curve,
   cartesian_transformation_operator_3d,
   circle,
   conic,
   curve,
   curve_replica,
   ellipse,
   geometric_representation_context,
   hyperbola,
   line,
   offset_curve_3d,
   parabola,
   point,
   point_replica,
   polyline,
   quasi_uniform_curve,
   rational_b_spline_curve,
   uniform_curve);
USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation);
USE FROM representation_schema                    -- ISO 10303-43
  (mapped_item);
USE FROM topology_schema                          -- ISO 10303-42
  (edge_curve,
   vertex_point);
ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
  WHERE
    WR1: SIZEOF (QUERY (it <* SELF.items |
           NOT
           (SIZEOF(['AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL',
                        'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM',
                        'AIC_EDGE_BASED_WIREFRAME.AXIS2_PLACEMENT_3D'] *
               TYPEOF (it)) = 1
         ))) = 0;
    WR2: SIZEOF (QUERY (it <* SELF.items |
            SIZEOF(['AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL',
            'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM'] * TYPEOF (it)) = 1
         )) >= 1;
    WR3: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
           ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
               IN TYPEOF (it))) |
           NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                     ebwm_boundary |
             NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
                NOT ('AIC_EDGE_BASED_WIREFRAME.EDGE_CURVE'
                        IN TYPEOF (edges)))) = 0
         ))) = 0))) = 0;
    WR4: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
            ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
                IN TYPEOF (it))) |
           NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                     ebwm_boundary |
             NOT (SIZEOF (QUERY (pline_edges <* QUERY (edges <* eb.ces_edges |
                ('AIC_EDGE_BASED_WIREFRAME.POLYLINE' IN
                    TYPEOF (edges\edge_curve.edge_geometry))) |
                NOT (SIZEOF (pline_edges\edge_curve.
                             edge_geometry\polyline.points) > 2))) = 0
         ))) = 0))) = 0;
    WR5: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
            ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
                IN TYPEOF (it))) |
           NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                     ebwm_boundary |
             NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
                NOT (('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT'
                         IN TYPEOF (edges.edge_start)) AND
                     ('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT'
                         IN TYPEOF (edges.edge_end))))) = 0
         ))) = 0))) = 0;
    WR6: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
            ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
                 IN TYPEOF (it))) |
           NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                     ebwm_boundary |
             NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
               NOT (valid_wireframe_edge_curve
                   (edges\edge_curve.edge_geometry))
          )) = 0))) = 0))) = 0;
    WR7: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items|
            ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
                 IN TYPEOF (it))) |
           NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                     ebwm_boundary |
             NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
               NOT ((valid_wireframe_vertex_point
                     (edges.edge_start\vertex_point.vertex_geometry)) AND
                    (valid_wireframe_vertex_point
                     (edges.edge_end\vertex_point.vertex_geometry))) )) = 0
             ))) = 0))) = 0;
   
    WR8: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
             ('AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it))) |
            NOT ('AIC_EDGE_BASED_WIREFRAME.' +
                 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION'
              IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)
          ))) = 0;
    WR9: SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3;
  END_ENTITY;
FUNCTION valid_wireframe_edge_curve (crv   : curve ) : BOOLEAN;
    -- check for valid basic curve types
  
    IF SIZEOF (['AIC_EDGE_BASED_WIREFRAME.LINE',
                'AIC_EDGE_BASED_WIREFRAME.CONIC',
                'AIC_EDGE_BASED_WIREFRAME.B_SPLINE_CURVE',
                'AIC_EDGE_BASED_WIREFRAME.POLYLINE'] * TYPEOF (crv)) = 1
      THEN RETURN (TRUE);
    ELSE
    -- recursively check for valid basic curves for curve_replica
      IF ('AIC_EDGE_BASED_WIREFRAME.CURVE_REPLICA') IN TYPEOF (crv)
        THEN RETURN (valid_wireframe_edge_curve
                           (crv\curve_replica.parent_curve));
      ELSE
        -- recursively check for valid basis curves for offset_curve
        IF( 'AIC_EDGE_BASED_WIREFRAME.OFFSET_CURVE_3D') IN TYPEOF (crv)
          THEN RETURN (valid_wireframe_edge_curve
                             (crv\offset_curve_3d.basis_curve));
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;
FUNCTION valid_wireframe_vertex_point (pnt   : point) : BOOLEAN;
    -- check for valid basic point types
    IF ('AIC_EDGE_BASED_WIREFRAME.CARTESIAN_POINT') IN TYPEOF (pnt)
      THEN RETURN (TRUE);
    ELSE
      -- recursively check for valid basic point types as parents for a
      -- point_replica
  
      IF( 'AIC_EDGE_BASED_WIREFRAME.POINT_REPLICA') IN TYPEOF (pnt)
        THEN RETURN (valid_wireframe_vertex_point
                           (pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;
  END_SCHEMA;  -- aic_edge_based_wireframe
SCHEMA aic_shell_based_wireframe;

USE FROM geometric_model_schema	-- ISO 10303-42
  (shell_based_wireframe_model);

USE FROM geometry_schema	-- ISO 10303-42
  (axis2_placement_3d,
   b_spline_curve_with_knots,
   bezier_curve,
   cartesian_transformation_operator_3d,
   circle,
   conic,
   curve,
   curve_replica,
   ellipse,
   geometric_representation_context,
   hyperbola,
   line,
   offset_curve_3d,
   parabola,
   point,
   point_replica,
   polyline,
   quasi_uniform_curve,
   rational_b_spline_curve,
   uniform_curve);

USE FROM product_property_representation_schema	-- ISO 10303-41
  (shape_representation);

USE FROM representation_schema	-- ISO 10303-43
  (mapped_item);

USE FROM topology_schema	-- ISO 10303-42
  (edge_curve,
   edge_loop,
   path,
   vertex_loop,
   vertex_point,
   vertex_shell,
   wire_shell);

REFERENCE FROM aic_edge_based_wireframe
    (valid_wireframe_vertex_point);

ENTITY shell_based_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT
(SIZEOF(['AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL',
                    'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM',
                    'AIC_SHELL_BASED_WIREFRAME.AXIS2_PLACEMENT_3D'] *
            TYPEOF (it)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
             SIZEOF(['AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL',
             'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM'] * TYPEOF (it)) = 1
       )) >= 1;
  WR3: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                               ws\wire_shell.wire_shell_extent |
                ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
               NOT ('AIC_SHELL_BASED_WIREFRAME.EDGE_CURVE' IN
                       TYPEOF (el.edge_element)))) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR4: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                               ws\wire_shell.wire_shell_extent |
               ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (pline_el <*
                          QUERY (el <* eloop\path.edge_list |
                    ('AIC_SHELL_BASED_WIREFRAME.POLYLINE' IN
                        TYPEOF (el.edge_element\edge_curve.edge_geometry))) |
               NOT (SIZEOF (pline_el.edge_element\edge_curve.
                            edge_geometry\polyline.points) >2)
             )) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR5: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
                 ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
               NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
                  NOT (valid_wireframe_edge_curve
                         (el.edge_element\edge_curve.edge_geometry )))) =0)
          )) = 0)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
               IN TYPEOF(it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                               ws\wire_shell.wire_shell_extent |
                   ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
               NOT (('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                        TYPEOF (el.edge_element.edge_start))
                AND
                    ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                        TYPEOF (el.edge_element.edge_end))) )) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
               ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
                    NOT ((valid_wireframe_vertex_point
                          (el.edge_element.
                           edge_start\vertex_point.vertex_geometry))
                 AND
                   (valid_wireframe_vertex_point
                 (el.edge_element.edge_end\vertex_point.vertex_geometry)))
             )) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
 
  WR8: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                    ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
            NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb))) |
              NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                      TYPEOF (vloop\vertex_loop.loop_vertex))
            )) = 0)
          )) = 0)
        )) = 0;
  WR9: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                    ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
            NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb))) |
              NOT (valid_wireframe_vertex_point (vloop\vertex_loop.
                    loop_vertex\vertex_point.vertex_geometry))
            )) = 0)
          )) = 0)
        )) = 0;
  WR10: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb))) |
            NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                    TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex))
          )) = 0)
        )) = 0;
  WR11: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb))) |
            NOT (valid_wireframe_vertex_point (vs\vertex_shell.
                   vertex_shell_extent.loop_vertex\vertex_point.
                   vertex_geometry))
          )) = 0)
        )) = 0;
  WR12: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
           ('AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it))) |
         NOT ('AIC_SHELL_BASED_WIREFRAME.' +
                 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN
           TYPEOF (mi\mapped_item.mapping_source.mapped_representation)
        ))) = 0;
  WR13: SELF.context_of_items\geometric_representation_context.
             coordinate_space_dimension = 3;
END_ENTITY;

FUNCTION valid_wireframe_edge_curve (crv   : curve) : BOOLEAN;
  -- check for valid basic curve types

  IF SIZEOF (['AIC_SHELL_BASED_WIREFRAME.LINE',
			  'AIC_SHELL_BASED_WIREFRAME.CONIC',
              'AIC_SHELL_BASED_WIREFRAME.B_SPLINE_CURVE',
              'AIC_SHELL_BASED_WIREFRAME.POLYLINE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
  -- recursively check for valid basic curves for curve_replica
    IF ('AIC_SHELL_BASED_WIREFRAME.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_wireframe_edge_curve
                         (crv\curve_replica.parent_curve));
    ELSE
      -- recursively check for valid basis curves for offset_curve
      IF ('AIC_SHELL_BASED_WIREFRAME.OFFSET_CURVE_3D') IN TYPEOF (crv)
        THEN RETURN (valid_wireframe_edge_curve
                           (crv\offset_curve_3d.basis_curve));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

END_SCHEMA;


SCHEMA aic_geometrically_bounded_2d_wireframe;
USE FROM geometric_model_schema    -- ISO 10303-42
    (geometric_curve_set,
     geometric_set);
USE FROM geometry_schema -- ISO 10303-42
   (axis2_placement_2d,
    b_spline_curve_with_knots,
    bezier_curve,
    circle,
    composite_curve,
    composite_curve_segment,
    curve,
    curve_replica,
    ellipse,
    geometric_representation_context,
    hyperbola,
    line,
    offset_curve_2d,
    parabola,
    point_on_curve,
    polyline,
    quasi_uniform_curve,
    rational_b_spline_curve,
    trimmed_curve,
    uniform_curve);
USE FROM product_property_representation_schema -- ISO 10303-41
   (shape_representation);
USE FROM representation_schema -- ISO 10303-43
   (mapped_item);
ENTITY geometrically_bounded_2d_wireframe_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: SIZEOF (QUERY (item <* SELF.items |
         NOT (SIZEOF (TYPEOF (item) *
['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
           
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.AXIS2_PLACEMENT_2D',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1)
       )) = 0;
  WR3: SIZEOF (QUERY (item <* SELF.items |
         SIZEOF (TYPEOF (item) *
          
['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1
       )) >= 1;
  WR4: SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM'
           IN TYPEOF (item))) |
         NOT ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.' +
              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
           IN TYPEOF
              (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
           NOT (SIZEOF (TYPEOF (elem) *
             ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE']) =
               1)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (crv <* 
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE'
                   IN TYPEOF (elem))) |
           NOT (valid_basis_curve_in_2d_wireframe
              (crv))
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |         
    ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pnt <*
           QUERY (elem <* gcs\geometric_set.elements |
             ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT'
                  IN TYPEOF(elem))) |
             NOT (SIZEOF (TYPEOF (pnt) *
               ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CARTESIAN_POINT',
                'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT_ON_CURVE'])
          = 1)
         )) = 0)
       )) = 0;
  WR8: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
        
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
           IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pl <* 
           QUERY (elem <* gcs\geometric_set.elements |
             ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE'
                  IN TYPEOF (elem))) |
             NOT (SIZEOF (pl\polyline.points) > 2)
         )) = 0)
       )) = 0;
END_ENTITY;
FUNCTION valid_basis_curve_in_2d_wireframe
   (crv: curve) : BOOLEAN;
   -- check for valid basic curve types
  IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE'] * 
               TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE') 
    IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.LINE',
                   'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.PARABOLA',
                   'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);
      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D') 
      IN TYPEOF (crv))
        THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\offset_curve_2d.basis_curve));
      ELSE
        -- recursively check the curve_replica parent curve
        IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE_REPLICA') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\curve_replica.parent_curve));
        ELSE
          -- recursively check the composite_curve segments
          IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE') 
          IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_basis_curve_in_2d_wireframe
                             (ccs.parent_curve)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
END_SCHEMA;  --aic_geometrically_bounded_2d_wireframe



  
SCHEMA aic_geometrically_bounded_surface;  
  
  USE FROM geometric_model_schema ( 
      geometric_set);  
  
  USE FROM geometry_schema ( 
      point,  
      cartesian_point,  
      point_on_curve,  
      point_on_surface,  
      degenerate_pcurve,  
      evaluated_degenerate_pcurve,  
      direction,  
      vector,  
      axis1_placement,  
      axis2_placement_2d,  
      axis2_placement_3d,  
      cartesian_transformation_operator_3d,  
      curve,  
      line,  
      circle,  
      ellipse,  
      hyperbola,  
      parabola,  
      polyline,  
      b_spline_curve,
      b_spline_curve_with_knots,  
      uniform_curve,  
      quasi_uniform_curve,  
      bezier_curve,  
      rational_b_spline_curve,  
      trimmed_curve,  
      composite_curve,  
      composite_curve_segment,  
      reparametrised_composite_curve_segment,  
      pcurve,  
      surface_curve,  
      intersection_curve,  
      seam_curve,  
      composite_curve_on_surface,  
      offset_curve_3d,  
      curve_replica,  
      surface,  
      plane,  
      cylindrical_surface,  
      conical_surface,  
      spherical_surface,  
      toroidal_surface,  
      degenerate_toroidal_surface,  
      swept_surface,
      surface_of_linear_extrusion,  
      surface_of_revolution,  
      b_spline_surface,
      b_spline_surface_with_knots,  
      uniform_surface,  
      quasi_uniform_surface,  
      bezier_surface,  
      rational_b_spline_surface,  
      rectangular_trimmed_surface,  
      curve_bounded_surface,  
      boundary_curve,  
      outer_boundary_curve,  
      rectangular_composite_surface,  
      surface_patch,  
      offset_surface,  
      surface_replica);  

  USE FROM product_property_representation_schema ( 
      shape_representation);  
  
  USE FROM representation_schema (
      definitional_representation,
      mapped_item,
      parametric_representation_context);
  
 

ENTITY geometrically_bounded_surface_shape_representation 
   SUBTYPE OF (shape_representation);  
WHERE 
  WR1 : SIZEOF (QUERY (it <* SELF.items |
        NOT (SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET',
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM',
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF
        (it)) = 1))) = 0;
  WR2 : SIZEOF (QUERY (it <* SELF.items |
        SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET',
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM'] * TYPEOF
        (it)) = 1)) > 0;
  WR3 : SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
        NOT ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.' +
        'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION'
        IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
        = 0;
  WR4 : SIZEOF (QUERY (gs <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (pnt <* QUERY (gsel <*
        gs\geometric_set.elements |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT' IN TYPEOF (gsel)) |
        NOT (gbsf_check_point(pnt)))) = 0))) = 0;
  WR5 : SIZEOF (QUERY (gs <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (cv <* QUERY (gsel <*
        gs\geometric_set.elements |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE' IN TYPEOF (gsel)) |
        NOT (gbsf_check_curve(cv)))) = 0))) = 0;
  WR6 : SIZEOF (QUERY (gs <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (sf <* QUERY (gsel <*
        gs\geometric_set.elements |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF (gsel)) |
        NOT (gbsf_check_surface(sf)))) = 0))) = 0;
END_ENTITY;

FUNCTION gbsf_check_point (pnt : point) : BOOLEAN;  
 
  -- check whether the input has the right type;
  -- a cartesian_point is valid and has no further references
 
  IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (pnt) THEN  
    RETURN(TRUE);  
  ELSE  
 
  -- a point_on_curve needs to be checked for the validity of its curve;  
  -- further references down the tree are taken care of by the function  
  -- gbsf_check_curve  
 
    IF 'GEOMETRY_SCHEMA.POINT_ON_CURVE' IN TYPEOF (pnt) THEN  
      RETURN (gbsf_check_curve 
      (pnt\point_on_curve.basis_curve));  
    ELSE  
 
    -- a point_on_surface needs to be checked for the validity of its surface;
    -- further references down the tree are taken care of by the function     
    -- gbsf_check_surface  
 
      IF 'GEOMETRY_SCHEMA.POINT_ON_SURFACE' IN TYPEOF (pnt) THEN  
        RETURN(gbsf_check_surface
        (pnt\point_on_surface.basis_surface));  
      ELSE  
 
      -- a degenerate_pcurve needs to be checked for the validity of its   
      -- definining geometry; further references down the tree are taken care  
      -- of by the functions gbsf_check_curve and gbsf_check_surface; 
      -- both return true for valid points
 
        IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF (pnt) THEN  
          RETURN
          ((gbsf_check_curve  
          (pnt\degenerate_pcurve.reference_to_curve.items[1]))  
          AND (gbsf_check_surface (pnt\degenerate_pcurve.basis_surface)));  
        END_IF;  
      END_IF;
    END_IF;  
  END_IF;  
  RETURN(FALSE);  
END_FUNCTION;


FUNCTION gbsf_check_curve (cv : curve) : BOOLEAN;  
 
  -- check whether the input has the right type;
 
  -- let those types pass that do not have any further references  
  -- respectively rules to be applied; ensure that complex entities
  -- with bounded_curve do not pass
 
  IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 'GEOMETRY_SCHEMA.CIRCLE', 
    'GEOMETRY_SCHEMA.ELLIPSE'] * TYPEOF(cv)) = 1 THEN RETURN(TRUE);  
  ELSE  
 
    -- the b_spline_curve shall not self intersect  
 
    IF (('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND
      (cv\b_spline_curve.self_intersect = FALSE))
    THEN RETURN(TRUE); 
    ELSE  
 
      -- if the curve is a composite_curve, all of its segments shall be valid
 
      IF (('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(cv)) AND
        (cv\composite_curve.self_intersect = FALSE)) THEN  
        RETURN (SIZEOF (QUERY (seg <* cv\composite_curve.segments |
        NOT (gbsf_check_curve(seg.parent_curve)))) = 0); 
      ELSE  
 
        -- the curve_replica references other curves that need to be checked  

        IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
          'GEOMETRY_SCHEMA.CURVE_REPLICA'] * TYPEOF(cv)) = 1 THEN 
          RETURN (gbsf_check_curve (cv\curve_replica.parent_curve)); 
        ELSE 
 
          -- offset_curve_3d references a curve and shall not self intersect

          IF ((SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
            'GEOMETRY_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) = 1) AND
            (cv\offset_curve_3d.self_intersect = FALSE)) THEN 
            RETURN (gbsf_check_curve (cv\offset_curve_3d.basis_curve));
          ELSE  
 
            -- pcurve references a curve - indirectly, and a basis_surface 
 
            IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
              'GEOMETRY_SCHEMA.PCURVE'] * TYPEOF(cv)) = 1 THEN 
              RETURN ((gbsf_check_curve 
              (cv\pcurve.reference_to_curve.items[1])) AND  
              (gbsf_check_surface (cv\pcurve.basis_surface)));  
            ELSE  
 
              -- polyline shall have at least 3 points and shall only  
              -- be used to represent an intersection_curve  
	-- this rule doesn't pass compiler now due to intersection_curve doesn't
        -- have a basis_surface attribute, so corrected rule to get by
        -- compiler.  will need a long term fix for fdis.
 
              IF 'GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN  
                IF (SIZEOF (cv\polyline.points) >= 3)  AND 
                  (SIZEOF ((bag_to_set (USEDIN (cv,'')) - 
                  bag_to_set (USEDIN (cv,  
                  'GEOMETRY_SCHEMA.SURFACE_CURVE.CURVE_3D')))) = 0) 
                  THEN RETURN (TRUE);  
                END_IF;  
              ELSE  
 
                -- surface_curve references a curve_3d and one or two  
                -- pcurves or one or two surface_curves or one of each  
 
                IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
                  'GEOMETRY_SCHEMA.SURFACE_CURVE'] * TYPEOF(cv)) = 1 THEN  
 
                  -- if the curve reference is correct, check also the rest 

                  IF gbsf_check_curve (cv\surface_curve.curve_3d) THEN  
                    REPEAT i := 1 TO SIZEOF 
                    (cv\surface_curve.associated_geometry);  
 
                    -- do for one or two associated_geometrys:  
 
                    IF 'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT gbsf_check_surface
                        (cv\surface_curve.associated_geometry[i]) THEN  
                        RETURN(FALSE);  
                      END_IF;  
                    ELSE 
                      IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF  
                        (cv\surface_curve.associated_geometry[i]) THEN  
                        IF NOT gbsf_check_curve 
                          (cv\surface_curve.associated_geometry[i]) THEN  
                          RETURN(FALSE);  
                        END_IF;  
                      END_IF;  
                    END_IF;  
                  END_REPEAT;  
                  RETURN(TRUE);  
                END_IF;  
              ELSE  
 
                -- if the curve is a trimmed_curve  
                                                         
                IF ('GEOMETRY_SCHEMA.TRIMMED_CURVE') IN TYPEOF (cv) THEN  
   
                -- if a line, parabola or hyperbola is being trimmed,  
                -- then valid  
 
                  IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
                  'GEOMETRY_SCHEMA.LINE', 
                  'GEOMETRY_SCHEMA.PARABOLA', 
                  'GEOMETRY_SCHEMA.HYPERBOLA'] *
                  TYPEOF (cv\trimmed_curve.basis_curve)) = 1 
                  THEN RETURN (TRUE); 

                    -- otherwise, recursively check the basis curve  
   
                    ELSE RETURN (gbsf_check_curve 
                      (cv\trimmed_curve.basis_curve));
                    END_IF; 
                  END_IF;  
                END_IF;  
              END_IF;  
            END_IF;  
          END_IF;   
        END_IF;  
      END_IF;  
    END_IF;  
  END_IF;  
  RETURN(FALSE);  
END_FUNCTION;


FUNCTION gbsf_check_surface (sf : surface) : BOOLEAN;  
 
  -- check whether the input has the right type and for some whether
  -- attribute restrictions are fulfilled (self-intersect e.g.)

  -- b_spline_surface has a self_intersect attribute that shall be false  
 
  IF (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND
    (sf\b_spline_surface.self_intersect = FALSE)) THEN
    RETURN(TRUE);
  ELSE  
 
    -- basis surface types return true 
 
    IF SIZEOF (['GEOMETRY_SCHEMA.SPHERICAL_SURFACE',  
      'GEOMETRY_SCHEMA.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN(TRUE);  
    ELSE  
  
      IF 'GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN  
 
      -- if there is a simple basis_surface, check the curves  
 
        IF SIZEOF (['GEOMETRY_SCHEMA.CONICAL_SURFACE',  
          'GEOMETRY_SCHEMA.CYLINDRICAL_SURFACE',  
          'GEOMETRY_SCHEMA.PLANE'] 
          * TYPEOF(sf\curve_bounded_surface.basis_surface)) = 1 THEN   
          RETURN(SIZEOF (QUERY (bcurve <*  
          sf\curve_bounded_surface.boundaries |
          NOT (gbsf_check_curve(bcurve)))) = 0);
           
        ELSE  
 
        -- recursively check the basis_surface and then the curves 
 
          IF gbsf_check_surface
          (sf\curve_bounded_surface.basis_surface) THEN  
            RETURN(SIZEOF (QUERY (bcurve <*
            sf\curve_bounded_surface.boundaries | 
            NOT (gbsf_check_curve(bcurve)))) = 0);
          END_IF;  
        END_IF;  
      ELSE  
 
        -- offset_surface references a surface and shall not self_intersect 
 
        IF (('GEOMETRY_SCHEMA.OFFSET_SURFACE' IN TYPEOF(sf)) AND
          (sf\offset_surface.self_intersect = FALSE)) THEN
          RETURN (gbsf_check_surface (sf\offset_surface.basis_surface));
        ELSE  
 
          -- rectangular_composite_surface references a matrix of surfaces  
 
          IF 'GEOMETRY_SCHEMA.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) 
          THEN
            REPEAT i := 1 TO SIZEOF
              (sf\rectangular_composite_surface.segments);  
              REPEAT j := 1 TO SIZEOF
                (sf\rectangular_composite_surface.segments[i]);  
                IF NOT (gbsf_check_surface
                  (sf\rectangular_composite_surface.segments[i][j].
                  parent_surface))
                  THEN RETURN (FALSE);  
                END_IF;  
              END_REPEAT;  
            END_REPEAT;  
            RETURN(TRUE);  
          ELSE  
 
            -- rectangular_trimmed_surface has a basis_surface  
 
            IF 'GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(sf) 
            THEN
              IF  SIZEOF (['GEOMETRY_SCHEMA.CONICAL_SURFACE',  
                'GEOMETRY_SCHEMA.CYLINDRICAL_SURFACE',  
                'GEOMETRY_SCHEMA.PLANE'] * TYPEOF
                (sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN 
                RETURN (TRUE); 
              ELSE 
                RETURN(gbsf_check_surface
                (sf\rectangular_trimmed_surface.basis_surface)); 
              END_IF;  
            ELSE  
 
              -- parent_surfaces need to be checked for their validity 
  
              IF 'GEOMETRY_SCHEMA.SURFACE_REPLICA' IN TYPEOF (sf) THEN 
                RETURN (gbsf_check_surface 
                (sf\surface_replica.parent_surface)); 
              ELSE  
 
                -- and the swept_surface must have a valid swept_curve  

                IF 'GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF(sf) THEN  
                  RETURN(gbsf_check_curve (sf\swept_surface.swept_curve)); 
                END_IF;    
              END_IF;    
            END_IF;     
          END_IF;  
        END_IF;  
      END_IF;  
    END_IF;  
  END_IF;  
  RETURN(FALSE);  
END_FUNCTION;

FUNCTION bag_to_set (the_bag : BAG OF GENERIC : intype) : 
                     SET OF GENERIC : intype;

  LOCAL
    the_set: SET OF GENERIC : intype := [];
    i      : INTEGER;
  END_LOCAL;

  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;

  RETURN (the_set);

END_FUNCTION;
  
END_SCHEMA; -- aic_geometrically_bounded_surface  

SCHEMA aic_manifold_surface;


  USE FROM aic_topologically_bounded_surface;


  USE FROM geometric_model_schema (
      shell_based_surface_model);


  USE FROM geometry_schema (
      b_spline_curve,
      b_spline_surface,
      bounded_pcurve,
      bounded_surface_curve,
      cartesian_transformation_operator_3d,
      curve,
      curve_replica,
      degenerate_pcurve,

evaluated_degenerate_pcurve,
      intersection_curve,
      offset_curve_3d,
      offset_surface,
      point_on_curve,
      point_on_surface,
      seam_curve,
      surface,
      surface_replica);


  USE FROM product_property_representation_schema (
      shape_representation);


  USE FROM representation_schema (
      mapped_item,
      representation,
      representation_map);


  USE FROM topology_schema (
      closed_shell,
      connected_face_set,
      face,
      open_shell,
      oriented_closed_shell,
      oriented_face);



ENTITY manifold_surface_shape_representation
   SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM',
       'AIC_MANIFOLD_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT ('AIC_MANIFOLD_SURFACE.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
       = 0;
  WR4: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.OPEN_SHELL',
       'AIC_MANIFOLD_SURFACE.ORIENTED_CLOSED_SHELL',
       'AIC_MANIFOLD_SURFACE.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.FACE_SURFACE',
       'AIC_MANIFOLD_SURFACE.ORIENTED_FACE'] * TYPEOF (fa)) = 1))) = 0)))
       = 0))) = 0;
  WR6: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |

NOT (SIZEOF (QUERY (f_sf <* QUERY (fa <*
      cfs\connected_face_set.cfs_faces |
      'AIC_MANIFOLD_SURFACE.FACE_SURFACE' IN TYPEOF (fa)) |
      NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (f_sf))
      OR
      (SIZEOF (['AIC_MANIFOLD_SURFACE.B_SPLINE_SURFACE',
      'AIC_MANIFOLD_SURFACE.ELEMENTARY_SURFACE',
      'AIC_MANIFOLD_SURFACE.OFFSET_SURFACE',
      'AIC_MANIFOLD_SURFACE.SURFACE_REPLICA',
      'AIC_MANIFOLD_SURFACE.SWEPT_SURFACE'] * TYPEOF
      (f_sf\face_surface.face_geometry)) = 1)))) = 0))) = 0))) = 0;
 WR7: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
      'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
      NOT (SIZEOF (QUERY (cfs <*
      sbsm\shell_based_surface_model.sbsm_boundary |
      NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
      NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
      OR
      (msf_surface_check(fa\face_surface.face_geometry))))) = 0)))
      = 0))) = 0;
 WR8: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
      'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
      NOT (SIZEOF (QUERY (cfs <*
      sbsm\shell_based_surface_model.sbsm_boundary |
      NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
      NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
      OR
      (SIZEOF (QUERY (bnds <* fa.bounds |
      NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.EDGE_LOOP',
      'AIC_MANIFOLD_SURFACE.VERTEX_LOOP']
      * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
 WR9: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items|
      'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
      NOT (SIZEOF (QUERY (cfs <*
      sbsm\shell_based_surface_model.sbsm_boundary |
      NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
      NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
      OR
      (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
      'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
      NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
      NOT ('AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF
      (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
WR10: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
      'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
      NOT (SIZEOF (QUERY (cfs <*
      sbsm\shell_based_surface_model.sbsm_boundary |
      NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
      NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
      OR
      (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
      'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |

NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <*
       elp_fbnds\path.edge_list |
       'AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.B_SPLINE_CURVE',
       'AIC_MANIFOLD_SURFACE.CONIC',
       'AIC_MANIFOLD_SURFACE.CURVE_REPLICA',
       'AIC_MANIFOLD_SURFACE.LINE',
       'AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D',
       'AIC_MANIFOLD_SURFACE.PCURVE',
       'AIC_MANIFOLD_SURFACE.POLYLINE',
       'AIC_MANIFOLD_SURFACE.SURFACE_CURVE'] *
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry))
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (msf_curve_check (oe.edge_element\edge_curve.edge_geometry))))
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY(sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end)))))
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',

'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR14: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0)))
       = 0))) = 0;
 WR15: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry))
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;

FUNCTION msf_curve_check (cv: curve) : BOOLEAN;





 
 IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE',
   'GEOMETRY_SCHEMA.CONIC',
   'GEOMETRY_SCHEMA.CURVE_REPLICA', 'GEOMETRY_SCHEMA.LINE',
   'GEOMETRY_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1
 THEN RETURN(FALSE);
 ELSE


  
  IF (('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
    (cv\b_spline_curve.self_intersect = FALSE))
  THEN RETURN(TRUE);
  ELSE


    
    IF SIZEOF (['GEOMETRY_SCHEMA.CONIC', 'GEOMETRY_SCHEMA.LINE']
      * TYPEOF (cv)) = 1 THEN
      RETURN(TRUE);
    ELSE


      
      IF 'GEOMETRY_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
        RETURN (msf_curve_check(cv\curve_replica.parent_curve));
      ELSE


        
        IF (('GEOMETRY_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF (cv)) AND
         (cv\offset_curve_3d.self_intersect = FALSE)) THEN
         RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve));
        ELSE


         
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(cv) THEN
     RETURN ((msf_curve_check
     (cv\pcurve.reference_to_curve\representation.items[1])) AND
     (msf_surface_check(cv\pcurve.basis_surface)));
   ELSE


     
     IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv) THEN


       
       IF msf_curve_check(cv\surface_curve.curve_3d) THEN
         REPEAT i := 1 TO SIZEOF
         (cv\surface_curve.associated_geometry);


           
           IF 'GEOMETRY_SCHEMA.SURFACE' IN
             TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
             IF NOT msf_surface_check
               (cv\surface_curve.associated_geometry[i]) THEN
               RETURN(FALSE);
             END_IF;
           ELSE
             IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF
               (cv\surface_curve.associated_geometry[i]) THEN
               IF NOT msf_curve_check
                (cv\surface_curve.associated_geometry[i]) THEN
                RETURN(FALSE);
               END_IF;
             END_IF;
           END_IF;
         END_REPEAT;
         RETURN(TRUE);
       END_IF;
     ELSE


       
       IF 'GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN
         IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
         END_IF;
       END_IF;
     END_IF;
   END_IF;
  END_IF;
END_IF;

END_IF;
  END_IF;
 END_IF;
 RETURN (FALSE);
END_FUNCTION;

FUNCTION msf_surface_check (surf : surface) : BOOLEAN;





  
  IF 'GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE


    
    IF 'GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF (surf) THEN
      RETURN (msf_curve_check(surf\swept_surface.swept_curve));
    ELSE

IF (('GEOMETRY_SCHEMA.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE)) THEN
        RETURN (msf_surface_check(surf\offset_surface.basis_surface));
      ELSE


        
        IF 'GEOMETRY_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf) THEN
         RETURN(msf_surface_check(surf\surface_replica.parent_surface));
        ELSE


         
         IF (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
           (surf\b_spline_surface.self_intersect = FALSE)) THEN
           RETURN(TRUE);
         END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION;

END_SCHEMA; -- aic_manifold_surface
SCHEMA aic_geometrically_bounded_wireframe;

  USE FROM geometric_model_schema  -- ISO 10303-42
    (geometric_curve_set,
     geometric_set);

  USE FROM geometry_schema  -- ISO 10303-42
    (axis1_placement,
     axis2_placement_3d,
     b_spline_curve_with_knots,
     bezier_curve,
     cartesian_transformation_operator_3d,
     circle,
     composite_curve,
     curve,
     curve_replica,
     ellipse,
     geometric_representation_context,
     hyperbola,
     line,
     offset_curve_3d,
     parabola,
     point,
     point_on_curve,
     point_replica,
     polyline,
     quasi_uniform_curve,
     rational_b_spline_curve,
     reparametrised_composite_curve_segment,
     trimmed_curve,
     uniform_curve);

  USE FROM product_property_representation_schema  -- ISO 10303-41
    (shape_representation);

  USE FROM representation_schema  -- ISO 10303-43
    (mapped_item);

ENTITY geometrically_bounded_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
         NOT (SIZEOF (TYPEOF(it) *
           ['AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D',
            'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM']) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF (TYPEOF (it) *
           ['AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM']) = 1
       )) >= 1;
  WR3: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (crv <*
           QUERY (elem <* gcs\geometric_set.elements |
            ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CURVE' IN TYPEOF (elem))) |
           NOT (valid_geometrically_bounded_wf_curve
                  (crv, 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME'))
         )) = 0)
       )) = 0;
  WR4: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (pnts <*
           QUERY (elem <* gcs\geometric_set.elements |
            ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT' IN TYPEOF (elem))) |
           NOT (valid_geometrically_bounded_wf_point
                  (pnts, 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME'))
         )) = 0)
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (cnc <*
           QUERY (elem <* gcs\geometric_set.elements |
            ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CONIC' IN TYPEOF (elem))) |
           NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D'
             IN TYPEOF (cnc\conic.position))
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (pline <*
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POLYLINE'
                  IN TYPEOF (elem))) |
           NOT (SIZEOF (pline\polyline.points) > 2)
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
          ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM'
               IN TYPEOF (it))) |
           NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.' +
                'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'
             IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR8: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 3;
END_ENTITY;

FUNCTION valid_geometrically_bounded_wf_curve
   (crv   : curve; schma : STRING) : BOOLEAN;

  -- check for valid basic curve types
  IF SIZEOF ([schma + '.POLYLINE',
              schma + '.B_SPLINE_CURVE',
              schma + '.ELLIPSE',
              schma + '.CIRCLE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF ((schma + '.TRIMMED_CURVE') IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF ([schma + '.LINE',
                  schma + '.PARABOLA',
                  schma + '.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);

      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_geometrically_bounded_wf_curve
                         (crv\trimmed_curve.basis_curve, schma));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF ((schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv))
        THEN RETURN (valid_geometrically_bounded_wf_curve
                           (crv\offset_curve_3d.basis_curve, schma));
      ELSE
        -- recursively check the curve_replica parent curve
        IF ((schma + '.CURVE_REPLICA') IN TYPEOF (crv))
          THEN RETURN (valid_geometrically_bounded_wf_curve
                         (crv\curve_replica.parent_curve, schma));
        ELSE
          -- recursively check the composite_curve segments
          IF ((schma + '.COMPOSITE_CURVE') IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_geometrically_bounded_wf_curve
                             (ccs.parent_curve, schma)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_geometrically_bounded_wf_point
   (pnt : point; schma : STRING) : BOOLEAN;

  -- check for valid basis types
  IF ((schma + '.CARTESIAN_POINT') IN TYPEOF (pnt))
    THEN RETURN (TRUE);
  ELSE
    -- if the input type is a point_on_curve then check for a valid
    -- geometrically bounded curve type as the basis
    IF ((schma + '.POINT_ON_CURVE') IN TYPEOF (pnt))
      THEN RETURN (valid_geometrically_bounded_wf_curve
                     (pnt\point_on_curve.basis_curve, schma));

    ELSE
      -- if the input type is a point_replica check for a valid parent point
      IF ((schma + '.POINT_REPLICA') IN TYPEOF (pnt))
        THEN RETURN (valid_geometrically_bounded_wf_point
                         (pnt\point_replica.parent_pt, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

END_SCHEMA; -- aic_geometrically_bounded_wireframe
 SCHEMA aic_topologically_bounded_surface;
  USE FROM geometry_schema(axis2_placement_2d,
                           axis2_placement_3d,
                           bezier_curve,
                           bezier_surface,
                           b_spline_curve_with_knots,
                           b_spline_surface_with_knots,
                           cartesian_point,
                           circle,
                           conical_surface,
                           cylindrical_surface,
                           degenerate_toroidal_surface,
                           direction,
                           ellipse,
                           hyperbola,
                           line,
                           parabola,
                           pcurve,
                           plane,
                           polyline,
                           quasi_uniform_curve,
                           quasi_uniform_surface,
                           rational_b_spline_curve,
                           rational_b_spline_surface,
                           spherical_surface,
                           surface_curve,
                           surface_of_linear_extrusion,
                           surface_of_revolution,
                           swept_surface,
                           toroidal_surface,
                           uniform_curve,
                           uniform_surface,
                           vector);
  USE FROM topology_schema(edge_curve,
                           edge_loop,
                           face_bound,
                           face_outer_bound,
                           face_surface,
                           path,
                           vertex_loop,
                           vertex_point);
  USE FROM representation_schema(definitional_representation,
                                 parametric_representation_context);
  USE FROM measure_schema (parameter_value);
 
ENTITY advanced_face
  SUBTYPE OF (face_surface);
WHERE
  WR1 : SIZEOF
(['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE',
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE',
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE'] *
            TYPEOF(face_geometry)) = 1;
  WR2 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
           'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                          TYPEOF(bnds.bound)) |
          NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
              NOT('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN
              TYPEOF(oe.edge_element)))) = 0))) = 0;
  WR3 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
           'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                            TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT (SIZEOF (['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE',
                         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC',
                         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE',
                         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE',
                         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE']
*
              TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
                )) = 0))) = 0;
  WR4 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
           'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                             TYPEOF(bnds.bound)) |
            NOT(SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list |
             NOT(((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN
                 TYPEOF(oe.edge_start)) AND
            ( 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN
             TYPEOF(oe.edge_start\vertex_point.vertex_geometry)))) AND
                 (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN
                    TYPEOF(oe.edge_end)) AND
                   ( 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT'
IN
                     TYPEOF(oe.edge_end\vertex_point.vertex_geometry)))
              ))) = 0))) = 0;
  WR5 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                           TYPEOF(bnds.bound)) |
            'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN
             TYPEOF(elp_fbnds.bound))) = 0;
  WR6 : (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN
                                              TYPEOF(face_geometry))) OR
             (SIZEOF (['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE',
                       'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC',
                       'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE',
                       'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE']
*
                  TYPEOF(face_geometry\swept_surface.swept_curve)) = 1);
  WR7 : SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* SELF.bounds |
           'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN
                                               TYPEOF(bnds.bound)) |
             NOT(('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                  ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN
                     TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
              ))) = 0;
  WR8 : SIZEOF (QUERY (bnd <* SELF.bounds |
         NOT (SIZEOF(['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP',
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP'] *
TYPEOF(bnd.bound))
                                = 1))) = 0;
  WR9 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                             TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND 
            (NOT (SIZEOF (QUERY (sc_ag <* 
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))) = 0))) = 0;
  WR10 : ((NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE'
IN
         TYPEOF(face_geometry))) OR
         ((NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN
         TYPEOF(face_geometry\swept_surface.swept_curve))) OR
         (SIZEOF(face_geometry\swept_surface.swept_curve\polyline.points)
         < 3))) AND
         (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
TYPEOF(bnds.bound)) |
         NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
         ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN
         TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND 
         (NOT (SIZEOF (oe.edge_element\edge_curve.edge_geometry\
         polyline.points) < 3)))) = 0))) = 0);
 END_ENTITY;

   END_SCHEMA; -- end AIC_TOPOLOGICALLY_BOUNDED_SURFACE SCHEMA
 
SCHEMA aic_faceted_brep;

 USE FROM geometry_schema(cartesian_point, axis2_placement_3d,
                      cartesian_transformation_operator_3d,
                      elementary_surface, plane);
 USE FROM topology_schema(poly_loop, face_surface,
                           face_bound, face_outer_bound,
                           closed_shell, oriented_closed_shell);
 USE FROM geometric_model_schema(brep_with_voids, manifold_solid_brep,
                                 faceted_brep);


 USE FROM representation_schema(mapped_item);

 USE FROM product_property_representation_schema(shape_representation);


 ENTITY faceted_brep_shape_representation
   SUBTYPE OF (shape_representation);
 WHERE
   WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF(['AIC_FACETED_BREP.FACETED_BREP',
            'AIC_FACETED_BREP.MAPPED_ITEM',
            'AIC_FACETED_BREP.AXIS2_PLACEMENT_3D'] *
             TYPEOF(it)) = 1))) = 0;
   WR2 : SIZEOF (QUERY (it <* SELF.items |
          SIZEOF(['AIC_FACETED_BREP.FACETED_BREP',
          'AIC_FACETED_BREP.MAPPED_ITEM'] * TYPEOF(it)) = 1)) > 0;
   WR3 : SIZEOF (QUERY (fbrep <* QUERY ( it <* SELF.items |
          'AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(fbrep, 'AIC_FACETED_BREP') |
          NOT (SIZEOF (QUERY (fcs <* csh.cfs_faces |
          NOT (('AIC_FACETED_BREP.FACE_SURFACE' IN TYPEOF (fcs)) AND
          (('AIC_FACETED_BREP.PLANE' IN TYPEOF
               (fcs\face_surface.face_geometry)) AND
          ('AIC_FACETED_BREP.CARTESIAN_POINT' IN TYPEOF (
               fcs\face_surface.face_geometry\
                    elementary_surface.position.location))))))
                      = 0))) = 0))) = 0;
   WR4 : SIZEOF (QUERY (fbrep <* QUERY ( it <* SELF.items |
          'AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(fbrep, 'AIC_FACETED_BREP') |
          NOT (SIZEOF (QUERY (fcs <* csh.cfs_faces |
          NOT (SIZEOF (QUERY (bnds <* fcs.bounds |
           'AIC_FACETED_BREP.FACE_OUTER_BOUND' IN TYPEOF(bnds)))
              = 1))) = 0))) = 0))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
          'AIC_FACETED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'AIC_FACETED_BREP.ORIENTED_CLOSED_SHELL' IN
              TYPEOF (msb\manifold_solid_brep.outer))) = 0;
   WR6 : SIZEOF (QUERY (brv <* QUERY (it <* SELF.items |
          'AIC_FACETED_BREP.BREP_WITH_VOIDS' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR7 : SIZEOF (QUERY (mi <*  QUERY (it <* SELF.items |
                 'AIC_FACETED_BREP.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT ('AIC_FACETED_BREP.FACETED_BREP_SHAPE_REPRESENTATION' IN
            TYPEOF(mi\mapped_item.mapping_source.mapped_representation))))
                = 0;
 END_ENTITY;

  FUNCTION msb_shells (brep: manifold_solid_brep;
                        schema_name : STRING) :
                        SET [1:?] OF  closed_shell;
     IF (schema_name + '.BREP_WITH_VOIDS' IN TYPEOF (brep)) THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
  END_FUNCTION;
 
 END_SCHEMA; -- end AIC FACETED BREP SCHEMA
 SCHEMA aic_advanced_brep;
  USE FROM aic_topologically_bounded_surface;

  USE FROM geometry_schema(cartesian_transformation_operator_3d);

  USE FROM geometric_model_schema(manifold_solid_brep,
                                  brep_with_voids);
  REFERENCE FROM aic_faceted_brep(msb_shells);

  USE FROM topology_schema(closed_shell,
                           connected_face_set,
                           oriented_closed_shell);

  USE FROM representation_schema(mapped_item);

  USE FROM product_property_representation_schema(shape_representation);

 ENTITY advanced_brep_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
     WR1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
              'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP',
              'AIC_ADVANCED_BREP.FACETED_BREP',
              'AIC_ADVANCED_BREP.MAPPED_ITEM',
              'AIC_ADVANCED_BREP.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) ))
              = 0;
     WR2: SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
              'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP',
              'AIC_ADVANCED_BREP.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) > 0;
     WR3: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items |
              ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) ) |
             ( NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,'AIC_ADVANCED_BREP') |
                              (NOT (SIZEOF(QUERY ( fcs <* csh\
              connected_face_set.cfs_faces | (NOT (
              'AIC_ADVANCED_BREP.ADVANCED_FACE' IN TYPEOF(fcs))) )) = 0)) ))
              = 0)) )) = 0;
     WR4: SIZEOF(QUERY ( msb <* QUERY ( it <* items |
            ( 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) ) |
            (  'AIC_ADVANCED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\
              manifold_solid_brep.outer)) )) = 0;
     WR5: SIZEOF(QUERY ( brv <* QUERY ( it <* items |
           ( 'AIC_ADVANCED_BREP.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (NOT
              (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids |
              ( csh\oriented_closed_shell.orientation)))  = 0)) ))
              = 0;
     WR6: SIZEOF(QUERY ( mi <* QUERY ( it <* items |
            ( 'AIC_ADVANCED_BREP.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT
            ( 'AIC_ADVANCED_BREP.ADVANCED_BREP_SHAPE_REPRESENTATION' IN
              TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) ))
              = 0;
 END_ENTITY;

 END_SCHEMA; -- end AIC_ADVANCED_BREP SCHEMA
SCHEMA aic_csg;

USE FROM aic_advanced_brep; 	-- ISO 10303-514

USE FROM aic_faceted_brep; 	-- ISO 10303-512

USE FROM geometric_model_schema 	-- ISO 10303-42  
     (block,
     boolean_operand,
     boolean_operator,
     boolean_result,
     box_domain,
     boxed_half_space,
     csg_primitive,
     csg_select,
     csg_solid,
     extruded_face_solid,
     half_space_solid,
     revolved_face_solid,
     right_angular_wedge,
     right_circular_cone,
     right_circular_cylinder,
     solid_replica, 
     sphere,
     torus);

ENTITY csg_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3;

  WR2: SIZEOF(QUERY (it <* SELF.items |
         SIZEOF(['AIC_CSG.CSG_SOLID',
                 'AIC_CSG.MAPPED_ITEM', 'AIC_CSG.AXIS2_PLACEMENT_3D',
                 'AIC_CSG.SOLID_REPLICA', 'AIC_CSG.REVOLVED_FACE_SOLID',
                 'AIC_CSG.EXTRUDED_FACE_SOLID'] * TYPEOF(it)) <> 1)) = 0;

  WR3: SIZEOF(QUERY (mi <* QUERY (it <* SELF.items |
              'AIC_CSG.MAPPED_ITEM' IN TYPEOF(it)) |
               NOT('AIC_CSG.CSG_SHAPE_REPRESENTATION' IN
       TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;

  WR4: SIZEOF(QUERY (sr <* QUERY (it <* SELF.items |
              'AIC_CSG.SOLID_REPLICA' IN TYPEOF(it)) |
              SIZEOF(['AIC_CSG.CSG_SOLID', 'AIC_CSG.REVOLVED_FACE_SOLID',
                      'AIC_CSG.EXTRUDED_FACE_SOLID'] *
                      TYPEOF(sr\solid_replica.parent_solid)) = 0)) = 0;

  WR5: SIZEOF(QUERY(it <* SELF.items | 
                    NOT('AIC_CSG.AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) > 0;

END_ENTITY;

END_SCHEMA; -- aic_csg



 (* part 521 Manifold subsurface AIC EXPRESS listing WG12 N971
 2001-09-03 *)
 SCHEMA aic_manifold_subsurface;  --- extracted from part 521 WG12 N970
  USE FROM aic_topologically_bounded_surface; -- ISO 10303-511

  USE FROM geometry_schema    -- ISO  10303-42
      (cartesian_transformation_operator_3d);
  USE FROM topology_schema  -- ISO  10303-42
      (closed_shell,
       connected_face_set,
       connected_face_sub_set,
       face,
       open_shell,
       subedge,
       subface);

  USE FROM representation_schema(mapped_item);   -- ISO  10303-43

  USE FROM product_property_representation_schema   -- ISO  10303-41
      (shape_representation);
 ENTITY manifold_subsurface_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
   WR1: SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET',
                'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM',
                'AIC_MANIFOLD_SUBSURFACE.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET',
         'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3: SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('AIC_MANIFOLD_SUBSURFACE.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR4: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT('AIC_MANIFOLD_SUBSURFACE.OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
--tt replacement from Ray Goult 2002-01-23
   WR5: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN
              TYPEOF(it)) |
          NOT( (('AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN
                   TYPEOF(cfss.parent_face_set)) AND
            (SIZEOF (QUERY (fac <* cfss.parent_face_set. cfs_faces | NOT
                 advanced_face_properties(fac))) = 0)) OR
             (SIZEOF (QUERY (fac <* cfss.parent_face_set .cfs_faces | NOT
            ('AIC_MANIFOLD_SUBSURFACE.ADVANCED_FACE' IN TYPEOF(fac)))) >= 0)
                    ))) = 0;

   WR6: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          ( SIZEOF (QUERY (fac <* cfss\connected_face_set.cfs_faces  | NOT
              advanced_face_properties(fac))) = 0))) = 0;
   WR7: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
          ('AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it))) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
            NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         ('AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound))) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT(('AIC_MANIFOLD_SUBSURFACE.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)) OR
           ('AIC_MANIFOLD_SUBSURFACE.SUBEDGE' IN
            TYPEOF(oe.edge_element)) ))) = 0
                   ))) = 0
                 ))) = 0
             ))) = 0;
   WR8: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
           ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         ('AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound))) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
          NOT(('AIC_MANIFOLD_SUBSURFACE.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AIC_MANIFOLD_SUBSURFACE.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                   ))) = 0;
   WR9: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY  (bnds <* fcs.bounds |
         NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP',
                'AIC_MANIFOLD_SUBSURFACE.VERTEX_LOOP'] *
                   TYPEOF(bnds.bound)) = 1 
                  ))) = 0
               )))) = 0
             ))) = 0;
   WR10: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           ('AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it))) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         ('AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound))) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.LINE',
                         'AIC_MANIFOLD_SUBSURFACE.CONIC',
                         'AIC_MANIFOLD_SUBSURFACE.POLYLINE',
                         'AIC_MANIFOLD_SUBSURFACE.SURFACE_CURVE',
                         'AIC_MANIFOLD_SUBSURFACE.B_SPLINE_CURVE' ] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 )))) = 0
                    ))) = 0;
   WR11: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           ('AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it))) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         ('AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound))) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_MANIFOLD_SUBSURFACE.SURFACE_CURVE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT ((SIZEOF (QUERY (sc_ag <*
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
   WR12: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           ('AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it))) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         ('AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound))) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_MANIFOLD_SUBSURFACE.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
 END_ENTITY;
FUNCTION advanced_face_properties (testface : face) : BOOLEAN;
(* return TRUE if testface is of type advanced_face *)
IF 'AIC_MANIFOLD_SUBSURFACE.ADVANCED_FACE' IN TYPEOF(testface) THEN
    RETURN (TRUE);
END_IF;
(* if testface is a subface recursively test the parent_face,
return FALSE for all other types of face *)
IF  ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(testface)) THEN
   RETURN(advanced_face_properties(testface.parent_face));
   ELSE  RETURN (FALSE);
END_IF;
END_FUNCTION;
   END_SCHEMA; -- end AIC_MANIFOLD_SUBSURFACE SCHEMA
