(*
Created:
Fri Jun 20 12:27:17 EDT 2003

 The object identifier assigned to this schema is:
                { 1 0 10303 210 wd1_35 1 1 }

 Using part 21 of ISO 10303, the file_schema entity will be as follows:

    FILE_SCHEMA (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN { 1 0 10303 210 wd1_35 1 1 }'));
 The object identifier assigned to this schema is:
                { 1 0 10303 210 RELEASEVERSION 1 SCHEMAID }

 Using part 21 of ISO 10303, the file_schema entity will be as follows:

    FILE_SCHEMA (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN { 1 0 10303 210 RELEASEVERSION 1 SCHEMAID }'));
*)
(* ************************************************************************** *)


SCHEMA electronic_assembly_interconnect_and_packaging_design '{ 1 0 10303 210 wd1_35 1 1 }';



(* ***********************************
Constants in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   CONSTANT
      dummy_gri : geometric_representation_item := representation_item('') || geometric_representation_item();
      dummy_tri : topological_representation_item := representation_item('') || topological_representation_item();
   END_CONSTANT;


(* ***********************************
Entities in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   ENTITY absorbed_dose_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\absorbed_dose_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = gray;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY action;
      name : label;
      description : OPTIONAL text;
      chosen_method : action_method;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY action_assignment
   ABSTRACT SUPERTYPE;
      assigned_action : action;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY action_directive;
      name : label;
      description : OPTIONAL text;
      analysis : text;
      comment : text;
      requests : SET [1:?] OF versioned_action_request;
   END_ENTITY;



   ENTITY action_method;
      name : label;
      description : OPTIONAL text;
      consequence : text;
      purpose : text;
   END_ENTITY;



   ENTITY action_method_relationship;
      name : label;
      description : OPTIONAL text;
      relating_method : action_method;
      related_method : action_method;
   END_ENTITY;



   ENTITY action_relationship;
      name : label;
      description : OPTIONAL text;
      relating_action : action;
      related_action : action;
   END_ENTITY;



   ENTITY action_request_assignment
   ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY action_request_solution;
      method : action_method;
      request : versioned_action_request;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY action_request_status;
      status : label;
      assigned_request : versioned_action_request;
   END_ENTITY;



   ENTITY action_status;
      status : label;
      assigned_action : executed_action;
   END_ENTITY;



   ENTITY activity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\activity_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = becquerel;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY add_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object addition'))) = 1;
   END_ENTITY;



   ENTITY add_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object addition'))) = 1;
   END_ENTITY;



   ENTITY address;
      internal_location : OPTIONAL label;
      street_number : OPTIONAL label;
      street : OPTIONAL label;
      postal_box : OPTIONAL label;
      town : OPTIONAL label;
      region : OPTIONAL label;
      postal_code : OPTIONAL label;
      country : OPTIONAL label;
      facsimile_number : OPTIONAL label;
      telephone_number : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number : OPTIONAL label;
   DERIVE
      name : label := get_name_value(SELF);
      url : identifier := get_id_value(SELF);
   WHERE
      WR1:
         ((((((((((EXISTS(internal_location) OR EXISTS(street_number)) OR EXISTS(street)) OR EXISTS(postal_box)) OR EXISTS(town)) OR EXISTS(region)) OR EXISTS(postal_code)) OR EXISTS(country)) OR EXISTS(facsimile_number)) OR EXISTS(telephone_number)) OR EXISTS(electronic_mail_address)) OR EXISTS(telex_number);
   END_ENTITY;



   ENTITY advanced_brep_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fcs)))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (msb <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\manifold_solid_brep.outer)))) = 0;
      WR5:
         SIZEOF(QUERY (brv <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation)) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (mi <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
   END_ENTITY;



   ENTITY advanced_face
   SUBTYPE OF (face_surface);
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' ] * TYPEOF(face_geometry)) = 1;
      WR2:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe.edge_start\vertex_point.vertex_geometry))) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_end)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe.edge_end\vertex_point.vertex_geometry)))))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' IN TYPEOF(elp_fbnds.bound)))) = 0;
      WR6:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' ] * TYPEOF(face_geometry\swept_surface.swept_curve)) = 1);
      WR7:
         SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) = 0;
      WR8:
         SIZEOF(QUERY (bnd <* SELF.bounds| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' ] * TYPEOF(bnd.bound)) = 1))) = 0;
      WR9:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(QUERY (sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(sc_ag)))) = 0))) = 0))) = 0;
      WR10:
         (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(face_geometry)) OR (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(face_geometry\swept_surface.swept_curve)) OR (SIZEOF(face_geometry\swept_surface.swept_curve\polyline.points) < 3))) AND (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(oe.edge_element\edge_curve.edge_geometry\polyline.points) < 3))) = 0))) = 0);
   END_ENTITY;



   ENTITY altered_package_terminal
   ABSTRACT SUPERTYPE OF ((shape_formed_terminal ANDOR
 surface_prepped_terminal) ANDOR
 length_trimmed_terminal)
   SUBTYPE OF (package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'terminal to be altered'))) = 1;
      WR2:
         SELF.of_shape.definition\product_definition.description = 'altered package';
   END_ENTITY;



   ENTITY alternate_product_relationship;
      name : label;
      definition : OPTIONAL text;
      alternate : product;
      base : product;
      basis : text;
   UNIQUE
      UR1 : alternate,
 base;
   WHERE
      WR1:
         alternate :<>: base;
   END_ENTITY;



   ENTITY amount_of_substance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY amount_of_substance_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY analytical_model
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 2;
      WR2:
         SIZEOF(QUERY (dr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (dr.assigned_document.kind\document_type.product_data_type = 'language reference manual'))) = 1;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER' IN TYPEOF(it)))) = 0;
      WR4:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr\representation_relationship.name = 'access mechanism') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(rr.rep_2)))) >= 1;
   END_ENTITY;



   ENTITY analytical_model_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\analytical_model_definition)) = 0;
      WR7:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'simulation model'))) >= 1;
   END_ENTITY;



   ENTITY analytical_model_make_from_relationship
   SUBTYPE OF (representation,
 representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,
 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL') ] * TYPEOF(SELF.rep_1)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL') ] * TYPEOF(SELF.rep_2)) = 1;
      WR3:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2)))) = 0;
      WR4:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT ((rr\representation_relationship.name = 'associated make from') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2))))) = 0;
      WR5:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL') ] * TYPEOF(SELF)) = 0;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\analytical_model_make_from_relationship)) = 0;
   END_ENTITY;



   ENTITY analytical_model_port
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'distributed property')) AND (it\descriptive_representation_item.description IN [ 'true',
 'false' ]))) = 1;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'nominal signal flow direction')) AND (it\descriptive_representation_item.description IN [ 'input direction',
 'output direction',
 'bidirectional',
 'unknown direction',
 'not applicable' ]))) <= 1;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'port type')) AND (it\descriptive_representation_item.description IN [ 'string property type',
 'logical property type',
 'physical property type',
 'boolean property type' ]))) = 1;
      WR4:
         SIZEOF(QUERY (am <* QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr\representation_relationship.name = 'access mechanism'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(am.rep_1)))) = 1;
      WR5:
         SIZEOF(QUERY (aga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| (aga.assigned_group\group.name IN [ 'scalar port',
 'digital scalar port',
 'vector port',
 'digital vector port',
 'digital analytical model port' ]))) <= 1;
      WR6:
         NOT (SIZEOF(QUERY (aga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| (aga.assigned_group\group.name IN [ 'vector port',
 'digital vector port' ]))) = 1) OR (SIZEOF(QUERY (it <* SELF.items| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'size')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COUNT_MEASURE' IN TYPEOF(it\measure_with_unit.value_component))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONTEXT_DEPENDENT_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 1);
      WR7:
         NOT (SIZEOF(QUERY (aga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| (aga.assigned_group\group.name IN [ 'digital scalar port',
 'digital vector port',
 'digital analytical model port' ]))) = 1) OR (SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'nominal signal flow direction')) AND (it\descriptive_representation_item.description IN [ 'input direction',
 'output direction',
 'bidirectional',
 'unknown direction' ]))) = 1);
   END_ENTITY;



   ENTITY analytical_representation
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))) >= 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1)))) = 1;
   END_ENTITY;



   ENTITY angular_dimension_with_orientation
   SUBTYPE OF (dimensional_location);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.description = 'angular';
   END_ENTITY;



   ENTITY angular_location
   SUBTYPE OF (dimensional_location);
      angle_selection : angle_relator;
   END_ENTITY;



   ENTITY angular_size
   SUBTYPE OF (dimensional_size);
      angle_selection : angle_relator;
   END_ENTITY;



   ENTITY angularity_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'angularity';
   END_ENTITY;



   ENTITY annotation_curve_occurrence
   SUBTYPE OF (annotation_occurrence);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(SELF\styled_item.item);
   END_ENTITY;



   ENTITY annotation_fill_area
   SUBTYPE OF (geometric_representation_item);
      boundaries : SET [1:?] OF curve;
   END_ENTITY;



   ENTITY annotation_fill_area_occurrence
   SUBTYPE OF (annotation_occurrence);
      fill_style_target : point;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_FILL_AREA' IN TYPEOF(SELF.item);
   END_ENTITY;



   ENTITY annotation_occurrence
   SUPERTYPE OF (ONEOF(annotation_curve_occurrence,
 annotation_fill_area_occurrence,
 annotation_text_occurrence,
 annotation_symbol_occurrence))
   SUBTYPE OF (styled_item);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_symbol
   SUBTYPE OF (mapped_item);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_REPRESENTATION_MAP' IN TYPEOF(SELF\mapped_item.mapping_source);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_TARGET' IN TYPEOF(SELF\mapped_item.mapping_target);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_symbol_occurrence
   SUBTYPE OF (annotation_occurrence);
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_SYMBOL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_SYMBOL' ] * TYPEOF(SELF\styled_item.item)) > 0;
   END_ENTITY;



   ENTITY annotation_text
   SUBTYPE OF (mapped_item);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(SELF\mapped_item.mapping_target);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_STRING_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_text_character
   SUBTYPE OF (mapped_item);
      alignment : text_alignment;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTER_GLYPH_SYMBOL' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(SELF\mapped_item.mapping_target);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
   END_ENTITY;



   ENTITY annotation_text_occurrence
   SUBTYPE OF (annotation_occurrence);
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT' ] * TYPEOF(SELF\styled_item.item)) > 0;
   END_ENTITY;



   ENTITY apex
   SUBTYPE OF (derived_shape_aspect);
   END_ENTITY;



   ENTITY application_context;
      application : label;
   DERIVE
      description : text := get_description_value(SELF);
      id : identifier := get_id_value(SELF);
   INVERSE
      context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY application_context_element
   SUPERTYPE OF (ONEOF(product_concept_context,
 product_context,
 product_definition_context));
      name : label;
      frame_of_reference : application_context;
   END_ENTITY;



   ENTITY application_protocol_definition;
      status : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year : year_number;
      application : application_context;
   END_ENTITY;



   ENTITY applied_action_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_assigned_item;
   END_ENTITY;



   ENTITY applied_approval_assignment
   SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_assigned_item;
   END_ENTITY;



   ENTITY applied_certification_assignment
   SUBTYPE OF (certification_assignment);
      items : SET [1:?] OF certification_assigned_item;
   END_ENTITY;



   ENTITY applied_classification_assignment
   SUBTYPE OF (group_assignment);
      items : SET [1:?] OF classification_assigned_item;
   END_ENTITY;



   ENTITY applied_contract_assignment
   SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contract_assigned_item;
   END_ENTITY;



   ENTITY applied_date_and_time_assignment
   SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_assigned_item;
   WHERE
      WR1:
         applied_date_time_correlation(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
      WR2:
         NOT (SELF.role\date_time_role.name = 'participant date and time') OR (SIZEOF(QUERY (ra <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION' IN TYPEOF(it)))| NOT (SIZEOF(USEDIN(ra,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')) = 1))) = 0);
   END_ENTITY;



   ENTITY applied_date_assignment
   SUBTYPE OF (date_assignment);
      items : SET [1:?] OF date_assigned_item;
   WHERE
      WR1:
         applied_date_correlation(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
   END_ENTITY;



   ENTITY applied_document_reference
   SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_assigned_item;
   END_ENTITY;



   ENTITY applied_group_assignment
   SUBTYPE OF (group_assignment);
      items : SET [1:?] OF group_assigned_item;
   END_ENTITY;



   ENTITY applied_organization_assignment
   SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_assigned_item;
   END_ENTITY;



   ENTITY applied_person_and_organization_assignment
   SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_assigned_item;
   END_ENTITY;



   ENTITY applied_person_assignment
   SUBTYPE OF (person_assignment);
      items : SET [1:?] OF person_assigned_item;
   END_ENTITY;



   ENTITY applied_promissory_usage_in_product_model_assignment
   SUBTYPE OF (group_assignment);
      items : SET [1:?] OF promissory_usage_in_product_model_assigned_item;
   WHERE
      WR1:
         SIZEOF(QUERY (pm <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_CONCEPT' IN TYPEOF(pm)))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(pd)))) = 1;
      WR3:
         SIZEOF(items) = 2;
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROMISSORY_USAGE_IN_PRODUCT_MODEL' IN TYPEOF(SELF\group_assignment.assigned_group);
      WR5:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) <= 1;
   END_ENTITY;



   ENTITY applied_security_classification_assignment
   SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF security_classification_assigned_item;
   END_ENTITY;



   ENTITY approval;
      status : approval_status;
      level : label;
   END_ENTITY;



   ENTITY approval_assignment
   ABSTRACT SUPERTYPE;
      assigned_approval : approval;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY approval_date_time;
      date_time : date_time_select;
      dated_approval : approval;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role : approval_role;
   END_ENTITY;



   ENTITY approval_relationship;
      name : label;
      description : OPTIONAL text;
      relating_approval : approval;
      related_approval : approval;
   END_ENTITY;



   ENTITY approval_role;
      role : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY approval_status;
      name : label;
   END_ENTITY;



   ENTITY area_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY area_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 2.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY array_placement_group_component_definition
   SUPERTYPE OF (ONEOF(linear_array_placement_group_component_definition,
 rectangular_array_placement_group_component_definition))
   SUBTYPE OF (assembly_group_component_definition);
   END_ENTITY;



   ENTITY array_placement_group_component_shape_aspect
   SUPERTYPE OF (ONEOF(linear_array_placement_group_component_shape_aspect,
 rectangular_array_placement_group_component_shape_aspect))
   SUBTYPE OF (assembly_group_component_shape_aspect);
   END_ENTITY;



   ENTITY assembly_bond_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
      WR2:
         SIZEOF(QUERY (aga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BOND_CATEGORY' IN TYPEOF(aga.assigned_group)))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 1'))) = 1;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 2'))) = 1;
      WR5:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SIZEOF(QUERY (prpc <* USEDIN(SELF.of_shape.definition.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'technology specific model'))) >= 1);
   END_ENTITY;



   ENTITY assembly_component_usage
   SUPERTYPE OF (ONEOF(next_assembly_usage_occurrence,
 specified_higher_usage_occurrence,
 promissory_usage_occurrence))
   SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
   END_ENTITY;



   ENTITY assembly_component_usage_substitute;
      name : label;
      definition : OPTIONAL text;
      base : assembly_component_usage;
      substitute : assembly_component_usage;
   UNIQUE
      UR1 : base,
 substitute;
   WHERE
      WR1:
         base.relating_product_definition :=: substitute.relating_product_definition;
      WR2:
         base :<>: substitute;
   END_ENTITY;



   ENTITY assembly_definition
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'assembly module');
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'assembly module'))) = 1);
      WR4:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
   END_ENTITY;



   ENTITY assembly_group_component_definition
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         (SIZEOF(QUERY (gc <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'group component'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(gc.related_product_definition)))) >= 1) OR (SIZEOF(QUERY (agcsa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(agcsa)))) = 0);
      WR2:
         (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (acu <* USEDIN(aj\shape_aspect_relationship.relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) >= 1))) >= 1);
      WR3:
         (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (acu <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) = 0))) = 0);
      WR4:
         (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (cl <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect.of_shape.definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION' IN TYPEOF(cl)) AND (aj IN cl\representation.items))) = 0))) = 0);
   END_ENTITY;



   ENTITY assembly_group_component_definition_placement_link
   SUBTYPE OF (product_definition,
 product_definition_relationship);
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\assembly_group_component_definition_placement_link)) = 0;
      WR5:
         SELF\product_definition.name = '';
      WR6:
         SELF\product_definition_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
   END_ENTITY;



   ENTITY assembly_group_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (gc <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'group component'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(gc.related_shape_aspect)))) >= 1;
   END_ENTITY;



   ENTITY assembly_group_component_shape_aspect_placement_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\assembly_group_component_shape_aspect_placement_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY assembly_joint
   SUBTYPE OF (shape_aspect_relationship,
 shape_aspect);
   WHERE
      WR1:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect)) AND (SELF.relating_shape_aspect\shape_aspect.description IN [ 'assembly module component terminal',
 'bare die component terminal',
 'interconnect component join terminal',
 'interconnect module component terminal',
 'package terminal occurrence',
 'packaged component join terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN TYPEOF(SELF.relating_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
      WR2:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description IN [ 'assembly module component terminal',
 'bare die component terminal',
 'interconnect component join terminal',
 'interconnect module component terminal',
 'package terminal occurrence',
 'packaged component join terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN TYPEOF(SELF.relating_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(SELF.related_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
      WR3:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with bonding') OR (SIZEOF(QUERY (ddu <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'default definition usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect)))) = 1);
      WR4:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with bonding') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'bond assembly position') AND (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'assembly position'))) = 1))) = 1))) <= 1);
      WR5:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with fasteners') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
      WR6:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) OR is_assembly_module_design(SELF.of_shape.definition);
      WR7:
         NOT (SELF\shape_aspect_relationship.name = 'assembled with bonding') OR (SIZEOF(QUERY (ddu <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'default definition usage'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect)) AND (SIZEOF(QUERY (sar <* USEDIN(ddu.relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 1'))) = 1)) AND (SIZEOF(QUERY (sar <* USEDIN(ddu.relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'bonded feature 1'))) = 1))) = 1);
      WR8:
         acyclic_shape_aspect_relationship(SELF,
 [ SELF\shape_aspect_relationship.related_shape_aspect ],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT');
   END_ENTITY;



   ENTITY assembly_module_interface_terminal
   SUBTYPE OF (assembly_module_terminal);
   END_ENTITY;



   ENTITY assembly_module_join_terminal
   SUBTYPE OF (assembly_module_terminal);
   END_ENTITY;



   ENTITY assembly_module_macro_component_join_terminal
   SUBTYPE OF (component_terminal);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'bare die component terminal',
 'component termination passage join terminal',
 'conductive interconnect element terminal',
 'interconnect component join terminal',
 'interconnect module component terminal',
 'land join terminal',
 'minimally defined component terminal',
 'non functional land join terminal',
 'packaged component join terminal',
 'printed component join terminal',
 'package terminal occurrence',
 'via terminal' ]);
   END_ENTITY;



   ENTITY assembly_module_terminal
   SUPERTYPE OF (ONEOF(assembly_module_interface_terminal,
 assembly_module_join_terminal))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR (SELF.of_shape.definition\product_definition.name = 'assembly module');
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR4:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR5:
         NOT (SELF\shape_aspect.description = 'pca terminal') OR (SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION') ]) >= 1) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design usage');
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
      WR7:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'interface terminal'))) <= 1;
   END_ENTITY;



   ENTITY assembly_module_usage_view_connector_relationship
   SUBTYPE OF (mapped_item);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(SELF\mapped_item.mapping_target);
      WR2:
         SELF\mapped_item.mapping_source.mapped_representation\representation.name = '3d bound volume shape';
      WR3:
         SIZEOF(QUERY (pdr <* USEDIN(SELF\mapped_item.mapping_source.mapped_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_CONNECTOR'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_CONNECTOR') ] * TYPEOF(pdr.definition.definition)) = 1))) = 1;
      WR4:
         SIZEOF(QUERY (r <* USEDIN(SELF\representation_item,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (SIZEOF(QUERY (pdr <* USEDIN(r,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.frame_of_reference\application_context_element.name = 'physical design usage')) AND (pdr.definition.definition\product_definition.name = 'assembly module'))) = 1))) = 1;
   END_ENTITY;



   ENTITY auxiliary_characteristic_dimension_representation
   SUBTYPE OF (dimensional_characteristic_representation);
   END_ENTITY;



   ENTITY axis1_placement
   SUBTYPE OF (placement);
      axis : OPTIONAL direction;
   DERIVE
      z : direction := NVL(normalise(axis),
 dummy_gri || direction([ 0.00000,
 0.00000,
 1.00000 ]));
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
   DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
      axis : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
   DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,
 ref_direction);
   WHERE
      WR1:
         SELF\placement.location.dim = 3;
      WR2:
         NOT EXISTS(axis) OR (axis.dim = 3);
      WR3:
         NOT EXISTS(ref_direction) OR (ref_direction.dim = 3);
      WR4:
         (NOT EXISTS(axis) OR NOT EXISTS(ref_direction)) OR (cross_product(axis,
 ref_direction).magnitude > 0.00000);
   END_ENTITY;



   ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF(uniform_curve,
 b_spline_curve_with_knots,
 quasi_uniform_curve,
 bezier_curve) ANDOR
 rational_b_spline_curve)
   SUBTYPE OF (bounded_curve);
      degree : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form : b_spline_curve_form;
      closed_curve : LOGICAL;
      self_intersect : LOGICAL;
   DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(control_points_list) - 1;
      control_points : ARRAY [0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,
 0,
 upper_index_on_control_points);
   WHERE
      WR1:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BEZIER_CURVE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots : LIST [2:?] OF parameter_value;
      knot_spec : knot_type;
   DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
   WHERE
      WR1:
         constraints_param_b_spline(degree,
 upper_index_on_knots,
 upper_index_on_control_points,
 knot_multiplicities,
 knots);
      WR2:
         SIZEOF(knot_multiplicities) = upper_index_on_knots;
   END_ENTITY;



   ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF(b_spline_surface_with_knots,
 uniform_surface,
 quasi_uniform_surface,
 bezier_surface) ANDOR
 rational_b_spline_surface)
   SUBTYPE OF (bounded_surface);
      u_degree : INTEGER;
      v_degree : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form : b_spline_surface_form;
      u_closed : LOGICAL;
      v_closed : LOGICAL;
      self_intersect : LOGICAL;
   DERIVE
      u_upper : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF cartesian_point := make_array_of_array(control_points_list,
 0,
 u_upper,
 0,
 v_upper);
   WHERE
      WR1:
         ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots : LIST [2:?] OF parameter_value;
      v_knots : LIST [2:?] OF parameter_value;
      knot_spec : knot_type;
   DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
   WHERE
      WR1:
         constraints_param_b_spline(SELF\b_spline_surface.u_degree,
 knot_u_upper,
 SELF\b_spline_surface.u_upper,
 u_multiplicities,
 u_knots);
      WR2:
         constraints_param_b_spline(SELF\b_spline_surface.v_degree,
 knot_v_upper,
 SELF\b_spline_surface.v_upper,
 v_multiplicities,
 v_knots);
      WR3:
         SIZEOF(u_multiplicities) = knot_u_upper;
      WR4:
         SIZEOF(v_multiplicities) = knot_v_upper;
   END_ENTITY;



   ENTITY bare_die
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (ifdu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\property_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition)) AND (ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'device unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0;
   END_ENTITY;



   ENTITY bare_die_bottom_surface
   SUBTYPE OF (bare_die_surface);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\bare_die_bottom_surface || SELF\part_mounting_feature || SELF\bare_die_surface)) = 0;
   END_ENTITY;



   ENTITY bare_die_edge_segment_surface
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect)))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\bare_die_edge_segment_surface)) = 0;
   END_ENTITY;



   ENTITY bare_die_edge_surface
   SUBTYPE OF (bare_die_surface);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\part_mounting_feature || SELF\bare_die_edge_surface || SELF\bare_die_surface)) = 0;
   END_ENTITY;



   ENTITY bare_die_surface
   ABSTRACT SUPERTYPE OF (ONEOF(bare_die_bottom_surface,
 bare_die_top_surface,
 bare_die_edge_surface))
   SUBTYPE OF (part_mounting_feature);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
   END_ENTITY;



   ENTITY bare_die_terminal
   SUBTYPE OF (minimally_defined_bare_die_terminal);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'external connection area'))| (eca.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
      WR4:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'seating plane zone'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY bare_die_top_surface
   SUBTYPE OF (bare_die_surface);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\part_mounting_feature || SELF\bare_die_top_surface || SELF\bare_die_surface)) = 0;
   END_ENTITY;



   ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY block
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x : positive_length_measure;
      y : positive_length_measure;
      z : positive_length_measure;
   END_ENTITY;



   ENTITY bond_category
   SUBTYPE OF (group,
 external_definition);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY boolean_result
   SUBTYPE OF (geometric_representation_item);
      operator : boolean_operator;
      first_operand : boolean_operand;
      second_operand : boolean_operand;
   END_ENTITY;



   ENTITY boundary_curve
   SUBTYPE OF (composite_curve_on_surface);
   WHERE
      WR1:
         SELF\composite_curve.closed_curve;
   END_ENTITY;



   ENTITY bounded_curve
   SUPERTYPE OF (ONEOF(polyline,
 b_spline_curve,
 trimmed_curve,
 bounded_pcurve,
 bounded_surface_curve,
 composite_curve))
   SUBTYPE OF (curve);
   END_ENTITY;



   ENTITY bounded_pcurve
   SUBTYPE OF (pcurve,
 bounded_curve);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]);
   END_ENTITY;



   ENTITY bounded_surface
   SUPERTYPE OF (ONEOF(b_spline_surface,
 rectangular_trimmed_surface,
 curve_bounded_surface,
 rectangular_composite_surface))
   SUBTYPE OF (surface);
   END_ENTITY;



   ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve,
 bounded_curve);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d);
   END_ENTITY;



   ENTITY box_domain;
      corner : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      zlength : positive_length_measure;
   WHERE
      WR1:
         SIZEOF(QUERY (item <* USEDIN(SELF,
 '')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0;
   END_ENTITY;



   ENTITY boxed_half_space
   SUBTYPE OF (half_space_solid);
      enclosure : box_domain;
   END_ENTITY;



   ENTITY brep_with_voids
   SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
   END_ENTITY;



   ENTITY bus_element_link
   SUBTYPE OF (product_definition,
 product_definition_relationship);
   UNIQUE
      UR1 : SELF\product_definition_relationship.related_product_definition,
 SELF\product_definition_relationship.relating_product_definition;
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition));
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition));
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\bus_element_link)) = 0;
      WR5:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = '');
      WR6:
         SELF\product_definition_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) >= 1;
   END_ENTITY;



   ENTITY bus_structural_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (bce <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'bus composition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_ELEMENT_LINK' IN TYPEOF(bce.related_product_definition)))) >= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment'))) <= 1))) <= 1;
      WR3:
         consistent_bus_structural_definition(bag_to_set(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_ELEMENT_LINK' IN TYPEOF(pdr.related_product_definition))));
   END_ENTITY;



   ENTITY cable_component
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1;
      WR2:
         SELF\product_definition.description :<>: 'laminate component';
   END_ENTITY;



   ENTITY calendar_date
   SUBTYPE OF (date);
      day_component : day_in_month_number;
      month_component : month_in_year_number;
   WHERE
      WR1:
         valid_calendar_date(SELF);
   END_ENTITY;



   ENTITY capacitance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\capacitance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = farad;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY cartesian_point
   SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
   END_ENTITY;



   ENTITY cartesian_transformation_operator
   SUPERTYPE OF (ONEOF(cartesian_transformation_operator_2d,
 cartesian_transformation_operator_3d))
   SUBTYPE OF (geometric_representation_item,
 functionally_defined_transformation);
      axis1 : OPTIONAL direction;
      axis2 : OPTIONAL direction;
      local_origin : cartesian_point;
      scale : OPTIONAL REAL;
   DERIVE
      scl : REAL := NVL(scale,
 1.00000);
   WHERE
      WR1:
         scl > 0.00000;
   END_ENTITY;



   ENTITY cartesian_transformation_operator_2d
   SUBTYPE OF (cartesian_transformation_operator);
   DERIVE
      u : LIST [2:2] OF direction := base_axis(2,
 SELF\cartesian_transformation_operator.axis1,
 SELF\cartesian_transformation_operator.axis2,
 ?);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
   DERIVE
      u : LIST [3:3] OF direction := base_axis(3,
 SELF\cartesian_transformation_operator.axis1,
 SELF\cartesian_transformation_operator.axis2,
 axis3);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY celsius_temperature_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY centre_of_symmetry
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sadr <* deriving_relationships| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMMETRIC_SHAPE_ASPECT' IN TYPEOF(sadr.related_shape_aspect)))) = 0;
   END_ENTITY;



   ENTITY certification;
      name : label;
      purpose : text;
      kind : certification_type;
   END_ENTITY;



   ENTITY certification_assignment
   ABSTRACT SUPERTYPE;
      assigned_certification : certification;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY certification_type;
      description : label;
   END_ENTITY;



   ENTITY change
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIRECTED_ACTION' IN TYPEOF(SELF.assigned_action);
      WR2:
         unique_version_change_order(SELF.assigned_action,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN');
   END_ENTITY;



   ENTITY change_from_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_assignment.assigned_action,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_TO_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
   END_ENTITY;



   ENTITY change_from_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_request_assignment.assigned_action_request,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_TO_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
   END_ENTITY;



   ENTITY change_request
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF change_request_item;
   END_ENTITY;



   ENTITY change_to_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_assignment.assigned_action,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_FROM_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
      WR2:
         SIZEOF(QUERY (pdr <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'design object change'))) = 1;
   END_ENTITY;



   ENTITY change_to_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (aa <* USEDIN(SELF\action_request_assignment.assigned_action_request,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_FROM_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))) >= 1;
      WR2:
         SIZEOF(QUERY (pdr <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'design object change'))) = 1;
   END_ENTITY;



   ENTITY character_glyph_font_usage;
      character : character_glyph_symbol;
      font : text_font;
   END_ENTITY;



   ENTITY character_glyph_style_outline;
      outline_style : curve_style;
   END_ENTITY;



   ENTITY character_glyph_style_stroke;
      stroke_style : curve_style;
   END_ENTITY;



   ENTITY character_glyph_symbol
   SUBTYPE OF (symbol_representation);
      character_box : planar_extent;
      baseline_ratio : ratio_measure;
   DERIVE
      box_height : length_measure := character_box.size_in_y;
   WHERE
      WR1:
         (0.00000 <= baseline_ratio) AND (baseline_ratio <= 1.00000);
      WR2:
         item_in_context(SELF.character_box,
 SELF\representation.context_of_items);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(SELF.box_height);
   END_ENTITY;



   ENTITY character_glyph_symbol_outline
   SUBTYPE OF (character_glyph_symbol);
      outlines : SET [1:?] OF annotation_fill_area;
   WHERE
      WR1:
         SELF.outlines <= SELF\representation.items;
   END_ENTITY;



   ENTITY characteristic_type
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'string property',
 'logical property',
 'boolean property',
 'numeric property',
 'externally defined property',
 'compound characteristic' ];
   END_ENTITY;



   ENTITY characterized_object;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY characterized_product_category
   SUBTYPE OF (characterized_object,
 product_category);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'product category values') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) <= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'product category parameters') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (ri <* pdr.used_representation.items| NOT (SIZEOF(TYPEOF(ri) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER') ]) = 1))) = 0))) >= 1))) <= 1;
      WR3:
         SELF\characterized_object.name = SELF\product_category.name;
      WR4:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY circle
   SUBTYPE OF (conic);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY circular_area
   SUBTYPE OF (primitive_2d);
      centre : cartesian_point;
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY circular_runout_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'circular runout';
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR3:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'referenced datum system definition') AND (pdr.related_property_definition\property_definition.description = 'datum system property without material conditions'))) = 1;
   END_ENTITY;



   ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
   END_ENTITY;



   ENTITY colour;
   END_ENTITY;



   ENTITY colour_rgb
   SUBTYPE OF (colour_specification);
      red : REAL;
      green : REAL;
      blue : REAL;
   WHERE
      WR1:
         (0.00000 <= red) AND (red <= 1.00000);
      WR2:
         (0.00000 <= green) AND (green <= 1.00000);
      WR3:
         (0.00000 <= blue) AND (blue <= 1.00000);
   END_ENTITY;



   ENTITY colour_specification
   SUBTYPE OF (colour);
      name : label;
   END_ENTITY;



   ENTITY component_definition
   SUPERTYPE OF ((ONEOF(printed_component,
 packaged_component,
 routed_physical_component) ANDOR
 thermal_component) ANDOR
 cable_component)
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR3:
         NOT (SELF\product_definition.description = 'bare die component') OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1);
      WR4:
         NOT is_assembly_module_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (ip.relating_product_definition\product_definition.name = 'assembly module'))) = 1);
      WR5:
         NOT is_assembly_module_occurrence(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'assembly module component terminal'))) >= 2))) >= 1);
      WR6:
         NOT is_interconnect_module_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (SELF\product_definition.name = 'interconnect module'))) = 1);
      WR7:
         NOT (SELF\product_definition.description = 'mating connector') OR ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) AND (SIZEOF(QUERY (doc <* SELF\product_definition_with_associated_documents.documentation_ids| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(doc)))) = 1) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'part template occurrence'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'printed connector template'))) = 1))) = 1))) = 0)) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition\product_definition.description = 'packaged connector'))) = 1));
      WR8:
         NOT (SELF\product_definition.description = 'mating connector') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'mating connector placement'))) = 1))) = 1);
      WR9:
         NOT (SELF\product_definition.description = 'mating connector') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr)))) = 0) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr)))) = 0);
      WR10:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| NOT (NOT (pdr\product_definition_relationship.name = 'instantiated part') OR (SELF.formation :=: pdr.relating_product_definition.formation)))) = 0;
      WR11:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| ((sr_pdr.used_representation\representation.name = 'part template non planar 2d shape') OR (sr_pdr.used_representation\representation.name = 'non planar 2d shape')) OR (sr_pdr.used_representation\representation.name = 'open shell based surface'))) <= 1))) = 0;
      WR12:
         NOT (SELF.frame_of_reference.name = 'layout occurrence') OR ((SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF)));
      WR13:
         NOT ((SELF.frame_of_reference.name = 'layout occurrence') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_COMPONENT' IN TYPEOF(SELF))) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(sa)) >= 1))) = 1))) = 0);
      WR14:
         NOT is_assembly_module_macro_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design definition'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design')) AND (ip.relating_product_definition\product_definition.name = 'assembly module'))) = 1);
      WR15:
         NOT is_interconnect_module_macro_occurrence(SELF) OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design definition'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition)) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design')) AND (ip.relating_product_definition\product_definition.name = 'interconnect module'))) = 1);
      WR16:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated definition') AND NOT (SELF.formation :=: pdr.relating_product_definition.formation))) = 0;
      WR17:
         NOT (SELF\product_definition.description = 'routed interconnect component') OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1) AND (SELF.frame_of_reference.name = 'physical occurrence');
   END_ENTITY;



   ENTITY component_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
   END_ENTITY;



   ENTITY component_feature_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\component_feature_relationship)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
   END_ENTITY;



   ENTITY component_functional_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(it.relating_shape_aspect)))) = 1;
      WR3:
         SIZEOF(QUERY (futba <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit terminal bus assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(futba.relating_property_definition.definition)))) <= 1;
      WR4:
         SIZEOF(QUERY (futna <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit terminal node assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(futna.relating_property_definition.definition)))) <= 1;
   END_ENTITY;



   ENTITY component_functional_unit
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'functional occurrence';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL' IN TYPEOF(sa)))) >= 1))) >= 1;
      WR3:
         SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated functional unit'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)))) = 1;
      WR4:
         SIZEOF(QUERY (nc <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'network composition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(nc.relating_product_definition)) AND (nc.relating_product_definition.frame_of_reference.name = 'functional network design'))) = 1;
   END_ENTITY;



   ENTITY component_interface_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interconnect component interface terminal',
 'packaged connector component interface terminal' ];
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design usage'))) <= 1;
      WR5:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
      WR6:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence');
      WR7:
         NOT (SELF\shape_aspect.description = 'interconnect component interface terminal') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1) AND NOT (SELF.of_shape.definition\product_definition.description IN [ 'assembly module component',
 'bare die component',
 'interconnect module component',
 'laminate component',
 'packaged component' ]);
      WR8:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR SELF.product_definitional;
      WR9:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'packaged connector component')) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence');
      WR10:
         NOT (SELF\shape_aspect.description = 'packaged connector component interface terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'interface terminal'))) = 1);
   END_ENTITY;



   ENTITY component_location
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'placement fixed')) AND ((it\descriptive_representation_item.description = 'true') OR (it\descriptive_representation_item.description = 'false')))) = 1;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 1;
      WR3:
         NOT (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(it)))) = 1);
      WR4:
         NOT (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3) OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) = 1);
      WR5:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)))) = 1;
      WR6:
         NOT (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(it)))) = 1) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND (SIZEOF(QUERY (mi <* USEDIN(cto2d,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM.MAPPING_TARGET')| (SIZEOF(QUERY (cl <* USEDIN(mi,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (cl = SELF))) = 1))) >= 1))) = 1);
      WR7:
         NOT (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) = 1) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(cto2d)) AND (SIZEOF(QUERY (mi <* USEDIN(cto2d,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM.MAPPING_TARGET')| (SIZEOF(QUERY (cl <* USEDIN(mi,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (cl = SELF))) = 1))) = 1))) = 1);
      WR8:
         NOT (((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component surface')) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'mounting surface assembly joint')) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar.relating_shape_aspect\shape_aspect.description = 'interconnect module primary surface') OR (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge surface')) OR (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge segment surface'))) = 1))) = 1)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,
 1.00000,
 0.00100000))) = 1);
      WR9:
         NOT (((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component surface')) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'mounting surface assembly joint')) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module secondary surface'))) = 1))) = 1)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,
 -1.00000,
 0.00100000))) = 1);
      WR10:
         NOT is_laminate_component_location(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 0);
      WR11:
         NOT (is_laminate_component_location(SELF) AND (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND cto2d_determinant_test(cto2d,
 1.00000,
 0.00100000))) = 1);
      WR12:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition\shape_aspect.description = 'interconnect module component surface feature'))) = 0;
      WR13:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component stacked')) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 0);
      WR14:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component edge')) OR (NOT is_laminate_component_location(SELF) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'reference terminal assembly joint')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(pdr.definition.definition.related_shape_aspect))) AND (pdr.definition.definition.related_shape_aspect\shape_aspect.description IN [ 'packaged component join terminal',
 'package terminal occurrence' ])) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.related_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sar.relating_shape_aspect)))) = 1)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))) AND (component_definition_located_by_component_location(SELF) = pdr.definition.definition.related_shape_aspect.of_shape.definition))) = 1)) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.name = 'mounting surface assembly joint')) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(pdr.definition.definition.relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge surface') OR (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module edge segment surface'))) = 1)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(pdr.definition.definition.related_shape_aspect))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))) AND (component_definition_located_by_component_location(SELF) = pdr.definition.definition.related_shape_aspect.of_shape.definition))) = 1);
      WR15:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component stacked')) OR NOT is_laminate_component_location(SELF) AND (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ((((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND ('mounting joint' = pdr.name)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(pdr.definition.definition.related_shape_aspect))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))) AND (component_definition_located_by_component_location(SELF) :=: pdr.definition.definition.related_shape_aspect.of_shape.definition)) AND (component_definition_located_by_component_location(SELF) :<>: pdr.definition.definition.relating_shape_aspect.of_shape.definition))) = 1);
      WR16:
         NOT is_interconnect_module_component_location(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.relating_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 0);
      WR17:
         NOT ((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2) AND (SELF.context_of_items.context_type = 'component stacked')) OR (SIZEOF(QUERY (cto2d <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d)) AND (cto2d_determinant_test(cto2d,
 1.00000,
 0.00100000) OR cto2d_determinant_test(cto2d,
 -1.00000,
 0.00100000)))) = 1);
      WR18:
         SIZEOF(QUERY (it <* SELF\representation.items| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D') ] * TYPEOF(it)) = 1))) = 0;
      WR19:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)) AND (it\representation_item.name = 'origin'))) = 0;
      WR20:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)) AND NOT ((((it\representation_item.name = 'component assembly 2d position') OR (it\representation_item.name = 'component assembly 3d position')) AND (it.mapping_source.mapping_origin\representation_item.name = 'origin')) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(it.mapping_source.mapping_origin)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it.mapping_source.mapping_origin)))))) = 0;
      WR21:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr.definition.definition)))) = 1;
   END_ENTITY;



   ENTITY component_mating_constraint_condition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,
 SELF\shape_aspect.of_shape;
   END_ENTITY;



   ENTITY component_mounting_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND') ] * TYPEOF(SELF)) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR5:
         NOT (SELF\shape_aspect.description IN [ 'component feature' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design usage'))) <= 1);
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
   END_ENTITY;



   ENTITY component_shape_aspect
   SUPERTYPE OF (ONEOF(land,
 connected_area_component,
 inter_stratum_feature) ANDOR
 thermal_component_shape_aspect)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FIDUCIAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTED_AREA_COMPONENT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'THERMAL_COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTEGRAL_SHIELD'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND') ] * TYPEOF(SELF)) >= 1) OR (SELF\shape_aspect.description IN [ 'part template occurrence',
 'laminate component',
 'laminate text component',
 'laminate text string component',
 'conductive interconnect element with pre defined transitions',
 'join 2 physical connectivity definition supporting',
 'conductive interconnect element with user defined single transition',
 'special symbol laminate component',
 'primary stratum indicator symbol',
 'stratum feature template component' ]);
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR5:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'laminate text component',
 'laminate text string component',
 'special symbol laminate component',
 'primary stratum indicator symbol',
 'stratum feature template component' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'laminate component'));
      WR6:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'laminate text component') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEXT_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)))) = 1));
      WR7:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'stratum feature template component' ]) OR (SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) = 1));
      WR8:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'conductive interconnect element with pre defined transitions',
 'join 2 physical connectivity definition supporting',
 'conductive interconnect element with ' + 'user defined single transition' ]) OR (SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed conductor'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(cc.related_shape_aspect)))) = 1));
      WR10:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'special symbol laminate component',
 'primary stratum indicator symbol' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.related_shape_aspect\shape_aspect.description = 'special symbol part template'))) = 1));
      WR11:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'stratum feature template component') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'stratum feature template') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) <= 1));
      WR12:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'laminate text component' ]) OR (SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) >= 1));
      WR13:
         NOT ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FIDUCIAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTED_AREA_COMPONENT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'THERMAL_COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTEGRAL_SHIELD'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND') ] * TYPEOF(SELF)) >= 1) OR (SELF\shape_aspect.description IN [ 'laminate component',
 'laminate text component',
 'laminate text string component',
 'conductive interconnect element with pre defined transitions',
 'join 2 physical connectivity definition supporting',
 'conductive interconnect element with user defined single transition',
 'special symbol laminate component',
 'primary stratum indicator symbol',
 'stratum feature template component' ])) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference\application_context_element.name = 'layout occurrence');
      WR14:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))) <= 1;
      WR15:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'join 2 physical connectivity definition supporting') OR (SIZEOF(QUERY (propd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (ri <* QUERY (propdr <* USEDIN(propd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (propdr\property_definition_relationship.name = 'requirement implementation'))| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(ri.relating_property_definition.definition)) AND (ri.relating_property_definition.definition\shape_aspect_relationship.name = 'ordered physical connectivity definition')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(ri.relating_property_definition.definition.related_shape_aspect))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(ri.relating_property_definition.definition.relating_shape_aspect)))) = 1))) = 1));
   END_ENTITY;



   ENTITY component_terminal
   SUPERTYPE OF (ONEOF(assembly_module_macro_component_join_terminal,
 interconnect_module_macro_component_join_terminal))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         ((SELF\shape_aspect.description IN [ 'assembly module component terminal',
 'bare die component terminal',
 'component termination passage join terminal',
 'conductive interconnect element terminal',
 'interconnect component join terminal',
 'interconnect module component terminal',
 'land join terminal',
 'minimally defined component terminal',
 'non functional land join terminal',
 'packaged component join terminal',
 'printed component join terminal',
 'package terminal occurrence',
 'via terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN TYPEOF(SELF));
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) <= 1;
      WR4:
         SIZEOF(QUERY (at <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(at.relating_shape_aspect)))) <= 1;
      WR5:
         SIZEOF(QUERY (cr <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connectivity requirement'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK' IN TYPEOF(cr.relating_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design usage'))) <= 1;
      WR7:
         NOT (SELF\shape_aspect.description IN [ 'assembly module component terminal',
 'bare die component terminal',
 'package terminal occurrence',
 'packaged component join terminal',
 'printed component join terminal' ]) OR SELF.product_definitional;
      WR8:
         NOT (SELF\shape_aspect.description = 'assembly module component terminal') OR ((SELF.of_shape.definition.frame_of_reference.name = 'physical occurrence') AND EXISTS(SELF.of_shape.definition\product_definition.name)) AND (NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR (SELF.of_shape.definition\product_definition.name = 'assembly module'));
      WR9:
         NOT (SELF\shape_aspect.description = 'assembly module component terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))) = 1);
      WR10:
         NOT (SELF\shape_aspect.description = 'bare die component terminal') OR (SELF.of_shape.definition\product_definition.description = 'bare die component');
      WR11:
         NOT (SELF\shape_aspect.description = 'bare die component terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description = 'component termination passage join terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description = 'component termination passage template join terminal'))) = 1);
      WR15:
         NOT (SELF\shape_aspect.description IN [ 'conductive interconnect element terminal',
 'interconnect component join terminal',
 'printed component join terminal' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1);
      WR16:
         NOT (SELF\shape_aspect.description = 'interconnect module component terminal') OR ((SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence') AND EXISTS(SELF.of_shape.definition\product_definition.name)) AND (NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR (SELF.of_shape.definition\product_definition.name = 'interconnect module'));
      WR17:
         NOT (SELF\shape_aspect.description = 'interconnect module component terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))) = 1);
      WR18:
         NOT (SELF\shape_aspect.description IN [ 'land join terminal',
 'non functional land join terminal' ]) OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND TRUE)) = 1);
      WR20:
         NOT (SELF\shape_aspect.description = 'minimally defined terminal') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'part terminal external reference'))) = 1);
      WR22:
         NOT (SELF\shape_aspect.description = 'package terminal occurrence') OR (SIZEOF(QUERY (ud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'usage definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(ud.relating_shape_aspect)))) = 1);
      WR23:
         NOT (SELF\shape_aspect.description IN [ 'package terminal occurrence',
 'packaged component join terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence');
      WR24:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'join terminal'))) = 1);
      WR25:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) <= 2))) <= 1))) <= 1);
      WR26:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'maximum wire length'))) <= 1))) <= 1))) <= 1);
      WR27:
         NOT (SELF\shape_aspect.description = 'packaged component join terminal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'minimum wire length'))) <= 1))) <= 1))) <= 1);
      WR28:
         NOT (SELF\shape_aspect.description = 'printed component join terminal') OR (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'layout occurrence') AND (SELF.of_shape.definition\product_definition.name = 'interconnect module');
      WR29:
         NOT (SELF\shape_aspect.description = 'printed component join terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'join terminal'))) = 1);
      WR30:
         NOT (SELF\shape_aspect.description = 'printed component join terminal') OR (SIZEOF(QUERY (i <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (pdr\shape_aspect_relationship.name = 'implementation'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(i.relating_shape_aspect)) >= 1) AND (i.relating_shape_aspect\shape_aspect.description = 'stratum feature template component'))) = 1);
      WR32:
         NOT (SELF\shape_aspect.description = 'via terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description = 'via template terminal'))) = 1);
      WR33:
         NOT (SELF\shape_aspect.description = 'interconnect component join terminal') OR (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical occurrence') AND NOT (SELF.of_shape.definition\product_definition.description IN [ 'assembly module component',
 'bare die component',
 'interconnect module component',
 'laminate component',
 'packaged component' ]);
      WR34:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (dri <* pdr.used_representation.items| (dri\representation_item.name = 'global swappable') AND (dri\descriptive_representation_item.description IN [ 'true',
 'false' ]))) = 1))) = 1))) <= 1;
      WR35:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (dri <* pdr.used_representation.items| (dri\representation_item.name = 'local swappable') AND (dri\descriptive_representation_item.description IN [ 'true',
 'false' ]))) = 1))) = 1))) <= 1;
      WR36:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (dri <* pdr.used_representation.items| (dri\representation_item.name = 'swap code'))) = 1))) = 1))) <= 1;
   END_ENTITY;



   ENTITY composite_array_shape_aspect
   SUPERTYPE OF (ONEOF(linear_composite_array_shape_aspect,
 rectangular_composite_array_shape_aspect))
   SUBTYPE OF (composite_shape_aspect);
   END_ENTITY;



   ENTITY composite_array_shape_aspect_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\composite_array_shape_aspect_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
      segments : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
   DERIVE
      n_segments : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
   WHERE
      WR1:
         NOT closed_curve AND (SIZEOF(QUERY (temp <* segments| (temp.transition = discontinuous))) = 1) OR closed_curve AND (SIZEOF(QUERY (temp <* segments| (temp.transition = discontinuous))) = 0);
   END_ENTITY;



   ENTITY composite_curve_on_surface
   SUPERTYPE OF (boundary_curve)
   SUBTYPE OF (composite_curve);
   DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
   WHERE
      WR1:
         SIZEOF(basis_surface) > 0;
      WR2:
         constraints_composite_curve_on_surface(SELF);
   END_ENTITY;



   ENTITY composite_curve_segment
   SUBTYPE OF (founded_item);
      transition : transition_code;
      same_sense : BOOLEAN;
      parent_curve : curve;
   INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE' IN TYPEOF(parent_curve);
   END_ENTITY;



   ENTITY composite_group_shape_aspect
   SUBTYPE OF (composite_shape_aspect);
   END_ENTITY;



   ENTITY composite_shape_aspect
   SUBTYPE OF (shape_aspect);
   INVERSE
      component_relationships : SET [2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
   END_ENTITY;



   ENTITY composite_signal_property_relationship
   SUBTYPE OF (property_definition,
 property_definition_relationship);
   WHERE
      WR1:
         SELF\property_definition_relationship.related_property_definition.definition :<>: SELF\property_definition_relationship.relating_property_definition.definition;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship || SELF\composite_signal_property_relationship || SELF\property_definition)) = 0;
      WR3:
         SELF\property_definition_relationship.related_property_definition.name = 'signal property';
      WR4:
         SELF\property_definition_relationship.relating_property_definition.name = 'composite signal property';
      WR5:
         SELF\property_definition.name = '';
      WR6:
         SELF\property_definition.description = '';
      WR7:
         SELF\property_definition_relationship.name = '';
      WR8:
         SELF\property_definition_relationship.description = '';
      WR9:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) AND (SELF\property_definition.definition.description = 'aggregate operation');
      WR10:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNAL_DEFINITION' IN TYPEOF(SELF\property_definition.definition);
   END_ENTITY;



   ENTITY composite_unit_shape_aspect
   SUBTYPE OF (composite_shape_aspect);
   END_ENTITY;



   ENTITY compound_representation_item
   SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
   END_ENTITY;



   ENTITY concentricity_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'concentricity';
   END_ENTITY;



   ENTITY conductance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\conductance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = siemens;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY conductive_interconnect_element_terminal_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\conductive_interconnect_element_terminal_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
      WR8:
         SELF\shape_aspect_relationship.related_shape_aspect.description = 'conductive interconnect element terminal';
      WR9:
         SELF\shape_aspect_relationship.relating_shape_aspect.description = 'conductive interconnect element terminal';
      WR10:
         SELF\shape_aspect.of_shape.definition\product_definition.description = 'laminate component';
   END_ENTITY;



   ENTITY configuration_design;
      configuration : configuration_item;
      design : configuration_design_item;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   UNIQUE
      UR1 : configuration,
 design;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY configuration_effectivity
   SUBTYPE OF (product_definition_effectivity);
      configuration : configuration_design;
   UNIQUE
      UR1 : configuration,
 usage,
 id;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF\product_definition_effectivity.usage);
   END_ENTITY;



   ENTITY configuration_item;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      item_concept : product_concept;
      purpose : OPTIONAL label;
   END_ENTITY;



   ENTITY conic
   SUPERTYPE OF (ONEOF(circle,
 ellipse,
 hyperbola,
 parabola))
   SUBTYPE OF (curve);
      position : axis2_placement;
   END_ENTITY;



   ENTITY conical_surface
   SUBTYPE OF (elementary_surface);
      radius : length_measure;
      semi_angle : plane_angle_measure;
   WHERE
      WR1:
         radius >= 0.00000;
   END_ENTITY;



   ENTITY connected_area_component
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SIZEOF(QUERY (prpc <* USEDIN(SELF.of_shape.definition.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1);
      WR2:
         SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) = 1;
      WR3:
         SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated layer connection point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sfi.relating_shape_aspect)))) >= 1;
      WR4:
         SELF\shape_aspect.description = 'stratum feature template component';
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\component_shape_aspect || SELF\connected_area_component)) = 0;
   END_ENTITY;



   ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
   END_ENTITY;



   ENTITY connected_face_set
   SUPERTYPE OF (ONEOF(closed_shell,
 open_shell))
   SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
   END_ENTITY;



   ENTITY connected_face_sub_set
   SUBTYPE OF (connected_face_set);
      parent_face_set : connected_face_set;
   END_ENTITY;



   ENTITY connection_zone_based_assembly_joint
   SUBTYPE OF (assembly_joint);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 1'))) = 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 2'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'connection zone'))) = 2;
   END_ENTITY;



   ENTITY connection_zone_based_fabrication_joint
   SUBTYPE OF (fabrication_joint);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 1'))) = 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'zone 2'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar.relating_shape_aspect\shape_aspect.description = 'connection zone'))) = 2;
   END_ENTITY;



   ENTITY connection_zone_interface_plane_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.name;
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship || SELF\connection_zone_interface_plane_relationship || SELF\shape_aspect)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'plane';
      WR4:
         SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'connection zone';
      WR5:
         SELF\shape_aspect_relationship.description IN [ 'area',
 'edge' ];
      WR6:
         SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
      WR7:
         SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
      WR8:
         SIZEOF(QUERY (dz <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'derived zone'))| (dz.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY connection_zone_map_identification
   SUBTYPE OF (shape_aspect,
 representation_relationship);
   WHERE
      WR1:
         SELF\representation_relationship.rep_2 :<>: SELF\representation_relationship.rep_1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF\representation_relationship.rep_1);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF\representation_relationship.rep_2);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\representation_relationship || SELF\connection_zone_map_identification)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\representation_relationship.name = '';
      WR7:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FOOTPRINT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
   END_ENTITY;



   ENTITY context_dependent_shape_representation;
      representation_relation : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition);
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY context_dependent_unit
   SUBTYPE OF (named_unit);
      name : label;
   END_ENTITY;



   ENTITY contract;
      name : label;
      purpose : text;
      kind : contract_type;
   END_ENTITY;



   ENTITY contract_assignment
   ABSTRACT SUPERTYPE;
      assigned_contract : contract;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY contract_type;
      description : label;
   END_ENTITY;



   ENTITY conversion_based_unit
   SUBTYPE OF (named_unit);
      name : label;
      conversion_factor : measure_with_unit;
   END_ENTITY;



   ENTITY coordinated_representation_item
   SUBTYPE OF (representation,
 representation_item);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (SIZEOF(USEDIN(pdr,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATA_ENVIRONMENT.ELEMENTS')) <= 1))) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
      WR3:
         NOT (SELF\representation_item.name = 'tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))) >= 1);
      WR4:
         NOT (SELF\representation_item.name = 'plus minus tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 3);
      WR5:
         NOT (SELF\representation_item.name = 'symmetrical tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 2);
      WR6:
         NOT (SELF\representation_item.name = 'plus minus tolerance') OR ((SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'basic value'))) = 1) AND (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'plus value'))) = 1)) AND (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'minus value'))) = 1);
      WR7:
         NOT (SELF\representation_item.name = 'symmetrical tolerance') OR (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'basic value'))) = 1) AND (SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'deviation value'))) = 1);
   END_ENTITY;



   ENTITY coordinated_universal_time_offset;
      hour_offset : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense : ahead_or_behind;
   DERIVE
      actual_minute_offset : INTEGER := NVL(minute_offset,
 0);
   WHERE
      WR1:
         (0 <= hour_offset) AND (hour_offset < 24);
      WR2:
         (0 <= actual_minute_offset) AND (actual_minute_offset <= 59);
      WR3:
         NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = exact));
   END_ENTITY;



   ENTITY csg_2d_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D' ] * TYPEOF(it)) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID' ] * TYPEOF(it)) = 1) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))) >= 1;
      WR4:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_representation || SELF\csg_2d_shape_representation || SELF\representation)) = 0;
   END_ENTITY;



   ENTITY csg_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REVOLVED_FACE_SOLID',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXTRUDED_FACE_SOLID' ] * TYPEOF(it)) <> 1))) = 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (sr <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA' IN TYPEOF(it)))| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REVOLVED_FACE_SOLID',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EXTRUDED_FACE_SOLID' ] * TYPEOF(sr\solid_replica.parent_solid)) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (it <* SELF.items| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(it)))) > 0;
   END_ENTITY;



   ENTITY csg_solid
   SUBTYPE OF (solid_model);
      tree_root_expression : csg_select;
   END_ENTITY;



   ENTITY curve
   SUPERTYPE OF (ONEOF(line,
 conic,
 pcurve,
 surface_curve,
 offset_curve_2d,
 offset_curve_3d,
 curve_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY curve_bounded_surface
   SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      boundaries : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
   WHERE
      WR1:
         NOT implicit_outer OR (SIZEOF(QUERY (temp <* boundaries| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))) = 0);
      WR2:
         NOT implicit_outer OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
      WR3:
         SIZEOF(QUERY (temp <* boundaries| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))) <= 1;
      WR4:
         SIZEOF(QUERY (temp <* boundaries| (temp\composite_curve_on_surface.basis_surface[1] <> SELF.basis_surface))) = 0;
   END_ENTITY;



   ENTITY curve_dimension
   SUBTYPE OF (dimensional_size);
   WHERE
      WR1:
         SELF\dimensional_size.name <> 'angular';
   END_ENTITY;



   ENTITY curve_replica
   SUBTYPE OF (curve);
      parent_curve : curve;
      transformation : cartesian_transformation_operator;
   WHERE
      WR1:
         transformation.dim = parent_curve.dim;
      WR2:
         acyclic_curve_replica(SELF,
 parent_curve);
   END_ENTITY;



   ENTITY curve_style;
      name : label;
      curve_font : curve_font_or_scaled_curve_font_select;
      curve_width : size_select;
      curve_colour : colour;
   END_ENTITY;



   ENTITY curve_style_font;
      name : label;
      pattern_list : LIST [1:?] OF curve_style_font_pattern;
   END_ENTITY;



   ENTITY curve_style_font_and_scaling;
      name : label;
      curve_font : curve_style_font_select;
      curve_font_scaling : REAL;
   END_ENTITY;



   ENTITY curve_style_font_pattern;
      visible_segment_length : positive_length_measure;
      invisible_segment_length : positive_length_measure;
   END_ENTITY;



   ENTITY curve_style_with_ends_and_corners
   SUBTYPE OF (curve_style);
      curve_ends : squared_or_rounded;
      curve_corners : squared_or_rounded;
   END_ENTITY;



   ENTITY curve_style_with_extension
   SUBTYPE OF (curve_style);
      curve_extensions : length_measure;
   END_ENTITY;



   ENTITY cutout_edge_segment
   SUPERTYPE OF (plated_cutout_edge_segment)
   SUBTYPE OF (inter_stratum_feature,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated cutout edge segment',
 'cutout edge segment' ];
      WR2:
         SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed cutout'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect)) AND (cc.relating_shape_aspect\shape_aspect.description IN [ 'cutout',
 'physical connectivity interrupting cutout',
 'plated cutout' ]))) = 1;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR5:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
   END_ENTITY;



   ENTITY cyclide_segment_solid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      radius1 : positive_length_measure;
      radius2 : positive_length_measure;
      cone_angle1 : plane_angle_measure;
      cone_angle2 : plane_angle_measure;
      turn_angle : plane_angle_measure;
   END_ENTITY;



   ENTITY cylindrical_surface
   SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY data_environment;
      name : label;
      description : text;
      elements : SET [1:?] OF property_definition_representation;
   END_ENTITY;



   ENTITY data_set_representation_item
   SUBTYPE OF (compound_representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')) > 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SET_REPRESENTATION_ITEM' IN TYPEOF(SELF\compound_representation_item.item_element);
   END_ENTITY;



   ENTITY date
   SUPERTYPE OF (calendar_date);
      year_component : year_number;
   END_ENTITY;



   ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
   END_ENTITY;



   ENTITY date_and_time_assignment
   ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role : date_time_role;
   END_ENTITY;



   ENTITY date_assignment
   ABSTRACT SUPERTYPE;
      assigned_date : date;
      role : date_role;
   END_ENTITY;



   ENTITY date_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY date_time_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY dated_effectivity
   SUBTYPE OF (effectivity);
      effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
      effectivity_start_date : date_time_or_event_occurrence;
   END_ENTITY;



   ENTITY datum_difference
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect));
      WR2:
         SELF\shape_aspect.name = SELF\shape_aspect_relationship.name;
      WR3:
         SELF\shape_aspect.description = SELF\shape_aspect_relationship.description;
      WR4:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\datum_difference)) = 0;
   END_ENTITY;



   ENTITY datum_difference_analytical_model_port_assignment
   SUBTYPE OF (property_definition_representation);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(SELF\property_definition_representation.used_representation)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(SELF\property_definition_representation.definition));
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_representation || SELF\datum_difference_analytical_model_port_assignment)) = 0;
   END_ENTITY;



   ENTITY datum_difference_based_characteristic
   SUBTYPE OF (representation_item);
   WHERE
      WR1:
         SIZEOF(QUERY (r <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (SIZEOF(QUERY (prd2 <* QUERY (prd <* USEDIN(r,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION' IN TYPEOF(prd)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(prd\property_definition_representation.definition)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(prd2\property_definition_representation.definition\property_definition.definition)))) = 1))) = 1;
   END_ENTITY;



   ENTITY datum_difference_based_model_parameter
   SUBTYPE OF (model_parameter);
   WHERE
      WR1:
         SIZEOF(QUERY (r <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (SIZEOF(QUERY (prd2 <* QUERY (prd <* USEDIN(r,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION' IN TYPEOF(prd)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(prd\property_definition_representation.definition)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(prd2\property_definition_representation.definition\property_definition.definition)))) = 1))) = 1;
   END_ENTITY;



   ENTITY datum_difference_functional_unit_usage_view_terminal_assignment
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship || SELF\datum_difference_functional_unit_usage_view_terminal_assignment)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_DIFFERENCE' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
   END_ENTITY;



   ENTITY datum_reference_frame
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\datum_reference_frame)) = 0;
      WR2:
         SELF\shape_aspect.product_definitional = FALSE;
      WR3:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference axis'))| (pud.related_shape_aspect\shape_aspect.description = 'axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) <= 3;
      WR4:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference plane'))| (pud.related_shape_aspect\shape_aspect.description = 'plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) <= 3;
      WR5:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference origin'))| (pud.related_shape_aspect\shape_aspect.description = 'point') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (ds <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'established datum reference frame'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(ds.related_shape_aspect)))) >= 1;
      WR7:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference axis'))| (pud.related_shape_aspect\shape_aspect.description = 'axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) + SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference plane'))| (pud.related_shape_aspect\shape_aspect.description = 'plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) + SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference origin'))| (pud.related_shape_aspect\shape_aspect.description = 'point') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(pud.related_shape_aspect)))) >= 1;
      WR8:
         SIZEOF(QUERY (pud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference origin'))| (pud.related_shape_aspect\shape_aspect.description <> 'point') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DERIVED_SHAPE_ASPECT' IN TYPEOF(pud.related_shape_aspect)))) = 0;
   END_ENTITY;



   ENTITY datum_system
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = FALSE;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'established datum reference frame'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum usage in datum system'))) >= 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'datum system property with material conditions') OR (pd\property_definition.description = 'datum system property without material conditions'))) = 1;
   END_ENTITY;



   ENTITY datum_system_based_dimensional_location
   SUBTYPE OF (dimensional_location);
   END_ENTITY;



   ENTITY definitional_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
   END_ENTITY;



   ENTITY degenerate_pcurve
   SUBTYPE OF (point);
      basis_surface : surface;
      reference_to_curve : definitional_representation;
   WHERE
      WR1:
         SIZEOF(reference_to_curve\representation.items) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
      WR3:
         reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
   WHERE
      WR1:
         major_radius < minor_radius;
   END_ENTITY;



   ENTITY delete_design_object_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object deletion'))) = 1;
   END_ENTITY;



   ENTITY delete_design_object_request_assignment
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF managed_design_object;
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it)) AND (it\product_definition_relationship.name = 'design object deletion'))) = 1;
   END_ENTITY;



   ENTITY dependent_material_removal_feature_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SELF\shape_aspect.description = 'material removal feature template';
      WR2:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(am.relating_shape_aspect)) AND (am.relating_shape_aspect.description IN [ 'default attachment size and component termination passage based',
 'default attachment size based',
 'default attachment size and via based',
 'default component termination passage based',
 'default via based',
 'default unsupported passage based' ]))) = 1;
   END_ENTITY;



   ENTITY derived_shape_aspect
   SUPERTYPE OF (ONEOF(apex,
 centre_of_symmetry,
 geometric_alignment,
 geometric_intersection,
 extension,
 tangent))
   SUBTYPE OF (shape_aspect);
   INVERSE
      deriving_relationships : SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
   END_ENTITY;



   ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
   DERIVE
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         (SIZEOF(elements) > 1) OR (SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.00000);
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY derived_unit_element;
      unit : named_unit;
      exponent : REAL;
   END_ENTITY;



   ENTITY description_attribute;
      attribute_value : text;
      described_item : description_attribute_select;
   END_ENTITY;



   ENTITY descriptive_representation_item
   SUBTYPE OF (representation_item);
      description : text;
   END_ENTITY;



   ENTITY design_layer_type_specific_padstack_definition
   SUBTYPE OF (padstack_definition);
   END_ENTITY;



   ENTITY design_make_from_relationship
   SUBTYPE OF (product_definition_relationship);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT') ] * TYPEOF(SELF.relating_product_definition)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT') ] * TYPEOF(SELF.related_product_definition)) = 1;
      WR3:
         SIZEOF(QUERY (pds <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pds)))) = 0;
   END_ENTITY;



   ENTITY design_object
   SUBTYPE OF (characterized_object);
   END_ENTITY;



   ENTITY device_terminal_map
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.related_shape_aspect,
 SELF\shape_aspect_relationship.relating_shape_aspect;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect);
   END_ENTITY;



   ENTITY dimension_related_tolerance_zone_element;
      related_dimension : dimensional_location;
      related_element : tolerance_zone_definition;
   END_ENTITY;



   ENTITY dimensional_characteristic_representation;
      dimension : dimensional_characteristic;
      representation : shape_dimension_representation;
   END_ENTITY;



   ENTITY dimensional_exponents;
      length_exponent : REAL;
      mass_exponent : REAL;
      time_exponent : REAL;
      electric_current_exponent : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent : REAL;
      luminous_intensity_exponent : REAL;
   END_ENTITY;



   ENTITY dimensional_location
   SUPERTYPE OF (ONEOF(angular_location,
 dimensional_location_with_path))
   SUBTYPE OF (shape_aspect_relationship);
   END_ENTITY;



   ENTITY dimensional_location_with_direction
   SUBTYPE OF (dimensional_location);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.description = 'linear';
   END_ENTITY;



   ENTITY dimensional_location_with_path
   SUBTYPE OF (dimensional_location);
      path : shape_aspect;
   END_ENTITY;



   ENTITY dimensional_size
   SUPERTYPE OF (angular_size);
      applies_to : shape_aspect;
      name : label;
   WHERE
      WR1:
         applies_to.product_definitional = TRUE;
   END_ENTITY;



   ENTITY dimensional_size_property
   SUBTYPE OF (dimensional_size,
 property_definition);
   END_ENTITY;



   ENTITY directed_action
   SUBTYPE OF (executed_action);
      directive : action_directive;
   END_ENTITY;



   ENTITY directed_dimensional_location
   SUBTYPE OF (dimensional_location);
   END_ENTITY;



   ENTITY direction
   SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
   WHERE
      WR1:
         SIZEOF(QUERY (tmp <* direction_ratios| (tmp <> 0.00000))) > 0;
   END_ENTITY;



   ENTITY discrete_shield
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical occurrence';
      WR2:
         SIZEOF(QUERY (si <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'shielded item'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(si.relating_product_definition)))) >= 1;
   END_ENTITY;



   ENTITY document;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      kind : document_type;
   INVERSE
      representation_types : SET [0:?] OF document_representation_type FOR represented_document;
   END_ENTITY;



   ENTITY document_identifier
   SUBTYPE OF (group);
   UNIQUE
      UR1 : SELF\group.name,
 SELF\group.description;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 '')) = 1;
   END_ENTITY;



   ENTITY document_identifier_assignment
   SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : document_identifier;
      items : SET [1:?] OF document_identifier_assigned_item;
   END_ENTITY;



   ENTITY document_reference
   ABSTRACT SUPERTYPE;
      assigned_document : document;
      source : label;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY document_relationship;
      name : label;
      description : OPTIONAL text;
      relating_document : document;
      related_document : document;
   END_ENTITY;



   ENTITY document_representation_type;
      name : label;
      represented_document : document;
   END_ENTITY;



   ENTITY document_type;
      product_data_type : label;
   END_ENTITY;



   ENTITY document_usage_constraint;
      source : document;
      subject_element : label;
      subject_element_value : text;
   END_ENTITY;



   ENTITY document_with_class
   SUBTYPE OF (document);
      class : identifier;
   END_ENTITY;



   ENTITY dose_equivalent_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\dose_equivalent_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = sievert;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY eccentric_cone
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      height : positive_length_measure;
      x_offset : length_measure;
      y_offset : length_measure;
      ratio : REAL;
   WHERE
      WR1:
         ratio >= 0.00000;
   END_ENTITY;



   ENTITY edge
   SUPERTYPE OF (ONEOF(edge_curve,
 oriented_edge,
 subedge))
   SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end : vertex;
   END_ENTITY;



   ENTITY edge_based_2d_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF\representation.items| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D') ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF\representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM') ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_CURVE' IN TYPEOF(edges)))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (pline_edges <* QUERY (edges <* eb.ces_edges| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POLYLINE' IN TYPEOF(edges\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_edges\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(edges.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(edges.edge_end))))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT valid_2d_wireframe_edge_curve(edges\edge_curve.edge_geometry,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (con_edges <* QUERY (edges <* eb.ces_edges| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONIC' IN TYPEOF(edges\edge_curve.edge_geometry)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(con_edges\edge_curve.edge_geometry\conic.position)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR10:
         SELF\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
   END_ENTITY;



   ENTITY edge_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
   END_ENTITY;



   ENTITY edge_based_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(edges)))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (pline_edges <* QUERY (edges <* eb.ces_edges| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(edges\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_edges\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(edges.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(edges.edge_end))))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (ebwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT (SIZEOF(QUERY (edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR9:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
   END_ENTITY;



   ENTITY edge_curve
   SUBTYPE OF (edge,
 geometric_representation_item);
      edge_geometry : curve;
      same_sense : BOOLEAN;
   END_ENTITY;



   ENTITY edge_loop
   SUBTYPE OF (loop,
 path);
   DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
   WHERE
      WR1:
         SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].edge_end;
   END_ENTITY;



   ENTITY edge_segment_cross_section
   SUBTYPE OF (volume_shape_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\volume_shape_intersection || SELF\edge_segment_cross_section)) = 0;
   END_ENTITY;



   ENTITY edge_segment_vertex
   SUBTYPE OF (physical_unit_datum);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\physical_unit_datum || SELF\edge_segment_vertex)) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'shape element characterization'))) = 1;
      WR3:
         SELF\shape_aspect.of_shape\property_definition.definition.frame_of_reference\application_context_element.name IN [ 'physical design occurrence',
 'physical design usage' ];
      WR4:
         SELF\shape_aspect.name = 'single datum';
   END_ENTITY;



   ENTITY ee_specification
   SUBTYPE OF (document);
   WHERE
      WR1:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'document source'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'document source'))) >= 1;
      WR2:
         SELF\document.kind\document_type.product_data_type IN [ 'assembly technology specification',
 'design specification',
 'fabrication technology specification',
 'interface specification',
 'language reference manual',
 'lead form specification',
 'material specification',
 'reference document',
 'source code',
 'process specification',
 'surface finish specification',
 'test specification' ];
   END_ENTITY;



   ENTITY effectivity
   SUPERTYPE OF (ONEOF(serial_numbered_effectivity,
 dated_effectivity,
 lot_effectivity));
      id : identifier;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY electric_charge_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\electric_charge_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = coulomb;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY electric_current_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY electric_current_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY electrical_isolation_component_shape_aspect
   SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY electrical_isolation_removal_template_definition
   SUBTYPE OF (part_template_definition);
   END_ENTITY;



   ENTITY electrical_network
   SUBTYPE OF (functional_unit);
   END_ENTITY;



   ENTITY electromotive_force_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\electromotive_force_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = volt;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY elementary_surface
   SUPERTYPE OF (ONEOF(plane,
 cylindrical_surface,
 conical_surface,
 spherical_surface,
 toroidal_surface))
   SUBTYPE OF (surface);
      position : axis2_placement_3d;
   END_ENTITY;



   ENTITY ellipse
   SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
   END_ENTITY;



   ENTITY ellipsoid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      semi_axis_3 : positive_length_measure;
   END_ENTITY;



   ENTITY elliptic_area
   SUBTYPE OF (primitive_2d);
      position : axis2_placement_2d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
   END_ENTITY;



   ENTITY energy_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\energy_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = joule;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY evaluated_characteristic
   SUBTYPE OF (representation,
 representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,
 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\representation_relationship_with_transformation || SELF\evaluated_characteristic)) = 0;
      WR2:
         SELF\representation_relationship.rep_1 <> SELF\representation_relationship.rep_2;
      WR3:
         SELF\representation_relationship.name = '';
      WR4:
         SELF\representation.name = '';
      WR5:
         SELF\representation_relationship.rep_1.name = 'planned characteristic';
   END_ENTITY;



   ENTITY evaluated_degenerate_pcurve
   SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
   END_ENTITY;



   ENTITY evaluation_product_definition
   SUBTYPE OF (product_definition);
   END_ENTITY;



   ENTITY executed_action
   SUBTYPE OF (action);
   END_ENTITY;



   ENTITY expanded_uncertainty
   SUBTYPE OF (standard_uncertainty);
      coverage_factor : REAL;
   END_ENTITY;



   ENTITY extension
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) = 1;
   END_ENTITY;



   ENTITY external_definition
   SUPERTYPE OF (bond_category)
   SUBTYPE OF (characterized_object,
 descriptive_representation_item,
 externally_defined_representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY external_source;
      source_id : source_item;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY external_source_relationship;
      name : label;
      description : OPTIONAL text;
      relating_source : external_source;
      related_source : external_source;
   END_ENTITY;



   ENTITY externally_defined_assembly_definition
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'assembly module');
      WR3:
         NOT (SELF.frame_of_reference\application_context_element.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
   END_ENTITY;



   ENTITY externally_defined_bare_die
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (ifdu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition)) AND (ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'device unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0;
   END_ENTITY;



   ENTITY externally_defined_curve_font
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_functional_unit
   SUBTYPE OF (functional_unit,
 externally_defined_product_definition);
   END_ENTITY;



   ENTITY externally_defined_hatch_style
   SUBTYPE OF (externally_defined_item,
 geometric_representation_item);
   END_ENTITY;



   ENTITY externally_defined_interconnect_definition
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'interconnect module');
   END_ENTITY;



   ENTITY externally_defined_item;
      item_id : source_item;
      source : external_source;
   END_ENTITY;



   ENTITY externally_defined_package
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical design usage';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'registered case style'))) >= 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr)))| (sr_pdr.used_representation\representation.name = 'seating plane'))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' IN TYPEOF(sa)))) <= 1))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(sa)))) >= 1))) = 0;
      WR6:
         NOT (SELF\product_definition.description = 'altered package') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package preparation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pdr.relating_product_definition)) = 1))) = 1);
   END_ENTITY;



   ENTITY externally_defined_packaged_connector
   SUBTYPE OF (externally_defined_packaged_part);
   END_ENTITY;



   ENTITY externally_defined_packaged_part
   SUPERTYPE OF (externally_defined_packaged_connector)
   SUBTYPE OF (externally_defined_physical_unit);
   WHERE
      WR1:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0);
      WR2:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)) AND (ifu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR4:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE' IN TYPEOF(upkg.related_product_definition)))) = 1);
      WR5:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (bpp <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'base packaged part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(bpp.relating_product_definition)) = 1) AND (bpp.relating_product_definition.frame_of_reference.name = 'physical design usage'))) >= 1);
      WR6:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(upkg.relating_product_definition)) = 1))) >= 1);
   END_ENTITY;



   ENTITY externally_defined_physical_unit
   SUPERTYPE OF (ONEOF(externally_defined_package,
 externally_defined_packaged_part,
 externally_defined_bare_die,
 externally_defined_assembly_definition,
 externally_defined_interconnect_definition))
   SUBTYPE OF (physical_unit,
 externally_defined_product_definition);
   END_ENTITY;



   ENTITY externally_defined_product_definition
   SUPERTYPE OF (library_defined_product_definition)
   SUBTYPE OF (product_definition,
 externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_representation_item
   SUBTYPE OF (externally_defined_item,
 representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY externally_defined_symbol
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_text_font
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_tile
   SUBTYPE OF (externally_defined_item);
   END_ENTITY;



   ENTITY externally_defined_tile_style
   SUBTYPE OF (externally_defined_item,
 geometric_representation_item);
   END_ENTITY;



   ENTITY extruded_area_solid
   SUBTYPE OF (swept_area_solid);
      extruded_direction : direction;
      depth : positive_length_measure;
   WHERE
      WR1:
         dot_product(SELF\swept_area_solid.swept_area.basis_surface\elementary_surface.position.p[3],
 extruded_direction) <> 0.00000;
   END_ENTITY;



   ENTITY extruded_face_solid
   SUBTYPE OF (swept_face_solid);
      extruded_direction : direction;
      depth : positive_length_measure;
   WHERE
      WR1:
         dot_product(SELF\swept_face_solid.swept_face.face_geometry\elementary_surface.position.p[3],
 extruded_direction) <> 0.00000;
   END_ENTITY;



   ENTITY fabrication_joint
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description IN [ 'via terminal',
 'printed component join terminal',
 'non functional land join terminal',
 'land join terminal',
 'conductive interconnect element terminal',
 'component termination passage join terminal' ]);
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect)) AND (SELF.relating_shape_aspect\shape_aspect.description IN [ 'via terminal',
 'printed component join terminal',
 'non functional land join terminal',
 'land join terminal',
 'conductive interconnect element terminal',
 'component termination passage join terminal' ]);
      WR3:
         SIZEOF(QUERY (ajm <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'auxiliary joint material'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND' IN TYPEOF(ajm.related_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(ajm.related_shape_aspect)) AND (ajm.related_shape_aspect\shape_aspect.description = 'stratum feature template component'))) <= 1;
      WR4:
         acyclic_shape_aspect_relationship(SELF,
 [ SELF\shape_aspect_relationship.related_shape_aspect ],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT');
   END_ENTITY;



   ENTITY face
   SUPERTYPE OF (ONEOF(face_surface,
 subface,
 oriented_face))
   SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
   WHERE
      WR1:
         NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)));
      WR2:
         SIZEOF(QUERY (temp <* bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp)))) <= 1;
   END_ENTITY;



   ENTITY face_bound
   SUBTYPE OF (topological_representation_item);
      bound : loop;
      orientation : BOOLEAN;
   END_ENTITY;



   ENTITY face_outer_bound
   SUBTYPE OF (face_bound);
   END_ENTITY;



   ENTITY face_surface
   SUBTYPE OF (face,
 geometric_representation_item);
      face_geometry : surface;
      same_sense : BOOLEAN;
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
   END_ENTITY;



   ENTITY faceted_brep
   SUBTYPE OF (manifold_solid_brep);
   END_ENTITY;



   ENTITY faceted_brep_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (fbrep <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(fbrep,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')| NOT (SIZEOF(QUERY (fcs <* csh.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE' IN TYPEOF(fcs)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(fcs\face_surface.face_geometry)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(fcs\face_surface.face_geometry\elementary_surface.position.location)))))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (fbrep <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(fbrep,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN')| NOT (SIZEOF(QUERY (fcs <* csh.cfs_faces| NOT (SIZEOF(QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds)))) = 1))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\manifold_solid_brep.outer)))) = 0;
      WR6:
         SIZEOF(QUERY (brv <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation)) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
   END_ENTITY;



   ENTITY faceted_primitive
   SUBTYPE OF (geometric_representation_item);
      points : LIST [4:?] OF UNIQUE cartesian_point;
   WHERE
      WR1:
         points[1].dim = 3;
   END_ENTITY;



   ENTITY feature_shape_occurrence_relationship
   SUBTYPE OF (representation,
 shape_representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,
 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\feature_shape_occurrence_relationship)) = 0;
   END_ENTITY;



   ENTITY fiducial
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'laminate component');
   END_ENTITY;



   ENTITY fiducial_part_feature
   SUBTYPE OF (part_tooling_feature);
   END_ENTITY;



   ENTITY fiducial_stratum_feature
   SUBTYPE OF (stratum_feature);
   END_ENTITY;



   ENTITY fill_area_style;
      name : label;
      fill_styles : SET [1:?] OF fill_style_select;
   WHERE
      WR1:
         SIZEOF(QUERY (fill_style <* SELF.fill_styles| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FILL_AREA_STYLE_COLOUR' IN TYPEOF(fill_style)))) <= 1;
   END_ENTITY;



   ENTITY fill_area_style_colour;
      name : label;
      fill_colour : colour;
   END_ENTITY;



   ENTITY fill_area_style_hatching
   SUBTYPE OF (geometric_representation_item);
      hatch_line_appearance : curve_style;
      start_of_next_hatch_line : one_direction_repeat_factor;
      point_of_reference_hatch_line : cartesian_point;
      pattern_start : cartesian_point;
      hatch_line_angle : plane_angle_measure;
   END_ENTITY;



   ENTITY fill_area_style_tile_coloured_region
   SUBTYPE OF (geometric_representation_item);
      closed_curve : curve_or_annotation_curve_occurrence;
      region_colour : colour;
   END_ENTITY;



   ENTITY fill_area_style_tile_curve_with_style
   SUBTYPE OF (geometric_representation_item);
      styled_curve : annotation_curve_occurrence;
   END_ENTITY;



   ENTITY fill_area_style_tile_symbol_with_style
   SUBTYPE OF (geometric_representation_item);
      symbol : annotation_symbol_occurrence;
   END_ENTITY;



   ENTITY fill_area_style_tiles
   SUBTYPE OF (geometric_representation_item);
      tiling_pattern : two_direction_repeat_factor;
      tiles : SET [1:?] OF fill_area_style_tile_shape_select;
      tiling_scale : positive_ratio_measure;
   END_ENTITY;



   ENTITY filled_area_material_removal_component_shape_aspect
   SUBTYPE OF (material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY footprint_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\footprint_definition)) = 0;
      WR7:
         SELF.frame_of_reference.name IN [ 'layout design usage' ];
      WR8:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'template model'))) = 1;
   END_ENTITY;



   ENTITY footprint_occurrence
   SUBTYPE OF (assembly_group_component_shape_aspect);
   END_ENTITY;



   ENTITY footprint_occurrence_shape_aspect_relationship
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         SELF\shape_aspect_relationship.name = 'footprint occurrence sub assembly relationship';
   END_ENTITY;



   ENTITY force_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\force_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = newton;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY founded_item;
   END_ENTITY;



   ENTITY frequency_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\frequency_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = hertz;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY frozen_assignment
   SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF frozen_assigned_item;
   WHERE
      WR1:
         SELF\approval_assignment.assigned_approval.status.name IN [ 'approved',
 'not yet approved' ];
   END_ENTITY;



   ENTITY functional_specification
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr\representation_relationship.name = 'functional characteristic category') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNAL_DEFINITION' IN TYPEOF(rr.rep_1.items[1])))) = 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr\representation_relationship.name = 'characterizing signal' + 'for functional specification'))) = 1;
      WR3:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr\representation_relationship.name = 'reference signal for' + 'functional specification'))) = 1;
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\functional_specification)) = 0;
      WR5:
         SELF\representation.name = '';
      WR6:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.definition.definition)))) = 0;
   END_ENTITY;



   ENTITY functional_specification_definition
   SUBTYPE OF (functional_unit);
   WHERE
      WR1:
         SELF.frame_of_reference\application_context_element.name = 'functional network design';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_SPECIFICATION' IN TYPEOF(pdr.used_representation)))) > 0))) > 0;
   END_ENTITY;



   ENTITY functional_terminal_group
   SUBTYPE OF (group);
   UNIQUE
      UR1 : SELF\group.name;
   END_ENTITY;



   ENTITY functional_unit
   SUPERTYPE OF ((electrical_network ANDOR
 thermal_network) ANDOR
 functional_specification_definition)
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name IN [ 'functional design usage',
 'functional network design' ];
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR3:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) = 1;
      WR4:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR5:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR6:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR7:
         NOT (SELF.frame_of_reference.name = 'functional network design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| (du.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR8:
         NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'THERMAL_NETWORK'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ELECTRICAL_NETWORK') ] * TYPEOF(SELF)) = 1) OR (SELF.frame_of_reference.name = 'functional network design');
   END_ENTITY;



   ENTITY functional_unit_terminal_definition
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'functional design usage');
      WR2:
         SIZEOF(QUERY (pd2 <* QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pd)))| (SIZEOF(QUERY (funtdba <* QUERY (pdr <* USEDIN(pd2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(funtdba.relating_property_definition.definition)))) <= 1))) <= 1;
      WR3:
         SIZEOF(QUERY (pd2 <* QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pd)))| (SIZEOF(QUERY (funtdna <* QUERY (pdr <* USEDIN(pd2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition node assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(funtdna.relating_property_definition.definition)))) <= 1))) <= 1;
   END_ENTITY;



   ENTITY functionally_defined_transformation;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY geometric_alignment
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) > 1;
   END_ENTITY;



   ENTITY geometric_curve_set
   SUBTYPE OF (geometric_set);
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* SELF\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(temp)))) = 0;
   END_ENTITY;



   ENTITY geometric_intersection
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) > 1;
   END_ENTITY;



   ENTITY geometric_representation_context
   SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
   END_ENTITY;



   ENTITY geometric_representation_item
   SUPERTYPE OF (ONEOF(point,
 direction,
 vector,
 placement,
 cartesian_transformation_operator,
 curve,
 surface,
 edge_curve,
 face_surface,
 poly_loop,
 vertex_point,
 solid_model,
 boolean_result,
 sphere,
 right_circular_cone,
 right_circular_cylinder,
 torus,
 block,
 primitive_2d,
 right_angular_wedge,
 ellipsoid,
 faceted_primitive,
 rectangular_pyramid,
 cyclide_segment_solid,
 half_space_solid,
 half_space_2d,
 shell_based_surface_model,
 shell_based_wireframe_model,
 edge_based_wireframe_model,
 geometric_set))
   SUBTYPE OF (representation_item);
   DERIVE
      dim : dimension_count := dimension_of(SELF);
   WHERE
      WR1:
         SIZEOF(QUERY (using_rep <* using_representations(SELF)| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(using_rep.context_of_items)))) = 0;
   END_ENTITY;



   ENTITY geometric_set
   SUPERTYPE OF (geometric_curve_set)
   SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
   END_ENTITY;



   ENTITY geometric_tolerance;
      name : label;
      description : text;
      magnitude : measure_with_unit;
      toleranced_shape_aspect : shape_aspect;
   WHERE
      WR1:
         magnitude.value_component >= 0.00000;
   END_ENTITY;



   ENTITY geometric_tolerance_group
   SUBTYPE OF (property_definition);
   WHERE
      WR1:
         SELF\property_definition.description IN [ 'separate requirement',
 'simultaneous requirement' ];
      WR2:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) >= 1);
      WR3:
         NOT (SELF\property_definition.description = 'simultaneous requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) >= 2);
      WR4:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.name = 'linear profile refinement')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) = 0);
      WR5:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.name = 'surface profile refinement')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) = 0);
      WR6:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.name = 'feature relating position')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) = 0);
      WR7:
         NOT (SELF\property_definition.description = 'separate requirement') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'group geometric tolerance') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE') ] * TYPEOF(pdr.related_property_definition)) > 0))) = 0);
   END_ENTITY;



   ENTITY geometric_tolerance_relationship;
      name : label;
      description : text;
      relating_geometric_tolerance : geometric_tolerance;
      related_geometric_tolerance : geometric_tolerance;
   END_ENTITY;



   ENTITY geometric_tolerance_with_specified_datum_system
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANGULARITY_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CIRCULAR_RUNOUT_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONCENTRICITY_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARALLELISM_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERPENDICULARITY_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SYMMETRY_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOTAL_RUNOUT_TOLERANCE') ] * TYPEOF(SELF)) = 1;
      WR2:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr.related_property_definition\property_definition.description = 'datum system property with material conditions') OR (pdr.related_property_definition\property_definition.description = 'datum system property without material conditions')) AND (pdr\property_definition_relationship.name = 'referenced datum system definition'))) = 1;
      WR3:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_GROUP' IN TYPEOF(pdr.related_property_definition)) AND (pdr.related_property_definition\property_definition.description = 'separate requirement')) AND (pdr\property_definition_relationship.name = 'group geometric tolerance'))) <= 1;
   END_ENTITY;



   ENTITY geometrically_bounded_2d_wireframe_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
      WR2:
         SIZEOF(QUERY (item <* SELF.items| NOT (SIZEOF(TYPEOF(item) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (item <* SELF.items| (SIZEOF(TYPEOF(item) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) >= 1;
      WR4:
         SIZEOF(QUERY (mi <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(item)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR5:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (elem <* gcs\geometric_set.elements| NOT (SIZEOF(TYPEOF(elem) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_2D',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' ]) = 1))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (crv <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(elem)))| NOT valid_basis_curve_in_2d_wireframe(crv))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (pnt <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' IN TYPEOF(elem)))| NOT (SIZEOF(TYPEOF(pnt) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE' ]) = 1))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (gcs <* QUERY (item <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(item)))| NOT (SIZEOF(QUERY (pl <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(elem)))| NOT (SIZEOF(pl\polyline.points) > 2))) = 0))) = 0;
   END_ENTITY;



   ENTITY geometrically_bounded_surface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (gs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (pnt <* QUERY (gsel <* gs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' IN TYPEOF(gsel)))| NOT gbsf_check_point(pnt))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (gs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cv <* QUERY (gsel <* gs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(gsel)))| NOT gbsf_check_curve(cv))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (gs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (sf <* QUERY (gsel <* gs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(gsel)))| NOT gbsf_check_surface(sf))) = 0))) = 0;
   END_ENTITY;



   ENTITY geometrically_bounded_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF(TYPEOF(it) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(TYPEOF(it) * [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ]) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (crv <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(elem)))| NOT valid_geometrically_bounded_wf_curve(crv,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (pnts <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT' IN TYPEOF(elem)))| NOT valid_geometrically_bounded_wf_point(pnts,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cnc <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC' IN TYPEOF(elem)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\conic.position)))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (gcs <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (pline <* QUERY (elem <* gcs\geometric_set.elements| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(elem)))| NOT (SIZEOF(pline\polyline.points) > 2))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR8:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
   END_ENTITY;



   ENTITY global_uncertainty_assigned_context
   SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
   END_ENTITY;



   ENTITY global_unit_assigned_context
   SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
   END_ENTITY;



   ENTITY group;
      name : label;
      description : OPTIONAL text;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY group_assignment
   ABSTRACT SUPERTYPE;
      assigned_group : group;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY group_product_definition
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'design requirement';
      WR2:
         NOT (SELF\product_definition.description = 'placement group') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))) >= 1);
   END_ENTITY;



   ENTITY group_relationship;
      name : label;
      description : OPTIONAL text;
      relating_group : group;
      related_group : group;
   END_ENTITY;



   ENTITY group_shape_aspect
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
      WR2:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF\shape_aspect.of_shape.definition)) AND EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name)) AND (NOT EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name) OR (SELF\shape_aspect.of_shape.definition\product_definition.name = 'interconnect module'));
      WR3:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'constrained object') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY' IN TYPEOF(pdr.related_property_definition.definition)))) = 1))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'design specific purpose'))) = 1))) = 1))) = 0);
      WR5:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'keepout')) AND (it\descriptive_representation_item.description IN [ 'true',
 'false' ]))) = 1))) = 1))) = 0);
      WR6:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) = 1))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description IN [ 'interconnect module constraint region' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition)))) = 1))) = 1);
      WR8:
         NOT (SELF\shape_aspect.description = 'termination constraint') OR (SIZEOF(QUERY (ctm <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'constrained termination member'))| (ctm.related_shape_aspect\shape_aspect.description = 'mating connector termination'))) >= 2);
      WR9:
         EXISTS(SELF\shape_aspect.description);
      WR10:
         NOT (SELF\shape_aspect.description IN [ 'placement group' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition))) AND (pdr.relating_property_definition\property_definition.name = 'requirement'))) = 1))) = 1);
      WR11:
         NOT (SELF\shape_aspect.description IN [ 'termination constraint' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'termination usage constraint') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition))) AND (pdr.relating_property_definition\property_definition.name = 'termination usage constraint'))) = 1))) = 1);
   END_ENTITY;



   ENTITY grouped_requirements_property
   SUBTYPE OF (group,
 requirements_property);
   WHERE
      WR1:
         NOT (SELF\group.name = 'item restricted requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(aga.items) = 1))) = 1);
      WR2:
         NOT (SELF\group.name = 'layout spacing requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(aga.items) = 2) AND (SIZEOF(QUERY (rp <* QUERY (it <* aga.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(rp)) AND (rp\characterized_object.name IN [ 'assembly module assembly component',
 'assembly module component terminal',
 'assembly module component',
 'assembly module macro component join terminal',
 'assembly module macro component',
 'assembly module',
 'bare die component terminal',
 'bare die component',
 'bonded conductive base blind via',
 'buried via',
 'cable component',
 'component feature',
 'component mounting feature',
 'component termination passage and contact size dependent land',
 'component termination passage and contact size dependent non functional land',
 'component termination passage dependent land',
 'component termination passage dependent non functional land',
 'component termination passage interface terminal',
 'component termination passage join terminal',
 'component termination passage',
 'conductive interconnect element terminal',
 'conductive interconnect element with pre defined transitions',
 'conductive interconnect element with user defined single transition',
 'connected area component',
 'contact size dependent land',
 'contact size dependent non functional land',
 'cutout edge segment',
 'cutout',
 'dielectric material passage',
 'electrical isolation laminate component',
 'embedded component terminal',
 'fiducial',
 'fill area',
 'filled area material removal laminate component',
 'inter stratum feature',
 'interconnect component interface terminal',
 'interconnect component join terminal',
 'interconnect module assembly component',
 'interconnect module component stratum based terminal',
 'interconnect module component surface feature',
 'interconnect module component terminal',
 'interconnect module component',
 'interconnect module edge segment',
 'interconnect module edge',
 'interconnect module macro component join terminal',
 'interconnect module macro component',
 'interface access material removal laminate component',
 'interface access stratum feature template component',
 'interface component',
 'interfacial connection',
 'internal probe access area',
 'join two physical connectivity definition supporting inter stratum feature',
 'join two physical connectivity definition supporting printed component',
 'laminate component',
 'laminate text component',
 'laminate text string component',
 'land interface terminal',
 'land join terminal',
 'land',
 'material removal laminate component',
 'minimally defined component terminal',
 'movable packaged component join terminal',
 'multi layer material removal laminate component',
 'multi layer stratum feature template component',
 'non conductive base blind via',
 'non functional land interface terminal',
 'non functional land join terminal',
 'non functional land',
 'packaged component join terminal',
 'packaged component',
 'packaged connector component interface terminal',
 'packaged connector component',
 'partially plated cutout',
 'partially plated interconnect module edge',
 'physical component',
 'physical connectivity interrupting cutout',
 'physical laminate component',
 'physical network supporting inter stratum feature',
 'plated conductive base blind via',
 'plated cutout edge segment',
 'plated cutout',
 'plated interconnect module edge segment',
 'plated interconnect module edge',
 'plated passage or unsupported passage',
 'plated passage',
 'primary stratum indicator symbol',
 'printed component join terminal',
 'printed connector component interface terminal',
 'probe access area',
 'routed interconnect component',
 'routed physical component',
 'special symbol laminate component',
 'stratum feature template component',
 'stratum feature',
 'thermal isolation laminate component',
 'unrouted conductive interconnect element',
 'unsupported passage dependent non functional land',
 'unsupported passage',
 'via and contact size dependent land',
 'via and contact size dependent non functional land',
 'via dependent land',
 'via dependent non functional land',
 'via terminal',
 'via' ]))) = 2))) = 1);
      WR3:
         NOT (SELF\group.name = 'layout spacing requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(QUERY (rp <* QUERY (it <* aga.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(rp)) AND (rp\characterized_object.description = 'dependent design object category'))) = 1))) = 1);
      WR4:
         NOT (SELF\group.name = 'layout spacing requirements property') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(QUERY (rp <* QUERY (it <* aga.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(it)))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_OBJECT' IN TYPEOF(rp)) AND (rp\characterized_object.description = 'reference design object category'))) = 1))) = 1);
   END_ENTITY;



   ENTITY guided_wave_terminal
   SUBTYPE OF (package_terminal);
   END_ENTITY;



   ENTITY half_space_2d
   SUBTYPE OF (geometric_representation_item);
      base_curve : curve;
      agreement_flag : BOOLEAN;
   END_ENTITY;



   ENTITY half_space_solid
   SUBTYPE OF (geometric_representation_item);
      base_surface : surface;
      agreement_flag : BOOLEAN;
   END_ENTITY;



   ENTITY hyperbola
   SUBTYPE OF (conic);
      semi_axis : positive_length_measure;
      semi_imag_axis : positive_length_measure;
   END_ENTITY;



   ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
   END_ENTITY;



   ENTITY illuminance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\illuminance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = lux;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY inductance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\inductance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = henry;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY integral_shield
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_property_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(pdr.relating_property_definition))) AND (pdr\property_definition_relationship.name = 'shielded item'))) >= 1;
   END_ENTITY;



   ENTITY inter_stratum_feature
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'bonded conductive base blind via',
 'buried via',
 'component termination passage',
 'interfacial connection',
 'non conductive base blind via',
 'plated conductive base blind via',
 'plated cutout',
 'partially plated cutout',
 'plated cutout edge segment',
 'partially plated interconnect module edge',
 'plated interconnect module edge segment',
 'plated interconnect module edge',
 'unsupported passage',
 'cutout',
 'physical connectivity interrupting cutout',
 'dielectric material passage',
 'cutout edge segment',
 'interconnect module edge segment',
 'interconnect module edge' ];
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'feature of size')) AND (it\descriptive_representation_item.description IN [ 'true',
 'false' ]))) = 1))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description IN [ 'inter stratum feature template',
 'via template',
 'component termination passage template',
 'unsupported passage template' ]))) = 1;
      WR4:
         NOT (SELF\shape_aspect.description = 'cutout edge segment') OR (SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed cutout'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect)) AND (((cc.relating_shape_aspect\shape_aspect.description = 'cutout') OR (cc.relating_shape_aspect\shape_aspect.description = 'physical connectivity interrupting cutout')) OR (cc.relating_shape_aspect\shape_aspect.description = 'partially plated cutout')))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND ((ce.relating_shape_aspect\shape_aspect.description = 'interconnect module edge') OR (ce.relating_shape_aspect\shape_aspect.description = 'interconnect module edge')))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'dielectric material passage') OR (SIZEOF(QUERY (pp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent passage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(pp.relating_shape_aspect)) AND (((pp.relating_shape_aspect\shape_aspect.description = 'cutout') OR (pp.relating_shape_aspect\shape_aspect.description = 'physical connectivity interrupting cutout')) OR (pp.relating_shape_aspect\shape_aspect.description = 'partially plated cutout')))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'dielectric material passage') OR ((SIZEOF(QUERY (rp <* QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))| (rp\property_definition.name = 'feature material'))) <= 1) OR (SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1));
      WR8:
         NOT (SELF\shape_aspect.description = 'physical connectivity interrupting cutout') OR (SIZEOF(QUERY (ice <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'interrupted connectivity elements'))| (ice.relating_shape_aspect\shape_aspect.name = 'conductive interconnect element'))) >= 1);
      WR9:
         NOT (SELF\shape_aspect.description = 'unsupported passage') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'unsupported passage template'))) = 1);
      WR10:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SIZEOF(QUERY (prpc <* USEDIN(SELF.of_shape.definition.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1);
      WR11:
         NOT (SELF\shape_aspect.description = 'cutout edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
      WR12:
         NOT (SELF\shape_aspect.description = 'plated cutout edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description = 'interconnect module edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
      WR14:
         NOT (SELF\shape_aspect.description = 'plated interconnect module edge segment') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1);
   END_ENTITY;



   ENTITY inter_stratum_feature_edge_segment_template
   SUBTYPE OF (part_template_definition,
 shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF(QUERY (ce <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE_EDGE_TEMPLATE' IN TYPEOF(ce.relating_shape_aspect)))) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition || SELF\shape_aspect_relationship || SELF\inter_stratum_feature_edge_segment_template)) = 0;
   END_ENTITY;



   ENTITY inter_stratum_feature_edge_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition || SELF\inter_stratum_feature_edge_template)) = 0;
      WR2:
         SELF\shape_aspect.description = 'inter stratum feature edge template';
   END_ENTITY;



   ENTITY interconnect_definition
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         NOT EXISTS(SELF\product_definition.name) OR (SELF\product_definition.name = 'interconnect module');
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_INTERCONNECT_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'interconnect module'))) = 1);
   END_ENTITY;



   ENTITY interconnect_module_component_surface_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SELF\shape_aspect.description IN [ 'interconnect module component surface feature' ];
      WR3:
         SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description IN [ 'interconnect module secondary surface',
 'interconnect module primary surface',
 'interconnect module cavity surface',
 'interconnect module cutout surface',
 'interconnect module edge surface',
 'interconnect module edge segment surface' ]))) = 1;
   END_ENTITY;



   ENTITY interconnect_module_cutout_segment_surface
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('interconnect module cutout surface' = ce.relating_shape_aspect\shape_aspect.description))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\interconnect_module_cutout_segment_surface)) = 0;
   END_ENTITY;



   ENTITY interconnect_module_design_object_category
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SELF\characterized_object.description IN [ 'cutout category',
 'fill area category',
 'inter stratum feature category',
 'stratum feature category',
 'via category' ];
   END_ENTITY;



   ENTITY interconnect_module_edge_segment
   SUBTYPE OF (inter_stratum_feature,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated interconnect module edge segment',
 'interconnect module edge segment' ];
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         NOT (SELF\shape_aspect.description = 'plated interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.description = 'plated interconnect module edge'))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description = 'interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.description = 'interconnect module edge'))) = 1);
      WR5:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR6:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR7:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
   END_ENTITY;



   ENTITY interconnect_module_edge_segment_surface
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('interconnect module edge surface' = ce.relating_shape_aspect\shape_aspect.description))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\interconnect_module_edge_segment_surface)) = 0;
   END_ENTITY;



   ENTITY interconnect_module_interface_terminal
   SUBTYPE OF (interconnect_module_terminal);
   END_ENTITY;



   ENTITY interconnect_module_join_terminal
   SUBTYPE OF (interconnect_module_terminal);
   END_ENTITY;



   ENTITY interconnect_module_macro_component_join_terminal
   SUBTYPE OF (component_terminal);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'assembly module component terminal',
 'bare die component terminal',
 'component termination passage join terminal',
 'conductive interconnect element terminal',
 'interconnect component join terminal',
 'land join terminal',
 'minimally defined component terminal',
 'non functional land join terminal',
 'packaged component join terminal',
 'printed component join terminal',
 'package terminal occurrence',
 'via terminal' ]);
   END_ENTITY;



   ENTITY interconnect_module_stratum_based_terminal
   SUBTYPE OF (interconnect_module_terminal);
   END_ENTITY;



   ENTITY interconnect_module_terminal
   SUPERTYPE OF (ONEOF(interconnect_module_interface_terminal,
 interconnect_module_join_terminal))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design usage')) AND (SELF.of_shape.definition\product_definition.name = 'interconnect module');
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) >= 1;
      WR4:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR5:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1;
   END_ENTITY;



   ENTITY interface_access_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY interface_access_material_removal_component_shape_aspect
   SUBTYPE OF (material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY interface_component_definition
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description IN [ 'interconnect component interface terminal',
 'packaged connector component interface terminal' ]))) >= 1))) >= 1;
   END_ENTITY;



   ENTITY interface_mounted_join
   SUBTYPE OF (shape_aspect_relationship,
 shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal');
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect)) AND ((((((SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal') OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal')) OR (SELF.relating_shape_aspect\shape_aspect.description = 'packaged connector component interface terminal'));
   END_ENTITY;



   ENTITY interfaced_group_component_definition
   SUBTYPE OF (assembly_group_component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (gc <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'group component'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(gc.related_product_definition)))) >= 1;
   END_ENTITY;



   ENTITY intersection_curve
   SUBTYPE OF (surface_curve);
   WHERE
      WR1:
         SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2:
         associated_surface(SELF\surface_curve.associated_geometry[1]) <> associated_surface(SELF\surface_curve.associated_geometry[2]);
   END_ENTITY;



   ENTITY item_defined_transformation;
      name : label;
      description : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
   END_ENTITY;



   ENTITY join_shape_aspect
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.name IN [ 'constrained intra layer join',
 'inter stratum join',
 'intra stratum join' ]) OR (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(cp.related_shape_aspect)))) >= 2);
      WR2:
         SIZEOF(QUERY (nt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'network topology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK' IN TYPEOF(nt.relating_shape_aspect)))) = 1;
      WR3:
         NOT (SELF\shape_aspect.name = 'intra stratum join') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect)) AND (ji.related_shape_aspect\shape_aspect.description = 'conductor'))) <= 1);
      WR4:
         NOT (SELF\shape_aspect.name = 'intra stratum join') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect)) AND (ji.related_shape_aspect\shape_aspect.description = 'connected filled area'))) <= 1);
      WR5:
         NOT (SELF\shape_aspect.name = 'inter stratum join') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP' IN TYPEOF(ji.related_shape_aspect)) AND (ji.related_shape_aspect\shape_aspect.description = 'physical network supporting stratum feature conductive join') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect)))) <= 1);
      WR6:
         NOT (SELF\shape_aspect.name = 'unrouted join') OR (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'unrouted terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(cp.related_shape_aspect)))) >= 2);
   END_ENTITY;



   ENTITY keepout_design_object_category
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SELF\characterized_object.description IN [ 'assembly module assembly component category',
 'component feature category',
 'assembly ee material category',
 'interconnect ee material category',
 'interconnect module assembly component category',
 'via category',
 'inter stratum feature category',
 'cutout category',
 'fill area category',
 'laminate component category',
 'stratum feature category' ];
   END_ENTITY;



   ENTITY laminate_component_interface_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage interface terminal',
 'land interface terminal',
 'printed connector component interface terminal',
 'non functional land interface terminal' ]) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))) = 1;
      WR4:
         NOT (SELF\shape_aspect.description = 'component termination passage interface terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| (i_f.relating_shape_aspect\shape_aspect.description = 'component termination passage template interface terminal'))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description IN [ 'land interface terminal',
 'non functional land interface terminal' ]) OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND TRUE)) = 1);
      WR8:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR SELF.product_definitional;
      WR9:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_COMPONENT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.description = 'printed connector component');
      WR10:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR (SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated feature'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)) AND (i_f.relating_shape_aspect\shape_aspect.description = 'interface terminal'))) = 1);
      WR11:
         NOT (SELF\shape_aspect.description = 'printed connector component interface terminal') OR (SIZEOF(QUERY (i <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (pdr\shape_aspect_relationship.name = 'implementation'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(i.relating_shape_aspect)) = 1))) = 1);
      WR12:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference\application_context_element.name = 'layout occurrence');
   END_ENTITY;



   ENTITY laminate_group_component_make_from_relationship
   SUBTYPE OF (make_from_usage_option);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION') ] * TYPEOF(SELF.relating_product_definition)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION') ] * TYPEOF(SELF.related_product_definition)) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr.name = 'stratum mapping') AND (pdr.related_property_definition\property_definition.definition\product_definition_relationship.name = 'stratum make from')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_USAGE_OPTION' IN TYPEOF(pdr.related_property_definition\property_definition.definition)))) > 0))) > 0;
   END_ENTITY;



   ENTITY land
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SIZEOF(QUERY (prpc <* USEDIN(SELF.of_shape.definition.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1);
      WR2:
         SIZEOF(QUERY (i_f <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(i_f.relating_shape_aspect)))) = 1;
      WR3:
         SIZEOF(QUERY (aud <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'alternate usage definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(aud.relating_shape_aspect)))) <= 1;
      WR4:
         SIZEOF(QUERY (sfi <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'stratum feature implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))) = 1;
      WR9:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage and contact size dependent land',
 'component termination passage and contact size dependent' + 'non functional land',
 'component termination passage dependent land',
 'component termination passage dependent non functional land' ]) OR (SIZEOF(QUERY (rp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference passage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(rp.relating_shape_aspect)) AND (rp.relating_shape_aspect\shape_aspect.description = 'component termination passage'))) = 1);
      WR10:
         NOT (SELF\shape_aspect.description IN [ 'via and contact size dependent land',
 'via and contact size dependent non functional land',
 'via dependent land',
 'via dependent non functional land' ]) OR (SIZEOF(QUERY (rv <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference via'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(rv.relating_shape_aspect)) AND (rv.relating_shape_aspect\shape_aspect.description IN [ 'buried via',
 'interfacial connection',
 'bonded conductive base blind via',
 'non conductive base blind via',
 'plated conductive base blind via' ]))) = 1);
      WR11:
         NOT (SELF\shape_aspect.description = 'unsupported passage dependent non functional land') OR (SIZEOF(QUERY (rp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference passage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(rp.relating_shape_aspect)) AND (rp.relating_shape_aspect\shape_aspect.description = 'unsupported passage'))) = 1);
      WR12:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage dependent land',
 'component termination passage dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default component termination passage based'))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage and contact size dependent land',
 'component termination passage and contact size dependent ' + 'non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default attachment size and component termination ' + 'passage based'))) = 1);
      WR14:
         NOT (SELF\shape_aspect.description IN [ 'contact size dependent land',
 'contact size dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default attachment size based'))) = 1);
      WR15:
         NOT (SELF\shape_aspect.description IN [ 'via and contact size dependent land',
 'via and contact size dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default attachment size and via based'))) = 1);
      WR16:
         NOT (SELF\shape_aspect.description IN [ 'via dependent land',
 'via dependent non functional land' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default via based'))) = 1);
      WR17:
         NOT (SELF\shape_aspect.description = 'unsupported passage dependent ' + 'non functional land') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'default unsupported passage based'))) = 1);
   END_ENTITY;



   ENTITY land_physical_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'pre defined classification code'))) = 1))) <= 1;
      WR2:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(am.related_shape_aspect)))) >= 1;
      WR3:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size based',
 'default attachment size and component termination passage based',
 'default attachment size and via based' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'minimum attachment region size') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1));
      WR4:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size based',
 'default attachment size and component termination passage based',
 'default attachment size and via based' ]) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'maximum attachment region size') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1));
      WR5:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default component termination passage based',
 'default attachment size and component termination passage based' ]) OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)) AND (tu.related_shape_aspect\shape_aspect.description = 'default component termination passage definition'))) = 1));
      WR6:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',
 'default attachment size based',
 'default attachment size and via based',
 'default component termination passage based',
 'default via based',
 'default unsupported passage based' ]) OR (SIZEOF(QUERY (ost <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'of stratum technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(ost.relating_shape_aspect.of_shape.definition)))) = 1));
      WR7:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',
 'default attachment size and via based',
 'default component termination passage based',
 'default via based',
 'default unsupported passage based' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) = 2))) = 1))) = 0));
      WR8:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',
 'default attachment size and via based',
 'default component termination passage based',
 'default via based',
 'default unsupported passage based' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum fabrication allowance'))) = 1))) = 1))) = 0));
      WR9:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',
 'default attachment size and via based',
 'default component termination passage based',
 'default via based',
 'default unsupported passage based' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum annular ring'))) = 1))) = 1))) = 0));
      WR10:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default attachment size and component termination passage based',
 'default attachment size and via based',
 'default component termination passage based',
 'default via based',
 'default unsupported passage based' ]) OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)))) = 1));
      WR11:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description IN [ 'default via based',
 'default attachment size and via based' ]) OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)) AND (tu.related_shape_aspect\shape_aspect.description = 'default via definition'))) = 1));
      WR12:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'default unsupported passage') OR (SIZEOF(QUERY (tu <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)) AND (tu.related_shape_aspect\shape_aspect.description = 'default unsupported passage definition'))) = 1));
   END_ENTITY;



   ENTITY land_template_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ];
      WR2:
         SIZEOF(QUERY (tcz <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'terminal connection zone') AND (sar\shape_aspect_relationship.description IN [ 'edge curve',
 'edge point',
 'surface area',
 'surface point' ]))| (tcz.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 0;
   END_ENTITY;



   ENTITY layer
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'layer definition'))) = 1))) <= 1;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition_relationship.name = 'inter stratum extent');
   END_ENTITY;



   ENTITY layer_connection_point
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,
 SELF\shape_aspect.of_shape;
   WHERE
      WR1:
         SELF\shape_aspect.of_shape.definition\product_definition.name = 'design layer';
      WR2:
         SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'intra stratum join'))) = 1;
      WR4:
         NOT (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'inter stratum join'))) = 1) OR (SIZEOF(QUERY (cp <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connected point'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect)) AND (cp.relating_shape_aspect.name = 'intra stratum join'))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'dependently located') OR (SIZEOF(QUERY (ado <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated design object'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTER_STRATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL') ] * TYPEOF(ado.relating_shape_aspect)) = 1) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(ado.relating_shape_aspect)) = 1) AND (ado.relating_shape_aspect.description IN [ 'printed component join terminal',
 'embedded component terminal' ]))) = 1);
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'connection point location 2d')) AND (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(it)) AND (it\geometric_representation_item.dim = 2))) = 1))) <= 1))) = 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'connection point location 3d')) AND (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(it)) AND (it\geometric_representation_item.dim = 3))) = 1))) <= 1))) = 0;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND ((pdr.used_representation\representation.name = 'connection point location 2d') OR (pdr.used_representation\representation.name = 'connection point location 3d')))) >= 1))) = 0;
      WR9:
         NOT (SELF\shape_aspect.description = 'dependently located') OR (SIZEOF(QUERY (ado <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference zone'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT') ] * TYPEOF(ado.relating_shape_aspect)) = 1) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT') ] * TYPEOF(ado.relating_shape_aspect)) = 1) AND (ado.relating_shape_aspect.description IN [ 'connection zone' ]))) <= 1);
   END_ENTITY;



   ENTITY layer_connection_point_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\layer_connection_point_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(QUERY (cp <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (cp\shape_aspect_relationship.name = 'connected points'))) = 1;
   END_ENTITY;



   ENTITY layout_macro_component
   SUBTYPE OF (printed_component);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'layout macro component shape aspect'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design definition'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_DEFINITION') ] * TYPEOF(ip.relating_product_definition)) = 1))) = 1;
      WR3:
         SELF\product_definition.description <> 'printed connector component';
   END_ENTITY;



   ENTITY layout_macro_definition
   SUBTYPE OF (interconnect_definition);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_INTERCONNECT_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'interconnect module'))) = 0;
      WR3:
         SELF.frame_of_reference\application_context_element.name = 'physical design';
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'layout macro definition shape aspect'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'floor layout view'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN TYPEOF(it.relating_shape_aspect)))) = 1))) = 1))) = 0;
   END_ENTITY;



   ENTITY layout_macro_definition_terminal_to_usage_terminal_assignment
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.name;
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship || SELF\layout_macro_definition_terminal_to_usage_terminal_assignment || SELF\shape_aspect)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description IN [ 'component termination passage join terminal',
 'conductive interconnect element terminal',
 'land join terminal',
 'non functional land join terminal',
 'printed component join terminal',
 'via terminal' ];
      WR4:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')) <= 1;
   END_ENTITY;



   ENTITY layout_macro_floor_plan_template
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description IN [ 'component termination passage template',
 'component termination passage template',
 'default trace template',
 'inter stratum feature template',
 'printed connector template',
 'printed part cross section template',
 'printed part template',
 'trace template',
 'unsupported passage template',
 'via template',
 'non conductive cross section template' ]);
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access maps') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYOUT_MACRO_DEFINITION_TERMINAL_TO_USAGE_TERMINAL_ASSIGNMENT' IN TYPEOF(sar.relating_shape_aspect)))) >= 1;
   END_ENTITY;



   ENTITY length_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY length_trimmed_terminal
   SUBTYPE OF (altered_package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) = 2))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum trimmed length'))) = 1))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum trimmed length'))) = 1))) = 1))) = 0;
   END_ENTITY;



   ENTITY length_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 1.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY library_defined_assembly_definition
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SELF\product_definition.name = 'assembly module';
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
   END_ENTITY;



   ENTITY library_defined_bare_die
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (ifdu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition)) AND (ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'device unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0;
   END_ENTITY;



   ENTITY library_defined_functional_unit
   SUBTYPE OF (externally_defined_functional_unit);
   DERIVE
      library : external_source := SELF\externally_defined_item.source;
   END_ENTITY;



   ENTITY library_defined_interconnect_definition
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SELF\product_definition.name = 'interconnect module';
   END_ENTITY;



   ENTITY library_defined_package
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical design usage';
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')) > 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sa)))) = 1))) = 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' IN TYPEOF(sa)))) = 1))) <= 1;
      WR5:
         NOT (EXISTS(SELF\product_definition.description) AND (SELF\product_definition.description = 'altered package')) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package preparation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pdr.relating_product_definition)) = 1))) = 1);
   END_ENTITY;



   ENTITY library_defined_packaged_connector
   SUBTYPE OF (library_defined_packaged_part);
   END_ENTITY;



   ENTITY library_defined_packaged_part
   SUBTYPE OF (library_defined_physical_unit);
   WHERE
      WR1:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))) >= 2))) = 0);
      WR2:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      WR3:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)) AND (ifu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR4:
         NOT (SELF.frame_of_reference.name = 'physical design usage') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE' IN TYPEOF(upkg.related_product_definition)))) = 1);
      WR5:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (bpp <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'base packaged part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(bpp.relating_product_definition)) = 1) AND (bpp.relating_product_definition.frame_of_reference.name = 'physical design usage'))) >= 1);
      WR6:
         NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(upkg.relating_product_definition)) = 1))) >= 1);
   END_ENTITY;



   ENTITY library_defined_physical_unit
   SUPERTYPE OF (ONEOF(library_defined_package,
 library_defined_assembly_definition,
 library_defined_interconnect_definition,
 library_defined_packaged_part,
 library_defined_bare_die))
   SUBTYPE OF (externally_defined_physical_unit);
   DERIVE
      library : external_source := SELF\externally_defined_item.source;
   END_ENTITY;



   ENTITY library_defined_product_definition
   SUBTYPE OF (externally_defined_product_definition);
   DERIVE
      library : external_source := SELF\externally_defined_item.source;
   END_ENTITY;



   ENTITY line
   SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
   WHERE
      WR1:
         dir.dim = pnt.dim;
   END_ENTITY;



   ENTITY linear_array_component_definition_link
   SUBTYPE OF (product_definition,
 product_definition_relationship);
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\linear_array_component_definition_link)) = 0;
      WR5:
         SELF\product_definition.name = '';
      WR6:
         SELF\product_definition_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
   END_ENTITY;



   ENTITY linear_array_component_shape_aspect_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\linear_array_component_shape_aspect_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY linear_array_placement_group_component_definition
   SUBTYPE OF (array_placement_group_component_definition);
   END_ENTITY;



   ENTITY linear_array_placement_group_component_shape_aspect
   SUBTYPE OF (array_placement_group_component_shape_aspect);
   END_ENTITY;



   ENTITY linear_composite_array_shape_aspect
   SUBTYPE OF (composite_array_shape_aspect);
   END_ENTITY;



   ENTITY linear_composite_array_shape_aspect_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\linear_composite_array_shape_aspect_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
   END_ENTITY;



   ENTITY linear_profile_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         NOT (SELF\geometric_tolerance.name = 'linear profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control')) AND ((gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile locating') OR (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')))) = 1);
      WR2:
         NOT (SELF\geometric_tolerance.name = 'linear profile locating') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) = 1);
      WR3:
         NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(SELF)) AND (SELF\geometric_tolerance.name = 'linear profile refinement')) OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) = 0);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'linear profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'linear profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) <= 1);
      WR5:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY local_time;
      hour_component : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone : coordinated_universal_time_offset;
   WHERE
      WR1:
         valid_time(SELF);
   END_ENTITY;



   ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop,
 edge_loop,
 poly_loop))
   SUBTYPE OF (topological_representation_item);
   END_ENTITY;



   ENTITY lot_effectivity
   SUBTYPE OF (effectivity);
      effectivity_lot_id : identifier;
      effectivity_lot_size : measure_with_unit;
   END_ENTITY;



   ENTITY luminous_flux_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\luminous_flux_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = lumen;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY luminous_intensity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY luminous_intensity_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.00000);
   END_ENTITY;



   ENTITY magnetic_flux_density_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\magnetic_flux_density_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = tesla;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY magnetic_flux_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\magnetic_flux_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = weber;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY make_from_connectivity_relationship
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.relating_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.related_shape_aspect);
   END_ENTITY;



   ENTITY make_from_feature_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.relating_shape_aspect)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.related_shape_aspect)) = 1;
      WR3:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.relating_shape_aspect)) OR (SELF.relating_shape_aspect\shape_aspect.description IN [ 'component feature',
 'component termination passage interface terminal',
 'land or non functional land interface terminal',
 'printed connector component interface terminal' ]);
      WR4:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.related_shape_aspect)) OR (SELF.related_shape_aspect\shape_aspect.description IN [ 'component feature',
 'component termination passage interface terminal',
 'land or non functional land interface terminal',
 'printed connector component interface terminal' ]);
   END_ENTITY;



   ENTITY make_from_functional_unit_terminal_definition_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.relating_shape_aspect,
 SELF\shape_aspect_relationship.related_shape_aspect;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') ] * TYPEOF(SELF.relating_shape_aspect)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION') ] * TYPEOF(SELF.related_shape_aspect)) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\make_from_functional_unit_terminal_definition_relationship)) = 0;
      WR4:
         relating_shape_aspect.of_shape :<>: related_shape_aspect.of_shape;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect.description = '';
      WR7:
         SELF\shape_aspect.product_definitional = FALSE;
      WR8:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')) = 0;
      WR9:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_MAKE_FROM_RELATIONSHIP' IN TYPEOF(sar.of_shape\property_definition.definition)))) = 1;
   END_ENTITY;



   ENTITY make_from_model_port_relationship
   SUBTYPE OF (representation,
 representation_relationship);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,
 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT') ] * TYPEOF(SELF.rep_1)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT') ] * TYPEOF(SELF.rep_2)) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\make_from_model_port_relationship)) = 0;
      WR4:
         rep_1 :<>: rep_2;
      WR5:
         SIZEOF(QUERY (rr1 <* USEDIN(SELF.rep_1,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (SIZEOF(QUERY (rr2 <* USEDIN(SELF.rep_2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr1.rep_1 :=: rr2.rep_1))) = 0))) = 1;
      WR6:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_MAKE_FROM_RELATIONSHIP' IN TYPEOF(rr.rep_1)))) = 1;
   END_ENTITY;



   ENTITY make_from_part_feature_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.relating_shape_aspect,
 SELF\shape_aspect_relationship.related_shape_aspect;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.relating_shape_aspect)) = 0;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ] * TYPEOF(SELF.related_shape_aspect)) = 0;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\make_from_part_feature_relationship)) = 0;
      WR4:
         SELF.related_shape_aspect.product_definitional = TRUE;
      WR5:
         SELF.relating_shape_aspect.product_definitional = TRUE;
      WR6:
         SELF\shape_aspect.name = '';
      WR7:
         SELF\shape_aspect.description = '';
      WR8:
         SELF\shape_aspect.product_definitional = FALSE;
      WR9:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')) = 0;
      WR10:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESIGN_MAKE_FROM_RELATIONSHIP' IN TYPEOF(sar.of_shape\property_definition.definition)))) = 1;
   END_ENTITY;



   ENTITY make_from_usage_option
   SUBTYPE OF (product_definition_usage);
      ranking : INTEGER;
      ranking_rationale : text;
      quantity : measure_with_unit;
   WHERE
      WR1:
         NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.value_component > 0);
   END_ENTITY;



   ENTITY manifold_constraining_context_dependent_shape_representation
   SUBTYPE OF (context_dependent_shape_representation,
 representation_relationship);
   END_ENTITY;



   ENTITY manifold_solid_brep
   SUBTYPE OF (solid_model);
      outer : closed_shell;
   END_ENTITY;



   ENTITY manifold_subsurface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
      WR5:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(cfss.parent_face_set)) AND (SIZEOF(QUERY (fac <* cfss.parent_face_set.cfs_faces| NOT advanced_face_properties(fac))) = 0) OR (SIZEOF(QUERY (fac <* cfss.parent_face_set.cfs_faces| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fac)))) >= 0)))) = 0;
      WR6:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| (SIZEOF(QUERY (fac <* cfss\connected_face_set.cfs_faces| NOT advanced_face_properties(fac))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBEDGE' IN TYPEOF(oe.edge_element))))) = 0))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_end))))) = 0))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (bnds <* fcs.bounds| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' ] * TYPEOF(bnds.bound)) = 1))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(QUERY (sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(sc_ag)))) = 0))) = 0))) = 0))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (cfss <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (fcs <* cfss\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(fcs)) AND NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3))) = 0))) = 0))) = 0))) = 0;
   END_ENTITY;



   ENTITY manifold_surface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR4:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (sh <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' ] * TYPEOF(sh)) = 1))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' ] * TYPEOF(fa)) = 1))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (f_sf <* QUERY (fa <* cfs\connected_face_set.cfs_faces| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_SURFACE' IN TYPEOF(fa)))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(f_sf)) OR (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' ] * TYPEOF(f_sf\face_surface.face_geometry)) = 1)))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR msf_surface_check(fa\face_surface.face_geometry)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (bnds <* fa.bounds| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' ] * TYPEOF(bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe_cv <* QUERY (oe <* elp_fbnds\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(oe.edge_element)))| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' ] * TYPEOF(oe_cv.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT msf_curve_check(oe.edge_element\edge_curve.edge_geometry))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR13:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ((SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1) AND (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR14:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) = 0))) = 0;
      WR15:
         SIZEOF(QUERY (sbsm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* sbsm\shell_based_surface_model.sbsm_boundary| NOT (SIZEOF(QUERY (fa <* cfs\connected_face_set.cfs_faces| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' ] * TYPEOF(vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) = 1))) = 0)))) = 0))) = 0))) = 0;
   END_ENTITY;



   ENTITY mapped_item
   SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
   WHERE
      WR1:
         acyclic_mapped_representation(using_representations(SELF),
 [ SELF ]);
   END_ENTITY;



   ENTITY mass_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY mass_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 1.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY material_designation;
      name : label;
      definitions : SET [1:?] OF characterized_definition;
   END_ENTITY;



   ENTITY material_designation_characterization;
      name : label;
      description : text;
      designation : material_designation;
      property : characterized_material_property;
   END_ENTITY;



   ENTITY material_electrical_conductivity_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'conductive',
 'non conductive',
 'resistive',
 'semi conductive' ];
   END_ENTITY;



   ENTITY material_functional_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'bonding agent',
 'potting compound',
 'marking material' ];
   END_ENTITY;



   ENTITY material_optical_conductivity_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'conductive',
 'non conductive',
 'resistive',
 'semi conductive' ];
   END_ENTITY;



   ENTITY material_property
   SUBTYPE OF (property_definition);
   UNIQUE
      UR1 : SELF\property_definition.name,
 SELF\property_definition.definition;
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) OR (SIZEOF(bag_to_set(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - QUERY (temp <* bag_to_set(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp)))) = 0);
   END_ENTITY;



   ENTITY material_property_representation
   SUBTYPE OF (property_definition_representation);
      dependent_environment : data_environment;
   END_ENTITY;



   ENTITY material_removal_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY material_thermal_conductivity_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'conductive',
 'non conductive',
 'resistive',
 'semi conductive' ];
   END_ENTITY;



   ENTITY measure_qualification;
      name : label;
      description : text;
      qualified_measure : measure_with_unit;
      qualifiers : SET [1:?] OF value_qualifier;
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* qualifiers| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRECISION_QUALIFIER' IN TYPEOF(temp)))) < 2;
   END_ENTITY;



   ENTITY measure_representation_item
   SUBTYPE OF (representation_item,
 measure_with_unit);
   END_ENTITY;



   ENTITY measure_with_unit
   SUPERTYPE OF (ONEOF(length_measure_with_unit,
 mass_measure_with_unit,
 time_measure_with_unit,
 electric_current_measure_with_unit,
 thermodynamic_temperature_measure_with_unit,
 celsius_temperature_measure_with_unit,
 amount_of_substance_measure_with_unit,
 luminous_intensity_measure_with_unit,
 plane_angle_measure_with_unit,
 solid_angle_measure_with_unit,
 area_measure_with_unit,
 volume_measure_with_unit,
 ratio_measure_with_unit));
      value_component : measure_value;
      unit_component : unit;
   WHERE
      WR1:
         valid_units(SELF);
   END_ENTITY;



   ENTITY minimally_defined_bare_die_terminal
   SUPERTYPE OF (bare_die_terminal)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'external connection area'))| (eca.related_shape_aspect\shape_aspect.description = 'connection zone'))) <= 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
      WR4:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY model_parameter
   SUBTYPE OF (representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
      WR2:
         SIZEOF(QUERY (cri <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COORDINATED_REPRESENTATION_ITEM' IN TYPEOF(cri)) AND (cri\representation.name = 'model parameter with valid range value'))) <= 1;
      WR3:
         SIZEOF(QUERY (aga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_TYPE' IN TYPEOF(aga.assigned_group)) AND (aga.assigned_group\group.name IN [ 'string property type',
 'logical property type',
 'physical property type',
 'boolean property type' ]))) = 1;
   END_ENTITY;



   ENTITY modified_geometric_tolerance
   SUBTYPE OF (geometric_tolerance);
      modifier : limit_condition;
   END_ENTITY;



   ENTITY mounting_restriction_area
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
      WR3:
         SELF.of_shape.definition.frame_of_reference.name IN [ 'physical design' ];
      WR4:
         SELF.of_shape.definition\product_definition.name = 'assembly module';
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) = 1))) = 0;
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'mounting surface') AND (sar.related_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 1;
      WR7:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\mounting_restriction_area)) = 0;
   END_ENTITY;



   ENTITY mounting_restriction_volume
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SELF.of_shape.definition.frame_of_reference.name IN [ 'physical design' ];
      WR3:
         SELF.of_shape.definition.name = 'assembly module';
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 3))) = 1))) = 0;
      WR5:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'mounting surface')) AND (sar.related_shape_aspect\shape_aspect.description = 'interconnect module component surface feature'))) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\mounting_restriction_volume)) = 0;
   END_ENTITY;



   ENTITY multi_layer_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY multi_layer_material_removal_component_shape_aspect
   SUBTYPE OF (material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY multi_layer_stratum_feature
   SUBTYPE OF (stratum_feature);
   END_ENTITY;



   ENTITY name_attribute;
      attribute_value : label;
      named_item : name_attribute_select;
   END_ENTITY;



   ENTITY named_unit
   SUPERTYPE OF (ONEOF(si_unit,
 conversion_based_unit,
 context_dependent_unit) ANDOR
 ONEOF(length_unit,
 mass_unit,
 time_unit,
 electric_current_unit,
 thermodynamic_temperature_unit,
 amount_of_substance_unit,
 luminous_intensity_unit,
 plane_angle_unit,
 solid_angle_unit,
 area_unit,
 volume_unit,
 ratio_unit));
      dimensions : dimensional_exponents;
   END_ENTITY;



   ENTITY network_node_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'functional network design';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (funtdna <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'functional unit network terminal definition node assignment'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(funtdna.related_property_definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(funtdna.related_property_definition.definition)))) <= 1))) <= 1;
      WR3:
         SIZEOF(QUERY (funn <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(funn.relating_product_definition)) AND (funn.relating_product_definition.frame_of_reference.name = 'functional network design'))) = 1;
   END_ENTITY;



   ENTITY next_assembly_usage_occurrence
   SUBTYPE OF (assembly_component_usage);
   END_ENTITY;



   ENTITY object_role;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY offset_curve_2d
   SUBTYPE OF (curve);
      basis_curve : curve;
      distance : length_measure;
      self_intersect : LOGICAL;
   WHERE
      WR1:
         basis_curve.dim = 2;
   END_ENTITY;



   ENTITY offset_curve_3d
   SUBTYPE OF (curve);
      basis_curve : curve;
      distance : length_measure;
      self_intersect : LOGICAL;
      ref_direction : direction;
   WHERE
      WR1:
         (basis_curve.dim = 3) AND (ref_direction.dim = 3);
   END_ENTITY;



   ENTITY offset_surface
   SUBTYPE OF (surface);
      basis_surface : surface;
      distance : length_measure;
      self_intersect : LOGICAL;
   END_ENTITY;



   ENTITY one_direction_repeat_factor
   SUBTYPE OF (geometric_representation_item);
      repeat_factor : vector;
   END_ENTITY;



   ENTITY open_shell
   SUBTYPE OF (connected_face_set);
   END_ENTITY;



   ENTITY opposing_boundary_dimensional_size
   SUBTYPE OF (dimensional_size);
   WHERE
      WR1:
         SELF\dimensional_size.name IN [ 'angular',
 'linear' ];
   END_ENTITY;



   ENTITY organization;
      id : OPTIONAL identifier;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY organization_assignment
   ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role : organization_role;
   END_ENTITY;



   ENTITY organization_relationship;
      name : label;
      description : OPTIONAL text;
      relating_organization : organization;
      related_organization : organization;
   END_ENTITY;



   ENTITY organization_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY organizational_address
   SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY organizational_project;
      name : label;
      description : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation : BOOLEAN;
   DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
 SELF.closed_shell_element.cfs_faces);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element));
   END_ENTITY;



   ENTITY oriented_edge
   SUBTYPE OF (edge);
      edge_element : edge;
      orientation : BOOLEAN;
   DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
 SELF.edge_element.edge_start,
 SELF.edge_element.edge_end);
      SELF\edge.edge_end : vertex := boolean_choose(SELF.orientation,
 SELF.edge_element.edge_end,
 SELF.edge_element.edge_start);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
   END_ENTITY;



   ENTITY oriented_face
   SUBTYPE OF (face);
      face_element : face;
      orientation : BOOLEAN;
   DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.orientation,
 SELF.face_element.bounds);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
   END_ENTITY;



   ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation : BOOLEAN;
   DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
 SELF.open_shell_element.cfs_faces);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF.open_shell_element));
   END_ENTITY;



   ENTITY oriented_path
   SUBTYPE OF (path);
      path_element : path;
      orientation : BOOLEAN;
   DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := conditional_reverse(SELF.orientation,
 SELF.path_element.edge_list);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
   END_ENTITY;



   ENTITY outer_boundary_curve
   SUBTYPE OF (boundary_curve);
   END_ENTITY;



   ENTITY owner_assignment
   SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF owner_assigned_item;
   END_ENTITY;



   ENTITY package
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'physical design usage';
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' IN TYPEOF(sa)))) = 1))) <= 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(sa)))) >= 1))) >= 1;
      WR5:
         NOT (SELF\product_definition.description = 'altered package') OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package alteration') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pdr.relating_product_definition)) = 1))) = 1);
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data'))) = 1))) = 1;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body height above seating plane'))) = 1))) = 1))) = 1;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body height below seating plane'))) = 1))) = 1))) <= 1;
      WR9:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body clearance above seating plane'))) = 1))) = 1))) <= 1;
      WR10:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum body clearance below seating plane'))) = 1))) = 1))) <= 1;
      WR11:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'minimum body clearance above seating plane'))) = 1))) = 1))) <= 1;
      WR12:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'minimum body clearance below seating plane'))) = 1))) = 1))) <= 1;
      WR13:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'maximum lead length below seating plane'))) = 1))) = 1))) <= 1;
      WR14:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'package mounting data') AND (SIZEOF(QUERY (item <* USEDIN(pdr.used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (item\representation_item.name = 'least lead length below seating plane'))) = 1))) = 1))) <= 1;
      WR15:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sa)) AND (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'package seating plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sar.related_shape_aspect)))) = 1))) = 1))) = 1;
      WR16:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sa)))) = 1))) = 1;
      WR17:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sa)) AND (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'of datum reference plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar.related_shape_aspect)))) = 1))) = 1))) <= 1;
      WR18:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sa)))) = 1))) <= 1;
   END_ENTITY;



   ENTITY package_body
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ]) = 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
   END_ENTITY;



   ENTITY package_body_bottom_surface
   SUBTYPE OF (package_body_surface);
   END_ENTITY;



   ENTITY package_body_edge_segment_surface
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR3:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
      WR4:
         SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed surface'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect)))) = 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\package_body_edge_segment_surface)) = 0;
   END_ENTITY;



   ENTITY package_body_edge_surface
   SUBTYPE OF (package_body_surface);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\part_mounting_feature || SELF\package_body_edge_surface || SELF\package_body_surface)) = 0;
   END_ENTITY;



   ENTITY package_body_surface
   ABSTRACT SUPERTYPE OF (ONEOF(package_body_top_surface,
 package_body_edge_surface,
 package_body_bottom_surface))
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ]) = 1;
      WR2:
         SELF\shape_aspect.product_definitional;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (TYPEOF(sar\shape_aspect_relationship.relating_shape_aspect) = [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY' ]))) = 1;
   END_ENTITY;



   ENTITY package_body_top_surface
   SUBTYPE OF (package_body_surface);
   END_ENTITY;



   ENTITY package_terminal
   SUPERTYPE OF (((altered_package_terminal ANDOR
 guided_wave_terminal) ANDOR
 wire_terminal) ANDOR
 primary_reference_terminal)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR2:
         SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ]) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND (sar\shape_aspect_relationship.name = 'terminal core material')) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference\application_context_element.name = 'material definition'))) <= 1;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND (sar\shape_aspect_relationship.name = 'terminal surface material')) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference\application_context_element.name = 'material definition'))) = 1;
      WR5:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'external connection zone') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'maximum terminal diametrical extent'))) <= 1))) <= 1))) <= 1;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (lmwu <* QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))| (lmwu\representation_item.name = 'minimum terminal diametrical extent'))) <= 1))) <= 1))) <= 1;
      WR9:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) <= 1;
      WR10:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) <= 1;
      WR11:
         SIZEOF(QUERY (eca <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'seating plane zone'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY packaged_component
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1;
      WR2:
         SIZEOF(QUERY (pa <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'package alternate'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(pa.relating_product_definition)) = 1) AND (pa.relating_product_definition\product_definition.description = 'altered package'))) <= 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'packaged component join terminal'))) >= 1))) = 0;
      WR4:
         NOT (SELF\product_definition.description = 'packaged connector component') OR (SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(ip.relating_product_definition)) = 1) AND TRUE)) = 1);
      WR5:
         NOT (SELF\product_definition.description = 'packaged connector component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'packaged component join terminal'))) >= 1))) = 0);
      WR6:
         NOT (SELF\product_definition.description = 'routed packaged component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (pd <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1))) = 1))) = 1))) = 0);
   END_ENTITY;



   ENTITY packaged_connector
   SUBTYPE OF (packaged_part);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sa)))) = 1))) >= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'interface plane'))) = 1))) = 1))) <= 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE' IN TYPEOF(sa)))) = 1))) <= 1;
   END_ENTITY;



   ENTITY packaged_connector_terminal_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         (SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ]) = 1) AND (SELF.of_shape.definition\product_definition.description = 'packaged connector');
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect)) AND (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'interface terminal');
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect)) AND (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'join terminal');
   END_ENTITY;



   ENTITY packaged_part
   SUPERTYPE OF (packaged_connector)
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))) >= 0))) = 0;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
      WR3:
         SIZEOF(QUERY (ifu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)) AND (ifu.relating_product_definition.frame_of_reference.name = 'functional design usage'))) <= 1;
      WR4:
         NOT EXISTS(SELF\product_definition.description) OR (NOT (SELF\product_definition.description = 'altered packaged part') OR (SIZEOF(QUERY (bpp <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'base packaged part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(bpp.relating_product_definition)) = 1) AND (bpp.relating_product_definition.frame_of_reference.name = 'physical design usage'))) >= 1));
      WR5:
         SIZEOF(QUERY (upkg <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE') ] * TYPEOF(upkg.relating_product_definition)) = 1))) >= 1;
      WR6:
         SELF.frame_of_reference.name = 'physical design usage';
   END_ENTITY;



   ENTITY packaged_part_terminal
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ];
      WR2:
         (SIZEOF(TYPEOF(SELF.of_shape.definition) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ]) = 1) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design usage');
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR4:
         SIZEOF(QUERY (top <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'terminal of package'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(top.related_shape_aspect)))) >= 1;
      WR5:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
      WR6:
         NOT (SELF\shape_aspect.description = 'interface terminal') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar)) AND (sar.relating_shape_aspect\shape_aspect.description = 'join terminal'))) >= 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'join terminal') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar)) AND (sar.relating_shape_aspect\shape_aspect.description = 'interface terminal'))) <= 1);
   END_ENTITY;



   ENTITY padstack_definition
   SUPERTYPE OF (ONEOF(design_layer_type_specific_padstack_definition,
 stratum_occurrence_specific_padstack_definition,
 stratum_type_independent_padstack_definition))
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\padstack_definition)) = 0;
      WR7:
         SELF.frame_of_reference.name IN [ 'layout design usage' ];
      WR9:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'template model'))) = 1;
   END_ENTITY;



   ENTITY padstack_occurrence
   SUBTYPE OF (assembly_group_component_shape_aspect);
   END_ENTITY;



   ENTITY padstack_occurrence_shape_aspect_relationship
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\padstack_occurrence_shape_aspect_relationship)) = 0;
      WR3:
         SELF\shape_aspect_relationship.name = 'padstack occurrence sub assembly relationship';
   END_ENTITY;



   ENTITY parabola
   SUBTYPE OF (conic);
      focal_dist : length_measure;
   WHERE
      WR1:
         focal_dist <> 0.00000;
   END_ENTITY;



   ENTITY parallelism_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'parallelism';
   END_ENTITY;



   ENTITY parameter_assignment_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(SELF.items) = 2;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(TYPEOF(it) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER') ]) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(TYPEOF(it) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COORDINATED_REPRESENTATION_ITEM') ]) = 1))) <= 1;
      WR4:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF(QUERY (aga <* USEDIN(it,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| (SIZEOF(TYPEOF(aga\group_assignment.assigned_group) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERISTIC_TYPE') ]) = 1))) = 1))) <= 1;
      WR5:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\parameter_assignment_representation)) = 0;
   END_ENTITY;



   ENTITY parameter_type
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'string property type',
 'logical property type',
 'physical property type',
 'boolean property type' ];
   END_ENTITY;



   ENTITY parametric_representation_context
   SUBTYPE OF (representation_context);
   END_ENTITY;



   ENTITY part_connected_terminals_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL') ] * TYPEOF(mct.related_shape_aspect)) = 1))) >= 2;
   END_ENTITY;



   ENTITY part_interface_access_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'interface_access area') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY part_mating_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'mating area') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY part_mounting_feature
   SUPERTYPE OF (bare_die_surface)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'mounting area') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;



   ENTITY part_template_definition
   SUPERTYPE OF (dependent_material_removal_feature_template)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.of_shape\property_definition.definition.frame_of_reference\application_context_element.name = 'template definition';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'part template analytical model'))) <= 1))) = 0;
      WR3:
         NOT (SELF\shape_aspect.description = 'component termination passage template') OR (SIZEOF(QUERY (ctpt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(ctpt.relating_shape_aspect)) AND (ctpt.relating_shape_aspect\shape_aspect.description = 'default component termination passage definition'))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description = 'component termination passage template') OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access mechanism'))| (am.related_shape_aspect\shape_aspect.description IN [ 'component termination passage template interface terminal',
 'component termination passage template join terminal' ]))) >= 2);
      WR5:
         NOT (SELF\shape_aspect.description = 'default trace template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'inter stratum feature template') OR (SIZEOF(QUERY (isfpt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(isfpt.relating_shape_aspect)))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'printed connector template') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name IN [ 'connector' ]))) >= 1);
      WR8:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = 'transmission line model'))) = 1))) = 0);
      WR9:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2))) = 2))) = 1))) = 0);
      WR10:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum width'))) = 1))) = 1))) = 0);
      WR11:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum width'))) = 1))) = 1))) = 0);
      WR12:
         NOT (SELF\shape_aspect.description = 'printed part template') OR (SIZEOF(QUERY (impl_func <* QUERY (pdr <* USEDIN(SELF.of_shape.definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(impl_func.relating_product_definition)) AND (impl_func.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR13:
         NOT (SELF\shape_aspect.description = 'printed part template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(ad.related_shape_aspect)) AND (ad.related_shape_aspect\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ]))) >= 2);
      WR14:
         NOT (SELF\shape_aspect.description = 'trace template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'curve style parameters'))) = 1))) = 1);
      WR15:
         NOT (SELF\shape_aspect.description = 'unsupported passage template') OR (SIZEOF(QUERY (upt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(upt.relating_shape_aspect)) AND (upt.relating_shape_aspect\shape_aspect.description = 'default unsupported passage definition'))) = 1);
      WR16:
         NOT (SELF\shape_aspect.description = 'via template') OR (SIZEOF(QUERY (vpt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'inter stratum feature passage technology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(vpt.relating_shape_aspect)) AND (vpt.relating_shape_aspect\shape_aspect.description = 'default via definition'))) = 1);
      WR17:
         NOT (SELF\shape_aspect.description = 'via template') OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access mechanism'))| (am.related_shape_aspect\shape_aspect.description = 'via template terminal'))) >= 2);
      WR18:
         EXISTS(SELF\shape_aspect.name);
      WR19:
         NOT (SELF\shape_aspect.description = 'non conductive cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1);
      WR20:
         NOT (SELF\shape_aspect.description = 'non conductive cross section template') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'nominal width'))) = 1))) = 1))) = 0);
      WR21:
         NOT (SELF\shape_aspect.description = 'printed connector template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(ad.related_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ]))) >= 2);
      WR22:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'horizontal material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'left'))))) = 0);
      WR27:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'horizontal material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'right'))))) = 0);
      WR28:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'vertical material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'bottom'))))) = 0);
      WR29:
         NOT (SELF\shape_aspect.description = 'printed part cross section template') OR (SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'vertical material link'))| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(ad.relating_shape_aspect)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect)) AND (ad.relating_shape_aspect\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'top'))))) = 0);
      WR30:
         SELF\shape_aspect.name = 'NULL';
   END_ENTITY;



   ENTITY part_text_template_definition
   SUBTYPE OF (part_template_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_LITERAL' IN TYPEOF(it)))) = 1))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum font vertical extent'))) = 1))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum font horizontal extent'))) = 1))) = 1))) = 0;
   END_ENTITY;



   ENTITY part_tooling_feature
   SUPERTYPE OF (fiducial_part_feature ANDOR
 test_point_part_feature)
   SUBTYPE OF (shape_aspect);
   END_ENTITY;



   ENTITY passage_technology
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,
 SELF\shape_aspect.of_shape;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT ((1 <= SIZEOF(pcr.used_representation.items)) AND (SIZEOF(pcr.used_representation.items) <= 8)))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| NOT (it\representation_item.name IN [ 'maximum aspect ratio',
 'plated passage',
 'maximum allowed component terminal extent',
 'minimum allowed component terminal extent',
 'maximum as finished deposition thickness',
 'minimum as finished deposition thickness',
 'maximum as finished passage extent',
 'minimum as finished passage extent' ]))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| ((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RATIO_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum aspect ratio')) AND (it\measure_with_unit.value_component > 1.00000))) <= 1))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'plated passage')) AND (it\descriptive_representation_item.description IN [ 'true',
 'false' ]))) = 1))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished passage extent'))) <= 1))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum as finished deposition thickness'))) <= 1))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished deposition thickness'))) <= 1))) = 0))) = 0;
      WR11:
         NOT (SELF\shape_aspect.description IN [ 'default component termination passage definition',
 'default via definition' ]) OR (SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
      WR12:
         NOT (SELF\shape_aspect.description IN [ 'default component termination passage definition',
 'default unsupported passage definition',
 'default via definition' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished passage extent'))) = 1))) = 0))) = 0);
      WR13:
         NOT (SELF\shape_aspect.description = 'default component termination passage definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished deposition thickness'))) = 1))) = 0))) = 0);
      WR14:
         NOT (SELF\shape_aspect.description = 'default component termination passage definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum allowed component terminal extent'))) = 1))) = 0))) = 0);
      WR15:
         NOT (SELF\shape_aspect.description = 'default component termination passage definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum allowed component terminal extent'))) = 1))) = 0))) = 0);
      WR16:
         NOT (SELF\shape_aspect.description = 'default via definition') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum as finished deposition thickness'))) = 1))) = 0))) = 0);
      WR17:
         SIZEOF(QUERY (rpt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'as finished inter stratum extent'))| (rpt.related_shape_aspect.of_shape\property_definition.description = 'finished stratum extent') AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(rpt.related_shape_aspect.of_shape\property_definition.definition)) AND (rpt.related_shape_aspect.of_shape\property_definition.definition\product_definition_relationship.name = 'inter stratum extent')))) = 1;
   END_ENTITY;



   ENTITY path
   SUPERTYPE OF (ONEOF(edge_loop,
 oriented_path))
   SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
   WHERE
      WR1:
         path_head_to_tail(SELF);
   END_ENTITY;



   ENTITY pcurve
   SUBTYPE OF (curve);
      basis_surface : surface;
      reference_to_curve : definitional_representation;
   WHERE
      WR1:
         SIZEOF(reference_to_curve\representation.items) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
      WR3:
         reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY perpendicularity_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'perpendicularity';
   END_ENTITY;



   ENTITY person;
      id : identifier;
      last_name : OPTIONAL label;
      first_name : OPTIONAL label;
      middle_names : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
   WHERE
      WR1:
         EXISTS(last_name) OR EXISTS(first_name);
   END_ENTITY;



   ENTITY person_and_organization;
      the_person : person;
      the_organization : organization;
   DERIVE
      name : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY person_and_organization_assignment
   ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role : person_and_organization_role;
   END_ENTITY;



   ENTITY person_and_organization_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY person_assignment
   ABSTRACT SUPERTYPE;
      assigned_person : person;
      role : person_role;
   END_ENTITY;



   ENTITY person_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY personal_address
   SUBTYPE OF (address);
      people : SET [1:?] OF person;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY physical_connectivity_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name,
 SELF\shape_aspect.of_shape;
   WHERE
      WR1:
         SIZEOF(QUERY (at <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(at.related_shape_aspect)) AND ((((((at.related_shape_aspect\shape_aspect.description = 'assembly module component terminal') OR (at.related_shape_aspect\shape_aspect.description = 'bare die component terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'interconnect component join terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'interconnect module component terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'minimally defined component terminal')) OR (at.related_shape_aspect\shape_aspect.description = 'packaged component join terminal')))) > 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'connectivity allocation'))) = 1))) <= 1;
   END_ENTITY;



   ENTITY physical_connectivity_element
   SUBTYPE OF (shape_aspect_relationship,
 shape_aspect);
   WHERE
      WR1:
         (SELF.relating_shape_aspect\shape_aspect.description = 'topological junction') XOR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(SELF.relating_shape_aspect)) = 1);
      WR2:
         (SELF.related_shape_aspect\shape_aspect.description = 'topological junction') XOR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(SELF.related_shape_aspect)) = 1);
      WR3:
         SIZEOF(QUERY (se <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'structure element'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(se.relating_shape_aspect)))) = 1;
      WR4:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.frame_of_reference.name = 'physical design');
   END_ENTITY;



   ENTITY physical_network
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (cr <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connectivity requirement'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(cr.related_shape_aspect)) AND ((((cr.related_shape_aspect\shape_aspect.description = 'component termination passage join terminal') OR (cr.related_shape_aspect\shape_aspect.description = 'land join terminal')) OR (cr.related_shape_aspect\shape_aspect.description = 'non functional land join terminal')) OR (cr.related_shape_aspect\shape_aspect.description = 'printed component join terminal')))) >= 2;
      WR2:
         SIZEOF(QUERY (nt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'network topology'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(nt.related_shape_aspect)))) >= 1;
      WR3:
         SIZEOF(QUERY (nt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'reference connected terminals'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(nt.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY physical_node_requirement_to_implementing_component_allocation
   SUBTYPE OF (shape_aspect_relationship,
 shape_aspect);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.related_shape_aspect.of_shape\property_definition.definition)) AND NOT (SELF.related_shape_aspect.of_shape\property_definition.definition\product_definition.description IN [ 'laminate component' ]);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.relating_shape_aspect);
      WR3:
         acyclic_shape_aspect_relationship(SELF,
 [ SELF\shape_aspect_relationship.related_shape_aspect ],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION');
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\physical_node_requirement_to_implementing_component_allocation)) = 0;
   END_ENTITY;



   ENTITY physical_unit
   SUPERTYPE OF (ONEOF(bare_die,
 package,
 packaged_part,
 assembly_definition,
 interconnect_definition,
 reference_packaged_part_assembly_implementation,
 reference_packaged_part_interconnect_implementation))
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SELF.frame_of_reference.name IN [ 'physical design',
 'physical design usage' ];
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (dut <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'physical unit technology'))| (dut.relating_property_definition\property_definition.name = 'unit technology'))) = 1))) <= 1;
      WR8:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)))) >= 1))) = 0);
      WR9:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum negative component height'))) <= 1))) = 0);
      WR10:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum positive component height'))) <= 1))) = 0);
      WR11:
         NOT is_assembly_module_usage(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.relating_product_definition.frame_of_reference.name = 'functional design usage'))) = 1);
      WR12:
         NOT is_assembly_module_design(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')| is_laminate_component(pdr.related_product_definition))) = 0);
      WR14:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.relating_product_definition.frame_of_reference.name = 'functional design usage'))) <= 1);
      WR15:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd1 <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd1)) AND (SIZEOF(QUERY (cd <* USEDIN(pd1,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_DEFINITION' IN TYPEOF(cd)) AND (SIZEOF(QUERY (pd2 <* USEDIN(cd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd2\property_definition.name = 'located interconnect module thickness') AND (SIZEOF(USEDIN(pd2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) > 1))) = 1))) = 1))) <= 1);
      WR16:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics'))) <= 1);
      WR17:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'minimum thickness over metal requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR18:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum thickness over metal requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR19:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'minimum thickness over dielectric requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR20:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'interconnect module usage view physical characteristics') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'maximum thickness over dielectric requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation)))) <= 1))) <= 1);
      WR21:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'restraint') OR (pd\property_definition.name = 'tolerance specific restraint'))) <= 1);
      WR22:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'interconnect module primary surface'))) <= 1))) = 0);
      WR23:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'interconnect module secondary surface'))) <= 1))) = 0);
      WR24:
         NOT is_interconnect_module_usage(SELF) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'interconnect module edge surface'))) <= 1))) = 0);
      WR25:
         NOT is_assembly_module_design(SELF) OR (NOT (((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(sa)))) > 0))) = 0)) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(sa)) AND (SIZEOF(QUERY (acu <* USEDIN(sa\shape_aspect_relationship.relating_shape_aspect.of_shape.definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) >= 1))) >= 1))) >= 1));
      WR26:
         NOT is_assembly_module_design(SELF) OR (NOT ((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (acu <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu)) AND (acu\product_definition_relationship.relating_product_definition = SELF))) = 0))) = 0));
      WR27:
         NOT is_assembly_module_design(SELF) OR (NOT ((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)))) = 0) OR (SIZEOF(QUERY (aj <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT' IN TYPEOF(aj)) AND (SIZEOF(QUERY (cl <* USEDIN(aj\shape_aspect_relationship.related_shape_aspect.of_shape.definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION' IN TYPEOF(cl)) AND (aj IN cl\representation.items))) = 0))) = 0));
      WR28:
         NOT is_interconnect_module_design(SELF) OR (NOT ((SELF.frame_of_reference.name = 'physical design') AND (SELF\product_definition.name = 'interconnect module')) OR (SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'interconnect module stratum assembly relationship')) AND (pdr.related_product_definition\product_definition.description = 'primary design layer stratum')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.related_product_definition)))) = 1));
   END_ENTITY;



   ENTITY physical_unit_datum
   SUPERTYPE OF (edge_segment_vertex)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'axis',
 'plane',
 'point',
 '' ];
      WR2:
         SELF\shape_aspect.product_definitional = FALSE;
      WR3:
         SELF\shape_aspect.name IN [ 'single datum',
 'common datum',
 '' ];
      WR4:
         NOT (SELF\shape_aspect.name = 'common datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in datum system') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(sar)))) >= 1);
      WR5:
         NOT (SELF\shape_aspect.name = 'common datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in common datum') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(sar)))) >= 2);
      WR6:
         NOT ((SELF\shape_aspect.description = 'axis') AND (SELF\shape_aspect.name IN [ 'common datum',
 'single datum' ])) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT (sar\shape_aspect_relationship.name = 'reference axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar)))) = 1);
      WR7:
         NOT ((SELF\shape_aspect.description = 'plane') AND (SELF\shape_aspect.name IN [ 'common datum',
 'single datum' ])) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT (sar\shape_aspect_relationship.name = 'reference plane') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar)))) = 1);
      WR8:
         NOT ((SELF\shape_aspect.description = 'point') AND (SELF\shape_aspect.name IN [ 'common datum',
 'single datum' ])) OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT (sar\shape_aspect_relationship.name = 'reference origin') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar)))) = 1);
      WR9:
         NOT (SELF\shape_aspect.name = 'single datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum usage in datum system') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(sar)))) >= 1);
      WR10:
         NOT (SELF\shape_aspect.name = 'single datum') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in single datum') AND TRUE)) <= 1);
      WR11:
         NOT ((SELF\shape_aspect.name IN [ '' ]) AND (SELF\shape_aspect.description IN [ '' ]));
      WR12:
         NOT (SELF\shape_aspect.description = 'plane') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'datum direction property'))) <= 2);
   END_ENTITY;



   ENTITY physical_unit_datum_feature
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')| (pd\property_definition.description = 'datum feature identification'))) = 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name IN [ 'datum feature usage in common datum',
 'datum feature usage in single datum' ]))) >= 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum feature usage in single datum'))) <= 1;
   END_ENTITY;



   ENTITY physical_unit_datum_target
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum target usage'))) >= 1;
   END_ENTITY;



   ENTITY physical_unit_datum_target_set
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'datum target usage'))) >= 1;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'constituent'))) = 0;
   END_ENTITY;



   ENTITY physical_unit_geometric_tolerance
   SUBTYPE OF (geometric_tolerance,
 property_definition);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = SELF\property_definition.name;
      WR2:
         SELF\geometric_tolerance.toleranced_shape_aspect = SELF\property_definition.definition;
      WR3:
         NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_PROFILE_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE') ] * TYPEOF(SELF)) = 0) OR (SELF\geometric_tolerance.name IN [ 'circularity',
 'cylindricity',
 'flatness',
 'straightness' ]);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'circularity') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR5:
         NOT (SELF\geometric_tolerance.name = 'cylindricity') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR6:
         NOT (SELF\geometric_tolerance.name = 'flatness') OR NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR7:
         SIZEOF(QUERY (pugt <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'group geometric tolerance'))| (pugt.relating_shape_aspect\shape_aspect.description = 'simultaneous requirement'))) <= 1;
   END_ENTITY;



   ENTITY physical_unit_network_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\physical_unit_network_definition)) = 0;
      WR7:
         SELF.frame_of_reference.name IN [ 'physical network design' ];
   END_ENTITY;



   ENTITY placement
   SUPERTYPE OF (ONEOF(axis1_placement,
 axis2_placement_2d,
 axis2_placement_3d))
   SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
   END_ENTITY;



   ENTITY planar_extent
   SUBTYPE OF (geometric_representation_item);
      size_in_x : length_measure;
      size_in_y : length_measure;
   END_ENTITY;



   ENTITY plane
   SUBTYPE OF (elementary_surface);
   END_ENTITY;



   ENTITY plane_angle_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY plane_angle_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY plated_cutout_edge_segment
   SUBTYPE OF (cutout_edge_segment,
 plated_inter_stratum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated cutout edge segment' ];
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         NOT (SELF\shape_aspect.description = 'plated cutout edge segment') OR (SIZEOF(QUERY (cc <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed cutout'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect)) AND (cc.relating_shape_aspect\shape_aspect.description = 'plated cutout'))) = 1);
   END_ENTITY;



   ENTITY plated_inter_stratum_feature
   SUPERTYPE OF (ONEOF(plated_passage,
 plated_cutout_edge_segment,
 plated_interconnect_module_edge_segment))
   SUBTYPE OF (inter_stratum_feature);
   WHERE
      WR1:
         (SELF\shape_aspect.description IN [ 'bonded conductive base blind via',
 'buried via',
 'component termination passage',
 'interfacial connection',
 'non conductive base blind via',
 'join two physical connectivity definition supporting inter stratum feature',
 'plated conductive base blind via',
 'plated cutout',
 'plated interconnect module edge' ]) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_CUTOUT_EDGE_SEGMENT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTERCONNECT_MODULE_EDGE_SEGMENT') ] * TYPEOF(SELF)) = 1);
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
   END_ENTITY;



   ENTITY plated_interconnect_module_edge_segment
   SUBTYPE OF (interconnect_module_edge_segment,
 plated_inter_stratum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'plated interconnect module edge segment' ];
      WR2:
         SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) <= 1;
      WR3:
         NOT (SELF\shape_aspect.description = 'plated interconnect module edge segment') OR (SIZEOF(QUERY (ce <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composed edge'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect)) AND (ce.relating_shape_aspect\shape_aspect.description = 'plated interconnect module edge'))) = 1);
   END_ENTITY;



   ENTITY plated_passage
   SUBTYPE OF (plated_inter_stratum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'bonded conductive base blind via',
 'buried via',
 'component termination passage',
 'interfacial connection',
 'non conductive base blind via',
 'plated conductive base blind via' ];
      WR2:
         NOT (SELF\shape_aspect.description = 'bonded conductive base blind via') OR (SIZEOF(QUERY (fj <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'features join'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP' IN TYPEOF(fj.relating_shape_aspect)) AND (fj.relating_shape_aspect\shape_aspect.name = 'stratum feature conductive join'))) = 1);
      WR3:
         NOT (SELF\shape_aspect.description = 'component termination passage') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'component termination passage template'))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description IN [ 'bonded conductive base blind via',
 'buried via',
 'interfacial connection',
 'non conductive base blind via',
 'plated conductive base blind via' ]) OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'via template'))) = 1);
   END_ENTITY;



   ENTITY plus_minus_tolerance;
      range : tolerance_method_definition;
      toleranced_dimension : dimensional_characteristic;
   UNIQUE
      UR1 : toleranced_dimension;
   END_ENTITY;



   ENTITY point
   SUPERTYPE OF (ONEOF(cartesian_point,
 point_on_curve,
 point_on_surface,
 point_replica,
 degenerate_pcurve))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY point_on_curve
   SUBTYPE OF (point);
      basis_curve : curve;
      point_parameter : parameter_value;
   END_ENTITY;



   ENTITY point_on_surface
   SUBTYPE OF (point);
      basis_surface : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
   END_ENTITY;



   ENTITY point_replica
   SUBTYPE OF (point);
      parent_pt : point;
      transformation : cartesian_transformation_operator;
   WHERE
      WR1:
         transformation.dim = parent_pt.dim;
      WR2:
         acyclic_point_replica(SELF,
 parent_pt);
   END_ENTITY;



   ENTITY poly_loop
   SUBTYPE OF (loop,
 geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
   END_ENTITY;



   ENTITY polygonal_area
   SUBTYPE OF (primitive_2d);
      bounds : LIST [3:?] OF UNIQUE cartesian_point;
   END_ENTITY;



   ENTITY polyline
   SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
   END_ENTITY;



   ENTITY position_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         NOT (SELF\geometric_tolerance.name = 'boundary based position') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
      WR2:
         NOT (SELF\geometric_tolerance.name = 'boundary based position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(gtr.related_geometric_tolerance)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance))) AND (gtr.related_geometric_tolerance\geometric_tolerance.name IN [ 'surface profile',
 'surface profile locating',
 'surface profile refinement' ])) AND (gtr\geometric_tolerance_relationship.name = 'profile control'))) <= 1);
      WR3:
         NOT (SELF\geometric_tolerance.name = 'feature relating position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| ((gtr\geometric_tolerance_relationship.name = 'position refining control') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))) AND (gtr.relating_geometric_tolerance\geometric_tolerance.name IN [ 'feature locating position',
 'feature relating position' ]))) = 1);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'feature locating position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'feature relating position')) AND (gtr\geometric_tolerance_relationship.name = 'position refining control'))) = 1);
      WR5:
         NOT (SELF\geometric_tolerance.name = 'feature relating position') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITION_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'feature relating position')) AND (gtr\geometric_tolerance_relationship.name = 'position refining control'))) <= 1);
   END_ENTITY;



   ENTITY positional_boundary
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'dimension related positional boundary',
 'profile related positional boundary' ];
      WR2:
         SELF\shape_aspect.product_definitional = FALSE;
      WR3:
         NOT (SELF\shape_aspect.description = 'dimension related positional boundary') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'boundary member'))) >= 1);
      WR4:
         NOT (SELF\shape_aspect.description = 'dimension related positional boundary') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect.product_definitional = FALSE) AND (sar\shape_aspect_relationship.name = 'constrained feature'))) + SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'constrained feature'))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'dimension related positional boundary') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'dimension related positional boundary property'))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'profile related positional boundary') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'profile related positional boundary property'))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'profile related positional boundary') OR (SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'positional boundary and profile boundary member'))) = 1);
   END_ENTITY;



   ENTITY positional_boundary_member
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = FALSE;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'positional boundary member property'))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'boundary member') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(sar.relating_shape_aspect))) AND (sar.relating_shape_aspect\shape_aspect.description = 'dimension related positional boundary'))) = 1;
   END_ENTITY;



   ENTITY power_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\power_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = watt;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY pre_defined_curve_font
   SUBTYPE OF (pre_defined_item);
   END_ENTITY;



   ENTITY pre_defined_item;
      name : label;
   END_ENTITY;



   ENTITY pre_defined_parallel_datum_axis_symbol_3d_2d_relationship
   SUBTYPE OF (volume_shape_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\volume_shape_intersection || SELF\pre_defined_parallel_datum_axis_symbol_3d_2d_relationship)) = 0;
   END_ENTITY;



   ENTITY pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship
   SUBTYPE OF (volume_shape_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\volume_shape_intersection || SELF\pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship)) = 0;
   END_ENTITY;



   ENTITY pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship
   SUBTYPE OF (volume_shape_intersection);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\volume_shape_intersection || SELF\pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship)) = 0;
   END_ENTITY;



   ENTITY precision_qualifier;
      precision_value : INTEGER;
   END_ENTITY;



   ENTITY presentation_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SELF\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
   END_ENTITY;



   ENTITY presentation_style_assignment;
      styles : SET [1:?] OF presentation_style_select;
   WHERE
      WR1:
         SIZEOF(QUERY (style1 <* SELF.styles| NOT (SIZEOF(QUERY (style2 <* SELF.styles - style1| NOT ((TYPEOF(style1) <> TYPEOF(style2)) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_STYLE_USAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_STYLE') ] * TYPEOF(style1)) = 1)))) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (style1 <* SELF.styles| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_STYLE_USAGE' IN TYPEOF(style1)))) <= 2;
   END_ENTITY;



   ENTITY presentation_style_by_context
   SUBTYPE OF (presentation_style_assignment);
      style_context : style_context_select;
   END_ENTITY;



   ENTITY pressure_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\pressure_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = pascal;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY primary_orientation_feature
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SELF\shape_aspect.product_definitional = TRUE;
      WR2:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY primary_reference_terminal
   SUBTYPE OF (package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feaure'))) <= 1;
   END_ENTITY;



   ENTITY primitive_2d
   SUPERTYPE OF (ONEOF(circular_area,
 elliptic_area,
 rectangular_area,
 polygonal_area))
   SUBTYPE OF (geometric_representation_item);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;



   ENTITY printed_component
   SUPERTYPE OF (layout_macro_component)
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SELF.frame_of_reference.name = 'layout occurrence';
      WR2:
         SELF\product_definition.description = 'printed component';
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'part template occurrence'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description IN [ 'printed part template',
 'printed part cross section template',
 'printed connector template' ]))) = 1))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'printed component join terminal'))) >= 1))) = 0;
      WR5:
         NOT (SELF\product_definition.description = 'printed connector component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAMINATE_COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(sa)) AND (sa\shape_aspect.description = 'printed connector component interface terminal'))) >= 1))) = 0);
      WR6:
         NOT (SELF\product_definition.description = 'printed connector component') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pt_occ <* QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (sa\shape_aspect.description = 'part template occurrence'))| (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(pt_occ,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated template'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect)) AND (it.relating_shape_aspect\shape_aspect.description = 'printed connector template'))) = 1))) = 1))) = 0);
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND (sar\shape_aspect_relationship.name = 'stratum feature implementation')) AND (sar.relating_shape_aspect.description = 'stratum feature template component'))) >= 1))) >= 1))) >= 1;
   END_ENTITY;



   ENTITY printed_component_link
   SUBTYPE OF (product_definition,
 product_definition_relationship);
   WHERE
      WR1:
         SELF\product_definition_relationship.related_product_definition :<>: SELF\product_definition_relationship.relating_product_definition;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.related_product_definition);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF\product_definition_relationship.relating_product_definition);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\product_definition_relationship || SELF\printed_component_link)) = 0;
      WR5:
         EXISTS(SELF\product_definition.name);
      WR6:
         SELF\product_definition.name = '';
      WR7:
         SELF\product_definition_relationship.name = '';
      WR8:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
   END_ENTITY;



   ENTITY printed_connector_template_terminal_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.relating_shape_aspect,
 SELF\shape_aspect_relationship.related_shape_aspect;
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'connector') AND (sar.relating_shape_aspect\shape_aspect.description = 'printed connector template'))) = 1;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect)) AND (SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'interface terminal');
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect)) AND (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'join terminal');
      WR4:
         SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
   END_ENTITY;



   ENTITY printed_part_cross_section_template_terminal
   SUBTYPE OF (printed_part_template_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'cross section definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(am.relating_shape_aspect)) AND (am.relating_shape_aspect\shape_aspect.description = 'printed part cross section template'))) = 1;
      WR2:
         SIZEOF(QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN TYPEOF(ga.assigned_group)) AND (ga.assigned_group.name IN [ 'area edge segment',
 'curve edge segment' ]))) = 1;
      WR3:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR4:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR5:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR6:
         SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) <= 1;
      WR7:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal') OR (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR8:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal') OR (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR9:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal') OR (sar\shape_aspect_relationship.name = 'material to left of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR10:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal') OR (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR11:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to right of terminal') OR (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
      WR12:
         NOT ((SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1) AND (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 1)) OR (SIZEOF(QUERY (am <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material to top of terminal') OR (sar\shape_aspect_relationship.name = 'material to bottom of terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect)))) = 2);
   END_ENTITY;



   ENTITY printed_part_template_connected_terminals_definition
   SUBTYPE OF (shape_aspect);
   UNIQUE
      UR1 : SELF\shape_aspect.name;
   WHERE
      WR1:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(mct.related_shape_aspect)) AND (mct.related_shape_aspect\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ]))) >= 2;
   END_ENTITY;



   ENTITY printed_part_template_link
   SUBTYPE OF (stratum_technology_link,
 shape_aspect_relationship);
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship || SELF\printed_part_template_link || SELF\property_definition || SELF\stratum_technology_link || SELF\shape_aspect_relationship)) = 0;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR5:
         SELF\shape_aspect_relationship.name = '';
      WR6:
         SELF\shape_aspect_relationship.description = '';
      WR7:
         SELF\shape_aspect_relationship.related_shape_aspect.description = 'printed part template';
      WR8:
         SELF\shape_aspect_relationship.relating_shape_aspect.description = 'printed part template';
   END_ENTITY;



   ENTITY printed_part_template_material
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION' IN TYPEOF(pdr.used_representation)))| ((sr_pdr.used_representation\representation.name = 'physical characteristics representation') AND (SIZEOF(sr_pdr.used_representation.items) = 2)) AND (SIZEOF(QUERY (it <* sr_pdr.used_representation.items| (it\representation_item.name IN [ 'maximum width',
 'minimum width' ]))) = 2))) = 1))) = 0;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\printed_part_template_material)) = 0;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'top'))) <= 1))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'bottom'))) <= 1))) = 0;
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'left'))) <= 1))) = 0;
      WR7:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa)) AND (sa.description = 'right'))) <= 1))) = 0;
   END_ENTITY;



   ENTITY printed_part_template_material_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : SELF\shape_aspect_relationship.related_shape_aspect,
 SELF\shape_aspect_relationship.relating_shape_aspect;
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\printed_part_template_material_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SELF\shape_aspect_relationship.related_shape_aspect.of_shape :<>: SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
      WR8:
         SELF\shape_aspect_relationship.relating_shape_aspect.description IN [ 'bottom',
 'right' ];
      WR9:
         SELF\shape_aspect_relationship.related_shape_aspect.description IN [ 'top',
 'left' ];
   END_ENTITY;



   ENTITY printed_part_template_terminal
   SUPERTYPE OF (printed_part_cross_section_template_terminal)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ];
      WR2:
         SIZEOF(QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN TYPEOF(ga.assigned_group)))) = 1;
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))) >= 1))) = 0;
      WR5:
         SIZEOF(QUERY (ad <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(ad.relating_shape_aspect)) AND ((ad.relating_shape_aspect\shape_aspect.description = 'printed part template') OR (ad.relating_shape_aspect\shape_aspect.description = 'printed connector template')))) = 1;
      WR6:
         SIZEOF(QUERY (mct <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'member connected terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY printed_part_template_terminal_connection_zone_category
   SUBTYPE OF (group);
   WHERE
      WR1:
         SELF\group.name IN [ 'area edge segment',
 'curve edge segment',
 'surface area',
 'surface point' ];
   END_ENTITY;



   ENTITY probe_access_area
   SUBTYPE OF (component_shape_aspect);
   WHERE
      WR1:
         EXISTS(SELF.of_shape.definition\product_definition.name);
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)) AND (SELF.of_shape.definition\product_definition.name = 'interconnect module');
      WR3:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
      WR4:
         SIZEOF(QUERY (pli <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'probed layout item'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(pli.related_shape_aspect)))) = 1;
      WR5:
         NOT (SELF\shape_aspect.description = 'internal probe access area') OR (SIZEOF(QUERY (i <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(i.relating_shape_aspect)))) = 1);
   END_ENTITY;



   ENTITY product;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
   END_ENTITY;



   ENTITY product_category;
      name : label;
      description : OPTIONAL text;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY product_category_relationship;
      name : label;
      description : OPTIONAL text;
      category : product_category;
      sub_category : product_category;
   WHERE
      WR1:
         acyclic_product_category_relationship(SELF,
 [ SELF.sub_category ]);
   END_ENTITY;



   ENTITY product_concept;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      market_context : product_concept_context;
   UNIQUE
      UR1 : id;
   END_ENTITY;



   ENTITY product_concept_context
   SUBTYPE OF (application_context_element);
      market_segment_type : label;
   END_ENTITY;



   ENTITY product_context
   SUBTYPE OF (application_context_element);
      discipline_type : label;
   END_ENTITY;



   ENTITY product_definition;
      id : identifier;
      description : OPTIONAL text;
      formation : product_definition_formation;
      frame_of_reference : product_definition_context;
   DERIVE
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY product_definition_context
   SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
   END_ENTITY;



   ENTITY product_definition_effectivity
   SUBTYPE OF (effectivity);
      usage : product_definition_relationship;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
   END_ENTITY;



   ENTITY product_definition_formation;
      id : identifier;
      description : OPTIONAL text;
      of_product : product;
   UNIQUE
      UR1 : id,
 of_product;
   END_ENTITY;



   ENTITY product_definition_formation_relationship;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      relating_product_definition_formation : product_definition_formation;
      related_product_definition_formation : product_definition_formation;
   END_ENTITY;



   ENTITY product_definition_formation_with_specified_source
   SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
   END_ENTITY;



   ENTITY product_definition_relationship;
      id : identifier;
      name : label;
      description : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition : product_definition;
   END_ENTITY;



   ENTITY product_definition_shape
   SUBTYPE OF (property_definition);
   UNIQUE
      UR1 : SELF\property_definition.definition;
   WHERE
      WR1:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTERIZED_PRODUCT_DEFINITION',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CHARACTERIZED_OBJECT' ] * TYPEOF(SELF\property_definition.definition)) > 0;
   END_ENTITY;



   ENTITY product_definition_usage
   SUPERTYPE OF (ONEOF(make_from_usage_option,
 assembly_component_usage))
   SUBTYPE OF (product_definition_relationship);
   UNIQUE
      UR1 : SELF\product_definition_relationship.id,
 SELF\product_definition_relationship.relating_product_definition,
 SELF\product_definition_relationship.related_product_definition;
   WHERE
      WR1:
         acyclic_product_definition_relationship(SELF,
 [ SELF\product_definition_relationship.related_product_definition ],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_USAGE');
   END_ENTITY;



   ENTITY product_definition_with_associated_documents
   SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
   END_ENTITY;



   ENTITY product_material_composition_relationship
   SUBTYPE OF (product_definition_relationship);
      class : label;
      constituent_amount : SET [1:?] OF measure_with_unit;
      composition_basis : label;
      determination_method : text;
   END_ENTITY;



   ENTITY product_related_characterized_product_category
   SUBTYPE OF (characterized_product_category,
 product_related_product_category);
   END_ENTITY;



   ENTITY product_related_product_category
   SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
   END_ENTITY;



   ENTITY product_specific_parameter_value_assignment
   SUBTYPE OF (product_related_characterized_product_category);
   WHERE
      WR1:
         SIZEOF(SELF\product_related_product_category.products) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'product category parameter') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM') ] * TYPEOF(pdr.used_representation)) = 1))) = 1))) = 1;
      WR3:
         SIZEOF(QUERY (pcr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY')| (pcr\product_category_relationship.description = 'product value assignment') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY' IN TYPEOF(pcr.category)))) = 1;
   END_ENTITY;



   ENTITY projected_zone_definition
   SUBTYPE OF (tolerance_zone_definition);
      projection_end : shape_aspect;
      projected_length : measure_with_unit;
   WHERE
      WR1:
         projected_length.value_component > 0.00000;
   END_ENTITY;



   ENTITY promissory_usage_in_product_model
   SUBTYPE OF (group);
   WHERE
      WR1:
         SIZEOF(QUERY (aga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PROMISSORY_USAGE_IN_PRODUCT_MODEL_ASSIGNMENT' IN TYPEOF(aga)))) >= 1;
   END_ENTITY;



   ENTITY promissory_usage_occurrence
   SUBTYPE OF (assembly_component_usage);
   END_ENTITY;



   ENTITY property_definition;
      name : label;
      description : OPTIONAL text;
      definition : characterized_definition;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY property_definition_relationship;
      name : label;
      description : text;
      relating_property_definition : property_definition;
      related_property_definition : property_definition;
   END_ENTITY;



   ENTITY property_definition_representation;
      definition : represented_definition;
      used_representation : representation;
   DERIVE
      description : text := get_description_value(SELF);
      name : label := get_name_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY qualitative_uncertainty
   SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : text;
   END_ENTITY;



   ENTITY quantified_assembly_component_usage
   SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
   WHERE
      WR1:
         NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.value_component > 0);
   END_ENTITY;



   ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY ratio_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY ratio_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
   DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := list_to_array(weights_data,
 0,
 upper_index_on_control_points);
   WHERE
      WR1:
         SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.control_points_list);
      WR2:
         curve_weights_positive(SELF);
   END_ENTITY;



   ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
   DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := make_array_of_array(weights_data,
 0,
 u_upper,
 0,
 v_upper);
   WHERE
      WR1:
         (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
      WR2:
         surface_weights_positive(SELF);
   END_ENTITY;



   ENTITY rectangle_domain;
      corner : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
   WHERE
      WR1:
         SIZEOF(QUERY (item <* USEDIN(SELF,
 '')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
   END_ENTITY;



   ENTITY rectangled_half_space
   SUBTYPE OF (half_space_2d);
      enclosure : rectangle_domain;
   END_ENTITY;



   ENTITY rectangular_area
   SUBTYPE OF (primitive_2d);
      position : axis2_placement_2d;
      x : positive_length_measure;
      y : positive_length_measure;
   END_ENTITY;



   ENTITY rectangular_array_placement_group_component_definition
   SUBTYPE OF (array_placement_group_component_definition);
   END_ENTITY;



   ENTITY rectangular_array_placement_group_component_shape_aspect
   SUBTYPE OF (array_placement_group_component_shape_aspect);
   END_ENTITY;



   ENTITY rectangular_composite_array_shape_aspect
   SUBTYPE OF (composite_array_shape_aspect);
   END_ENTITY;



   ENTITY rectangular_composite_surface
   SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
   DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
   WHERE
      WR1:
         SIZEOF(QUERY (s <* segments| (n_v <> SIZEOF(s)))) = 0;
      WR2:
         constraints_rectangular_composite_surface(SELF);
   END_ENTITY;



   ENTITY rectangular_pyramid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      height : positive_length_measure;
   END_ENTITY;



   ENTITY rectangular_trimmed_surface
   SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1 : parameter_value;
      u2 : parameter_value;
      v1 : parameter_value;
      v2 : parameter_value;
      usense : BOOLEAN;
      vsense : BOOLEAN;
   WHERE
      WR1:
         u1 <> u2;
      WR2:
         v1 <> v2;
      WR3:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(basis_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))) OR (usense = (u2 > u1));
      WR4:
         (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR (vsense = (v2 > v1));
   END_ENTITY;



   ENTITY reference_packaged_part_assembly_implementation
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         (SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1) AND (SELF\product_definition.name = 'assembly module');
      WR2:
         NOT (SELF.frame_of_reference.name = 'physical design') OR (SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| (((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'assembly module')) AND (SIZEOF(QUERY (prpc <* USEDIN(du.relating_product_definition.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1))) = 1);
   END_ENTITY;



   ENTITY reference_packaged_part_interconnect_implementation
   SUBTYPE OF (physical_unit);
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         (SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1) AND (SELF\product_definition.name = 'interconnect module');
      WR3:
         SIZEOF(QUERY (du <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'design usage'))| (((SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PHYSICAL_UNIT') ] * TYPEOF(du.relating_product_definition)) = 1) AND (du.relating_product_definition.frame_of_reference.name = 'physical design usage')) AND (du.relating_product_definition\product_definition.name = 'interconnect module')) AND (SIZEOF(QUERY (prpc <* USEDIN(du.relating_product_definition.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| (prpc\product_category.name = 'template model'))) >= 1))) <= 1;
      WR4:
         SELF.frame_of_reference.name = 'physical design';
   END_ENTITY;



   ENTITY reparametrised_composite_curve_segment
   SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
   WHERE
      WR1:
         param_length > 0.00000;
   END_ENTITY;



   ENTITY representation;
      name : label;
      items : SET [1:?] OF representation_item;
      context_of_items : representation_context;
   DERIVE
      id : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY representation_context;
      context_identifier : identifier;
      context_type : text;
   INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
   END_ENTITY;



   ENTITY representation_item;
      name : label;
   WHERE
      WR1:
         SIZEOF(using_representations(SELF)) > 0;
   END_ENTITY;



   ENTITY representation_map;
      mapping_origin : representation_item;
      mapped_representation : representation;
   INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
   WHERE
      WR1:
         item_in_context(SELF.mapping_origin,
 SELF.mapped_representation.context_of_items);
   END_ENTITY;



   ENTITY representation_relationship;
      name : label;
      description : OPTIONAL text;
      rep_1 : representation;
      rep_2 : representation;
   END_ENTITY;



   ENTITY representation_relationship_with_transformation
   SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
   WHERE
      WR1:
         SELF\representation_relationship.rep_1.context_of_items :<>: SELF\representation_relationship.rep_2.context_of_items;
   END_ENTITY;



   ENTITY requirement_allocation_group
   SUBTYPE OF (group,
 property_definition_relationship);
   WHERE
      WR1:
         SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONFIGURATION_ITEM') ] * TYPEOF(aga.items)) = 1))) = 1;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(SELF\property_definition_relationship.relating_property_definition);
      WR4:
         NOT (SELF\property_definition_relationship.related_property_definition.description = 'test requirement') OR (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION') ] * TYPEOF(aga.items)) = 1))) >= 1);
   END_ENTITY;



   ENTITY requirement_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)) OR (SIZEOF(QUERY (docs <* SELF\product_definition_with_associated_documents.documentation_ids| (docs.kind\document_type.product_data_type = 'CAD filename'))) <= 1);
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'creation date'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'creation date'))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
      WR4:
         SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\person_and_organization_role.name = 'creator'))) + SIZEOF(QUERY (apoa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (apoa.role\organization_role.name = 'creator'))) >= 1;
      WR5:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      WR6:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition || SELF\requirement_definition)) = 0;
      WR7:
         SIZEOF(QUERY (prpc <* USEDIN(SELF.formation.of_product,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| (prpc\product_category.name = 'requirements model'))) >= 1;
   END_ENTITY;



   ENTITY requirements_property
   SUBTYPE OF (property_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'requirements property composition'))) <= 1;
      WR2:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'requirements description'))) = 1))) <= 1;
      WR3:
         SIZEOF(QUERY (dr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(dr.assigned_document)))) >= 1;
      WR4:
         NOT EXISTS(SELF\property_definition.description) OR (NOT (SELF\property_definition.description IN [ 'constraint',
 'part based constraint' ]) OR (SIZEOF(QUERY (dc <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'design constraint'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION' IN TYPEOF(dc.relating_property_definition.definition)))) = 1));
      WR5:
         NOT EXISTS(SELF\property_definition.description) OR (NOT (SELF\property_definition.description = 'part based constraint') OR (SIZEOF(QUERY (cp <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'constraining part'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(cp.relating_property_definition.definition)) AND (cp.relating_property_definition.definition\product_definition_relationship.name = 'constraining part')) AND (cp.relating_property_definition.definition.related_product_definition.frame_of_reference.name = 'design requirement'))) = 1));
      WR6:
         NOT EXISTS(SELF\property_definition.description) OR (NOT (SELF\property_definition.description = 'interface requirement') OR (SIZEOF(QUERY (itnha <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'interface to next higher assembly'))| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(itnha.relating_property_definition.definition)) AND (itnha.relating_property_definition.definition.frame_of_reference.name = 'design requirement')) AND (SIZEOF(QUERY (hai <* QUERY (pdr <* USEDIN(itnha.relating_property_definition.definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'higher assembly interface'))| (SIZEOF(QUERY (pdr <* USEDIN(hai,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdr)))) = 1))) = 1))) = 1));
      WR7:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'requirements name'))) = 1))) = 1;
   END_ENTITY;



   ENTITY requirements_property_group
   SUBTYPE OF (requirements_property,
 group);
   WHERE
      WR1:
         SIZEOF(QUERY (rpc <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'requirements property composition'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rpc.related_property_definition)))) >= 1;
   END_ENTITY;



   ENTITY resistance_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\resistance_measure_with_unit)) = 0;
      WR2:
         SELF\measure_with_unit.unit_component\si_unit.name = ohm;
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SI_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY revolved_area_solid
   SUBTYPE OF (swept_area_solid);
      axis : axis1_placement;
      angle : plane_angle_measure;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis.location,
 representation_item('') || geometric_representation_item() || vector(axis.z,
 1.00000));
   END_ENTITY;



   ENTITY revolved_face_solid
   SUBTYPE OF (swept_face_solid);
      axis : axis1_placement;
      angle : plane_angle_measure;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis.location,
 representation_item('') || geometric_representation_item() || vector(axis.z,
 1.00000));
   END_ENTITY;



   ENTITY right_angular_wedge
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x : positive_length_measure;
      y : positive_length_measure;
      z : positive_length_measure;
      ltx : length_measure;
   WHERE
      WR1:
         (0.00000 <= ltx) AND (ltx < x);
   END_ENTITY;



   ENTITY right_circular_cone
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height : positive_length_measure;
      radius : length_measure;
      semi_angle : plane_angle_measure;
   WHERE
      WR1:
         radius >= 0.00000;
   END_ENTITY;



   ENTITY right_circular_cylinder
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height : positive_length_measure;
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY role_association;
      role : object_role;
      item_with_role : role_select;
   END_ENTITY;



   ENTITY routed_physical_component
   SUBTYPE OF (component_definition);
   WHERE
      WR1:
         SIZEOF(QUERY (ip <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'instantiated part'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT') ] * TYPEOF(ip.relating_product_definition)) = 1) AND (ip.relating_product_definition.frame_of_reference.name = 'physical design usage'))) = 1;
      WR2:
         SELF\product_definition.description :<>: 'laminate component';
   END_ENTITY;



   ENTITY routed_printed_component
   SUBTYPE OF (printed_component);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'printed part cross section template')) AND (sar\shape_aspect_relationship.name = 'instantiated template'))) = 1))) = 1))) = 1;
      WR2:
         SIZEOF(QUERY (csa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(csa)) AND (SIZEOF(QUERY (sar <* USEDIN(csa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (SIZEOF(QUERY (pdr <* USEDIN(sar,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND (pdr\product_definition_relationship.name = 'inter stratum extent'))) = 1) AND (sar\shape_aspect_relationship.name = 'component extent'))) = 1))) = 1;
   END_ENTITY;



   ENTITY rule_action
   SUBTYPE OF (action);
   WHERE
      WR1:
         SIZEOF(QUERY (aaa <* QUERY (aa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ACTION_ASSIGNMENT' IN TYPEOF(aa)))| (SIZEOF(QUERY (it <* aaa.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it)) AND (it\product_definition_formation.description = 'rule version'))) = 1))) = 1;
      WR2:
         SIZEOF(QUERY (adta <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adta.role\date_time_role.name = 'participant date and time'))) + SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| (ada.role\date_role.name = 'participant date'))) = 1;
      WR3:
         NOT (SELF\action.name = 'rule justification') OR (SIZEOF(QUERY (ja <* QUERY (ar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| (ar\action_relationship.name = 'justified action'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION' IN TYPEOF(ja.relating_action)))) = 1);
      WR4:
         NOT (SELF\action.name = 'rule modification') OR (SIZEOF(QUERY (mr <* QUERY (ar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| (ar\action_relationship.name = 'modification rationale'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION' IN TYPEOF(mr.relating_action)) AND (mr.relating_action\action.name = 'rule change request'))) = 1);
      WR5:
         NOT (SELF\action.name = 'rule replacement from') OR (SIZEOF(QUERY (rrfa <* QUERY (aa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_REPLACEMENT_FROM_ASSIGNMENT' IN TYPEOF(aa)))| (SIZEOF(QUERY (it <* rrfa.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it)) AND (it\product_definition_formation.description = 'rule version'))) = 1))) = 1);
      WR6:
         NOT (SELF\action.name = 'rule replacement to') OR (SIZEOF(QUERY (rrta <* QUERY (aa <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_REPLACEMENT_TO_ASSIGNMENT' IN TYPEOF(aa)))| (SIZEOF(QUERY (it <* rrta.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it)) AND (it\product_definition_formation.description = 'rule version'))) = 1))) = 1);
   END_ENTITY;



   ENTITY rule_complex_clause
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr.rep_1)))) >= 1;
      WR2:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_complex_clause)) = 0;
   END_ENTITY;



   ENTITY rule_conclusion_definition
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))) = 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr\representation_relationship.rep_1)))) >= 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_conclusion_definition)) = 0;
   END_ENTITY;



   ENTITY rule_definition
   SUBTYPE OF (product_definition);
   WHERE
      WR1:
         SELF\product_definition.formation.description = 'rule version';
   END_ENTITY;



   ENTITY rule_function_definition
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODEL_PARAMETER' IN TYPEOF(it)))) >= 1;
      WR2:
         SIZEOF(QUERY (adf <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adf\document_reference.assigned_document.kind\document_type.product_data_type = 'reference document') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT') ] * TYPEOF(adf\document_reference.assigned_document)) >= 1))) = 1;
      WR3:
         SIZEOF(QUERY (adf <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adf\document_reference.assigned_document.kind\document_type.product_data_type = 'source code') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(adf\document_reference.assigned_document)))) = 1;
   END_ENTITY;



   ENTITY rule_premise_definition
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))) = 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_COMPLEX_CLAUSE' IN TYPEOF(rr\representation_relationship.rep_1)))) >= 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_premise_definition)) = 0;
   END_ENTITY;



   ENTITY rule_replacement_from_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF replacement_from_item;
   END_ENTITY;



   ENTITY rule_replacement_to_assignment
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF replacement_to_item;
   END_ENTITY;



   ENTITY rule_set
   SUBTYPE OF (group);
   UNIQUE
      UR1 : SELF\group.name;
   WHERE
      WR1:
         (SIZEOF(QUERY (aga <* QUERY (ga <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga)))| (SIZEOF(QUERY (rd <* QUERY (it <* aga.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION' IN TYPEOF(it)))| (SIZEOF(QUERY (pd <* USEDIN(rd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'rule priority'))) >= 1))) >= 1))) >= 1))) >= 1) OR (SIZEOF(QUERY (rsge <* QUERY (gr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_RELATIONSHIP.RELATING_GROUP')| (gr\group_relationship.name = 'rule set group element'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_SET' IN TYPEOF(rsge.related_group)))) >= 2);
   END_ENTITY;



   ENTITY rule_simple_clause
   SUBTYPE OF (representation);
   UNIQUE
      UR1 : SELF\representation.name;
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))) >= 1;
      WR2:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(rr.rep_1)))) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\rule_simple_clause)) = 0;
   END_ENTITY;



   ENTITY runout_zone_definition
   SUBTYPE OF (tolerance_zone_definition);
      orientation : runout_zone_orientation;
   END_ENTITY;



   ENTITY runout_zone_orientation;
      angle : measure_with_unit;
   END_ENTITY;



   ENTITY runout_zone_orientation_reference_direction
   SUBTYPE OF (runout_zone_orientation);
      orientation_defining_relationship : shape_aspect_relationship;
   END_ENTITY;



   ENTITY scalar_terminal_definition_link
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   UNIQUE
      UR1 : related_shape_aspect,
 relating_shape_aspect;
   WHERE
      WR1:
         SELF\shape_aspect_relationship.related_shape_aspect :<>: SELF\shape_aspect_relationship.relating_shape_aspect;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.related_shape_aspect);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
      WR4:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\shape_aspect_relationship || SELF\scalar_terminal_definition_link)) = 0;
      WR5:
         SELF\shape_aspect.name = '';
      WR6:
         SELF\shape_aspect_relationship.name = '';
      WR7:
         SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'scalar terminal';
      WR8:
         SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'scalar terminal';
   END_ENTITY;



   ENTITY scattering_parameter_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\measure_with_unit || SELF\scattering_parameter_measure_with_unit)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY seam_curve
   SUBTYPE OF (surface_curve);
   WHERE
      WR1:
         SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2:
         associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2]);
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
   END_ENTITY;



   ENTITY seating_plane
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\seating_plane)) = 0;
   END_ENTITY;



   ENTITY secondary_orientation_feature
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_ORIENTATION_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ]) = 0;
      WR2:
         SELF.product_definitional = TRUE;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
      WR4:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY security_classification;
      name : label;
      purpose : text;
      security_level : security_classification_level;
   END_ENTITY;



   ENTITY security_classification_assignment
   ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
   DERIVE
      role : object_role := get_role(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
   END_ENTITY;



   ENTITY security_classification_level;
      name : label;
   END_ENTITY;



   ENTITY sequential_laminate_passage_based_fabrication_joint
   SUBTYPE OF (shape_aspect);
   END_ENTITY;



   ENTITY serial_numbered_effectivity
   SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id : OPTIONAL identifier;
   END_ENTITY;



   ENTITY shape_aspect;
      name : label;
      description : OPTIONAL text;
      of_shape : product_definition_shape;
      product_definitional : LOGICAL;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY shape_aspect_deriving_relationship
   SUBTYPE OF (shape_aspect_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DERIVED_SHAPE_ASPECT' IN TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
   END_ENTITY;



   ENTITY shape_aspect_relationship;
      name : label;
      description : OPTIONAL text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect : shape_aspect;
   DERIVE
      id : identifier := get_id_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
   END_ENTITY;



   ENTITY shape_definition_representation
   SUBTYPE OF (property_definition_representation);
   WHERE
      WR1:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF.definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition));
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
   END_ENTITY;



   ENTITY shape_dimension_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* SELF.items| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(temp)))) = 0;
      WR2:
         SIZEOF(SELF.items) <= 2;
      WR3:
         SIZEOF(QUERY (pos_mri <* QUERY (real_mri <* SELF.items| ('REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)))| NOT (pos_mri\measure_with_unit.value_component > 0.00000))) = 0;
   END_ENTITY;



   ENTITY shape_formed_terminal
   SUBTYPE OF (altered_package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document)) AND (ada.assigned_document.kind\document_type.product_data_type = 'lead form specification')) AND (SIZEOF(QUERY (dr <* USEDIN(ada.assigned_document,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT')| (dr.relating_document.kind\document_type.product_data_type = 'material specification'))) = 1))) = 1;
   END_ENTITY;



   ENTITY shape_modification
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(QUERY (dim <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design intent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(dim.relating_shape_aspect)))) = 1;
      WR2:
         (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)) AND (pd\property_definition.description = 'modification causal'))) = 1) OR (SIZEOF(QUERY (mcf <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'modification causal feature'))| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(mcf.relating_shape_aspect)) = 1) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(mcf.relating_shape_aspect.of_shape.definition)))) = 1);
      WR3:
         NOT (SELF\shape_aspect.description IN [ 'electrical isolation removal',
 'thermal isolation removal' ]) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.name = 'spacing requirement') AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'spacing requirement') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition)))) = 1))) = 1);
      WR4:
         NOT (SELF\shape_aspect.description IN [ 'electrical isolation removal',
 'thermal isolation removal' ]) OR (SIZEOF(QUERY (di <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'design intent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(di.relating_shape_aspect)) AND (di.relating_shape_aspect\shape_aspect.description IN [ 'conductive filled area',
 'connected filled area' ]))) = 1);
      WR5:
         NOT (SELF\shape_aspect.description = 'thermal isolation removal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)) AND (pd\property_definition.description = 'angular orientation requirement'))) = 1);
      WR6:
         NOT (SELF\shape_aspect.description = 'thermal isolation removal') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)) AND (pd\property_definition.description = 'effective current capacity requirement'))) = 1);
      WR7:
         NOT (SELF\shape_aspect.description = 'material addition feature') OR (SIZEOF(QUERY (dim <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'material addition shape'))| (dim.relating_shape_aspect\shape_aspect.description = 'material addition feature template'))) = 1);
   END_ENTITY;



   ENTITY shape_representation
   SUBTYPE OF (representation);
   END_ENTITY;



   ENTITY shape_representation_relationship
   SUBTYPE OF (representation_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2);
   END_ENTITY;



   ENTITY shape_representation_relationship_with_transformation
   SUBTYPE OF (shape_representation_relationship,
 representation_relationship_with_transformation);
   END_ENTITY;



   ENTITY shell_based_2d_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF\representation.items| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D') ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF\representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM') ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_CURVE' IN TYPEOF(el.edge_element)))) = 0))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (pline_el <* QUERY (el <* eloop\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POLYLINE' IN TYPEOF(el.edge_element\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT valid_2d_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN'))) = 0))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(el.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(el.edge_element.edge_end))))) = 0))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (con_edges <* QUERY (el <* eloop\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONIC' IN TYPEOF(el.edge_element\edge_curve.edge_geometry)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(con_edges.edge_element\edge_curve.edge_geometry\conic.position)))) = 0))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_LOOP' IN TYPEOF(wsb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(vloop\vertex_loop.loop_vertex)))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_LOOP' IN TYPEOF(wsb)))| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_SHELL' IN TYPEOF(sb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_POINT' IN TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex)))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VERTEX_SHELL' IN TYPEOF(sb)))| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0;
      WR13:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR14:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
   END_ENTITY;



   ENTITY shell_based_surface_model
   SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
   WHERE
      WR1:
         constraints_geometry_shell_based_surface_model(SELF);
   END_ENTITY;



   ENTITY shell_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
   WHERE
      WR1:
         constraints_geometry_shell_based_wireframe_model(SELF);
   END_ENTITY;



   ENTITY shell_based_wireframe_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) >= 1;
      WR3:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_CURVE' IN TYPEOF(el.edge_element)))) = 0))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (pline_el <* QUERY (el <* eloop\path.edge_list| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(el.edge_element\edge_curve.edge_geometry)))| NOT (SIZEOF(pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2))) = 0))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry))) = 0))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(el.edge_element.edge_start)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(el.edge_element.edge_end))))) = 0))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (eloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE_LOOP' IN TYPEOF(wsb)))| NOT (SIZEOF(QUERY (el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)))) = 0))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(wsb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vloop\vertex_loop.loop_vertex)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (ws <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(sb)))| NOT (SIZEOF(QUERY (vloop <* QUERY (wsb <* ws\wire_shell.wire_shell_extent| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_LOOP' IN TYPEOF(wsb)))| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_POINT' IN TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex)))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (sbwm <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (vs <* QUERY (sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)))| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR13:
         SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
   END_ENTITY;



   ENTITY si_unit
   SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name : si_unit_name;
   DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
   END_ENTITY;



   ENTITY signal
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SIZEOF(QUERY (aca <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SIGNAL_CATEGORY' IN TYPEOF(aca.assigned_group)))) >= 1;
      WR2:
         SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'signal category'))) = 1))) = 1;
      WR3:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
   END_ENTITY;



   ENTITY signal_category
   SUBTYPE OF (group,
 externally_defined_item);
   WHERE
      WR1:
         SELF\group.description IN [ 'signal characteristic category',
 'signal property category' ];
   END_ENTITY;



   ENTITY solid_angle_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY solid_angle_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY solid_curve_font
   SUBTYPE OF (pre_defined_curve_font);
   END_ENTITY;



   ENTITY solid_model
   SUPERTYPE OF (ONEOF(csg_solid,
 manifold_solid_brep,
 swept_face_solid,
 swept_area_solid,
 solid_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY solid_replica
   SUBTYPE OF (solid_model);
      parent_solid : solid_model;
      transformation : cartesian_transformation_operator_3d;
   WHERE
      WR1:
         acyclic_solid_replica(SELF,
 parent_solid);
      WR2:
         parent_solid\geometric_representation_item.dim = 3;
   END_ENTITY;



   ENTITY specified_higher_usage_occurrence
   SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage : next_assembly_usage_occurrence;
   UNIQUE
      UR1 : upper_usage,
 next_usage;
   WHERE
      WR1:
         SELF :<>: upper_usage;
      WR2:
         SELF\product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition;
      WR3:
         SELF\product_definition_relationship.related_product_definition :=: next_usage.related_product_definition;
      WR4:
         (upper_usage.related_product_definition :=: next_usage.relating_product_definition) OR (SIZEOF(QUERY (pdr <* USEDIN(upper_usage.related_product_definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| (pdr.relating_product_definition :=: next_usage.relating_product_definition))) = 1);
      WR5:
         SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPECIFIED_HIGHER_USAGE_OCCURRENCE' ] * TYPEOF(upper_usage)) = 1;
   END_ENTITY;



   ENTITY sphere
   SUBTYPE OF (geometric_representation_item);
      radius : positive_length_measure;
      centre : point;
   END_ENTITY;



   ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
   END_ENTITY;



   ENTITY standard_uncertainty
   SUPERTYPE OF (expanded_uncertainty)
   SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : REAL;
   END_ENTITY;



   ENTITY start_request
   SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF start_request_item;
   END_ENTITY;



   ENTITY start_work
   SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIRECTED_ACTION' IN TYPEOF(SELF.assigned_action);
   END_ENTITY;



   ENTITY statistical_dimensional_location
   SUBTYPE OF (dimensional_location);
   END_ENTITY;



   ENTITY statistical_dimensional_size
   SUBTYPE OF (dimensional_size_property);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'substitutable dimension'))) <= 1))) <= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'dimensional tolerance statistical control requirement'))) <= 1))) <= 1;
      WR3:
         NOT (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'substitutable dimension'))) <= 1))) <= 1) OR NOT (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STATISTICAL_DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition))) AND (pdr\property_definition_relationship.name = 'substitutable dimension'))) <= 1))) <= 1);
   END_ENTITY;



   ENTITY statistical_geometric_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance'))) <= 1;
      WR2:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'geometric tolerance statistical control requirement'))) = 1;
      WR3:
         SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STATISTICAL_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance'))) <= 0;
   END_ENTITY;



   ENTITY stratum
   SUBTYPE OF (product_definition);
   UNIQUE
      UR1 : SELF\product_definition.id,
 SELF\product_definition.formation;
   WHERE
      WR1:
         EXISTS(SELF\product_definition.name);
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))) = 1))) = 1;
      WR3:
         (SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (SIZEOF(QUERY (duc <* USEDIN(ada.assigned_document,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| (duc\document_usage_constraint.subject_element = 'attachment region size'))) = 1))) <= 1) OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'stratum usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNAL_DEFINITION' IN TYPEOF(tu.relating_property_definition)))) = 1))) <= 1);
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = '3d bound volume shape'))) <= 1))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (sr_pdr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))| (sr_pdr.used_representation\representation.name = 'planar projected shape'))) <= 1))) = 0;
      WR6:
         SIZEOF(QUERY (acu <* QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr)))| (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship'))) >= 1;
      WR7:
         NOT (SELF\product_definition.name = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)) AND (tu.relating_property_definition.definition\characterized_object.description = 'design layer'))) = 1))) = 1);
      WR8:
         NOT (SELF\product_definition.name = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sa)))) >= 1))) >= 1);
      WR9:
         NOT (SELF\product_definition.name = 'documentation layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (tu <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)) AND (tu.relating_property_definition.definition\characterized_object.description = 'documentation layer'))) = 1))) = 1);
      WR10:
         NOT (SELF\product_definition.name = 'design layer') OR ((NOT (SELF\product_definition.description = 'primary design layer stratum') OR (SIZEOF(QUERY (imps <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(imps,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module primary surface'))) >= 0))) >= 0))) = 1)) OR (NOT (SELF\product_definition.description = 'non primary design layer stratum') OR (SIZEOF(QUERY (imps <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (sa <* USEDIN(imps,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'interconnect module primary surface'))) >= 0))) >= 0))) = 0)));
   END_ENTITY;



   ENTITY stratum_concept_relationship
   SUBTYPE OF (shape_aspect,
 shape_aspect_relationship);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))) >= 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1))) = 1;
      WR3:
         NOT (SELF\shape_aspect_relationship.name = 'dielectric crossover area') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(SELF.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(SELF.related_shape_aspect));
      WR4:
         NOT (SELF\shape_aspect_relationship.name = 'dielectric crossover area') OR (SIZEOF(QUERY (rdc <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'resulting dielectric crossover'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(rdc.relating_shape_aspect)))) = 1);
      WR5:
         NOT (SELF\shape_aspect_relationship.name = 'stratum feature conductive join') OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND' IN TYPEOF(SELF.relating_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.relating_shape_aspect)) AND (SELF.relating_shape_aspect\shape_aspect.description = 'stratum feature template component'));
      WR6:
         NOT (SELF\shape_aspect_relationship.name = 'stratum feature conductive join') OR (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND' IN TYPEOF(SELF.related_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.related_shape_aspect)) AND (SELF.related_shape_aspect\shape_aspect.description = 'stratum feature template component'));
      WR7:
         NOT (SELF\shape_aspect_relationship.name = 'stratum feature conductive join') OR (SIZEOF(QUERY (fj <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'features join'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(fj.related_shape_aspect)) AND (fj.related_shape_aspect\shape_aspect.description = 'bonded conductive base blind via'))) <= 1);
      WR8:
         NOT ((SELF\shape_aspect.description = 'physical network supporting stratum feature conductive join') AND (SELF\shape_aspect_relationship.name = 'stratum feature conductive join')) OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'inter stratum join'))) = 1);
   END_ENTITY;



   ENTITY stratum_feature
   SUPERTYPE OF (fiducial_stratum_feature)
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(SELF.of_shape.definition);
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'feature of size')) AND (it\descriptive_representation_item.description IN [ 'true',
 'false' ]))) = 1))) = 1))) = 0;
      WR3:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'conductor') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'intra stratum join'))) = 1));
      WR4:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'connected filled area') OR (SIZEOF(QUERY (ji <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'join implementation'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect)) AND (ji.relating_shape_aspect\shape_aspect.name = 'intra stratum join'))) = 1));
      WR5:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'conductor') OR (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
      WR6:
         NOT EXISTS(SELF\shape_aspect.description) OR (NOT (SELF\shape_aspect.description = 'connected filled area') OR (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
   END_ENTITY;



   ENTITY stratum_occurrence_specific_padstack_definition
   SUBTYPE OF (padstack_definition);
   END_ENTITY;



   ENTITY stratum_surface
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description IN [ 'primary surface',
 'secondary surface',
 'average surface' ];
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
   END_ENTITY;



   ENTITY stratum_technology
   SUBTYPE OF (characterized_object);
   UNIQUE
      UR1 : SELF\characterized_object.name;
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'stiffness class representation'))) <= 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))) = 1))) = 1;
      WR4:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (scr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'stratum class representation'))| NOT (SIZEOF(QUERY (it <* scr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'laminate stiffness class')) AND (it\descriptive_representation_item.description IN [ 'fluid like',
 'conformal coat',
 'stiff laminate' ]))) = 1))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT ((2 <= SIZEOF(pcr.used_representation.items)) AND (SIZEOF(pcr.used_representation.items) <= 8)))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| NOT (it\representation_item.name IN [ 'layer purpose',
 'layer position',
 'maximum feature size requirement',
 'minimum finished feature spacing',
 'minimum finished feature size',
 'maximum thickness',
 'minimum thickness' ]))) = 0))) = 0))) = 0;
      WR7:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum finished feature size'))) = 1))) = 0))) = 0));
      WR8:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum thickness'))) = 1))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum thickness'))) = 1))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'maximum feature size requirement'))) <= 1))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum finished feature spacing'))) <= 1))) = 0))) = 0;
      WR12:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'documentation layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'layer purpose'))) = 1))) = 0))) = 0));
      WR13:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT') ] * TYPEOF(it)) = 2) AND (it\representation_item.name = 'minimum finished feature spacing'))) = 1))) = 0))) = 0));
      WR14:
         NOT EXISTS(SELF\characterized_object.description) OR (NOT (SELF\characterized_object.description = 'design layer') OR (SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'layer purpose')) AND (it\descriptive_representation_item.description IN [ 'power or ground',
 'other signal',
 'lands only' ]))) = 1))) = 0))) = 0));
      WR15:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pcr <* QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'physical characteristics representation'))| NOT (SIZEOF(QUERY (it <* pcr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'layer position')) AND (it\descriptive_representation_item.description IN [ 'primary',
 'secondary',
 'internal',
 'external',
 'all' ]))) = 1))) = 0))) = 0;
      WR16:
         NOT EXISTS(SELF\characterized_object.description) OR (SELF\characterized_object.description IN [ 'design layer',
 'documentation layer' ]);
   END_ENTITY;



   ENTITY stratum_technology_link
   SUPERTYPE OF (printed_part_template_link)
   SUBTYPE OF (property_definition,
 property_definition_relationship);
   WHERE
      WR1:
         SELF\property_definition_relationship.related_property_definition.definition :<>: SELF\property_definition_relationship.relating_property_definition.definition;
      WR2:
         (SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship || SELF\stratum_technology_link || SELF\property_definition)) = 0) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_LINK' IN TYPEOF(SELF));
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(SELF\property_definition_relationship.related_property_definition.definition);
      WR4:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(SELF\property_definition_relationship.relating_property_definition.definition);
      WR5:
         SELF\property_definition.name = '';
      WR6:
         SELF\property_definition.description = '';
      WR7:
         SELF\property_definition_relationship.name = '';
      WR8:
         SELF\property_definition_relationship.description = '';
      WR9:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\property_definition.definition)) AND (SELF\property_definition.definition.description = 'printed part template');
      WR10:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr.name = 'precedent stratum technology link'))) <= 1;
      WR11:
         SIZEOF(QUERY (pdr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr.name = 'precedent stratum technology link'))) <= 1;
   END_ENTITY;



   ENTITY stratum_type_independent_padstack_definition
   SUBTYPE OF (padstack_definition);
   END_ENTITY;



   ENTITY structured_text_representation_context
   SUBTYPE OF (representation_context);
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.CONTEXT_OF_ITEMS')| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rep)))) = 0;
   END_ENTITY;



   ENTITY structured_text_representation_item
   SUBTYPE OF (representation,
 descriptive_representation_item);
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rr.rep_1)))) <= 1;
      WR2:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) >= 1;
      WR3:
         SIZEOF(QUERY (it <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_REPRESENTATION_ITEM' IN TYPEOF(it)))) = 1;
   END_ENTITY;



   ENTITY styled_item
   SUBTYPE OF (representation_item);
      styles : SET [1:?] OF presentation_style_assignment;
      item : representation_item;
   WHERE
      WR1:
         (SIZEOF(SELF.styles) = 1) XOR (SIZEOF(QUERY (pres_style <* SELF.styles| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(pres_style)))) = 0);
   END_ENTITY;



   ENTITY subedge
   SUBTYPE OF (edge);
      parent_edge : edge;
   END_ENTITY;



   ENTITY subface
   SUBTYPE OF (face);
      parent_face : face;
   WHERE
      WR1:
         NOT mixed_loop_type_set((list_to_set(list_face_loops(SELF)) + list_to_set(list_face_loops(parent_face))));
   END_ENTITY;



   ENTITY supplied_part_relationship
   SUBTYPE OF (product_definition_relationship);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN TYPEOF(SELF.related_product_definition.formation);
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION' IN ROLESOF(SELF));
   END_ENTITY;



   ENTITY surface
   SUPERTYPE OF (ONEOF(elementary_surface,
 swept_surface,
 bounded_surface,
 offset_surface,
 surface_replica))
   SUBTYPE OF (geometric_representation_item);
   END_ENTITY;



   ENTITY surface_curve
   SUPERTYPE OF (ONEOF(intersection_curve,
 seam_curve) ANDOR
 bounded_surface_curve)
   SUBTYPE OF (curve);
      curve_3d : curve;
      associated_geometry : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
   DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
   WHERE
      WR1:
         curve_3d.dim = 3;
      WR2:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation <> pcurve_s1);
      WR3:
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation <> pcurve_s2);
      WR4:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(curve_3d));
   END_ENTITY;



   ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
   END_ENTITY;



   ENTITY surface_of_revolution
   SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis_position.location,
 representation_item('') || geometric_representation_item() || vector(axis_position.z,
 1.00000));
   END_ENTITY;



   ENTITY surface_patch
   SUBTYPE OF (founded_item);
      parent_surface : bounded_surface;
      u_transition : transition_code;
      v_transition : transition_code;
      u_sense : BOOLEAN;
      v_sense : BOOLEAN;
   INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR segments;
   WHERE
      WR1:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface));
   END_ENTITY;



   ENTITY surface_prepped_terminal
   SUBTYPE OF (altered_package_terminal);
   WHERE
      WR2:
         SIZEOF(QUERY (ada <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document)) AND (ada.assigned_document.kind\document_type.product_data_type = 'surface finish specification'))) = 1;
   END_ENTITY;



   ENTITY surface_profile_tolerance
   SUBTYPE OF (physical_unit_geometric_tolerance);
   WHERE
      WR1:
         NOT (SELF\geometric_tolerance.name = 'surface profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance)) AND ((gtr.relating_geometric_tolerance\geometric_tolerance.name = 'surface profile locating') OR (gtr.relating_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement'))) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 1);
      WR2:
         NOT (SELF\geometric_tolerance.name = 'surface profile locating') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 1);
      WR3:
         NOT (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(SELF)) AND (SELF\geometric_tolerance.name = 'surface profile refinement')) OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 0);
      WR4:
         NOT (SELF\geometric_tolerance.name = 'surface profile refinement') OR (SIZEOF(QUERY (gtr <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(gtr.related_geometric_tolerance)) AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 'surface profile refinement')) AND (gtr\geometric_tolerance_relationship.name = 'surface profile refining control'))) = 1);
      WR5:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY surface_replica
   SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
   WHERE
      WR1:
         acyclic_surface_replica(SELF,
 parent_surface);
   END_ENTITY;



   ENTITY swept_area_solid
   SUPERTYPE OF (ONEOF(revolved_area_solid,
 extruded_area_solid))
   SUBTYPE OF (solid_model);
      swept_area : curve_bounded_surface;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(swept_area.basis_surface);
   END_ENTITY;



   ENTITY swept_face_solid
   SUPERTYPE OF (ONEOF(extruded_face_solid,
 revolved_face_solid))
   SUBTYPE OF (solid_model);
      swept_face : face_surface;
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' IN TYPEOF(swept_face.face_geometry);
   END_ENTITY;



   ENTITY swept_surface
   SUPERTYPE OF (ONEOF(surface_of_linear_extrusion,
 surface_of_revolution))
   SUBTYPE OF (surface);
      swept_curve : curve;
   END_ENTITY;



   ENTITY symbol_representation
   SUBTYPE OF (representation);
   END_ENTITY;



   ENTITY symbol_representation_map
   SUBTYPE OF (representation_map);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SYMBOL_REPRESENTATION' IN TYPEOF(SELF\representation_map.mapped_representation);
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(SELF\representation_map.mapping_origin);
   END_ENTITY;



   ENTITY symbol_target
   SUBTYPE OF (geometric_representation_item);
      placement : axis2_placement;
      x_scale : positive_ratio_measure;
      y_scale : positive_ratio_measure;
   END_ENTITY;



   ENTITY symmetric_shape_aspect
   SUBTYPE OF (shape_aspect);
   INVERSE
      basis_relationships : SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
   WHERE
      WR1:
         SIZEOF(QUERY (X <* SELF.basis_relationships| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CENTRE_OF_SYMMETRY' IN TYPEOF(X.related_shape_aspect)))) >= 1;
   END_ENTITY;



   ENTITY symmetry_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'symmetry';
   END_ENTITY;



   ENTITY table_representation_item
   SUBTYPE OF (compound_representation_item);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')) > 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIST_REPRESENTATION_ITEM' IN TYPEOF(SELF\compound_representation_item.item_element);
   END_ENTITY;



   ENTITY tangent
   SUBTYPE OF (derived_shape_aspect);
   WHERE
      WR1:
         SIZEOF(SELF\derived_shape_aspect.deriving_relationships) = 1;
   END_ENTITY;



   ENTITY template_material_cross_section_boundary
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect || SELF\template_material_cross_section_boundary)) = 0;
      WR2:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(SELF.of_shape\property_definition.definition);
      WR3:
         SELF\shape_aspect.description IN [ 'top',
 'left',
 'right',
 'bottom' ];
   END_ENTITY;



   ENTITY template_stratum_assignment
   SUBTYPE OF (shape_aspect_relationship);
   END_ENTITY;



   ENTITY tertiary_orientation_feature
   SUBTYPE OF (physical_unit_datum_feature);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) * [ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRIMARY_ORIENTATION_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SECONDARY_ORIENTATION_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEATING_PLANE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT') ]) = 0;
      WR2:
         SELF.product_definitional = TRUE;
      WR3:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
      WR4:
         SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1;
   END_ENTITY;



   ENTITY test_point_part_feature
   SUBTYPE OF (part_tooling_feature);
   END_ENTITY;



   ENTITY text_font;
      id : identifier;
      name : label;
      description : text;
   INVERSE
      glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
   END_ENTITY;



   ENTITY text_font_family;
      id : identifier;
      name : label;
      description : text;
   INVERSE
      fonts : SET [1:?] OF text_font_in_family FOR family;
   END_ENTITY;



   ENTITY text_font_in_family;
      font : text_font;
      family : text_font_family;
   END_ENTITY;



   ENTITY text_literal
   SUBTYPE OF (geometric_representation_item);
      literal : presentable_text;
      placement : axis2_placement;
      alignment : text_alignment;
      path : text_path;
      font : font_select;
   END_ENTITY;



   ENTITY text_literal_with_associated_curves
   SUBTYPE OF (text_literal);
      associated_curves : SET [1:?] OF curve;
   END_ENTITY;



   ENTITY text_literal_with_extent
   SUBTYPE OF (text_literal);
      extent : planar_extent;
   END_ENTITY;



   ENTITY text_string_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         SIZEOF(QUERY (item <* SELF\representation.items| (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' ] * TYPEOF(item)) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (item <* SELF\representation.items| NOT (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TEXT_LITERAL',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ANNOTATION_TEXT_CHARACTER',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEFINED_CHARACTER_GLYPH',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_TEXT' ] * TYPEOF(item)) = 0))) >= 1;
      WR3:
         SIZEOF(QUERY (a2p <* QUERY (item <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT' IN TYPEOF(item)))| NOT ((SIZEOF(QUERY (at <* QUERY (item <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_TEXT' IN TYPEOF(item)))| (at\mapped_item.mapping_target :=: a2p))) >= 1) OR (SIZEOF(QUERY (atc <* QUERY (item <* SELF\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF(item)))| (atc\mapped_item.mapping_target :=: a2p))) >= 1)))) = 0;
   END_ENTITY;



   ENTITY text_style;
      name : label;
      character_appearance : character_style_select;
   END_ENTITY;



   ENTITY text_style_for_defined_font;
      text_colour : colour;
   END_ENTITY;



   ENTITY thermal_component
   SUBTYPE OF (component_definition);
   END_ENTITY;



   ENTITY thermal_component_shape_aspect
   SUBTYPE OF (component_shape_aspect);
   END_ENTITY;



   ENTITY thermal_feature
   SUBTYPE OF (shape_aspect);
   END_ENTITY;



   ENTITY thermal_isolation_component_shape_aspect
   SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
   END_ENTITY;



   ENTITY thermal_isolation_removal_template_definition
   SUBTYPE OF (part_template_definition);
   END_ENTITY;



   ENTITY thermal_network
   SUBTYPE OF (functional_unit);
   END_ENTITY;



   ENTITY thermodynamic_temperature_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY thermodynamic_temperature_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY time_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY time_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 1.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY tolerance_value;
      lower_bound : measure_with_unit;
      upper_bound : measure_with_unit;
   WHERE
      WR1:
         upper_bound.value_component > lower_bound.value_component;
      WR2:
         upper_bound.unit_component = lower_bound.unit_component;
   END_ENTITY;



   ENTITY tolerance_zone
   SUBTYPE OF (shape_aspect);
      defining_tolerance : SET [1:?] OF geometric_tolerance;
      form : tolerance_zone_form;
   END_ENTITY;



   ENTITY tolerance_zone_boundary
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         NOT (SELF\shape_aspect.description = 'conical') OR NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
      WR2:
         NOT (SELF\shape_aspect.description = 'circular or cylindrical or spherical') OR NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
      WR3:
         SELF\shape_aspect.product_definitional = FALSE;
      WR4:
         NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
      WR5:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| (pd\property_definition.description = 'boundary zone definition with specified size') OR (pd\property_definition.description = 'conical tolerance zone boundary'))) = 1;
      WR6:
         SIZEOF(USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_DEFINITION.BOUNDARIES')) = 1;
   END_ENTITY;



   ENTITY tolerance_zone_definition
   SUPERTYPE OF (ONEOF(projected_zone_definition,
 runout_zone_definition));
      zone : tolerance_zone;
      boundaries : SET [1:?] OF shape_aspect;
   END_ENTITY;



   ENTITY tolerance_zone_explicit_opposing_boundary_set
   SUBTYPE OF (tolerance_zone_boundary);
   END_ENTITY;



   ENTITY tolerance_zone_form;
      name : label;
   END_ENTITY;



   ENTITY tolerance_zone_implicit_opposing_boundary_set
   SUBTYPE OF (tolerance_zone_boundary);
   END_ENTITY;



   ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex,
 edge,
 face_bound,
 face,
 vertex_shell,
 wire_shell,
 connected_edge_set,
 connected_face_set,
 loop ANDOR
 path))
   SUBTYPE OF (representation_item);
   END_ENTITY;



   ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
   END_ENTITY;



   ENTITY torus
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
   WHERE
      WR1:
         major_radius > minor_radius;
   END_ENTITY;



   ENTITY total_runout_tolerance
   SUBTYPE OF (geometric_tolerance_with_specified_datum_system);
   WHERE
      WR1:
         SELF\geometric_tolerance.name = 'total runout';
      WR2:
         NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
   END_ENTITY;



   ENTITY trimmed_curve
   SUBTYPE OF (bounded_curve);
      basis_curve : curve;
      trim_1 : SET [1:2] OF trimming_select;
      trim_2 : SET [1:2] OF trimming_select;
      sense_agreement : BOOLEAN;
      master_representation : trimming_preference;
   WHERE
      WR1:
         (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
      WR2:
         (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
   END_ENTITY;



   ENTITY two_direction_repeat_factor
   SUBTYPE OF (one_direction_repeat_factor);
      second_repeat_factor : vector;
   END_ENTITY;



   ENTITY type_qualifier;
      name : label;
   END_ENTITY;



   ENTITY uncertainty_measure_with_unit
   SUBTYPE OF (measure_with_unit);
      name : label;
      description : OPTIONAL text;
   WHERE
      WR1:
         valid_measure_value(SELF\measure_with_unit.value_component);
   END_ENTITY;



   ENTITY uncertainty_qualifier
   SUPERTYPE OF (ONEOF(standard_uncertainty,
 qualitative_uncertainty));
      measure_name : label;
      description : text;
   END_ENTITY;



   ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
   END_ENTITY;



   ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
   END_ENTITY;



   ENTITY usage_view_connection_zone_terminal_shape_relationship
   SUBTYPE OF (representation,
 representation_relationship_with_transformation);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,
 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION') ] * TYPEOF(SELF.rep_1)) = 1;
      WR2:
         SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION') ] * TYPEOF(SELF.rep_2)) = 1;
      WR3:
         SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\representation_relationship_with_transformation || SELF\usage_view_connection_zone_terminal_shape_relationship)) = 0;
      WR4:
         SELF\representation_relationship.rep_1 <> SELF\representation_relationship.rep_2;
   END_ENTITY;



   ENTITY vector
   SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude : length_measure;
   WHERE
      WR1:
         magnitude >= 0.00000;
   END_ENTITY;



   ENTITY versioned_action_request;
      id : identifier;
      version : label;
      purpose : text;
      description : OPTIONAL text;
   END_ENTITY;



   ENTITY vertex
   SUBTYPE OF (topological_representation_item);
   END_ENTITY;



   ENTITY vertex_loop
   SUBTYPE OF (loop);
      loop_vertex : vertex;
   END_ENTITY;



   ENTITY vertex_point
   SUBTYPE OF (vertex,
 geometric_representation_item);
      vertex_geometry : point;
   END_ENTITY;



   ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
   END_ENTITY;



   ENTITY viewing_plane
   SUBTYPE OF (shape_aspect);
   WHERE
      WR1:
         SELF\shape_aspect.description = 'affected plane';
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')| (pd\property_definition.description = 'viewing plane property'))) = 1;
      WR3:
         NOT SELF\shape_aspect.product_definitional;
   END_ENTITY;



   ENTITY volume_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
   END_ENTITY;



   ENTITY volume_shape_intersection
   SUPERTYPE OF (ONEOF(edge_segment_cross_section,
 pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,
 pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,
 pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship))
   SUBTYPE OF (representation,
 shape_representation_relationship,
 representation_relationship_with_transformation);
   UNIQUE
      UR1 : SELF\representation_relationship.rep_1,
 SELF\representation_relationship.rep_2;
   WHERE
      WR1:
         SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
      WR2:
         ((((SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation || SELF\representation_relationship || SELF\shape_representation_relationship || SELF\representation_relationship_with_transformation || SELF\volume_shape_intersection)) = 0) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EDGE_SEGMENT_CROSS_SECTION' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_PARALLEL_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_PLANE_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF));
      WR3:
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF(SELF\representation_relationship_with_transformation.transformation_operator);
   END_ENTITY;



   ENTITY volume_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 3.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;



   ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
   WHERE
      WR1:
         NOT mixed_loop_type_set(wire_shell_extent);
   END_ENTITY;



   ENTITY wire_terminal
   SUBTYPE OF (package_terminal);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 2))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'maximum wire terminal length')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 1))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (SIZEOF(QUERY (it <* pdr.used_representation.items| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND (it\representation_item.name = 'minimum wire terminal length')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_UNIT' IN TYPEOF(it\measure_with_unit.unit_component)))) = 1))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (sar <* USEDIN(SELF,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'internal connection zone') AND (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
   END_ENTITY;


(* ***********************************
Types in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   TYPE action_assigned_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE ahead_or_behind = ENUMERATION OF
      (ahead,

       exact,

       behind);
   END_TYPE;



   TYPE amount_of_substance_measure = REAL;
   END_TYPE;



   TYPE angle_relator = ENUMERATION OF
      (equal,

       large,

       small);
   END_TYPE;



   TYPE approval_assigned_item = SELECT
      (action,

       action_directive,

       certification,

       change,

       change_request,

       configuration_effectivity,

       configuration_item,

       contract,

       date,

       directed_action,

       document,

       product,

       product_definition,

       product_definition_formation,

       product_definition_formation_with_specified_source,

       representation,

       security_classification,

       start_request,

       start_work,

       versioned_action_request);
   END_TYPE;



   TYPE area_measure = REAL;
   END_TYPE;



   TYPE attribute_type = SELECT
      (label,

       text);
   END_TYPE;



   TYPE axis2_placement = SELECT
      (axis2_placement_2d,

       axis2_placement_3d);
   END_TYPE;



   TYPE b_spline_curve_form = ENUMERATION OF
      (polyline_form,

       circular_arc,

       elliptic_arc,

       parabolic_arc,

       hyperbolic_arc,

       unspecified);
   END_TYPE;



   TYPE b_spline_surface_form = ENUMERATION OF
      (plane_surf,

       cylindrical_surf,

       conical_surf,

       spherical_surf,

       toroidal_surf,

       surf_of_revolution,

       ruled_surf,

       generalised_cone,

       quadric_surf,

       surf_of_linear_extrusion,

       unspecified);
   END_TYPE;



   TYPE boolean_operand = SELECT
      (solid_model,

       half_space_solid,

       csg_primitive,

       boolean_result,

       half_space_2d);
   END_TYPE;



   TYPE boolean_operator = ENUMERATION OF
      (union,

       intersection,

       difference);
   END_TYPE;



   TYPE box_characteristic_select = SELECT
      (box_height,

       box_width,

       box_slant_angle,

       box_rotate_angle);
   END_TYPE;



   TYPE box_height = positive_ratio_measure;
   END_TYPE;



   TYPE box_rotate_angle = plane_angle_measure;
   END_TYPE;



   TYPE box_slant_angle = plane_angle_measure;
   END_TYPE;



   TYPE box_width = positive_ratio_measure;
   END_TYPE;



   TYPE celsius_temperature_measure = REAL;
   END_TYPE;



   TYPE certification_assigned_item = SELECT
      (supplied_part_relationship,

       make_from_usage_option,

       product_definition_formation_with_specified_source);
   END_TYPE;



   TYPE change_request_item = SELECT
      (product_definition_formation,

       representation_relationship);
   END_TYPE;



   TYPE character_spacing_select = SELECT
      (length_measure,

       ratio_measure,

       measure_with_unit,

       descriptive_measure);
   END_TYPE;



   TYPE character_style_select = SELECT
      (character_glyph_style_stroke,

       character_glyph_style_outline,

       text_style_for_defined_font);
   END_TYPE;



   TYPE characterized_action_definition = SELECT
      (action,

       action_method,

       action_method_relationship,

       action_relationship);
   END_TYPE;



   TYPE characterized_definition = SELECT
      (characterized_object,

       characterized_product_definition,

       shape_definition);
   END_TYPE;



   TYPE characterized_material_property = SELECT
      (material_property_representation,

       product_material_composition_relationship);
   END_TYPE;



   TYPE characterized_product_definition = SELECT
      (product_definition,

       product_definition_relationship);
   END_TYPE;



   TYPE classification_assigned_item = SELECT
      (material_designation,

       requirements_property,

       signal,

       stratum);
   END_TYPE;



   TYPE compound_item_definition = SELECT
      (list_representation_item,

       set_representation_item);
   END_TYPE;



   TYPE configuration_design_item = SELECT
      (product_definition,

       product_definition_formation);
   END_TYPE;



   TYPE context_dependent_measure = REAL;
   END_TYPE;



   TYPE contract_assigned_item = SELECT
      (alternate_product_relationship,

       directed_action,

       product,

       product_definition_formation);
   END_TYPE;



   TYPE count_measure = NUMBER;
   END_TYPE;



   TYPE csg_primitive = SELECT
      (sphere,

       ellipsoid,

       block,

       right_angular_wedge,

       faceted_primitive,

       rectangular_pyramid,

       torus,

       right_circular_cone,

       eccentric_cone,

       right_circular_cylinder,

       cyclide_segment_solid,

       primitive_2d);
   END_TYPE;



   TYPE csg_select = SELECT
      (boolean_result,

       csg_primitive);
   END_TYPE;



   TYPE curve_font_or_scaled_curve_font_select = SELECT
      (curve_style_font_select,

       curve_style_font_and_scaling);
   END_TYPE;



   TYPE curve_on_surface = SELECT
      (pcurve,

       surface_curve,

       composite_curve_on_surface);
   END_TYPE;



   TYPE curve_or_annotation_curve_occurrence = SELECT
      (curve,

       annotation_curve_occurrence);
   END_TYPE;



   TYPE curve_or_render = SELECT
      (curve_style);
   END_TYPE;



   TYPE curve_style_font_select = SELECT
      (curve_style_font,

       pre_defined_curve_font,

       externally_defined_curve_font);
   END_TYPE;



   TYPE date_and_time_assigned_item = SELECT
      (approval_person_organization,

       certification,

       change,

       contract,

       directed_action,

       document,

       product_definition,

       rule_action,

       security_classification,

       versioned_action_request);
   END_TYPE;



   TYPE date_assigned_item = SELECT
      (product_definition,

       versioned_action_request,

       directed_action,

       approval_person_organization,

       contract,

       security_classification,

       certification);
   END_TYPE;



   TYPE date_time_or_event_occurrence = SELECT
      (date_time_select);
   END_TYPE;



   TYPE date_time_select = SELECT
      (date,

       local_time,

       date_and_time);
   END_TYPE;



   TYPE day_in_month_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 31);
   END_TYPE;



   TYPE defined_symbol_select = SELECT
      (externally_defined_symbol);
   END_TYPE;



   TYPE derived_property_select = SELECT
      (property_definition);
   END_TYPE;



   TYPE description_attribute_select = SELECT
      (action_request_solution,

       application_context,

       approval_role,

       configuration_design,

       date_role,

       date_time_role,

       context_dependent_shape_representation,

       effectivity,

       external_source,

       organization_role,

       person_and_organization_role,

       person_and_organization,

       person_role,

       property_definition_representation,

       representation);
   END_TYPE;



   TYPE descriptive_measure = STRING;
   END_TYPE;



   TYPE dimension_count = INTEGER;
   WHERE
      WR1:
         SELF > 0;
   END_TYPE;



   TYPE dimensional_characteristic = SELECT
      (dimensional_location,

       dimensional_size);
   END_TYPE;



   TYPE document_assigned_item = SELECT
      (action_method,

       assembly_component_usage,

       bond_category,

       characterized_object,

       component_definition,

       component_feature,

       component_interface_terminal,

       component_shape_aspect,

       component_terminal,

       coordinated_representation_item,

       configuration_item,

       descriptive_representation_item,

       externally_defined_item,

       functional_unit_terminal_definition,

       inter_stratum_feature,

       interconnect_module_component_surface_feature,

       layer,

       laminate_component_interface_terminal,

       material_designation,

       measure_representation_item,

       package_terminal,

       part_template_definition,

       physical_connectivity_definition,

       physical_connectivity_element,

       product,

       product_definition,

       product_definition_formation,

       product_definition_formation_relationship,

       property_definition,

       representation,

       representation_item,

       requirements_property,

       rule_definition,

       shape_aspect,

       signal,

       stratum,

       stratum_feature);
   END_TYPE;



   TYPE document_identifier_assigned_item = SELECT
      (document);
   END_TYPE;



   TYPE electric_current_measure = REAL;
   END_TYPE;



   TYPE fill_area_style_tile_shape_select = SELECT
      (fill_area_style_tile_curve_with_style,

       fill_area_style_tile_coloured_region,

       fill_area_style_tile_symbol_with_style,

       externally_defined_tile);
   END_TYPE;



   TYPE fill_style_select = SELECT
      (fill_area_style_colour,

       externally_defined_tile_style,

       fill_area_style_tiles,

       externally_defined_hatch_style,

       fill_area_style_hatching);
   END_TYPE;



   TYPE font_select = SELECT
      (externally_defined_text_font);
   END_TYPE;



   TYPE founded_item_select = SELECT
      (founded_item,

       representation_item);
   END_TYPE;



   TYPE frozen_assigned_item = SELECT
      (alternate_product_relationship,

       applied_date_and_time_assignment,

       applied_document_reference,

       applied_group_assignment,

       characterized_object,

       colour,

       component_definition,

       component_shape_aspect,

       composite_curve_segment,

       curve_style,

       curve_style_font,

       curve_style_font_and_scaling,

       dimension_related_tolerance_zone_element,

       dimensional_characteristic_representation,

       dimensional_size,

       document_usage_constraint,

       externally_defined_item,

       fill_area_style,

       fill_area_style_colour,

       geometric_tolerance,

       geometric_tolerance_relationship,

       group,

       inter_stratum_feature,

       material_designation,

       measure_with_unit,

       plus_minus_tolerance,

       pre_defined_item,

       product_concept,

       product_definition_formation_relationship,

       product_definition_relationship,

       property_definition,

       property_definition_relationship,

       property_definition_representation,

       representation,

       representation_context,

       representation_item,

       representation_relationship,

       runout_zone_orientation,

       shape_aspect,

       shape_aspect_relationship,

       stratum_feature,

       tolerance_value,

       tolerance_zone_form);
   END_TYPE;



   TYPE geometric_set_select = SELECT
      (point,

       curve,

       surface);
   END_TYPE;



   TYPE group_assigned_item = SELECT
      (assembly_bond_definition,

       design_object,

       component_definition,

       component_feature,

       component_interface_terminal,

       component_shape_aspect,

       component_terminal,

       compound_representation_item,

       configuration_item,

       inter_stratum_feature,

       laminate_component_interface_terminal,

       printed_part_template_terminal,

       product,

       product_definition_formation,

       property_definition_representation,

       representation,

       representation_item,

       requirements_property,

       rule_definition,

       shape_aspect,

       shape_aspect_relationship,

       stratum,

       stratum_feature,

       stratum_surface);
   END_TYPE;



   TYPE hiding_or_blanking_select = SELECT
      (annotation_fill_area,

       character_glyph_symbol_outline);
   END_TYPE;



   TYPE hour_in_day = INTEGER;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF < 24);
   END_TYPE;



   TYPE id_attribute_select = SELECT
      (action,

       address,

       product_category,

       property_definition,

       shape_aspect,

       shape_aspect_relationship,

       application_context,

       group,

       organizational_project,

       representation);
   END_TYPE;



   TYPE identifier = STRING;
   END_TYPE;



   TYPE invisibility_context = SELECT
      (presentation_representation);
   END_TYPE;



   TYPE invisible_item = SELECT
      (styled_item,

       representation);
   END_TYPE;



   TYPE knot_type = ENUMERATION OF
      (uniform_knots,

       quasi_uniform_knots,

       piecewise_bezier_knots,

       unspecified);
   END_TYPE;



   TYPE label = STRING;
   END_TYPE;



   TYPE layered_item = SELECT
      (presentation_representation,

       representation_item);
   END_TYPE;



   TYPE length_measure = REAL;
   END_TYPE;



   TYPE limit_condition = ENUMERATION OF
      (maximum_material_condition,

       least_material_condition,

       regardless_of_feature_size);
   END_TYPE;



   TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
   END_TYPE;



   TYPE list_representation_item = LIST [1:?] OF representation_item;
   END_TYPE;



   TYPE luminous_intensity_measure = REAL;
   END_TYPE;



   TYPE managed_design_object = SELECT
      (action,

       alternate_product_relationship,

       applied_approval_assignment,

       applied_date_and_time_assignment,

       applied_document_reference,

       applied_group_assignment,

       approval,

       approval_status,

       certification,

       characterized_object,

       colour,

       composite_curve_segment,

       configuration_effectivity,

       configuration_item,

       contract,

       curve_style,

       curve_style_font,

       curve_style_font_and_scaling,

       date,

       dimension_related_tolerance_zone_element,

       dimensional_characteristic_representation,

       dimensional_size,

       document,

       document_usage_constraint,

       externally_defined_item,

       fill_area_style,

       fill_area_style_colour,

       geometric_tolerance,

       geometric_tolerance_relationship,

       group,

       layer_connection_point,

       layer_connection_point_link,

       material_designation,

       measure_with_unit,

       organization,

       person,

       person_and_organization,

       plus_minus_tolerance,

       pre_defined_item,

       product,

       product_concept,

       product_definition,

       product_definition_formation,

       product_definition_formation_relationship,

       product_definition_relationship,

       property_definition,

       property_definition_relationship,

       property_definition_representation,

       representation,

       representation_context,

       representation_item,

       representation_relationship,

       runout_zone_orientation,

       security_classification,

       shape_aspect,

       shape_aspect_relationship,

       tolerance_value,

       tolerance_zone_form,

       versioned_action_request);
   END_TYPE;



   TYPE mass_measure = REAL;
   END_TYPE;



   TYPE measure_value = SELECT
      (length_measure,

       mass_measure,

       time_measure,

       electric_current_measure,

       thermodynamic_temperature_measure,

       celsius_temperature_measure,

       amount_of_substance_measure,

       luminous_intensity_measure,

       plane_angle_measure,

       solid_angle_measure,

       area_measure,

       volume_measure,

       ratio_measure,

       parameter_value,

       numeric_measure,

       context_dependent_measure,

       descriptive_measure,

       positive_length_measure,

       positive_plane_angle_measure,

       positive_ratio_measure,

       count_measure);
   END_TYPE;



   TYPE minute_in_hour = INTEGER;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF <= 59);
   END_TYPE;



   TYPE month_in_year_number = INTEGER;
   WHERE
      WR1:
         (1 <= SELF) AND (SELF <= 12);
   END_TYPE;



   TYPE name_attribute_select = SELECT
      (action_request_solution,

       address,

       configuration_design,

       context_dependent_shape_representation,

       derived_unit,

       effectivity,

       person_and_organization,

       product_definition,

       property_definition_representation);
   END_TYPE;



   TYPE numeric_measure = NUMBER;
   END_TYPE;



   TYPE organization_assigned_item = SELECT
      (configuration_item,

       contract,

       directed_action,

       document,

       versioned_action_request,

       product,

       product_definition,

       product_definition_formation,

       product_definition_formation_with_specified_source,

       rule_definition,

       representation,

       security_classification);
   END_TYPE;



   TYPE owner_assigned_item = SELECT
      (alternate_product_relationship,

       characterized_object,

       colour,

       component_definition,

       component_shape_aspect,

       composite_curve_segment,

       curve_style,

       curve_style_font,

       curve_style_font_and_scaling,

       dimension_related_tolerance_zone_element,

       dimensional_characteristic_representation,

       dimensional_size,

       document_usage_constraint,

       externally_defined_item,

       fill_area_style,

       fill_area_style_colour,

       geometric_tolerance,

       geometric_tolerance_relationship,

       group,

       inter_stratum_feature,

       material_designation,

       measure_with_unit,

       plus_minus_tolerance,

       pre_defined_item,

       product_concept,

       product_definition_formation_relationship,

       product_definition_relationship,

       property_definition,

       property_definition_relationship,

       property_definition_representation,

       representation,

       representation_context,

       representation_item,

       representation_relationship,

       runout_zone_orientation,

       shape_aspect,

       shape_aspect_relationship,

       stratum_feature,

       tolerance_value,

       tolerance_zone_form);
   END_TYPE;



   TYPE parameter_value = REAL;
   END_TYPE;



   TYPE pcurve_or_surface = SELECT
      (pcurve,

       surface);
   END_TYPE;



   TYPE person_and_organization_assigned_item = SELECT
      (change,

       configuration_item,

       contract,

       document,

       product,

       product_definition_formation,

       product_definition,

       directed_action,

       rule_action,

       security_classification,

       versioned_action_request);
   END_TYPE;



   TYPE person_assigned_item = SELECT
      (document);
   END_TYPE;



   TYPE person_organization_select = SELECT
      (person,

       organization,

       person_and_organization);
   END_TYPE;



   TYPE plane_angle_measure = REAL;
   END_TYPE;



   TYPE positive_length_measure = length_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE positive_plane_angle_measure = plane_angle_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE positive_ratio_measure = ratio_measure;
   WHERE
      WR1:
         SELF > 0.00000;
   END_TYPE;



   TYPE preferred_surface_curve_representation = ENUMERATION OF
      (curve_3d,

       pcurve_s1,

       pcurve_s2);
   END_TYPE;



   TYPE presentable_text = STRING;
   END_TYPE;



   TYPE presentation_representation_select = SELECT
      (presentation_representation);
   END_TYPE;



   TYPE presentation_style_select = SELECT
      (curve_style,

       fill_area_style,

       text_style);
   END_TYPE;



   TYPE process_or_process_relationship = SELECT
      (relationship_with_condition);
   END_TYPE;



   TYPE product_or_formation_or_definition = SELECT
      (product,

       product_definition_formation,

       product_definition);
   END_TYPE;



   TYPE promissory_usage_in_product_model_assigned_item = SELECT
      (product_concept,

       product_definition);
   END_TYPE;



   TYPE property_or_shape_select = SELECT
      (property_definition,

       shape_definition);
   END_TYPE;



   TYPE ratio_measure = REAL;
   END_TYPE;



   TYPE relationship_with_condition = SELECT
      (action_method_relationship,

       action_relationship);
   END_TYPE;



   TYPE replacement_from_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE replacement_to_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE represented_definition = SELECT
      (property_definition,

       property_definition_relationship,

       shape_aspect,

       shape_aspect_relationship);
   END_TYPE;



   TYPE reversible_topology = SELECT
      (reversible_topology_item,

       list_of_reversible_topology_item,

       set_of_reversible_topology_item);
   END_TYPE;



   TYPE reversible_topology_item = SELECT
      (edge,

       path,

       face,

       face_bound,

       closed_shell,

       open_shell);
   END_TYPE;



   TYPE role_select = SELECT
      (action_assignment,

       action_request_assignment,

       approval_assignment,

       approval_date_time,

       certification_assignment,

       contract_assignment,

       document_reference,

       group_assignment,

       security_classification_assignment);
   END_TYPE;



   TYPE second_in_minute = REAL;
   WHERE
      WR1:
         (0 <= SELF) AND (SELF <= 60.0000);
   END_TYPE;



   TYPE security_classification_assigned_item = SELECT
      (applied_promissory_usage_in_product_model_assignment,

       assembly_component_usage,

       document,

       make_from_usage_option,

       product_definition_formation,

       product_definition);
   END_TYPE;



   TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
   END_TYPE;



   TYPE set_representation_item = SET [1:?] OF representation_item;
   END_TYPE;



   TYPE shape_definition = SELECT
      (product_definition_shape,

       shape_aspect,

       shape_aspect_relationship);
   END_TYPE;



   TYPE shell = SELECT
      (vertex_shell,

       wire_shell,

       open_shell,

       closed_shell);
   END_TYPE;



   TYPE si_prefix = ENUMERATION OF
      (exa,

       peta,

       tera,

       giga,

       mega,

       kilo,

       hecto,

       deca,

       deci,

       centi,

       milli,

       micro,

       nano,

       pico,

       femto,

       atto);
   END_TYPE;



   TYPE si_unit_name = ENUMERATION OF
      (metre,

       gram,

       second,

       ampere,

       kelvin,

       mole,

       candela,

       radian,

       steradian,

       hertz,

       newton,

       pascal,

       joule,

       watt,

       coulomb,

       volt,

       farad,

       ohm,

       siemens,

       weber,

       tesla,

       henry,

       degree_Celsius,

       lumen,

       lux,

       becquerel,

       gray,

       sievert);
   END_TYPE;



   TYPE size_select = SELECT
      (positive_length_measure,

       measure_with_unit,

       descriptive_measure);
   END_TYPE;



   TYPE solid_angle_measure = REAL;
   END_TYPE;



   TYPE source = ENUMERATION OF
      (made,

       bought,

       not_known);
   END_TYPE;



   TYPE source_item = SELECT
      (identifier);
   END_TYPE;



   TYPE squared_or_rounded = ENUMERATION OF
      (squared,

       rounded);
   END_TYPE;



   TYPE start_request_item = SELECT
      (product_definition_formation,

       representation_relationship);
   END_TYPE;



   TYPE style_context_select = SELECT
      (group,

       representation,

       representation_item);
   END_TYPE;



   TYPE supported_item = SELECT
      (action_directive,

       action,

       action_method);
   END_TYPE;



   TYPE surface_boundary = SELECT
      (boundary_curve,

       degenerate_pcurve);
   END_TYPE;



   TYPE surface_model = SELECT
      (shell_based_surface_model);
   END_TYPE;



   TYPE text = STRING;
   END_TYPE;



   TYPE text_alignment = label;
   END_TYPE;



   TYPE text_or_character = SELECT
      (annotation_text,

       annotation_text_character,

       text_literal);
   END_TYPE;



   TYPE text_path = ENUMERATION OF
      (left,

       right,

       up,

       down);
   END_TYPE;



   TYPE thermodynamic_temperature_measure = REAL;
   END_TYPE;



   TYPE time_measure = REAL;
   END_TYPE;



   TYPE tolerance_method_definition = SELECT
      (tolerance_value);
   END_TYPE;



   TYPE tolerance_select = SELECT
      (geometric_tolerance,

       plus_minus_tolerance);
   END_TYPE;



   TYPE transformation = SELECT
      (item_defined_transformation,

       functionally_defined_transformation);
   END_TYPE;



   TYPE transition_code = ENUMERATION OF
      (discontinuous,

       continuous,

       cont_same_gradient,

       cont_same_gradient_same_curvature);
   END_TYPE;



   TYPE trimming_preference = ENUMERATION OF
      (cartesian,

       parameter,

       unspecified);
   END_TYPE;



   TYPE trimming_select = SELECT
      (cartesian_point,

       parameter_value);
   END_TYPE;



   TYPE unit = SELECT
      (named_unit,

       derived_unit);
   END_TYPE;



   TYPE value_qualifier = SELECT
      (precision_qualifier,

       type_qualifier,

       uncertainty_qualifier);
   END_TYPE;



   TYPE vector_or_direction = SELECT
      (vector,

       direction);
   END_TYPE;



   TYPE volume_measure = REAL;
   END_TYPE;



   TYPE wireframe_model = SELECT
      (shell_based_wireframe_model,

       edge_based_wireframe_model);
   END_TYPE;



   TYPE work_item = SELECT
      (product_definition_formation);
   END_TYPE;



   TYPE year_number = INTEGER;
   END_TYPE;


(* ***********************************
Functions in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   FUNCTION acyclic_curve_replica
      (rep : curve_replica;
       parent : curve ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_curve_replica(rep,
 parent\curve_replica.parent_curve));
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_mapped_representation
      (parent_set : SET OF representation;
       children_set : SET OF representation_item ) : BOOLEAN;
   LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
   END_LOCAL;
      x := QUERY (z <* children_set| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' IN TYPEOF(z));
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            IF x[i]\mapped_item.mapping_source.mapped_representation IN parent_set THEN
               RETURN (FALSE);
            END_IF;
            IF NOT acyclic_mapped_representation((parent_set + x[i]\mapped_item.mapping_source.mapped_representation),
 x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      x := children_set - x;
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            y := QUERY (z <* bag_to_set(USEDIN(x[i],
 ''))| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z));
            IF NOT acyclic_mapped_representation(parent_set,
 y) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_point_replica
      (rep : point_replica;
       parent : point ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_point_replica(rep,
 parent\point_replica.parent_pt));
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_product_category_relationship
      (relation : product_category_relationship;
       children : SET OF product_category ) : BOOLEAN;
   LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(children);
         IF relation.category :=: children[i] THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      x := bag_to_set(USEDIN(relation.category,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
      local_children := children + relation.category;
      IF SIZEOF(x) > 0 THEN
         REPEAT i := 1 TO HIINDEX(x);
            IF NOT acyclic_product_category_relationship(x[i],
 local_children) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_product_definition_relationship
      (relation : product_definition_relationship;
       relatives : SET [1:?] OF product_definition;
       specific_relation : STRING ) : BOOLEAN;
   LOCAL
      x : SET OF product_definition_relationship;
   END_LOCAL;
      IF relation.relating_product_definition IN relatives THEN
         RETURN (FALSE);
      END_IF;
      x := QUERY (pd <* bag_to_set(USEDIN(relation.relating_product_definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))| specific_relation IN TYPEOF(pd));
      REPEAT i := 1 TO HIINDEX(x);
         IF NOT acyclic_product_definition_relationship(x[i],
 (relatives + relation.relating_product_definition),
 specific_relation) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_shape_aspect_relationship
      (relation : shape_aspect_relationship;
       relatives : SET [1:?] OF shape_aspect;
       specific_relation : STRING ) : BOOLEAN;
   LOCAL
      x : SET OF shape_aspect_relationship;
   END_LOCAL;
      IF relation.relating_shape_aspect IN relatives THEN
         RETURN (FALSE);
      END_IF;
      x := QUERY (sa <* bag_to_set(USEDIN(relation.relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT'))| specific_relation IN TYPEOF(sa));
      REPEAT i := 1 TO HIINDEX(x);
         IF NOT acyclic_shape_aspect_relationship(x[i],
 (relatives + relation.relating_shape_aspect),
 specific_relation) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION acyclic_solid_replica
      (rep : solid_replica;
       parent : solid_model ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_solid_replica(rep,
 parent\solid_replica.parent_solid));
      END_IF;
   END_FUNCTION;



   FUNCTION acyclic_surface_replica
      (rep : surface_replica;
       parent : surface ) : BOOLEAN;
      IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent)) THEN
         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_surface_replica(rep,
 parent\surface_replica.parent_surface));
      END_IF;
   END_FUNCTION;



   FUNCTION advanced_face_properties
      (testface : face ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ADVANCED_FACE' IN TYPEOF(testface) THEN
         RETURN (TRUE);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SUBFACE' IN TYPEOF(testface) THEN
         RETURN (advanced_face_properties(testface.parent_face));
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION applied_date_correlation
      (e : applied_date_assignment;
       schema_name : STRING ) : BOOLEAN;
   LOCAL
      d_role : STRING;
   END_LOCAL;
      d_role := e\date_assignment.role\date_role.name;
      CASE d_role OF
         'creation date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.PRODUCT_DEFINITION'),
 (schema_name + '.DOCUMENT') ] * TYPEOF(x)) >= 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'request date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.VERSIONED_ACTION_REQUEST' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'release date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),
 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'start date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),
 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'sign off date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.APPROVAL_PERSON_ORGANIZATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'contract date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CONTRACT' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'certification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CERTIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'classification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'declassification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
      OTHERWISE :
            RETURN (TRUE);
      END_CASE;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION applied_date_time_correlation
      (e : applied_date_and_time_assignment;
       schema_name : STRING ) : BOOLEAN;
   LOCAL
      dt_role : STRING;
   END_LOCAL;
      dt_role := e\date_and_time_assignment.role\date_time_role.name;
      CASE dt_role OF
         'creation date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.PRODUCT_DEFINITION'),
 (schema_name + '.DOCUMENT') ] * TYPEOF(x)) >= 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'request date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.VERSIONED_ACTION_REQUEST' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'release date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),
 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'start date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (SIZEOF([ (schema_name + '.CHANGE'),
 (schema_name + '.START_WORK') ] * TYPEOF(x)) = 1))) THEN
                  RETURN (FALSE);
               END_IF;
         'sign off date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.APPROVAL_PERSON_ORGANIZATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'contract date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CONTRACT' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'certification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.CERTIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'classification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'declassification date' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.SECURITY_CLASSIFICATION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
         'participant date and time' :
               IF SIZEOF(e.items) <> SIZEOF(QUERY (x <* e.items| (schema_name + '.RULE_ACTION' IN TYPEOF(x)))) THEN
                  RETURN (FALSE);
               END_IF;
      OTHERWISE :
            RETURN (TRUE);
      END_CASE;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION associated_surface
      (arg : pcurve_or_surface ) : surface;
   LOCAL
      surf : surface;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(arg) THEN
         surf := arg.basis_surface;
      ELSE
         surf := arg;
      END_IF;
      RETURN (surf);
   END_FUNCTION;



   FUNCTION bag_to_set
      (the_bag : BAG OF GENERIC : intype ) : SET OF GENERIC : intype;
   LOCAL
      the_set : SET OF GENERIC : intype := [];
      i : INTEGER;
   END_LOCAL;
      IF SIZEOF(the_bag) > 0 THEN
         REPEAT i := 1 TO HIINDEX(the_bag);
            the_set := the_set + the_bag[i];
         END_REPEAT;
      END_IF;
      RETURN (the_set);
   END_FUNCTION;



   FUNCTION base_axis
      (dim : INTEGER;
       axis1 : direction;
       axis2 : direction;
       axis3 : direction ) : LIST [2:3] OF direction;
   LOCAL
      u : LIST [2:3] OF direction;
      factor : REAL;
      d1 : direction;
      d2 : direction;
   END_LOCAL;
      IF dim = 3 THEN
         d1 := NVL(normalise(axis3),
 dummy_gri || direction([ 0.00000,
 0.00000,
 1.00000 ]));
         d2 := first_proj_axis(d1,
 axis1);
         u := [ d2,
 second_proj_axis(d1,
 d2,
 axis2),
 d1 ];
      ELSE
         IF EXISTS(axis1) THEN
            d1 := normalise(axis1);
            u := [ d1,
 orthogonal_complement(d1) ];
            IF EXISTS(axis2) THEN
               factor := dot_product(axis2,
 u[2]);
               IF factor < 0.00000 THEN
                  u[2].direction_ratios[1] := -u[2].direction_ratios[1];
                  u[2].direction_ratios[2] := -u[2].direction_ratios[2];
               END_IF;
            END_IF;
         ELSE
            IF EXISTS(axis2) THEN
               d1 := normalise(axis2);
               u := [ orthogonal_complement(d1),
 d1 ];
               u[1].direction_ratios[1] := -u[1].direction_ratios[1];
               u[1].direction_ratios[2] := -u[1].direction_ratios[2];
            ELSE
               u := [ dummy_gri || direction([ 1.00000,
 0.00000 ]),
 dummy_gri || direction([ 0.00000,
 1.00000 ]) ];
            END_IF;
         END_IF;
      END_IF;
      RETURN (u);
   END_FUNCTION;



   FUNCTION boolean_choose
      (b : BOOLEAN;
       choice1 : GENERIC : item;
       choice2 : GENERIC : item ) : GENERIC : item;
      IF b THEN
         RETURN (choice1);
      ELSE
         RETURN (choice2);
      END_IF;
   END_FUNCTION;



   FUNCTION build_2axes
      (ref_direction : direction ) : LIST [2:2] OF direction;
   LOCAL
      d : direction := NVL(normalise(ref_direction),
 dummy_gri || direction([ 1.00000,
 0.00000 ]));
   END_LOCAL;
      RETURN ([ d,
 orthogonal_complement(d) ]);
   END_FUNCTION;



   FUNCTION build_axes
      (axis : direction;
       ref_direction : direction ) : LIST [3:3] OF direction;
   LOCAL
      d1 : direction;
      d2 : direction;
   END_LOCAL;
      d1 := NVL(normalise(axis),
 dummy_gri || direction([ 0.00000,
 0.00000,
 1.00000 ]));
      d2 := first_proj_axis(d1,
 ref_direction);
      RETURN ([ d2,
 normalise(cross_product(d1,
 d2)).orientation,
 d1 ]);
   END_FUNCTION;



   FUNCTION closed_shell_reversed
      (a_shell : closed_shell ) : oriented_closed_shell;
   LOCAL
      the_reverse : oriented_closed_shell;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell) THEN
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() || oriented_closed_shell(a_shell\oriented_closed_shell.closed_shell_element,
 NOT a_shell\oriented_closed_shell.orientation);
      ELSE
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() || oriented_closed_shell(a_shell,
 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION component_definition_located_by_component_location
      (cl : component_location ) : component_definition;
   LOCAL
      pdr : BAG OF property_definition_representation := USEDIN(cl,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(pdr) BY 1;
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr[i].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr[i].definition.definition\product_definition_relationship.related_product_definition)) THEN
            RETURN (pdr[i].definition.definition\product_definition_relationship.related_product_definition);
         END_IF;
      END_REPEAT;
      RETURN (?);
   END_FUNCTION;



   FUNCTION conditional_reverse
      (p : BOOLEAN;
       an_item : reversible_topology ) : reversible_topology;
      IF p THEN
         RETURN (an_item);
      ELSE
         RETURN (topology_reversed(an_item));
      END_IF;
   END_FUNCTION;



   FUNCTION consistent_bus_structural_definition
      (input_rel : SET [1:?] OF product_definition_relationship ) : BOOLEAN;
   LOCAL
      input : SET OF product_definition := [];
      vertex : SET OF product_definition := [];
      edge : INTEGER := SIZEOF(input);
      vc : INTEGER := 0;
      vertex_degree : INTEGER := 0;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(input_rel) BY 1;
         input := input + input_rel[i].related_product_definition;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(input) BY 1;
         vertex := vertex + input[i]\product_definition_relationship.relating_product_definition;
         vertex := vertex + input[i]\product_definition_relationship.related_product_definition;
      END_REPEAT;
      vc := SIZEOF(vertex);
      IF vc <> edge + 1 THEN
         RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO vc BY 1;
         vertex_degree := 0;
         REPEAT j := 1 TO SIZEOF(input) BY 1;
            IF input[j]\product_definition_relationship.relating_product_definition = vertex[i] THEN
               vertex_degree := vertex_degree + 1;
            END_IF;
            IF input[j]\product_definition_relationship.related_product_definition = vertex[i] THEN
               vertex_degree := vertex_degree + 1;
            END_IF;
         END_REPEAT;
         IF vertex_degree > 2 THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION constraints_composite_curve_on_surface
      (c : composite_curve_on_surface ) : BOOLEAN;
   LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
      REPEAT k := 1 TO n_segments;
         IF (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\composite_curve.segments[k].parent_curve)) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION constraints_geometry_shell_based_surface_model
      (m : shell_based_surface_model ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
         IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[j])) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary[j])) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION constraints_geometry_shell_based_wireframe_model
      (m : shell_based_wireframe_model ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
         IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[j])) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary[j])) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION constraints_param_b_spline
      (degree : INTEGER;
       up_knots : INTEGER;
       up_cp : INTEGER;
       knot_mult : LIST OF INTEGER;
       knots : LIST OF parameter_value ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
      k : INTEGER;
      sum : INTEGER;
   END_LOCAL;
      sum := knot_mult[1];
      REPEAT i := 2 TO up_knots;
         sum := sum + knot_mult[i];
      END_REPEAT;
      IF (((degree < 1) OR (up_knots < 2)) OR (up_cp < degree)) OR (sum <> degree + up_cp + 2) THEN
         result := FALSE;
         RETURN (result);
      END_IF;
      k := knot_mult[1];
      IF (k < 1) OR (k > degree + 1) THEN
         result := FALSE;
         RETURN (result);
      END_IF;
      REPEAT i := 2 TO up_knots;
         IF (knot_mult[i] < 1) OR (knots[i] <= knots[(i - 1)]) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
         k := knot_mult[i];
         IF (i < up_knots) AND (k > degree) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
         IF (i = up_knots) AND (k > degree + 1) THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION constraints_rectangular_composite_surface
      (s : rectangular_composite_surface ) : BOOLEAN;
      REPEAT i := 1 TO s.n_u;
         REPEAT j := 1 TO s.n_v;
            IF NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.segments[i][j].parent_surface)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.segments[i][j].parent_surface))) THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO s.n_u - 1;
         REPEAT j := 1 TO s.n_v;
            IF s.segments[i][j].u_transition = discontinuous THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO s.n_u;
         REPEAT j := 1 TO s.n_v - 1;
            IF s.segments[i][j].v_transition = discontinuous THEN
               RETURN (FALSE);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION cross_product
      (arg1 : direction;
       arg2 : direction ) : vector;
   LOCAL
      mag : REAL;
      res : direction;
      v1 : LIST [3:3] OF REAL;
      v2 : LIST [3:3] OF REAL;
      result : vector;
   END_LOCAL;
      IF (NOT EXISTS(arg1) OR (arg1.dim = 2)) OR (NOT EXISTS(arg2) OR (arg2.dim = 2)) THEN
         RETURN (?);
      ELSE
         BEGIN
            v1 := normalise(arg1).direction_ratios;
            v2 := normalise(arg2).direction_ratios;
            res := dummy_gri || direction([ (v1[2] * v2[3] - v1[3] * v2[2]),
 (v1[3] * v2[1] - v1[1] * v2[3]),
 (v1[1] * v2[2] - v1[2] * v2[1]) ]);
            mag := 0.00000;
            REPEAT i := 1 TO 3;
               mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
            END_REPEAT;
            IF mag > 0.00000 THEN
               result := dummy_gri || vector(res,
 sqrt(mag));
            ELSE
               result := dummy_gri || vector(arg1,
 0.00000);
            END_IF;
            RETURN (result);
         END;
      END_IF;
   END_FUNCTION;



   FUNCTION cto2d_determinant_test
      (cto2d : cartesian_transformation_operator_2d;
       expected_value : REAL;
       delta : REAL ) : BOOLEAN;
   LOCAL
      det : REAL := 0.00000;
      DRs : LIST [4:4] OF REAL := [];
   END_LOCAL;
      DRs[1] := cto2d.u[1].direction_ratios[1];
      DRs[2] := cto2d.u[1].direction_ratios[2];
      DRs[3] := cto2d.u[2].direction_ratios[1];
      DRs[4] := cto2d.u[2].direction_ratios[2];
      det := DRs[1] * DRs[4] - DRs[2] * DRs[3];
      IF abs(expected_value - det) < abs(delta) THEN
         RETURN (TRUE);
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION curve_weights_positive
      (b : rational_b_spline_curve ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 0 TO b.upper_index_on_control_points;
         IF b.weights[i] <= 0.00000 THEN
            result := FALSE;
            RETURN (result);
         END_IF;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION derive_dimensional_exponents
      (x : unit ) : dimensional_exponents;
   LOCAL
      result : dimensional_exponents := dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000);
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DERIVED_UNIT' IN TYPEOF(x) THEN
         REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
            result.length_exponent := result.length_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent;
            result.mass_exponent := result.mass_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent;
            result.time_exponent := result.time_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent;
            result.electric_current_exponent := result.electric_current_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent;
            result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent;
            result.amount_of_substance_exponent := result.amount_of_substance_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent;
            result.luminous_intensity_exponent := result.luminous_intensity_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent;
         END_REPEAT;
      ELSE
         result := x.dimensions;
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION dimension_of
      (item : geometric_representation_item ) : dimension_count;
   LOCAL
      x : SET OF representation;
      y : representation_context;
      dim : dimension_count;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(item) THEN
         dim := SIZEOF(item\cartesian_point.coordinates);
         RETURN (dim);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DIRECTION' IN TYPEOF(item) THEN
         dim := SIZEOF(item\direction.direction_ratios);
         RETURN (dim);
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(item) THEN
         dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
         RETURN (dim);
      END_IF;
      x := using_representations(item);
      y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
      RETURN (dim);
   END_FUNCTION;



   FUNCTION dimensions_for_si_unit
      (n : si_unit_name ) : dimensional_exponents;
      CASE n OF
         metre :
               RETURN (dimensional_exponents(1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         gram :
               RETURN (dimensional_exponents(0.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         second :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         ampere :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000));
         kelvin :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000));
         mole :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000));
         candela :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000));
         radian :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         steradian :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         hertz :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 -1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         newton :
               RETURN (dimensional_exponents(1.00000,
 1.00000,
 -2.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         pascal :
               RETURN (dimensional_exponents(-1.00000,
 1.00000,
 -2.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         joule :
               RETURN (dimensional_exponents(2.00000,
 1.00000,
 -2.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         watt :
               RETURN (dimensional_exponents(2.00000,
 1.00000,
 -3.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         coulomb :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 1.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000));
         volt :
               RETURN (dimensional_exponents(2.00000,
 1.00000,
 -3.00000,
 -1.00000,
 0.00000,
 0.00000,
 0.00000));
         farad :
               RETURN (dimensional_exponents(-2.00000,
 -1.00000,
 4.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000));
         ohm :
               RETURN (dimensional_exponents(2.00000,
 1.00000,
 -3.00000,
 -2.00000,
 0.00000,
 0.00000,
 0.00000));
         siemens :
               RETURN (dimensional_exponents(-2.00000,
 -1.00000,
 3.00000,
 2.00000,
 0.00000,
 0.00000,
 0.00000));
         weber :
               RETURN (dimensional_exponents(2.00000,
 1.00000,
 -2.00000,
 -1.00000,
 0.00000,
 0.00000,
 0.00000));
         tesla :
               RETURN (dimensional_exponents(0.00000,
 1.00000,
 -2.00000,
 -1.00000,
 0.00000,
 0.00000,
 0.00000));
         henry :
               RETURN (dimensional_exponents(2.00000,
 1.00000,
 -2.00000,
 -2.00000,
 0.00000,
 0.00000,
 0.00000));
         degree_Celsius :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000));
         lumen :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000));
         lux :
               RETURN (dimensional_exponents(-2.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000));
         becquerel :
               RETURN (dimensional_exponents(0.00000,
 0.00000,
 -1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         gray :
               RETURN (dimensional_exponents(2.00000,
 0.00000,
 -2.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
         sievert :
               RETURN (dimensional_exponents(2.00000,
 0.00000,
 -2.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000));
      OTHERWISE :
            RETURN (?);
      END_CASE;
   END_FUNCTION;



   FUNCTION dot_product
      (arg1 : direction;
       arg2 : direction ) : REAL;
   LOCAL
      scalar : REAL;
      vec1 : direction;
      vec2 : direction;
      ndim : INTEGER;
   END_LOCAL;
      IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) THEN
         scalar := ?;
      ELSE
         IF arg1.dim <> arg2.dim THEN
            scalar := ?;
         ELSE
            BEGIN
               vec1 := normalise(arg1);
               vec2 := normalise(arg2);
               ndim := arg1.dim;
               scalar := 0.00000;
               REPEAT i := 1 TO ndim;
                  scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
               END_REPEAT;
            END;
         END_IF;
      END_IF;
      RETURN (scalar);
   END_FUNCTION;



   FUNCTION edge_reversed
      (an_edge : edge ) : oriented_edge;
   LOCAL
      the_reverse : oriented_edge;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
         the_reverse := dummy_tri || edge(an_edge.edge_end,
 an_edge.edge_start) || oriented_edge(an_edge\oriented_edge.edge_element,
 NOT an_edge\oriented_edge.orientation);
      ELSE
         the_reverse := dummy_tri || edge(an_edge.edge_end,
 an_edge.edge_start) || oriented_edge(an_edge,
 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION face_bound_reversed
      (a_face_bound : face_bound ) : face_bound;
   LOCAL
      the_reverse : face_bound;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound) THEN
         the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
 NOT a_face_bound\face_bound.orientation) || face_outer_bound();
      ELSE
         the_reverse := dummy_tri || face_bound(a_face_bound.bound,
 NOT a_face_bound.orientation);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION face_reversed
      (a_face : face ) : oriented_face;
   LOCAL
      the_reverse : oriented_face;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
         the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face\oriented_face.face_element,
 NOT a_face\oriented_face.orientation);
      ELSE
         the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face,
 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION first_proj_axis
      (z_axis : direction;
       arg : direction ) : direction;
   LOCAL
      x_axis : direction;
      v : direction;
      z : direction;
      x_vec : vector;
   END_LOCAL;
      IF NOT EXISTS(z_axis) THEN
         RETURN (?);
      ELSE
         z := normalise(z_axis);
         IF NOT EXISTS(arg) THEN
            IF z.direction_ratios <> [ 1.00000,
 0.00000,
 0.00000 ] THEN
               v := dummy_gri || direction([ 1.00000,
 0.00000,
 0.00000 ]);
            ELSE
               v := dummy_gri || direction([ 0.00000,
 1.00000,
 0.00000 ]);
            END_IF;
         ELSE
            IF arg.dim <> 3 THEN
               RETURN (?);
            END_IF;
            IF cross_product(arg,
 z).magnitude = 0.00000 THEN
               RETURN (?);
            ELSE
               v := normalise(arg);
            END_IF;
         END_IF;
         x_vec := scalar_times_vector(dot_product(v,
 z),
 z);
         x_axis := vector_difference(v,
 x_vec).orientation;
         x_axis := normalise(x_axis);
      END_IF;
      RETURN (x_axis);
   END_FUNCTION;



   FUNCTION gbsf_check_curve
      (cv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE' ] * TYPEOF(cv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) THEN
            RETURN (TRUE);
         ELSE
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) THEN
               RETURN (SIZEOF(QUERY (seg <* cv\composite_curve.segments| NOT gbsf_check_curve(seg.parent_curve))) = 0);
            ELSE
               IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' ] * TYPEOF(cv)) = 1 THEN
                  RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
               ELSE
                  IF (SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' ] * TYPEOF(cv)) = 1) AND (cv\offset_curve_3d.self_intersect = FALSE) THEN
                     RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
                  ELSE
                     IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' ] * TYPEOF(cv)) = 1 THEN
                        RETURN (gbsf_check_curve(cv\pcurve.reference_to_curve.items[1]) AND gbsf_check_surface(cv\pcurve.basis_surface));
                     ELSE
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                           IF (SIZEOF(cv\polyline.points) >= 3) AND (SIZEOF(bag_to_set(USEDIN(cv,
 '')) - bag_to_set(USEDIN(cv,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE.CURVE_3D'))) = 0) THEN
                              RETURN (TRUE);
                           END_IF;
                        ELSE
                           IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' ] * TYPEOF(cv)) = 1 THEN
                              IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                                 REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                                    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                       IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                                          RETURN (FALSE);
                                       END_IF;
                                    ELSE
                                       IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                                             RETURN (FALSE);
                                          END_IF;
                                       END_IF;
                                    END_IF;
                                 END_REPEAT;
                                 RETURN (TRUE);
                              END_IF;
                           ELSE
                              IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' IN TYPEOF(cv) THEN
                                 IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARABOLA',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.HYPERBOLA' ] * TYPEOF(cv\trimmed_curve.basis_curve)) = 1 THEN
                                    RETURN (TRUE);
                                 ELSE
                                    RETURN (gbsf_check_curve(cv\trimmed_curve.basis_curve));
                                 END_IF;
                              END_IF;
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION gbsf_check_point
      (pnt : point ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
            RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
               RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
                  RETURN (gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve.items[1]) AND gbsf_check_surface(pnt\degenerate_pcurve.basis_surface));
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION gbsf_check_surface
      (sf : surface ) : BOOLEAN;
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) THEN
         RETURN (TRUE);
      ELSE
         IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SPHERICAL_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TOROIDAL_SURFACE' ] * TYPEOF(sf)) = 1 THEN
            RETURN (TRUE);
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN
               IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONICAL_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CYLINDRICAL_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' ] * TYPEOF(sf\curve_bounded_surface.basis_surface)) = 1 THEN
                  RETURN (SIZEOF(QUERY (bcurve <* sf\curve_bounded_surface.boundaries| NOT gbsf_check_curve(bcurve))) = 0);
               ELSE
                  IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface) THEN
                     RETURN (SIZEOF(QUERY (bcurve <* sf\curve_bounded_surface.boundaries| NOT gbsf_check_curve(bcurve))) = 0);
                  END_IF;
               END_IF;
            ELSE
               IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) THEN
                  RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
               ELSE
                  IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
                     REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
                        REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
                           IF NOT gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface) THEN
                              RETURN (FALSE);
                           END_IF;
                        END_REPEAT;
                     END_REPEAT;
                     RETURN (TRUE);
                  ELSE
                     IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(sf) THEN
                        IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONICAL_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CYLINDRICAL_SURFACE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE' ] * TYPEOF(sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN
                           RETURN (TRUE);
                        ELSE
                           RETURN (gbsf_check_surface(sf\rectangular_trimmed_surface.basis_surface));
                        END_IF;
                     ELSE
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' IN TYPEOF(sf) THEN
                           RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
                        ELSE
                           IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(sf) THEN
                              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION get_basis_surface
      (c : curve_on_surface ) : SET [0:2] OF surface;
   LOCAL
      surfs : SET [0:2] OF surface;
      n : INTEGER;
   END_LOCAL;
      surfs := [];
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(c) THEN
         surfs := [ c\pcurve.basis_surface ];
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
            n := SIZEOF(c\surface_curve.associated_geometry);
            REPEAT i := 1 TO n;
               surfs := surfs + associated_surface(c\surface_curve.associated_geometry[i]);
            END_REPEAT;
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) THEN
         n := SIZEOF(c\composite_curve.segments);
         surfs := get_basis_surface(c\composite_curve.segments[1].parent_curve);
         IF n > 1 THEN
            REPEAT i := 2 TO n;
               surfs := surfs * get_basis_surface(c\composite_curve.segments[i].parent_curve);
            END_REPEAT;
         END_IF;
      END_IF;
      RETURN (surfs);
   END_FUNCTION;



   FUNCTION get_description_value
      (obj : description_attribute_select ) : text;
   LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
   END_LOCAL;
      IF SIZEOF(description_bag) = 1 THEN
         RETURN (description_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_id_value
      (obj : id_attribute_select ) : identifier;
   LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
   END_LOCAL;
      IF SIZEOF(id_bag) = 1 THEN
         RETURN (id_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_name_value
      (obj : name_attribute_select ) : label;
   LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM');
   END_LOCAL;
      IF SIZEOF(name_bag) = 1 THEN
         RETURN (name_bag[1].attribute_value);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION get_role
      (obj : role_select ) : object_role;
   LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE');
   END_LOCAL;
      IF SIZEOF(role_bag) = 1 THEN
         RETURN (role_bag[1].role);
      ELSE
         RETURN (?);
      END_IF;
   END_FUNCTION;



   FUNCTION instance_unique
      (the_bag : BAG OF GENERIC : intype ) : BOOLEAN;
   LOCAL
      the_set : SET OF GENERIC : intype := [];
      i : INTEGER;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      IF SIZEOF(the_bag) > 0 THEN
         the_set := bag_to_set(the_bag);
      END_IF;
      IF NOT (SIZEOF(the_set) = SIZEOF(the_bag)) THEN
         pass := FALSE;
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_assembly_module_design
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'physical design') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_assembly_module_macro_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'macro occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_assembly_module_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'physical occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_assembly_module_usage
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'assembly module') AND (pd.frame_of_reference\application_context_element.name = 'physical design usage') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_ee_product_definition
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF (((((((NOT is_laminate_component(pd) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(pd))) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd)) THEN
         RETURN (TRUE);
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_interconnect_module_component_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_interconnect_module_occurrence(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION is_interconnect_module_design
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'physical design') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_interconnect_module_macro_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'macro occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_interconnect_module_occurrence
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'physical occurrence') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_interconnect_module_usage
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF NOT EXISTS(pd\product_definition.name) THEN
         RETURN (FALSE);
      END_IF;
      IF (pd\product_definition.name = 'interconnect module') AND (pd.frame_of_reference\application_context_element.name = 'physical design usage') THEN
         RETURN (TRUE);
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_laminate_component
      (pd : product_definition ) : BOOLEAN;
   LOCAL
      pass : BOOLEAN := FALSE;
   END_LOCAL;
      IF pd\product_definition.description = 'laminate component' THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_COMPONENT' IN TYPEOF(pd) THEN
            RETURN (TRUE);
         END_IF;
      END_IF;
      RETURN (pass);
   END_FUNCTION;



   FUNCTION is_laminate_component_location
      (cl : component_location ) : BOOLEAN;
   LOCAL
      pdrs : SET OF property_definition_representation := bag_to_set(USEDIN(cl,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
   END_LOCAL;
      IF SIZEOF(pdrs) = 1 THEN
         IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdrs[1].definition.definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdrs[1].definition.definition.related_product_definition))) AND is_laminate_component(pdrs[1].definition.definition.related_product_definition) THEN
            RETURN (TRUE);
         ELSE
            RETURN (FALSE);
         END_IF;
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION item_in_context
      (item : representation_item;
       cntxt : representation_context ) : BOOLEAN;
   LOCAL
      y : BAG OF representation_item;
   END_LOCAL;
      IF SIZEOF(USEDIN(item,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS') * cntxt.representations_in_context) > 0 THEN
         RETURN (TRUE);
      ELSE
         y := QUERY (z <* USEDIN(item,
 '')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z));
         IF SIZEOF(y) > 0 THEN
            REPEAT i := 1 TO HIINDEX(y);
               IF item_in_context(y[i],
 cntxt) THEN
                  RETURN (TRUE);
               END_IF;
            END_REPEAT;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION leap_year
      (year : year_number ) : BOOLEAN;
      IF (year MOD 4 = 0) AND (year MOD 100 <> 0) OR (year MOD 400 = 0) THEN
         RETURN (TRUE);
      ELSE
         RETURN (FALSE);
      END_IF;
   END_FUNCTION;



   FUNCTION list_face_loops
      (f : face ) : LIST [0:?] OF loop;
   LOCAL
      loops : LIST [0:?] OF loop := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(f.bounds);
         loops := loops + f.bounds[i].bound;
      END_REPEAT;
      RETURN (loops);
   END_FUNCTION;



   FUNCTION list_of_topology_reversed
      (a_list : list_of_reversible_topology_item ) : list_of_reversible_topology_item;
   LOCAL
      the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
      the_reverse := [];
      REPEAT i := 1 TO SIZEOF(a_list);
         the_reverse := topology_reversed(a_list[i]) + the_reverse;
      END_REPEAT;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION list_to_array
      (lis : LIST [0:?] OF GENERIC : T;
       low : INTEGER;
       u : INTEGER ) : ARRAY OF GENERIC : T;
   LOCAL
      n : INTEGER;
      res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      n := SIZEOF(lis);
      IF n <> u - low + 1 THEN
         RETURN (?);
      ELSE
         res := [ lis[1] ];
         REPEAT i := 2 TO n;
            res[(low + i - 1)] := lis[i];
         END_REPEAT;
         RETURN (res);
      END_IF;
   END_FUNCTION;



   FUNCTION list_to_set
      (l : LIST [0:?] OF GENERIC : T ) : SET OF GENERIC : T;
   LOCAL
      s : SET OF GENERIC : T := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(l);
         s := s + l[i];
      END_REPEAT;
      RETURN (s);
   END_FUNCTION;



   FUNCTION make_array_of_array
      (lis : LIST [1:?] OF LIST [1:?] OF GENERIC : T;
       low1 : INTEGER;
       u1 : INTEGER;
       low2 : INTEGER;
       u2 : INTEGER ) : ARRAY OF ARRAY OF GENERIC : T;
   LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;
      IF u1 - low1 + 1 <> SIZEOF(lis) THEN
         RETURN (?);
      END_IF;
      IF u2 - low2 + 1 <> SIZEOF(lis[1]) THEN
         RETURN (?);
      END_IF;
      res := [ list_to_array(lis[1],
 low2,
 u2) ];
      REPEAT i := 2 TO HIINDEX(lis);
         IF u2 - low2 + 1 <> SIZEOF(lis[i]) THEN
            RETURN (?);
         END_IF;
         res[(low1 + i - 1)] := list_to_array(lis[i],
 low2,
 u2);
      END_REPEAT;
      RETURN (res);
   END_FUNCTION;



   FUNCTION mixed_loop_type_set
      (l : SET [0:?] OF loop ) : LOGICAL;
   LOCAL
      poly_loop_type : LOGICAL;
   END_LOCAL;
      IF SIZEOF(l) <= 1 THEN
         RETURN (FALSE);
      END_IF;
      poly_loop_type := 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
      REPEAT i := 2 TO SIZEOF(l);
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type THEN
            RETURN (TRUE);
         END_IF;
      END_REPEAT;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION msb_shells
      (brep : manifold_solid_brep;
       schema_name : STRING ) : SET [1:?] OF closed_shell;
      IF schema_name + '.BREP_WITH_VOIDS' IN TYPEOF(brep) THEN
         RETURN (brep\brep_with_voids.voids + brep.outer);
      ELSE
         RETURN ([ brep.outer ]);
      END_IF;
   END_FUNCTION;



   FUNCTION msf_curve_check
      (cv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.BOUNDED_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' ] * TYPEOF(cv)) > 1 THEN
         RETURN (FALSE);
      ELSE
         IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) THEN
            RETURN (TRUE);
         ELSE
            IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE' ] * TYPEOF(cv)) = 1 THEN
               RETURN (TRUE);
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
                  RETURN (msf_curve_check(cv\curve_replica.parent_curve));
               ELSE
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND (cv\offset_curve_3d.self_intersect = FALSE) THEN
                     RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve));
                  ELSE
                     IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                        RETURN (msf_curve_check(cv\pcurve.reference_to_curve\representation.items[1]) AND msf_surface_check(cv\pcurve.basis_surface));
                     ELSE
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_CURVE' IN TYPEOF(cv) THEN
                           IF msf_curve_check(cv\surface_curve.curve_3d) THEN
                              REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                                 IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                    IF NOT msf_surface_check(cv\surface_curve.associated_geometry[i]) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                 ELSE
                                    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                       IF NOT msf_curve_check(cv\surface_curve.associated_geometry[i]) THEN
                                          RETURN (FALSE);
                                       END_IF;
                                    END_IF;
                                 END_IF;
                              END_REPEAT;
                              RETURN (TRUE);
                           END_IF;
                        ELSE
                           IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                              IF SIZEOF(cv\polyline.points) >= 3 THEN
                                 RETURN (TRUE);
                              END_IF;
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION msf_surface_check
      (surf : surface ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SWEPT_SURFACE' IN TYPEOF(surf) THEN
            RETURN (msf_curve_check(surf\swept_surface.swept_curve));
         ELSE
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_SURFACE' IN TYPEOF(surf)) AND (surf\offset_surface.self_intersect = FALSE) THEN
               RETURN (msf_surface_check(surf\offset_surface.basis_surface));
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SURFACE_REPLICA' IN TYPEOF(surf) THEN
                  RETURN (msf_surface_check(surf\surface_replica.parent_surface));
               ELSE
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND (surf\b_spline_surface.self_intersect = FALSE) THEN
                     RETURN (TRUE);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION normalise
      (arg : vector_or_direction ) : vector_or_direction;
   LOCAL
      ndim : INTEGER;
      v : direction;
      result : vector_or_direction;
      vec : vector;
      mag : REAL;
   END_LOCAL;
      IF NOT EXISTS(arg) THEN
         result := ?;
      ELSE
         ndim := arg.dim;
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg) THEN
            BEGIN
               v := dummy_gri || direction(arg.orientation.direction_ratios);
               IF arg.magnitude = 0.00000 THEN
                  RETURN (?);
               ELSE
                  vec := dummy_gri || vector(v,
 1.00000);
               END_IF;
            END;
         ELSE
            v := dummy_gri || direction(arg.direction_ratios);
         END_IF;
         mag := 0.00000;
         REPEAT i := 1 TO ndim;
            mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
         END_REPEAT;
         IF mag > 0.00000 THEN
            mag := sqrt(mag);
            REPEAT i := 1 TO ndim;
               v.direction_ratios[i] := v.direction_ratios[i] / mag;
            END_REPEAT;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg) THEN
               vec.orientation := v;
               result := vec;
            ELSE
               result := v;
            END_IF;
         ELSE
            RETURN (?);
         END_IF;
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION open_shell_reversed
      (a_shell : open_shell ) : oriented_open_shell;
   LOCAL
      the_reverse : oriented_open_shell;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) THEN
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() || oriented_open_shell(a_shell\oriented_open_shell.open_shell_element,
 NOT a_shell\oriented_open_shell.orientation);
      ELSE
         the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() || oriented_open_shell(a_shell,
 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION orthogonal_complement
      (vec : direction ) : direction;
   LOCAL
      result : direction;
   END_LOCAL;
      IF (vec.dim <> 2) OR NOT EXISTS(vec) THEN
         RETURN (?);
      ELSE
         result := dummy_gri || direction([ -vec.direction_ratios[2],
 vec.direction_ratios[1] ]);
         RETURN (result);
      END_IF;
   END_FUNCTION;



   FUNCTION path_head_to_tail
      (a_path : path ) : BOOLEAN;
   LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
   END_LOCAL;
      n := SIZEOF(a_path.edge_list);
      REPEAT i := 2 TO n;
         p := p AND (a_path.edge_list[(i - 1)].edge_end :=: a_path.edge_list[i].edge_start);
      END_REPEAT;
      RETURN (p);
   END_FUNCTION;



   FUNCTION path_reversed
      (a_path : path ) : oriented_path;
   LOCAL
      the_reverse : oriented_path;
   END_LOCAL;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
         the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path\oriented_path.path_element,
 NOT a_path\oriented_path.orientation);
      ELSE
         the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path,
 FALSE);
      END_IF;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION scalar_times_vector
      (scalar : REAL;
       vec : vector_or_direction ) : vector;
   LOCAL
      v : direction;
      mag : REAL;
      result : vector;
   END_LOCAL;
      IF NOT EXISTS(scalar) OR NOT EXISTS(vec) THEN
         RETURN (?);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(vec) THEN
            v := dummy_gri || direction(vec.orientation.direction_ratios);
            mag := scalar * vec.magnitude;
         ELSE
            v := dummy_gri || direction(vec.direction_ratios);
            mag := scalar;
         END_IF;
         IF mag < 0.00000 THEN
            REPEAT i := 1 TO SIZEOF(v.direction_ratios);
               v.direction_ratios[i] := -v.direction_ratios[i];
            END_REPEAT;
            mag := -mag;
         END_IF;
         result := dummy_gri || vector(normalise(v),
 mag);
      END_IF;
      RETURN (result);
   END_FUNCTION;



   FUNCTION second_proj_axis
      (z_axis : direction;
       x_axis : direction;
       arg : direction ) : direction;
   LOCAL
      y_axis : vector;
      v : direction;
      temp : vector;
   END_LOCAL;
      IF NOT EXISTS(arg) THEN
         v := dummy_gri || direction([ 0.00000,
 1.00000,
 0.00000 ]);
      ELSE
         v := arg;
      END_IF;
      temp := scalar_times_vector(dot_product(v,
 z_axis),
 z_axis);
      y_axis := vector_difference(v,
 temp);
      temp := scalar_times_vector(dot_product(v,
 x_axis),
 x_axis);
      y_axis := vector_difference(y_axis,
 temp);
      y_axis := normalise(y_axis);
      RETURN (y_axis.orientation);
   END_FUNCTION;



   FUNCTION set_of_topology_reversed
      (a_set : set_of_reversible_topology_item ) : set_of_reversible_topology_item;
   LOCAL
      the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
      the_reverse := [];
      REPEAT i := 1 TO SIZEOF(a_set);
         the_reverse := the_reverse + topology_reversed(a_set[i]);
      END_REPEAT;
      RETURN (the_reverse);
   END_FUNCTION;



   FUNCTION shell_reversed
      (a_shell : shell ) : shell;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
         RETURN (open_shell_reversed(a_shell));
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
            RETURN (closed_shell_reversed(a_shell));
         ELSE
            RETURN (?);
         END_IF;
      END_IF;
   END_FUNCTION;



   FUNCTION surface_weights_positive
      (b : rational_b_spline_surface ) : BOOLEAN;
   LOCAL
      result : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 0 TO b.u_upper;
         REPEAT j := 0 TO b.v_upper;
            IF b.weights[i][j] <= 0.00000 THEN
               result := FALSE;
               RETURN (result);
            END_IF;
         END_REPEAT;
      END_REPEAT;
      RETURN (result);
   END_FUNCTION;



   FUNCTION topology_reversed
      (an_item : reversible_topology ) : reversible_topology;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.EDGE' IN TYPEOF(an_item) THEN
         RETURN (edge_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PATH' IN TYPEOF(an_item) THEN
         RETURN (path_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
         RETURN (face_bound_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FACE' IN TYPEOF(an_item) THEN
         RETURN (face_reversed(an_item));
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SHELL' IN TYPEOF(an_item) THEN
         RETURN (shell_reversed(an_item));
      END_IF;
      IF 'SET' IN TYPEOF(an_item) THEN
         RETURN (set_of_topology_reversed(an_item));
      END_IF;
      IF 'LIST' IN TYPEOF(an_item) THEN
         RETURN (list_of_topology_reversed(an_item));
      END_IF;
      RETURN (?);
   END_FUNCTION;



   FUNCTION unique_version_change_order
      (c : action;
       schema_name : STRING ) : BOOLEAN;
   LOCAL
      ords : action_directive := c\directed_action.directive;
      assign : SET OF action_request_assignment := [];
      versions : SET OF product_definition_formation := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ords.requests);
         assign := assign + QUERY (ara <* bag_to_set(USEDIN(ords.requests[i],
 schema_name + '.ACTION_REQUEST_ASSIGNMENT.' + 'ASSIGNED_ACTION_REQUEST'))| (schema_name + '.CHANGE_REQUEST' IN TYPEOF(ara)));
      END_REPEAT;
      REPEAT k := 1 TO SIZEOF(assign);
         versions := versions + assign[k]\change_request.items;
      END_REPEAT;
      RETURN (SIZEOF(QUERY (vers <* versions| NOT (SIZEOF(QUERY (other_vers <* versions - vers| (vers.of_product :=: other_vers.of_product))) = 0))) = 0);
   END_FUNCTION;



   FUNCTION using_items
      (item : founded_item_select;
       checked_items : SET OF founded_item_select ) : SET OF founded_item_select;
   LOCAL
      new_check_items : SET OF founded_item_select;
      result_items : SET OF founded_item_select;
      next_items : SET OF founded_item_select;
   END_LOCAL;
      result_items := [];
      new_check_items := checked_items + item;
      next_items := QUERY (z <* bag_to_set(USEDIN(item,
 ''))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.FOUNDED_ITEM' IN TYPEOF(z)));
      IF SIZEOF(next_items) > 0 THEN
         REPEAT i := 1 TO HIINDEX(next_items);
            IF NOT (next_items[i] IN new_check_items) THEN
               result_items := result_items + next_items[i] + using_items(next_items[i],
 new_check_items);
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (result_items);
   END_FUNCTION;



   FUNCTION using_representations
      (item : founded_item_select ) : SET OF representation;
   LOCAL
      results : SET OF representation;
      result_bag : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
   END_LOCAL;
      results := [];
      result_bag := USEDIN(item,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
         REPEAT i := 1 TO HIINDEX(result_bag);
            results := results + result_bag[i];
         END_REPEAT;
      END_IF;
      intermediate_items := using_items(item,
 []);
      IF SIZEOF(intermediate_items) > 0 THEN
         REPEAT i := 1 TO HIINDEX(intermediate_items);
            result_bag := USEDIN(intermediate_items[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.REPRESENTATION.ITEMS');
            IF SIZEOF(result_bag) > 0 THEN
               REPEAT j := 1 TO HIINDEX(result_bag);
                  results := results + result_bag[j];
               END_REPEAT;
            END_IF;
         END_REPEAT;
      END_IF;
      RETURN (results);
   END_FUNCTION;



   FUNCTION valid_2d_wireframe_edge_curve
      (crv : curve;
       schma : STRING ) : BOOLEAN;
      IF SIZEOF([ (schma + '.LINE'),
 (schma + '.B_SPLINE_CURVE'),
 (schma + '.CIRCLE'),
 (schma + '.HYPERBOLA'),
 (schma + '.ELLIPSE'),
 (schma + '.PARABOLA'),
 (schma + '.POLYLINE') ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF schma + '.CURVE_REPLICA' IN TYPEOF(crv) THEN
            RETURN (valid_2d_wireframe_edge_curve(crv\curve_replica.parent_curve,
 schma));
         ELSE
            IF schma + '.OFFSET_CURVE_2D' IN TYPEOF(crv) THEN
               RETURN (valid_2d_wireframe_edge_curve(crv\offset_curve_2d.basis_curve,
 schma));
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_basis_curve_in_2d_wireframe
      (crv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELLIPSE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CIRCLE' ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TRIMMED_CURVE' IN TYPEOF(crv) THEN
            IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PARABOLA',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.HYPERBOLA' ] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1 THEN
               RETURN (TRUE);
            ELSE
               RETURN (valid_basis_curve_in_2d_wireframe(crv\trimmed_curve.basis_curve));
            END_IF;
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_2D' IN TYPEOF(crv) THEN
               RETURN (valid_basis_curve_in_2d_wireframe(crv\offset_curve_2d.basis_curve));
            ELSE
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
                  RETURN (valid_basis_curve_in_2d_wireframe(crv\curve_replica.parent_curve));
               ELSE
                  IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.COMPOSITE_CURVE' IN TYPEOF(crv) THEN
                     RETURN (SIZEOF(QUERY (ccs <* crv\composite_curve.segments| NOT valid_basis_curve_in_2d_wireframe(ccs.parent_curve))) = 0);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_calendar_date
      (date : calendar_date ) : LOGICAL;
      CASE date.month_component OF
         1 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         2 :
               BEGIN
                  IF leap_year(date.year_component) THEN
                     RETURN ((1 <= date.day_component) AND (date.day_component <= 29));
                  ELSE
                     RETURN ((1 <= date.day_component) AND (date.day_component <= 28));
                  END_IF;
               END;
         3 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         4 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         5 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         6 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         7 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         8 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         9 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         10 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
         11 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 30));
         12 :
               RETURN ((1 <= date.day_component) AND (date.day_component <= 31));
      END_CASE;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_geometrically_bounded_wf_curve
      (crv : curve;
       schma : STRING ) : BOOLEAN;
      IF SIZEOF([ (schma + '.POLYLINE'),
 (schma + '.B_SPLINE_CURVE'),
 (schma + '.ELLIPSE'),
 (schma + '.CIRCLE') ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF schma + '.TRIMMED_CURVE' IN TYPEOF(crv) THEN
            IF SIZEOF([ (schma + '.LINE'),
 (schma + '.PARABOLA'),
 (schma + '.HYPERBOLA') ] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1 THEN
               RETURN (TRUE);
            ELSE
               RETURN (valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve,
 schma));
            END_IF;
         ELSE
            IF schma + '.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
               RETURN (valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve,
 schma));
            ELSE
               IF schma + '.CURVE_REPLICA' IN TYPEOF(crv) THEN
                  RETURN (valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve,
 schma));
               ELSE
                  IF schma + '.COMPOSITE_CURVE' IN TYPEOF(crv) THEN
                     RETURN (SIZEOF(QUERY (ccs <* crv\composite_curve.segments| NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve,
 schma))) = 0);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_geometrically_bounded_wf_point
      (pnt : point;
       schma : STRING ) : BOOLEAN;
      IF schma + '.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
         RETURN (TRUE);
      ELSE
         IF schma + '.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
            RETURN (valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve,
 schma));
         ELSE
            IF schma + '.POINT_REPLICA' IN TYPEOF(pnt) THEN
               RETURN (valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt,
 schma));
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_measure_value
      (m : measure_value ) : BOOLEAN;
      IF 'REAL' IN TYPEOF(m) THEN
         RETURN (m > 0.00000);
      ELSE
         IF 'INTEGER' IN TYPEOF(m) THEN
            RETURN (m > 0);
         ELSE
            RETURN (TRUE);
         END_IF;
      END_IF;
   END_FUNCTION;



   FUNCTION valid_time
      (time : local_time ) : BOOLEAN;
      IF EXISTS(time.second_component) THEN
         RETURN (EXISTS(time.minute_component));
      ELSE
         RETURN (TRUE);
      END_IF;
   END_FUNCTION;



   FUNCTION valid_units
      (m : measure_with_unit ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 1.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(3.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
         IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000,
 0.00000) THEN
            RETURN (FALSE);
         END_IF;
      END_IF;
      RETURN (TRUE);
   END_FUNCTION;



   FUNCTION valid_wireframe_edge_curve
      (crv : curve ) : BOOLEAN;
      IF SIZEOF([ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LINE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CONIC',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.B_SPLINE_CURVE',
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POLYLINE' ] * TYPEOF(crv)) = 1 THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
            RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
         ELSE
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
               RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION valid_wireframe_vertex_point
      (pnt : point ) : BOOLEAN;
      IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
         RETURN (TRUE);
      ELSE
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
            RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
         END_IF;
      END_IF;
      RETURN (FALSE);
   END_FUNCTION;



   FUNCTION vector_difference
      (arg1 : vector_or_direction;
       arg2 : vector_or_direction ) : vector;
   LOCAL
      result : vector;
      res : direction;
      vec1 : direction;
      vec2 : direction;
      mag : REAL;
      mag1 : REAL;
      mag2 : REAL;
      ndim : INTEGER;
   END_LOCAL;
      IF (NOT EXISTS(arg1) OR NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim) THEN
         RETURN (?);
      ELSE
         BEGIN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
               mag1 := arg1.magnitude;
               vec1 := arg1.orientation;
            ELSE
               mag1 := 1.00000;
               vec1 := arg1;
            END_IF;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
               mag2 := arg2.magnitude;
               vec2 := arg2.orientation;
            ELSE
               mag2 := 1.00000;
               vec2 := arg2;
            END_IF;
            vec1 := normalise(vec1);
            vec2 := normalise(vec2);
            ndim := SIZEOF(vec1.direction_ratios);
            mag := 0.00000;
            res := dummy_gri || direction(vec1.direction_ratios);
            REPEAT i := 1 TO ndim;
               res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] + mag2 * vec2.direction_ratios[i];
               mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
            END_REPEAT;
            IF mag > 0.00000 THEN
               result := dummy_gri || vector(res,
 sqrt(mag));
            ELSE
               result := dummy_gri || vector(vec1,
 0.00000);
            END_IF;
         END;
      END_IF;
      RETURN (result);
   END_FUNCTION;


(* ***********************************
Rules in the schema electronic_assembly_interconnect_and_packaging_design
*********************************** *)


   RULE add_design_object_management_relationship_unique_constraint FOR (add_design_object_assignment,
 add_design_object_request_assignment );
   LOCAL
      pdr_bag : BAG OF product_definition_relationship := [];
      pd_bag : BAG OF product_definition := [];
      adoa_bag : BAG OF add_design_object_assignment;
      adora_bag : BAG OF add_design_object_request_assignment;
      pass : BOOLEAN := TRUE;
      mdo_bag : BAG OF managed_design_object;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(add_design_object_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(add_design_object_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(add_design_object_assignment[i].items[j])) AND (add_design_object_assignment[i].items[j].name = 'design object addition') THEN
               IF EXISTS(add_design_object_assignment[i].items[j].related_product_definition) THEN
                  IF NOT (add_design_object_assignment[i].items[j].related_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + add_design_object_assignment[i].items[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(add_design_object_request_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(add_design_object_request_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(add_design_object_request_assignment[i].items[j])) AND (add_design_object_request_assignment[i].items[j].name = 'design object addition') THEN
               IF EXISTS(add_design_object_request_assignment[i].items[j].related_product_definition) THEN
                  IF NOT (add_design_object_request_assignment[i].items[j].related_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + add_design_object_request_assignment[i].items[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         mdo_bag := [];
         pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object addition');
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adoa_bag := QUERY (adoa <* add_design_object_assignment| pdr_bag[j] IN adoa.items);
            REPEAT k := 1 TO SIZEOF(adoa_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(adoa_bag[k].items) BY 1;
                  IF EXISTS(adoa_bag[k].items[l]) THEN
                     IF adoa_bag[k].items[l] IN mdo_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        mdo_bag := mdo_bag + adoa_bag[k].items[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adora_bag := QUERY (adora <* add_design_object_request_assignment| pdr_bag[j] IN adora.items);
            REPEAT k := 1 TO SIZEOF(adora_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(adora_bag[k].items) BY 1;
                  IF adora_bag[k].items[l] IN mdo_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     mdo_bag := mdo_bag + adora_bag[k].items[l];
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE adjacent_stratum_surface_definition_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(sar.related_shape_aspect)) AND (sar.related_shape_aspect\shape_aspect.description IN [ 'secondary surface' ])))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description IN [ 'primary surface' ])))) = 0;
   END_RULE;



   RULE adjacent_stratum_surface_definition_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      assd : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.description = 'adjacent stratum surface definition');
      pass1 : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
      pss_bag : BAG OF stratum_surface := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass2 : BOOLEAN := TRUE;
      sss_bag : BAG OF stratum_surface;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(assd) BY 1;
         IF EXISTS(assd[i]\shape_aspect_relationship.name) THEN
            IF assd[i]\shape_aspect_relationship.name IN name_bag THEN
               pass1 := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + assd[i]\shape_aspect_relationship.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(assd) BY 1;
         IF EXISTS(assd[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(assd[i].relating_shape_aspect) THEN
               IF NOT (assd[i].relating_shape_aspect IN pss_bag) THEN
                  pss_bag := pss_bag + assd[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pss_bag) BY 1;
         IF NOT pass2 THEN
            ESCAPE;
         END_IF;
         sss_bag := [];
         sar_bag := QUERY (sar <* assd| sar.relating_shape_aspect :=: pss_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(assd[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN sss_bag THEN
                     pass2 := FALSE;
                     ESCAPE;
                  ELSE
                     sss_bag := sss_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE aggregate_connectivity_requirement_unique_constraint FOR (product_definition_relationship );
   LOCAL
      acr : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'aggregate connectivity requirement');
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(acr) BY 1;
         IF EXISTS(acr[i].related_product_definition) THEN
            IF acr[i].id = 'design composition path' THEN
               IF acr[i].related_product_definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + acr[i].related_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE analytical_model_port_unique_constraint FOR (analytical_model_port );
   LOCAL
      name_bag : BAG OF STRING := [];
      amp_bag : BAG OF analytical_model_port;
      rr_bag : BAG OF representation_relationship;
      pass : BOOLEAN := TRUE;
      am_bag : BAG OF analytical_model;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(analytical_model_port) BY 1;
         IF EXISTS(analytical_model_port[i].name) THEN
            IF NOT (analytical_model_port[i].name IN name_bag) THEN
               name_bag := name_bag + analytical_model_port[i].name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         amp_bag := QUERY (amp <* analytical_model_port| amp\representation.name = name_bag[i]);
         am_bag := [];
         REPEAT j := 1 TO SIZEOF(amp_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rr_bag := QUERY (rr <* USEDIN(amp_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (rr\representation_relationship.name = 'access mechanism') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1)));
            REPEAT k := 1 TO SIZEOF(rr_bag) BY 1;
               IF EXISTS(rr_bag[k].rep_1) THEN
                  IF rr_bag[k].rep_1 IN am_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     am_bag := am_bag + rr_bag[k].rep_1;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE angular_dimension_with_direction_vector_unique_constraint FOR (angular_dimension_with_orientation );
   LOCAL
      p_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_relationship;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF property_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(angular_dimension_with_orientation) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         p_bag := QUERY (pd <* USEDIN(angular_dimension_with_orientation[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.description = 'dimensional location property');
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(p_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'measurement orientation') AND (pdr.related_property_definition\property_definition.description = 'datum based vector orientation'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].related_property_definition) THEN
                  IF pdr_bag[k].related_property_definition IN pd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pd_bag := pd_bag + pdr_bag[k].related_property_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE application_context_requires_ap_definition FOR (application_context,
 application_protocol_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (ac <* application_context| NOT (SIZEOF(QUERY (apd <* application_protocol_definition| (ac :=: apd\application_protocol_definition.application) AND (apd\application_protocol_definition.application_interpreted_model_schema_name = 'electronic_assembly_interconnect_and_packaging_design'))) = 1))) = 0;
   END_RULE;



   RULE approval_requires_approval_date_time FOR (approval,
 approval_date_time );
   WHERE
      WR1:
         SIZEOF(QUERY (app <* approval| NOT (SIZEOF(QUERY (adt <* approval_date_time| (app :=: adt.dated_approval))) = 1))) = 0;
   END_RULE;



   RULE approval_requires_approval_person_organization FOR (approval,
 approval_person_organization );
   WHERE
      WR1:
         SIZEOF(QUERY (app <* approval| NOT (SIZEOF(QUERY (apo <* approval_person_organization| (app :=: apo.authorized_approval))) >= 1))) = 0;
   END_RULE;



   RULE approval_role_constraint FOR (approval_role );
   WHERE
      WR1:
         SIZEOF(QUERY (apr <* approval_role| NOT (apr\approval_role.role = 'authorizer'))) = 0;
   END_RULE;



   RULE approvals_are_assigned FOR (approval,
 approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (app <* approval| NOT (SIZEOF(QUERY (aa <* approval_assignment| (app :=: aa.assigned_approval))) >= 1))) = 0;
   END_RULE;



   RULE assembly_composition_relationship_unique_constraint FOR (assembly_component_usage );
   LOCAL
      acr : BAG OF assembly_component_usage := QUERY (acu <* assembly_component_usage| acu\product_definition_relationship.name = 'assembly composition');
      pu_bag : BAG OF physical_unit := [];
      acu_bag : BAG OF assembly_component_usage;
      pass : BOOLEAN := TRUE;
      cd_bag : BAG OF component_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(acr) BY 1;
         IF EXISTS(acr[i].relating_product_definition) THEN
            IF (acr[i].relating_product_definition.frame_of_reference.name = 'physical design') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(acr[i].relating_product_definition)) THEN
               IF NOT (acr[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + acr[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         cd_bag := [];
         acu_bag := QUERY (acu <* acr| acu.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(acu_bag) BY 1;
            IF EXISTS(acu_bag[j].related_product_definition) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(acu_bag[j].related_product_definition) THEN
                  IF acu_bag[j].related_product_definition IN cd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     cd_bag := cd_bag + acu_bag[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE assembly_module_usage_view_connector_relationship_unique_constraint FOR (assembly_module_usage_view_connector_relationship );
   LOCAL
      r_bag : BAG OF representation;
      pdr_bag : BAG OF property_definition_representation;
      pu_bag : BAG OF physical_unit := [];
      pd_bag : BAG OF property_definition;
      amuvcr : BAG OF assembly_module_usage_view_connector_relationship;
      rr_bag : BAG OF representation_relationship;
      pass : BOOLEAN := TRUE;
      desc_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(assembly_module_usage_view_connector_relationship) BY 1;
         r_bag := USEDIN(assembly_module_usage_view_connector_relationship[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS');
         REPEAT j := 1 TO SIZEOF(r_bag) BY 1;
            pdr_bag := QUERY (pdr <* USEDIN(r_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition.frame_of_reference.name = 'physical design usage')) AND (pdr.definition.definition\product_definition.name = 'assembly module'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].definition.definition) THEN
                  IF NOT (pdr_bag[k].definition.definition IN pu_bag) THEN
                     pu_bag := pu_bag + pdr_bag[k].definition.definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         desc_bag := [];
         pd_bag := USEDIN(pu_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION');
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := USEDIN(pd_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               amuvcr := QUERY (r <* assembly_module_usage_view_connector_relationship| r IN pdr_bag[k].used_representation.items);
               REPEAT l := 1 TO SIZEOF(amuvcr) BY 1;
                  IF NOT pass THEN
                     ESCAPE;
                  END_IF;
                  r_bag := USEDIN(amuvcr[l],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS');
                  REPEAT m := 1 TO SIZEOF(r_bag) BY 1;
                     IF NOT pass THEN
                        ESCAPE;
                     END_IF;
                     rr_bag := QUERY (rr <* USEDIN(r_bag[m],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| (((rr\representation_relationship.name = 'reference designation assignment') AND (rr.rep_1\representation.name = 'externally visible partial reference designation')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(rr.rep_1.items[1]))) AND (rr.rep_1.items[1]\representation_item.name = 'partial reference designation'));
                     REPEAT n := 1 TO SIZEOF(rr_bag) BY 1;
                        IF EXISTS(rr_bag[n].rep_1.items[1]\descriptive_representation_item.description) THEN
                           IF rr_bag[n].rep_1.items[1]\descriptive_representation_item.description IN desc_bag THEN
                              pass := FALSE;
                              ESCAPE;
                           ELSE
                              desc_bag := desc_bag + rr_bag[n].rep_1.items[1]\descriptive_representation_item.description;
                           END_IF;
                        END_IF;
                     END_REPEAT;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE bare_die_unique_constraint FOR (bare_die,
 externally_defined_bare_die,
 library_defined_bare_die );
   LOCAL
      bd : BAG OF physical_unit := QUERY (r <* bare_die| r.frame_of_reference.name = 'physical design usage');
      edbd : BAG OF physical_unit := QUERY (r <* externally_defined_bare_die| r.frame_of_reference.name = 'physical design usage');
      ldbd : BAG OF physical_unit := QUERY (r <* library_defined_bare_die| r.frame_of_reference.name = 'physical design usage');
      pu : BAG OF physical_unit;
      pdr_bag : BAG OF product_definition_relationship;
      fu_bag : BAG OF functional_unit := [];
      pu_bag : BAG OF physical_unit;
      ut_bag : BAG OF property_definition;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF property_definition;
   END_LOCAL;
      pu := bd + edbd + ldbd;
      REPEAT i := 1 TO SIZEOF(pu) BY 1;
         pdr_bag := QUERY (pdr <* USEDIN(pu[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ((pdr\product_definition_relationship.name = 'implemented function') AND (pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)));
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j].relating_product_definition) THEN
               IF NOT (pdr_bag[j].relating_product_definition IN fu_bag) THEN
                  fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pu_bag := QUERY (r <* pu| SIZEOF(QUERY (pdr <* USEDIN(fu_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'implemented function') AND (pdr.related_product_definition :=: r))) > 0);
         pd_bag := [];
         REPEAT j := 1 TO SIZEOF(pu_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            ut_bag := QUERY (pd <* USEDIN(pu_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.name = 'unit technology');
            REPEAT k := 1 TO SIZEOF(ut_bag) BY 1;
               IF EXISTS(ut_bag[k]) THEN
                  IF ut_bag[k] IN pd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pd_bag := pd_bag + ut_bag[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE boundary_size_characteristic_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| ((rep\representation.name = 'diametrical boundary size') OR (rep\representation.name = 'opposing boundary set size')) AND NOT (SIZEOF(QUERY (lmwu <* rep.items| (lmwu\representation_item.name = 'tolerance value'))) = 1))) = 0;
   END_RULE;



   RULE bus_structural_definition_unique_constraint FOR (bus_structural_definition,
 product_definition_formation,
 product );
   LOCAL
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(bus_structural_definition) BY 1;
         IF EXISTS(bus_structural_definition[i].formation.of_product.name) THEN
            IF bus_structural_definition[i].formation.of_product.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + bus_structural_definition[i]\product_definition.formation.of_product.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE cartesian_coordinate_system_constraint FOR (global_unit_assigned_context,
 geometric_representation_context,
 global_uncertainty_assigned_context );
   LOCAL
      guac_inst : SET OF global_unit_assigned_context := QUERY (guac <* global_unit_assigned_context| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(guac)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN TYPEOF(guac)));
   END_LOCAL;
   WHERE
      WR1:
         SIZEOF(QUERY (guac <* guac_inst| NOT (SIZEOF(guac.units) <= 3))) = 0;
      WR2:
         SIZEOF(QUERY (guac <* guac_inst| NOT (((SIZEOF(QUERY (u <* guac.units| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT' IN TYPEOF(u)))) = 1) AND (SIZEOF(QUERY (u <* guac.units| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLANE_ANGLE_UNIT' IN TYPEOF(u)))) = 1)) AND (SIZEOF(QUERY (u <* guac.units| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SOLID_ANGLE_UNIT' IN TYPEOF(u)))) <= 1)))) = 0;
      WR3:
         SIZEOF(QUERY (grc <* guac_inst| NOT ((grc.coordinate_space_dimension = 2) OR (grc.coordinate_space_dimension = 3)))) = 0;
      WR4:
         SIZEOF(QUERY (guac <* guac_inst| NOT (SIZEOF(QUERY (u <* guac.uncertainty| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(u)))) = 1))) = 0;
      WR5:
         SIZEOF(QUERY (guac <* guac_inst| NOT (SIZEOF(QUERY (u <* guac.units| NOT (NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLANE_ANGLE_UNIT' IN TYPEOF(u)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONVERSION_BASED_UNIT' IN TYPEOF(u))) AND (u\conversion_based_unit.name = 'degree')) OR (abs(u\conversion_based_unit.conversion_factor\measure_with_unit.value_component - 0.0174533) <= 0.00100000) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF(u\conversion_based_unit.conversion_factor))))) = 0))) = 0;
   END_RULE;



   RULE cartesian_transformation_operator_2d_constraint FOR (cartesian_transformation_operator_2d );
   WHERE
      WR1:
         SIZEOF(QUERY (cto2 <* cartesian_transformation_operator_2d| NOT ((EXISTS(cto2.axis1) AND EXISTS(cto2.axis2)) AND (cto2.scale > 0.00000)))) = 0;
   END_RULE;



   RULE certification_requires_date_or_date_and_time FOR (certification,
 applied_date_and_time_assignment,
 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (cert <* certification| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (cert IN adata.items))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (cert IN ada.items))) = 1)))) = 0;
   END_RULE;



   RULE certification_unique_constraint FOR (certification );
   LOCAL
      r : BAG OF certification := QUERY (r <* certification| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\certification.name) THEN
            IF r[i]\certification.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\certification.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE change_design_object_management_relationship_unique_constraint FOR (change_from_design_object_assignment,
 change_from_design_object_request_assignment,
 change_to_design_object_assignment,
 change_to_design_object_request_assignment );
   LOCAL
      pd_bag : BAG OF product_definition := [];
      pdr_bag : BAG OF product_definition_relationship;
      ctdoa_bag : BAG OF change_to_design_object_assignment;
      ctdora_bag : BAG OF change_to_design_object_request_assignment;
      cfdoa_bag : BAG OF change_from_design_object_assignment;
      cfdora_bag : BAG OF change_from_design_object_request_assignment;
      pass1 : BOOLEAN := TRUE;
      pass2 : BOOLEAN := TRUE;
      mdo_bag : BAG OF managed_design_object;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(change_from_design_object_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(change_from_design_object_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(change_from_design_object_assignment[i].items[j])) AND (change_from_design_object_assignment[i].items[j].name = 'design object change') THEN
               IF EXISTS(change_from_design_object_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (change_from_design_object_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + change_from_design_object_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(change_from_design_object_request_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(change_from_design_object_request_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(change_from_design_object_request_assignment[i].items[j])) AND (change_from_design_object_request_assignment[i].items[j].name = 'design object change') THEN
               IF EXISTS(change_from_design_object_request_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (change_from_design_object_request_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + change_from_design_object_request_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
         IF NOT (pass1 AND pass2) THEN
            ESCAPE;
         END_IF;
         IF pass1 THEN
            mdo_bag := [];
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object change');
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass1 THEN
                  ESCAPE;
               END_IF;
               ctdoa_bag := QUERY (ctdoa <* change_to_design_object_assignment| pdr_bag[j] IN ctdoa.items);
               REPEAT k := 1 TO SIZEOF(ctdoa_bag) BY 1;
                  IF NOT pass1 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(ctdoa_bag[k].items) BY 1;
                     IF EXISTS(ctdoa_bag[k].items[l]) THEN
                        IF ctdoa_bag[k].items[l] IN mdo_bag THEN
                           pass1 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + ctdoa_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass1 THEN
                  ESCAPE;
               END_IF;
               ctdora_bag := QUERY (ctdora <* change_to_design_object_request_assignment| pdr_bag[j] IN ctdora.items);
               REPEAT k := 1 TO SIZEOF(ctdora_bag) BY 1;
                  IF NOT pass1 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(ctdora_bag[k].items) BY 1;
                     IF EXISTS(ctdora_bag[k].items[l]) THEN
                        IF ctdora_bag[k].items[l] IN mdo_bag THEN
                           pass1 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + ctdora_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
         END_IF;
         IF pass2 THEN
            mdo_bag := [];
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object change');
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass2 THEN
                  ESCAPE;
               END_IF;
               cfdoa_bag := QUERY (cfdoa <* change_from_design_object_assignment| pdr_bag[j] IN cfdoa.items);
               REPEAT k := 1 TO SIZEOF(cfdoa_bag) BY 1;
                  IF NOT pass2 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(cfdoa_bag[k].items) BY 1;
                     IF EXISTS(cfdoa_bag[k].items[l]) THEN
                        IF cfdoa_bag[k].items[l] IN mdo_bag THEN
                           pass2 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + cfdoa_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
            REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass2 THEN
                  ESCAPE;
               END_IF;
               cfdora_bag := QUERY (cfdora <* change_from_design_object_request_assignment| pdr_bag[j] IN cfdora.items);
               REPEAT k := 1 TO SIZEOF(cfdora_bag) BY 1;
                  IF NOT pass2 THEN
                     ESCAPE;
                  END_IF;
                  REPEAT l := 1 TO SIZEOF(cfdora_bag[k].items) BY 1;
                     IF EXISTS(cfdora_bag[k].items[l]) THEN
                        IF cfdora_bag[k].items[l] IN mdo_bag THEN
                           pass2 := FALSE;
                           ESCAPE;
                        ELSE
                           mdo_bag := mdo_bag + cfdora_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE change_request_unique_constraint FOR (versioned_action_request );
   LOCAL
      cr : BAG OF versioned_action_request := QUERY (v <* versioned_action_request| SIZEOF(QUERY (ara <* USEDIN(v,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST' IN TYPEOF(ara)))) > 0);
      version_bag : BAG OF STRING := [];
      var_bag : BAG OF versioned_action_request;
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(versioned_action_request) BY 1;
         IF EXISTS(versioned_action_request[i].version) THEN
            IF NOT (versioned_action_request[i].version IN version_bag) THEN
               version_bag := version_bag + versioned_action_request[i].version;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(version_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         var_bag := QUERY (v <* versioned_action_request| v\versioned_action_request.version = version_bag[i]);
         id_bag := [];
         REPEAT j := 1 TO SIZEOF(var_bag) BY 1;
            IF EXISTS(var_bag[j].id) THEN
               IF var_bag[j].id IN id_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  id_bag := id_bag + var_bag[j].id;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE characterized_product_category_unique_constraint FOR (characterized_product_category );
   LOCAL
      adr : BAG OF applied_document_reference := [];
      documents : BAG OF document := [];
      labels : BAG OF label := [];
      pass : BOOLEAN := TRUE;
      size_of : BAG OF INTEGER := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(characterized_product_category);
         adr := adr + USEDIN(characterized_product_category[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
         labels := labels + characterized_product_category[i]\product_category.name;
      END_REPEAT;
      IF SIZEOF(adr) <> SIZEOF(labels) THEN
         pass := FALSE;
      END_IF;
      REPEAT k := 1 TO SIZEOF(adr);
         documents := documents + adr[k]\document_reference.assigned_document;
      END_REPEAT;
      IF SIZEOF(documents) <> SIZEOF(labels) THEN
         pass := FALSE;
      END_IF;
      REPEAT i := 1 TO SIZEOF(labels);
         REPEAT j := 1 TO SIZEOF(documents);
            REPEAT k := 1 TO SIZEOF(adr);
               IF (labels[i] = adr[k].items[1]\product_category.name) AND (documents[j] = adr[k]\document_reference.assigned_document) THEN
                  size_of[i] := size_of[i] + 1;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(labels);
         IF size_of[i] <> 1 THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE compatible_dimension FOR (cartesian_point,
 direction,
 representation_context,
 geometric_representation_context );
   WHERE
      WR1:
         SIZEOF(QUERY (x <* cartesian_point| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x,
 y) AND (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0))) = 0;
      WR2:
         SIZEOF(QUERY (x <* direction| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x,
 y) AND (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension))) > 0))) = 0;
   END_RULE;



   RULE component_external_reference_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'design owner')))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'part number')))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'revision code')))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'product definition id')))) = 1))) = 0;
      WR5:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'component external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'reference designation')))) = 1))) = 0;
   END_RULE;



   RULE component_feature_external_reference_unique_constraint FOR (descriptive_representation_item );
   LOCAL
      cfer : BAG OF descriptive_representation_item := QUERY (dri <* descriptive_representation_item| dri\representation_item.name = 'component feature external reference');
      desc_bag : BAG OF STRING := [];
      dri_bag : BAG OF descriptive_representation_item;
      rep_bag : BAG OF representation;
      pass : BOOLEAN := TRUE;
      r_bag : BAG OF representation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cfer) BY 1;
         IF EXISTS(cfer[i]\descriptive_representation_item.description) THEN
            IF NOT (cfer[i]\descriptive_representation_item.description IN desc_bag) THEN
               desc_bag := desc_bag + cfer[i]\descriptive_representation_item.description;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(desc_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         r_bag := [];
         dri_bag := QUERY (dri <* cfer| dri\descriptive_representation_item.description = desc_bag[i]);
         REPEAT j := 1 TO SIZEOF(dri_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rep_bag := QUERY (r <* USEDIN(dri_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| r\representation.name = 'component external reference');
            REPEAT k := 1 TO SIZEOF(rep_bag) BY 1;
               IF EXISTS(rep_bag[k]) THEN
                  IF rep_bag[k] IN r_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     r_bag := r_bag + rep_bag[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_feature_to_layout_feature_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'component feature to layout feature') AND NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL') ] * TYPEOF(sar.relating_shape_aspect)) > 0))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'component feature to layout feature') AND NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(sar.related_shape_aspect)) > 0))) = 0;
   END_RULE;



   RULE component_feature_unique_constraint FOR (component_terminal,
 component_interface_terminal );
   LOCAL
      ct : BAG OF shape_aspect := QUERY (ct <* component_terminal| ct\shape_aspect.description IN [ 'assembly module component terminal',
 'bare die component terminal',
 'interconnect component join terminal',
 'interconnect module component terminal',
 'interconnect module component stratum based terminal',
 'minimally defined component terminal',
 'packaged component join terminal' ]);
      cit : BAG OF shape_aspect := QUERY (cit <* component_interface_terminal| cit\shape_aspect.description IN [ 'interconnect component interface terminal',
 'packaged connector component interface terminal' ]);
      cf : BAG OF shape_aspect;
      cd_bag : BAG OF component_definition := [];
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      def_bag : BAG OF shape_aspect;
   END_LOCAL;
      cf := ct + cit;
      REPEAT i := 1 TO SIZEOF(cf) BY 1;
         IF EXISTS(cf[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(cf[i].of_shape.definition) THEN
               IF NOT (cf[i].of_shape.definition IN cd_bag) THEN
                  cd_bag := cd_bag + cf[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         def_bag := [];
         sa_bag := QUERY (sa <* cf| sa.of_shape.definition :=: cd_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'instantiated feature');
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN def_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     def_bag := def_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_mounting_clearance_relationship_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'mounting clearance') AND (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum height'))) = 0))) = 0;
   END_RULE;



   RULE component_overlap_relationship_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'overlap clearance') AND (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum clearance'))) = 0))) = 0;
   END_RULE;



   RULE component_part_2d_geometric_representation_relationship_constraint FOR (shape_representation_relationship );
   LOCAL
      rr : SET OF representation_relationship := QUERY (srr <* shape_representation_relationship| srr\representation_relationship.name = 'component part planar shape');
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rr) BY 1;
         IF rr[i].rep_1.context_of_items.coordinate_space_dimension <> rr[i].rep_2.context_of_items.coordinate_space_dimension THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_part_3d_geometric_representation_relationship_constraint FOR (shape_representation_relationship );
   LOCAL
      rr : SET OF representation_relationship := QUERY (srr <* shape_representation_relationship| srr\representation_relationship.name = 'component part 3d shape');
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rr) BY 1;
         IF rr[i].rep_1.context_of_items.coordinate_space_dimension <> rr[i].rep_2.context_of_items.coordinate_space_dimension THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_placement_restriction_assignment_constraint FOR (representation );
   LOCAL
      cpra : SET OF representation := QUERY (cpra <* representation| cpra.name = 'component placement restriction assignment');
      i : INTEGER;
      pass1 : BOOLEAN := TRUE;
      pass2 : BOOLEAN := TRUE;
      mra : BOOLEAN := FALSE;
      mrv : BOOLEAN := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cpra);
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         IF NOT ((SIZEOF(QUERY (rr <* USEDIN(cpra[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment area') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))) = 1))) <= 1) OR (SIZEOF(QUERY (rr <* USEDIN(cpra[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment volume') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))) = 1))) <= 1)) THEN
            pass1 := FALSE;
         END_IF;
         mra := SIZEOF(QUERY (rr <* USEDIN(cpra[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment area') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))) = 1))) = 1;
         mrv := SIZEOF(QUERY (rr <* USEDIN(cpra[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| (rr.name = 'component placement restriction assignment volume') AND (SIZEOF(QUERY (pdr <* USEDIN(rr.rep_2,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))) = 1))) = 1;
         IF NOT (mra OR mrv) THEN
            pass1 := FALSE;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cpra);
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         IF NOT pass2 THEN
            ESCAPE;
         END_IF;
         IF NOT (SIZEOF(QUERY (pdr <* USEDIN(cpra[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.definition)) AND (pdr.definition\group.name = 'item restricted requirements property'))) = 1) THEN
            pass2 := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      amt_bag : BAG OF assembly_module_interface_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
         IF EXISTS(cttamta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) THEN
               IF cttamta[i].relating_shape_aspect IN amt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      amt_bag : BAG OF assembly_module_join_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
         IF EXISTS(cttamta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_JOIN_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) THEN
               IF cttamta[i].relating_shape_aspect IN amt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttimta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      imt_bag : BAG OF interconnect_module_interface_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttimta) BY 1;
         IF EXISTS(cttimta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttimta[i].relating_shape_aspect) THEN
               IF cttimta[i].relating_shape_aspect IN imt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttimta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      imt_bag : BAG OF interconnect_module_join_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttimta) BY 1;
         IF EXISTS(cttimta[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_JOIN_TERMINAL' IN TYPEOF(cttimta[i].relating_shape_aspect) THEN
               IF cttimta[i].relating_shape_aspect IN imt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      cttamta : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'component feature to physical usage view assignment');
      pass : BOOLEAN := TRUE;
      amt_bag : BAG OF assembly_module_terminal := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cttamta) BY 1;
         IF EXISTS(cttamta[i].relating_shape_aspect) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(cttamta[i].relating_shape_aspect)) AND (cttamta[i].relating_shape_aspect\shape_aspect.description = 'pca terminal') THEN
               IF cttamta[i].relating_shape_aspect IN amt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE component_termination_passage_template_terminal_unique_constraint FOR (shape_aspect );
   LOCAL
      ctptt : BAG OF shape_aspect := QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'component termination passage template interface terminal') OR (sa\shape_aspect.description = 'component termination passage template join terminal'));
      name_bag : BAG OF STRING := [];
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      ptd_bag : BAG OF part_template_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ctptt) BY 1;
         IF EXISTS(ctptt[i]\shape_aspect.name) THEN
            IF NOT (ctptt[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + ctptt[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ptd_bag := [];
         sa_bag := QUERY (sa <* ctptt| sa\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'access mechanism') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))) AND (sar.relating_shape_aspect\shape_aspect.name = 'component termination passage template'));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN ptd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE composite_shape_element_constraint FOR (composite_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (csa <* composite_shape_aspect| (SIZEOF(QUERY (sar <* USEDIN(csa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'composing'))) < 2))) = 0;
      WR2:
         SIZEOF(QUERY (csa <* composite_shape_aspect| NOT (((SIZEOF(TYPEOF(csa)) > 2) OR (csa\shape_aspect.description <> '')) OR (csa\shape_aspect.name <> '')))) = 0;
   END_RULE;



   RULE conductive_interconnect_element_terminal_unique_constraint FOR (component_terminal );
   LOCAL
      ciet : BAG OF component_terminal := QUERY (ct <* component_terminal| ct\shape_aspect.description = 'conductive interconnect element terminal');
      name_bag : BAG OF STRING := [];
      ct_bag : BAG OF component_terminal;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      csa_bag : BAG OF component_shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ciet) BY 1;
         IF EXISTS(ciet[i]\shape_aspect.name) THEN
            IF NOT (ciet[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + ciet[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ct_bag := QUERY (ct <* ciet| ct\shape_aspect.name = name_bag[i]);
         csa_bag := [];
         REPEAT j := 1 TO SIZEOF(ct_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(ct_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'associated component') AND (sar.relating_shape_aspect\shape_aspect.description IN [ 'conductive interconnect element with pre defined transitions',
 'conductive interconnect element with user defined single transition' ])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN csa_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     csa_bag := csa_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE configuration_item_requires_person_organization FOR (configuration_item,
 applied_person_and_organization_assignment,
 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ci <* configuration_item| NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (ci IN apaoa.items))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (ci IN aoa.items))) = 1)))) = 0;
   END_RULE;



   RULE connection_zone_constraint FOR (shape_aspect,
 representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'connection zone') AND NOT (SIZEOF(USEDIN(sa,
 '')) >= 1))) = 0;
      WR2:
         SIZEOF(QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'connection zone') AND NOT (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name IN [ 'connection',
 'minimum attachment region size',
 'maximum attachment region size',
 'external connection area',
 'external connection zone',
 'internal connection zone',
 'mounting area',
 'terminal connection zone' ]))) >= 1))) = 0;
   END_RULE;



   RULE contract_unique_constraint FOR (contract );
   LOCAL
      r : BAG OF contract := QUERY (r <* contract| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\contract.name) THEN
            IF r[i]\contract.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\contract.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE curve_style_font_and_scaling_unique_constraint FOR (curve_style_font_and_scaling );
   LOCAL
      r : BAG OF curve_style_font_and_scaling := QUERY (r <* curve_style_font_and_scaling| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\curve_style_font_and_scaling.name) THEN
            IF r[i]\curve_style_font_and_scaling.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\curve_style_font_and_scaling.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE curve_style_requires_length_measure_with_unit FOR (curve_style );
   WHERE
      WR1:
         SIZEOF(QUERY (cs <* curve_style| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(cs)))) = 0;
   END_RULE;



   RULE curve_style_unique_constraint FOR (representation );
   LOCAL
      cs : BAG OF representation := QUERY (r <* representation| (r\representation.name = 'curve style parameters') AND (r.context_of_items\representation_context.context_type = 'curve style parametric context'));
      pass : BOOLEAN := TRUE;
      desc_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(cs) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         REPEAT j := 1 TO SIZEOF(cs[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(cs[i].items[j])) AND (cs[i].items[j]\representation_item.name = 'curve style name') THEN
               IF EXISTS(cs[i].items[j]\descriptive_representation_item.description) THEN
                  IF cs[i].items[j]\descriptive_representation_item.description IN desc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     desc_bag := desc_bag + cs[i].items[j]\descriptive_representation_item.description;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE date_and_time_require_minute_and_second FOR (date_and_time );
   WHERE
      WR1:
         SIZEOF(QUERY (dat <* date_and_time| NOT EXISTS(dat.time_component.minute_component))) = 0;
      WR2:
         SIZEOF(QUERY (dat <* date_and_time| NOT EXISTS(dat.time_component.second_component))) = 0;
   END_RULE;



   RULE date_constraint FOR (date );
   WHERE
      WR1:
         SIZEOF(QUERY (d <* date| (d.year_component < 1856))) = 0;
   END_RULE;



   RULE datum_feature_usage_in_datum_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      dfuidr : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'datum feature usage in common datum') OR (sar\shape_aspect_relationship.name = 'datum feature usage in single datum'));
      pudf_bag : BAG OF physical_unit_datum_feature := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pud_bag : BAG OF physical_unit_datum;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuidr) BY 1;
         IF EXISTS(dfuidr[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(dfuidr[i].relating_shape_aspect) THEN
               IF NOT (dfuidr[i].relating_shape_aspect IN pud_bag) THEN
                  pud_bag := pud_bag + dfuidr[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pud_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pudf_bag := [];
         sar_bag := QUERY (sar <* dfuidr| (sar.relating_shape_aspect :=: pud_bag[i]) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_FEATURE' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN pudf_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pudf_bag := pudf_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE datum_precedence_assignment_unique_constraint FOR (property_definition );
   LOCAL
      dpa : BAG OF property_definition := QUERY (pd <* property_definition| pd\property_definition.description = 'datum precedence assignment');
      name_bag : BAG OF STRING := [];
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_relationship;
      pass : BOOLEAN := TRUE;
      pds : BAG OF property_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dpa) BY 1;
         IF EXISTS(dpa[i]\property_definition.name) THEN
            IF NOT (dpa[i]\property_definition.name IN name_bag) THEN
               name_bag := name_bag + dpa[i]\property_definition.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pds := [];
         pd_bag := QUERY (pd <* dpa| pd\property_definition.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'assigned datum precedence') AND (pdr.relating_property_definition\property_definition.description IN [ 'datum system property with material conditions',
 'datum system property without material conditions' ]));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_property_definition) THEN
                  IF pdr_bag[k].relating_property_definition IN pds THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pds := pds + pdr_bag[k].relating_property_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE datum_target_usage_in_datum_target_set_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      dtuidts : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'datum target usage');
      pudts_bag : BAG OF physical_unit_datum_target_set := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass1 : BOOLEAN := TRUE;
      pudt_bag : BAG OF physical_unit_datum_target;
      pass2 : BOOLEAN := TRUE;
      num_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dtuidts) BY 1;
         IF EXISTS(dtuidts[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET_SET' IN TYPEOF(dtuidts[i].relating_shape_aspect) THEN
               IF NOT (dtuidts[i].relating_shape_aspect IN pudts_bag) THEN
                  pudts_bag := pudts_bag + dtuidts[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pudts_bag) BY 1;
         IF NOT (pass1 AND pass2) THEN
            ESCAPE;
         END_IF;
         num_bag := [];
         pudt_bag := [];
         sar_bag := QUERY (sar <* dtuidts| sar.relating_shape_aspect :=: pudts_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT (pass1 AND pass2) THEN
               ESCAPE;
            END_IF;
            IF pass1 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET' IN TYPEOF(sar_bag[j].related_shape_aspect)) THEN
               IF EXISTS(sar_bag[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN pudt_bag THEN
                     pass1 := FALSE;
                  ELSE
                     pudt_bag := pudt_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
            IF pass2 THEN
               IF EXISTS(sar_bag[j]\shape_aspect_relationship.description) THEN
                  IF sar_bag[j]\shape_aspect_relationship.description IN num_bag THEN
                     pass2 := FALSE;
                  ELSE
                     num_bag := num_bag + sar_bag[j]\shape_aspect_relationship.description;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE datum_usage_in_datum_system_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      duidsr : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'datum usage in datum system');
      ds_bag : BAG OF datum_system := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pud_bag : BAG OF physical_unit_datum;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(duidsr) BY 1;
         IF EXISTS(duidsr[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM' IN TYPEOF(duidsr[i].relating_shape_aspect) THEN
               IF NOT (duidsr[i].relating_shape_aspect IN ds_bag) THEN
                  ds_bag := ds_bag + duidsr[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ds_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pud_bag := [];
         sar_bag := QUERY (sar <* duidsr| sar.relating_shape_aspect :=: ds_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(sar_bag[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN pud_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pud_bag := pud_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE default_assembly_bond_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'default assembly bond shape') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(sr,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)))) = 1))) = 0;
   END_RULE;



   RULE default_passage_based_land_physical_template_unique_constraint FOR (land_physical_template );
   LOCAL
      dpblpt : BAG OF land_physical_template := QUERY (lpt <* land_physical_template| lpt\shape_aspect.description IN [ 'default via based',
 'default attachment size and via based',
 'default unsupported passage based',
 'default component termination passage based',
 'default attachment size and component termination passage based' ]);
      sar_bag : BAG OF shape_aspect_relationship;
      pt_bag : BAG OF passage_technology := [];
      pdr_bag : BAG OF property_definition_relationship;
      pass : BOOLEAN := TRUE;
      st_bag : BAG OF stratum_technology;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dpblpt) BY 1;
         sar_bag := QUERY (sar <* USEDIN(dpblpt[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF NOT (sar_bag[j].related_shape_aspect IN pt_bag) THEN
                  pt_bag := pt_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pt_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         st_bag := [];
         sar_bag := QUERY (sar <* USEDIN(pt_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'technology usage') AND (sar.relating_shape_aspect IN dpblpt));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(sar_bag[j].relating_shape_aspect\shape_aspect.of_shape,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'technology usage') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(pdr.relating_property_definition.definition)));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_property_definition.definition) THEN
                  IF pdr_bag[k].relating_property_definition.definition IN st_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     st_bag := st_bag + pdr_bag[k].relating_property_definition.definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE delete_design_object_management_relationship_unique_constraint FOR (delete_design_object_assignment,
 delete_design_object_request_assignment );
   LOCAL
      pdr_bag : BAG OF product_definition_relationship := [];
      pd_bag : BAG OF product_definition := [];
      ddoa_bag : BAG OF delete_design_object_assignment;
      ddora_bag : BAG OF delete_design_object_request_assignment;
      pass : BOOLEAN := TRUE;
      mdo_bag : BAG OF managed_design_object;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(delete_design_object_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(delete_design_object_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(delete_design_object_assignment[i].items[j])) AND (delete_design_object_assignment[i].items[j].name = 'design object deletion') THEN
               IF EXISTS(delete_design_object_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (delete_design_object_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + delete_design_object_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(delete_design_object_request_assignment) BY 1;
         REPEAT j := 1 TO SIZEOF(delete_design_object_request_assignment[i].items) BY 1;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(delete_design_object_request_assignment[i].items[j])) AND (delete_design_object_request_assignment[i].items[j].name = 'design object deletion') THEN
               IF EXISTS(delete_design_object_request_assignment[i].items[j].relating_product_definition) THEN
                  IF NOT (delete_design_object_request_assignment[i].items[j].relating_product_definition IN pd_bag) THEN
                     pd_bag := pd_bag + delete_design_object_request_assignment[i].items[j].relating_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         mdo_bag := [];
         pdr_bag := QUERY (pdr <* USEDIN(pd_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr\product_definition_relationship.name = 'design object deletion');
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            ddoa_bag := QUERY (ddoa <* delete_design_object_assignment| pdr_bag[j] IN ddoa.items);
            REPEAT k := 1 TO SIZEOF(ddoa_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(ddoa_bag[k].items) BY 1;
                  IF EXISTS(ddoa_bag[k].items[l]) THEN
                     IF ddoa_bag[k].items[l] IN mdo_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        mdo_bag := mdo_bag + ddoa_bag[k].items[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            ddora_bag := QUERY (ddora <* delete_design_object_request_assignment| pdr_bag[j] IN ddora.items);
            REPEAT k := 1 TO SIZEOF(ddora_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(ddora_bag[k].items) BY 1;
                  IF EXISTS(ddora_bag[k].items[l]) THEN
                     IF ddora_bag[k].items[l] IN mdo_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        mdo_bag := mdo_bag + ddora_bag[k].items[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE dependent_instantiable_action_directive FOR (action_directive );
   WHERE
      WR1:
         SIZEOF(QUERY (ad <* action_directive| NOT (SIZEOF(USEDIN(ad,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_approval_status FOR (approval_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ast <* approval_status| NOT (SIZEOF(USEDIN(ast,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_certification_type FOR (certification_type );
   WHERE
      WR1:
         SIZEOF(QUERY (ct <* certification_type| NOT (SIZEOF(USEDIN(ct,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_contract_type FOR (contract_type );
   WHERE
      WR1:
         SIZEOF(QUERY (ct <* contract_type| NOT (SIZEOF(USEDIN(ct,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_date FOR (date );
   WHERE
      WR1:
         SIZEOF(QUERY (dt <* date| NOT (SIZEOF(USEDIN(dt,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_date_role FOR (date_role );
   WHERE
      WR1:
         SIZEOF(QUERY (dr <* date_role| NOT (SIZEOF(USEDIN(dr,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_date_time_role FOR (date_time_role );
   WHERE
      WR1:
         SIZEOF(QUERY (dtr <* date_time_role| NOT (SIZEOF(USEDIN(dtr,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_document_type FOR (document_type );
   WHERE
      WR1:
         SIZEOF(QUERY (dt <* document_type| NOT (SIZEOF(USEDIN(dt,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_named_unit FOR (named_unit );
   WHERE
      WR1:
         SIZEOF(QUERY (nu <* named_unit| NOT (SIZEOF(USEDIN(nu,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_organization_role FOR (organization_role );
   WHERE
      WR1:
         SIZEOF(QUERY (org <* organization_role| NOT (SIZEOF(USEDIN(org,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_parametric_representation_context FOR (parametric_representation_context );
   WHERE
      WR1:
         SIZEOF(QUERY (prc <* parametric_representation_context| NOT (SIZEOF(USEDIN(prc,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_person_and_organization_role FOR (person_and_organization_role );
   WHERE
      WR1:
         SIZEOF(QUERY (poar <* person_and_organization_role| NOT (SIZEOF(USEDIN(poar,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_representation_item FOR (representation_item );
   WHERE
      WR1:
         SIZEOF(QUERY (ri <* representation_item| NOT (SIZEOF(USEDIN(ri,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_security_classification_level FOR (security_classification_level );
   WHERE
      WR1:
         SIZEOF(QUERY (scl <* security_classification_level| NOT (SIZEOF(USEDIN(scl,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_shape_representation FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (SIZEOF(USEDIN(sr,
 '')) >= 1))) = 0;
   END_RULE;



   RULE dependent_instantiable_tolerance_value FOR (tolerance_value );
   WHERE
      WR1:
         SIZEOF(QUERY (tv <* tolerance_value| NOT (SIZEOF(USEDIN(tv,
 '')) >= 1))) = 0;
   END_RULE;



   RULE design_functional_unit_allocation_to_assembly_component_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') AND NOT ((pdr.relating_product_definition\product_definition.description = 'design definition path') AND (pdr.relating_product_definition.id = 'design composition path')))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.related_product_definition)))) = 0;
   END_RULE;



   RULE design_functional_unit_allocation_to_assembly_component_unique_constraint FOR (product_definition_relationship );
   LOCAL
      dfuatac : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component');
      cd_bag : BAG OF component_definition := [];
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuatac) BY 1;
         IF EXISTS(dfuatac[i].related_product_definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(dfuatac[i].related_product_definition) THEN
               IF NOT (dfuatac[i].related_product_definition IN cd_bag) THEN
                  cd_bag := cd_bag + dfuatac[i].related_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdr_bag := QUERY (pdr <* dfuatac| pdr.related_product_definition :=: cd_bag[i]);
         id_bag := [];
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j].id) THEN
               IF pdr_bag[j].id IN id_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  id_bag := id_bag + pdr_bag[j].id;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR (product_definition_relationship );
   LOCAL
      dfuataj : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'design functional unit allocation to assembly joint');
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuataj) BY 1;
         IF EXISTS(dfuataj[i].relating_product_definition) THEN
            IF dfuataj[i].relating_product_definition.id = 'design composition path' THEN
               IF dfuataj[i].relating_product_definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + dfuataj[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE design_functional_unit_allocation_to_fabrication_joint_unique_constraint FOR (product_definition_relationship );
   LOCAL
      dfuatfj : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.name = 'design functional unit allocation to fabrication joint');
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dfuatfj) BY 1;
         IF EXISTS(dfuatfj[i].relating_product_definition) THEN
            IF dfuatfj[i].relating_product_definition.id = 'design composition path' THEN
               IF dfuatfj[i].relating_product_definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + dfuatfj[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE design_intent_modification_3d_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'positioned design intent modification 3d shape') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE design_intent_modification_planar_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'design intent modification planar position') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
      WR2:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'design intent modification planar position') AND (SIZEOF(QUERY (rep <* USEDIN(mi,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (SIZEOF(USEDIN(rep,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) = 0))) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'design intent modification planar position') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_source.mapped_representation)))) = 0;
   END_RULE;



   RULE design_intent_modification_sequence_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'shape modification sequence') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'shape modification sequence') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar.related_shape_aspect)))) = 0;
   END_RULE;



   RULE design_intent_modification_sequence_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      dims : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'shape modification sequence');
      pm_bag : BAG OF shape_modification := [];
      sar_bag : BAG OF shape_aspect_relationship;
      sm_bag : BAG OF shape_modification;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dims) BY 1;
         IF EXISTS(dims[i].relating_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(dims[i].relating_shape_aspect) THEN
               IF NOT (dims[i].relating_shape_aspect IN pm_bag) THEN
                  pm_bag := pm_bag + dims[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pm_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* dims| sar.relating_shape_aspect :=: pm_bag[i]);
         sm_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar_bag[j].related_shape_aspect) THEN
                  IF sar_bag[j].related_shape_aspect IN sm_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     sm_bag := sm_bag + sar_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE device_terminal_map_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'device terminal map relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'device terminal map relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP' IN TYPEOF(sar.related_shape_aspect)))) = 0;
   END_RULE;



   RULE dimension_along_curve_unique_constraint FOR (dimensional_location_with_path );
   LOCAL
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dimensional_location_with_path) BY 1;
         IF EXISTS(dimensional_location_with_path[i].path) THEN
            IF dimensional_location_with_path[i].path IN sa_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               sa_bag := sa_bag + dimensional_location_with_path[i].path;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE dimension_location_with_direction_vector_unique_constraint FOR (dimensional_location_with_direction );
   LOCAL
      p_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_relationship;
      pdrep_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF property_definition := [];
      place_bag : BAG OF placement := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dimensional_location_with_direction) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         p_bag := QUERY (pd <* USEDIN(dimensional_location_with_direction[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.description = 'dimensional location property');
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(p_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'measurement orientation') AND (pdr.related_property_definition\property_definition.description = 'datum based vector orientation'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].related_property_definition) THEN
                  IF pdr_bag[k].related_property_definition IN pd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pd_bag := pd_bag + pdr_bag[k].related_property_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdrep_bag := USEDIN(p_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pdrep_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(pdrep_bag[k].used_representation.items) BY 1;
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLACEMENT' IN TYPEOF(pdrep_bag[k].used_representation.items[l])) AND (pdrep_bag[k].used_representation.items[l]\representation_item.name = 'orientation') THEN
                     IF EXISTS(pdrep_bag[k].used_representation.items[l]) THEN
                        IF pdrep_bag[k].used_representation.items[l] IN place_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           place_bag := place_bag + pdrep_bag[k].used_representation.items[l];
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE directed_action_requires_approval FOR (directed_action,
 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (da <* directed_action| NOT (SIZEOF(QUERY (aaa <* applied_approval_assignment| (da IN aaa.items))) = 1))) = 0;
   END_RULE;



   RULE directed_action_requires_date_or_date_and_time FOR (directed_action,
 applied_date_and_time_assignment,
 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (da <* directed_action| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (da IN adata.items) AND (adata.role\date_time_role.name = 'start date'))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (da IN ada.items) AND (ada.role\date_role.name = 'start date'))) = 1)))) = 0;
   END_RULE;



   RULE directed_axis_constraint FOR (derived_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (dsa <* derived_shape_aspect| (dsa\shape_aspect.description = 'directed axis') AND NOT (SIZEOF(QUERY (sar <* USEDIN(dsa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'derived axis') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))) AND (sar\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'axis'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (dsa <* derived_shape_aspect| (dsa\shape_aspect.description = 'directed axis') AND NOT (SIZEOF(QUERY (sar <* USEDIN(dsa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'end shape aspect') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect)))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (dsa <* derived_shape_aspect| (dsa\shape_aspect.description = 'directed axis') AND NOT (SIZEOF(QUERY (sar <* USEDIN(dsa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'start shape aspect') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect)))) = 1))) = 0;
   END_RULE;



   RULE directed_axis_unique_constraint FOR (derived_shape_aspect );
   LOCAL
      da : BAG OF derived_shape_aspect := QUERY (r <* derived_shape_aspect| r\shape_aspect.description = 'directed axis');
      sar_bag : BAG OF shape_aspect_relationship;
      cos_bag : BAG OF centre_of_symmetry := [];
      sar2_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(da) BY 1;
         sar_bag := QUERY (sar <* USEDIN(da[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'derived axis') AND (sar.related_shape_aspect\shape_aspect.description = 'axis')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF NOT (sar_bag[j].related_shape_aspect IN cos_bag) THEN
                  cos_bag := cos_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cos_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sa_bag := [];
         sar_bag := QUERY (sar <* USEDIN(cos_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'derived axis') AND (sar.relating_shape_aspect IN da));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar2_bag := QUERY (sar <* USEDIN(sar_bag[j].relating_shape_aspect,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'start shape aspect');
            REPEAT k := 1 TO SIZEOF(sar2_bag) BY 1;
               IF EXISTS(sar2_bag[k].related_shape_aspect) THEN
                  IF sar2_bag[k].related_shape_aspect IN sa_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     sa_bag := sa_bag + sar2_bag[k].related_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE direction_element_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'direction element') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'element direction vector') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))) AND (pdr.related_property_definition\property_definition.description = 'datum direction_property'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'direction element') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'half datum plane direction vector') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))) AND (pdr.related_property_definition\property_definition.description = 'datum direction_property'))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'direction element') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ((pdr\property_definition_relationship.name = 'direction component') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))) AND (pdr.related_property_definition\property_definition.description = 'datum based vector orientation'))) = 1))) = 0;
   END_RULE;



   RULE edge_segment_vertex_constraint FOR (shape_aspect_relationship,
 edge_segment_vertex );
   LOCAL
      sar : BAG OF shape_aspect_relationship := [];
      esv : BAG OF edge_segment_vertex := edge_segment_vertex;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(esv) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar := QUERY (sar <* shape_aspect_relationship| esv[i] = sar\shape_aspect_relationship.related_shape_aspect);
         pass := SIZEOF(sar) = 2;
         REPEAT j := 2 TO SIZEOF(sar) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pass := sar[j] :<>: sar[(j - 1)];
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pass := TYPEOF(sar[j]) = TYPEOF(sar[(j - 1)]);
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pass := sar[j].relating_shape_aspect :=: sar[(j - 1)].relating_shape_aspect;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE edge_segment_vertex_unique_constraint FOR (edge_segment_vertex );
   LOCAL
      esv : BAG OF edge_segment_vertex := QUERY (r <* edge_segment_vertex| r\shape_aspect.name = 'single datum');
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      desc_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(esv) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pd_bag := QUERY (pd <* USEDIN(esv[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| pd\property_definition.description = 'shape element characterization');
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := USEDIN(pd_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               IF (pdr_bag[k].used_representation\representation.name = 'shape element characterization') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(pdr_bag[k].used_representation.items[1])) THEN
                  IF EXISTS(pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description) THEN
                     IF pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description IN desc_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        desc_bag := desc_bag + pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description;
                     END_IF;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_colour_unique_constraint FOR (colour_rgb,
 colour_specification );
   LOCAL
      r : BAG OF colour_rgb := QUERY (r <* colour_rgb| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\colour_specification.name) THEN
            IF r[i]\colour_specification.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\colour_specification.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_document_constraint FOR (document );
   WHERE
      WR1:
         SIZEOF(QUERY (doc <* document| (SIZEOF(QUERY (adata <* USEDIN(doc,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adata.role\date_time_role.name = 'creation date'))) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (doc <* document| NOT ((SIZEOF(QUERY (aoa <* USEDIN(doc,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'publisher'))) = 1) OR (SIZEOF(QUERY (apaoa <* USEDIN(doc,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apaoa.role\person_and_organization_role.name = 'publisher'))) = 1)))) = 0;
      WR3:
         SIZEOF(QUERY (doc <* document| NOT (SIZEOF(USEDIN(doc,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS')) = 1))) = 0;
   END_RULE;



   RULE ee_document_unique_constraint FOR (document,
 document_identifier_assignment );
   LOCAL
      pass : BOOLEAN := TRUE;
      rev_exists_bag : BAG OF document := [];
      dia_bag : BAG OF document_identifier_assignment := [];
      desc_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(document) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF NOT EXISTS(document[i].description) THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(document_identifier_assignment) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         desc_bag := [];
         REPEAT j := 1 TO SIZEOF(document_identifier_assignment[i].items) BY 1;
            desc_bag := desc_bag + document_identifier_assignment[i].items[j]\document.description;
         END_REPEAT;
         IF NOT value_unique(desc_bag) THEN
            pass := FALSE;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_material_unique_constraint FOR (material_designation );
   LOCAL
      name_bag : BAG OF STRING := [];
      md_bag : BAG OF material_designation;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      doc_bag : BAG OF ee_specification;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(material_designation) BY 1;
         IF EXISTS(material_designation[i].name) THEN
            IF NOT (material_designation[i].name IN name_bag) THEN
               name_bag := name_bag + material_designation[i].name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         md_bag := QUERY (md <* material_designation| md\material_designation.name = name_bag[i]);
         doc_bag := [];
         REPEAT j := 1 TO SIZEOF(md_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := QUERY (adr <* USEDIN(md_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT' IN TYPEOF(adr.assigned_document));
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN doc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     doc_bag := doc_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_configuration_unique_constraint FOR (configuration_item );
   LOCAL
      id_bag : BAG OF STRING := [];
      ci_bag : BAG OF configuration_item;
      cd_bag : BAG OF configuration_design;
      pass : BOOLEAN := TRUE;
      pdf_bag : BAG OF product_definition_formation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(configuration_item) BY 1;
         IF EXISTS(configuration_item[i].id) THEN
            IF NOT (configuration_item[i].id IN id_bag) THEN
               id_bag := id_bag + configuration_item[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdf_bag := [];
         ci_bag := QUERY (ci <* configuration_item| ci.id = id_bag[i]);
         REPEAT j := 1 TO SIZEOF(ci_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            cd_bag := USEDIN(ci_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONFIGURATION_DESIGN.CONFIGURATION');
            REPEAT k := 1 TO SIZEOF(cd_bag) BY 1;
               IF EXISTS(cd_bag[k].design) THEN
                  IF cd_bag[k].design IN pdf_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pdf_bag := pdf_bag + cd_bag[k].design;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_constraint FOR (product );
   WHERE
      WR1:
         SIZEOF(QUERY (prod <* product| NOT ((SIZEOF(QUERY (aoa <* USEDIN(prod,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'design owner'))) = 1) OR (SIZEOF(QUERY (apaoa <* USEDIN(prod,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apaoa.role\person_and_organization_role.name = 'design owner'))) = 1)))) = 0;
      WR2:
         SIZEOF(QUERY (p <* product| (SIZEOF(USEDIN(p,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT')) = 0))) = 0;
   END_RULE;



   RULE ee_product_definition_constraint FOR (product_definition_with_associated_documents );
   WHERE
      WR1:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT (SIZEOF(QUERY (adata <* USEDIN(pdwad,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| (adata.role\date_time_role.name = 'creation date'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT ((SIZEOF(QUERY (aoa <* USEDIN(pdwad,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'creator'))) = 1) OR (SIZEOF(QUERY (apaoa <* USEDIN(pdwad,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| (apaoa.role\person_and_organization_role.name = 'creator'))) = 1)))) = 0;
      WR3:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT (SIZEOF(USEDIN(pdwad,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (pdwad <* product_definition_with_associated_documents| NOT (SIZEOF(USEDIN(pdwad,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1))) = 0;
   END_RULE;



   RULE ee_product_definition_unique_constraint FOR (product_definition_with_associated_documents,
 physical_unit,
 functional_unit );
   LOCAL
      pdwad : BAG OF product_definition := QUERY (r <* product_definition_with_associated_documents| TRUE);
      pu : BAG OF product_definition := QUERY (r <* physical_unit| TRUE);
      fu : BAG OF product_definition := QUERY (r <* functional_unit| TRUE);
      epd : BAG OF product_definition;
      pdf_bag : BAG OF product_definition_formation;
      pd_bag : BAG OF product_definition;
      pass1 : BOOLEAN := TRUE;
      lcs_bag : BAG OF STRING;
      pass2 : BOOLEAN := TRUE;
      id_bag : BAG OF STRING;
   END_LOCAL;
      epd := pdwad + pu + fu;
      REPEAT i := 1 TO SIZEOF(epd) BY 1;
         IF EXISTS(epd[i].formation) THEN
            IF NOT (epd[i].formation IN pdf_bag) THEN
               pdf_bag := pdf_bag + epd[i].formation;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdf_bag) BY 1;
         IF NOT (pass1 OR pass2) THEN
            ESCAPE;
         END_IF;
         lcs_bag := [];
         id_bag := [];
         pd_bag := QUERY (pd <* epd| pd.formation :=: pdf_bag[i]);
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT (pass1 OR pass2) THEN
               ESCAPE;
            END_IF;
            IF pass2 THEN
               IF EXISTS(pd_bag[j].id) THEN
                  IF pd_bag[j].id IN id_bag THEN
                     pass2 := FALSE;
                     ESCAPE;
                  ELSE
                     id_bag := id_bag + pd_bag[j].id;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass2;
   END_RULE;



   RULE ee_product_model_unique_constraint FOR (product_concept );
   LOCAL
      r : BAG OF product_concept := QUERY (r <* product_concept| TRUE);
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].id) THEN
            IF r[i]\product_concept.id IN id_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               id_bag := id_bag + r[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_unique_constraint FOR (product );
   LOCAL
      id_bag : BAG OF STRING := [];
      p_bag : BAG OF product;
      aoa_bag : BAG OF applied_organization_assignment;
      apaoa_bag : BAG OF applied_person_and_organization_assignment;
      pass : BOOLEAN := TRUE;
      o_bag : BAG OF organization;
      pao_bag : BAG OF person_and_organization;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(product) BY 1;
         IF EXISTS(product[i].id) THEN
            IF NOT (product[i].id IN id_bag) THEN
               id_bag := id_bag + product[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         o_bag := [];
         pao_bag := [];
         p_bag := QUERY (p <* product| p.id = id_bag[i]);
         REPEAT j := 1 TO SIZEOF(p_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            aoa_bag := QUERY (aoa <* USEDIN(p_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ORGANIZATION' IN TYPEOF(aoa.assigned_organization)) AND (aoa.role\organization_role.name = 'design owner'));
            REPEAT k := 1 TO SIZEOF(aoa_bag) BY 1;
               IF EXISTS(aoa_bag[k].assigned_organization) THEN
                  IF aoa_bag[k].assigned_organization IN o_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     o_bag := o_bag + aoa_bag[k].assigned_organization;
                  END_IF;
               END_IF;
            END_REPEAT;
            apaoa_bag := QUERY (apaoa <* USEDIN(p_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERSON_AND_ORGANIZATION' IN TYPEOF(apaoa.assigned_person_and_organization)) AND (apaoa.role\person_and_organization_role.name = 'design owner'));
            REPEAT k := 1 TO SIZEOF(apaoa_bag) BY 1;
               IF EXISTS(apaoa_bag[k].assigned_person_and_organization) THEN
                  IF apaoa_bag[k].assigned_person_and_organization IN pao_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pao_bag := pao_bag + apaoa_bag[k].assigned_person_and_organization;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_product_version_supersedence_constraint FOR (product_definition_formation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdfr <* product_definition_formation_relationship| (pdfr\product_definition_formation_relationship.name = 'product version supersedence') AND NOT (pdfr.relating_product_definition_formation.of_product :=: pdfr.related_product_definition_formation.of_product))) = 0;
   END_RULE;



   RULE ee_rule_conclusion_definition_unique_constraint FOR (rule_conclusion_definition,
 representation,
 representation_relationship );
   LOCAL
      r : BAG OF representation := QUERY (r <* representation| r\representation.name = 'rule definition');
      rr : BAG OF representation_relationship := [];
      pass : BOOLEAN := TRUE;
      count : INTEGER := 0;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         count := 0;
         name_bag := [];
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         rr := USEDIN(r[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1');
         REPEAT j := 1 TO SIZEOF(rr) BY 1;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_CONCLUSION_DEFINITION' IN TYPEOF(rr[j].rep_2) THEN
               IF EXISTS(rr[j].rep_2\representation.name) THEN
                  IF rr[j].rep_2\representation.name IN name_bag THEN
                     pass := FALSE;
                  ELSE
                     name_bag := name_bag + rr[j].rep_2\representation.name;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_rule_function_unique_constraint FOR (rule_function_definition );
   LOCAL
      name_bag : BAG OF STRING := [];
      rfd_bag : BAG OF rule_function_definition;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      doc_bag : BAG OF document;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rule_function_definition) BY 1;
         IF EXISTS(rule_function_definition[i]\representation.name) THEN
            IF NOT (rule_function_definition[i]\representation.name IN name_bag) THEN
               name_bag := name_bag + rule_function_definition[i]\representation.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         doc_bag := [];
         rfd_bag := QUERY (am <* rule_function_definition| am\representation.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(rfd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := QUERY (adr <* USEDIN(rfd_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| adr.assigned_document.kind\document_type.product_data_type = 'reference document');
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN doc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     doc_bag := doc_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE ee_rule_premise_definition_unique_constraint FOR (rule_premise_definition,
 representation,
 representation_relationship );
   LOCAL
      r : BAG OF representation := QUERY (r <* representation| r\representation.name = 'rule definition');
      rr : BAG OF representation_relationship := [];
      pass : BOOLEAN := TRUE;
      count : INTEGER := 0;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         count := 0;
         name_bag := [];
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         rr := USEDIN(r[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_1');
         REPEAT j := 1 TO SIZEOF(rr) BY 1;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_PREMISE_DEFINITION' IN TYPEOF(rr[j].rep_2) THEN
               IF EXISTS(rr[j].rep_2\representation.name) THEN
                  IF rr[j].rep_2\representation.name IN name_bag THEN
                     pass := FALSE;
                  ELSE
                     name_bag := name_bag + rr[j].rep_2\representation.name;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE explicitly_located_layer_connection_point_unique_constraint FOR (layer_connection_point );
   LOCAL
      ellcp : BAG OF layer_connection_point := QUERY (lcp <* layer_connection_point| lcp\shape_aspect.description = 'explicitly located');
      s_bag : BAG OF stratum := [];
      lcp_bag : BAG OF layer_connection_point;
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      cp_bag : BAG OF cartesian_point;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ellcp) BY 1;
         IF EXISTS(ellcp[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(ellcp[i].of_shape.definition) THEN
               IF NOT (ellcp[i].of_shape.definition IN s_bag) THEN
                  s_bag := s_bag + ellcp[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         cp_bag := [];
         lcp_bag := QUERY (lcp <* ellcp| lcp.of_shape.definition :=: s_bag[i]);
         REPEAT j := 1 TO SIZEOF(lcp_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pd_bag := USEDIN(lcp_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               pdr_bag := QUERY (pdr <* USEDIN(pd_bag[k],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| (pdr.used_representation\representation.name = 'connection point location') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(pdr.used_representation.items[1])));
               REPEAT l := 1 TO SIZEOF(pdr_bag) BY 1;
                  IF EXISTS(pdr_bag[l].used_representation.items[1]) THEN
                     IF pdr_bag[l].used_representation.items[1] IN cp_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        cp_bag := cp_bag + pdr_bag[l].used_representation.items[1];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE feature_group_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'feature group relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
   END_RULE;



   RULE feature_shape_definition_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| ((sr\representation.name = 'zone shape') AND (sr.context_of_items.coordinate_space_dimension = 3)) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(sr)))) = 0;
   END_RULE;



   RULE fill_area_occurrence_constraint FOR (annotation_fill_area_occurrence );
   WHERE
      WR1:
         SIZEOF(QUERY (afao <* annotation_fill_area_occurrence| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_FILL_AREA' IN TYPEOF(afao.item)))) = 0;
      WR2:
         SIZEOF(QUERY (afao <* annotation_fill_area_occurrence| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CARTESIAN_POINT' IN TYPEOF(afao.fill_style_target)))) = 0;
      WR3:
         SIZEOF(QUERY (afao <* annotation_fill_area_occurrence| (SIZEOF(QUERY (psa <* afao.styles| (SIZEOF(QUERY (cs <* psa.styles| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CURVE_STYLE' IN TYPEOF(cs)))) = 0))) = 0))) = 0;
   END_RULE;



   RULE fill_area_style_constraint FOR (fill_area_style );
   WHERE
      WR1:
         SIZEOF(QUERY (fas <* fill_area_style| NOT (SIZEOF(fas.fill_styles) = 1))) = 0;
   END_RULE;



   RULE fill_area_style_unique_constraint FOR (fill_area_style );
   LOCAL
      r : BAG OF fill_area_style := QUERY (r <* fill_area_style| TRUE);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i]\fill_area_style.name) THEN
            IF r[i]\fill_area_style.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i]\fill_area_style.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_unit_network_node_definition_unique_constraint FOR (network_node_definition );
   LOCAL
      funnd : BAG OF network_node_definition := QUERY (nnd <* network_node_definition| nnd.frame_of_reference.name = 'functional network design');
      name_bag : BAG OF STRING := [];
      nnd_bag : BAG OF network_node_definition;
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      fu_bag : BAG OF functional_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(funnd) BY 1;
         IF EXISTS(funnd[i]\product_definition.name) THEN
            IF NOT (funnd[i]\product_definition.name IN name_bag) THEN
               name_bag := name_bag + funnd[i]\product_definition.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         fu_bag := [];
         nnd_bag := QUERY (nnd <* funnd| nnd\product_definition.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(nnd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(nnd_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND (pdr\product_definition_relationship.name = 'functional unit network node'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_product_definition) THEN
                  IF pdr_bag[k].relating_product_definition IN fu_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_unit_network_terminal_definition_bus_assignment_constraint FOR (property_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition)))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pdr.related_property_definition.definition)) AND (SIZEOF(QUERY (futd <* USEDIN(pdr.related_property_definition.definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION.OF_SHAPE' IN TYPEOF(futd)))) > 0)))) = 0;
   END_RULE;



   RULE functional_unit_terminal_bus_assignment_constraint FOR (property_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'functional unit terminal bus assignment') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition)))) = 0;
   END_RULE;



   RULE functional_unit_unique_constraint FOR (component_functional_unit );
   LOCAL
      fu : BAG OF component_functional_unit := QUERY (cfu <* component_functional_unit| cfu.frame_of_reference.name = 'functional occurrence');
      id_bag : BAG OF STRING := [];
      cfu_bag : BAG OF component_functional_unit;
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      fu_bag : BAG OF functional_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(fu) BY 1;
         IF EXISTS(fu[i].id) THEN
            IF NOT (fu[i].id IN id_bag) THEN
               id_bag := id_bag + fu[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(id_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         fu_bag := [];
         cfu_bag := QUERY (cfu <* fu| cfu.id = id_bag[i]);
         REPEAT j := 1 TO SIZEOF(cfu_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(cfu_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ((pdr\product_definition_relationship.name = 'network composition') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition))) AND (pdr.relating_product_definition.frame_of_reference.name = 'functional network design'));
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].relating_product_definition) THEN
                  IF pdr_bag[k].relating_product_definition IN fu_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR (functional_unit_terminal_definition );
   LOCAL
      name_bag : BAG OF STRING := [];
      futd_bag : BAG OF functional_unit_terminal_definition;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      fu_bag : BAG OF functional_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(functional_unit_terminal_definition) BY 1;
         IF EXISTS(functional_unit_terminal_definition[i]\shape_aspect.name) THEN
            IF NOT (functional_unit_terminal_definition[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + functional_unit_terminal_definition[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         fu_bag := [];
         futd_bag := QUERY (futd <* functional_unit_terminal_definition| ((futd\shape_aspect.name = name_bag[i]) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT' IN TYPEOF(futd.of_shape.definition))) AND (futd.of_shape.definition.frame_of_reference.name = 'functional design usage'));
         REPEAT j := 1 TO SIZEOF(futd_bag) BY 1;
            IF EXISTS(futd_bag[j].of_shape.definition) THEN
               IF futd_bag[j].of_shape.definition IN fu_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  fu_bag := fu_bag + futd_bag[j].of_shape.definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_usage_view_to_part_terminal_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal')))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.related_shape_aspect))))) = 0;
   END_RULE;



   RULE functional_usage_view_to_part_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      fuvtpta : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'functional terminal allocation');
      futd_bag : BAG OF functional_unit_terminal_definition := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(fuvtpta) BY 1;
         IF EXISTS(fuvtpta[i].relating_shape_aspect) THEN
            IF fuvtpta[i].relating_shape_aspect\shape_aspect.description = 'scalar terminal' THEN
               IF NOT (fuvtpta[i].relating_shape_aspect IN futd_bag) THEN
                  futd_bag := futd_bag + fuvtpta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(futd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* fuvtpta| (sar.relating_shape_aspect :=: futd_bag[i]) AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL') ] * TYPEOF(sar.related_shape_aspect)) > 0));
         sa_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE functional_usage_view_to_printed_part_template_terminal_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal')))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'functional terminal allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)) AND ((sar.related_shape_aspect\shape_aspect.description = 'interface terminal') OR (sar.related_shape_aspect\shape_aspect.description = 'join terminal'))))) = 0;
   END_RULE;



   RULE functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      fuvtpptta : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'functional terminal allocation');
      futd_bag : BAG OF functional_unit_terminal_definition := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pptt_bag : BAG OF printed_part_template_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(fuvtpptta) BY 1;
         IF EXISTS(fuvtpptta[i].relating_shape_aspect) THEN
            IF fuvtpptta[i].relating_shape_aspect\shape_aspect.description = 'scalar terminal' THEN
               IF NOT (fuvtpptta[i].relating_shape_aspect IN futd_bag) THEN
                  futd_bag := futd_bag + fuvtpptta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(futd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pptt_bag := [];
         sar_bag := QUERY (sar <* fuvtpptta| ((sar.relating_shape_aspect :=: futd_bag[i]) AND (sar.related_shape_aspect\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ])) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN pptt_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pptt_bag := pptt_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE geometric_tolerance_qualifier_constraint FOR (measure_qualification );
   WHERE
      WR1:
         SIZEOF(QUERY (mq <* measure_qualification| ((mq\measure_qualification.name = 'predefined geometric tolerance qualifier') OR (mq\measure_qualification.name = 'user defined geometric tolerance qualifier')) AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(mq.qualified_measure)) AND (SIZEOF(QUERY (pugt <* USEDIN(mq.qualified_measure,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE.MAGNITUDE')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt)))) = 0)))) = 0;
   END_RULE;



   RULE inter_stratum_extent_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'inter stratum extent') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.related_product_definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.relating_product_definition))))) = 0;
   END_RULE;



   RULE interconnect_component_interface_terminal_unique_constraint FOR (component_interface_terminal );
   LOCAL
      icit : BAG OF component_interface_terminal := QUERY (cit <* component_interface_terminal| cit\shape_aspect.description = 'interconnect component interface terminal');
      icd_bag : BAG OF interface_component_definition := [];
      cit_bag : BAG OF component_interface_terminal;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(icit) BY 1;
         IF EXISTS(icit[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(icit[i].of_shape.definition) THEN
               IF NOT (icit[i].of_shape.definition IN icd_bag) THEN
                  icd_bag := icd_bag + icit[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(icd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         cit_bag := QUERY (cit <* icit| cit.of_shape.definition :=: icd_bag[i]);
         REPEAT j := 1 TO SIZEOF(cit_bag) BY 1;
            IF EXISTS(cit_bag[j]\shape_aspect.name) THEN
               IF cit_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + cit_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE interconnect_component_join_terminal_unique_constraint FOR (component_terminal );
   LOCAL
      icjt : BAG OF component_terminal := QUERY (ct <* component_terminal| ct\shape_aspect.description = 'interconnect component join terminal');
      cd_bag : BAG OF component_definition := [];
      ct_bag : BAG OF component_terminal;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(icjt) BY 1;
         IF EXISTS(icjt[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(icjt[i].of_shape.definition) THEN
               IF NOT (icjt[i].of_shape.definition IN cd_bag) THEN
                  cd_bag := cd_bag + icjt[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         ct_bag := QUERY (ct <* icjt| ct.of_shape.definition :=: cd_bag[i]);
         REPEAT j := 1 TO SIZEOF(ct_bag) BY 1;
            IF EXISTS(ct_bag[j]\shape_aspect.name) THEN
               IF ct_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + ct_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE interconnect_module_constraint_region_constraint FOR (group_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (gsa <* group_shape_aspect| NOT (gsa\shape_aspect.description = 'interconnect module constraint region') OR NOT (SIZEOF(QUERY (pd <* USEDIN(gsa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) OR (pdr.used_representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 3)))) = 1))) = 0))) = 0;
   END_RULE;



   RULE interconnect_module_stratum_assembly_relationship_constraint FOR (assembly_component_usage );
   WHERE
      WR1:
         SIZEOF(QUERY (acu <* assembly_component_usage| (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(acu.relating_product_definition)))) = 0;
      WR2:
         SIZEOF(QUERY (acu <* assembly_component_usage| (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(acu.related_product_definition)))) = 0;
   END_RULE;



   RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR (assembly_component_usage );
   LOCAL
      imsar : BAG OF assembly_component_usage := QUERY (acu <* assembly_component_usage| acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship');
      pu_bag : BAG OF physical_unit := [];
      acu_bag : BAG OF assembly_component_usage;
      pass : BOOLEAN := TRUE;
      refdes_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(imsar) BY 1;
         IF EXISTS(imsar[i].relating_product_definition) THEN
            IF (imsar[i].relating_product_definition.frame_of_reference.name = 'physical design') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(imsar[i].relating_product_definition)) THEN
               IF NOT (imsar[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + imsar[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         refdes_bag := [];
         acu_bag := QUERY (acu <* imsar| acu.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(acu_bag) BY 1;
            IF EXISTS(acu_bag[j].reference_designator) THEN
               IF acu_bag[j].reference_designator IN refdes_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  refdes_bag := refdes_bag + acu_bag[j].reference_designator;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE interconnect_module_surface_feature_constraint FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| (((((((sa\shape_aspect.description = 'interconnect module edge segment surface') OR (sa\shape_aspect.description = 'interconnect module cavity surface')) OR (sa\shape_aspect.description = 'interconnect module cutout surface')) OR (sa\shape_aspect.description = 'interconnect module edge surface')) OR (sa\shape_aspect.description = 'interconnect module primary surface')) OR (sa\shape_aspect.description = 'interconnect module secondary surface')) OR (sa\shape_aspect.description = 'interconnect module surface feature')) AND NOT (((sa.of_shape.definition\product_definition.name = 'interconnect module') AND (sa.of_shape.definition.frame_of_reference.name = 'physical design usage')) AND ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition)))))) = 0;
   END_RULE;



   RULE interface_component_allocation_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'interface component allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_product_definition)) AND (pdr.relating_product_definition\product_definition.description = 'mating connector')))) = 0;
   END_RULE;



   RULE internal_stratum_access_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      isa : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'internal stratum access');
      paa_bag : BAG OF probe_access_area := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pp_bag : BAG OF plated_passage;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(isa) BY 1;
         IF EXISTS(isa[i].relating_shape_aspect) THEN
            IF (isa[i].relating_shape_aspect\shape_aspect.description = 'internal probe access area') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROBE_ACCESS_AREA' IN TYPEOF(isa[i].relating_shape_aspect)) THEN
               IF NOT (isa[i].relating_shape_aspect IN paa_bag) THEN
                  paa_bag := paa_bag + isa[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(paa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pp_bag := [];
         sar_bag := QUERY (sar <* isa| ((sar.relating_shape_aspect :=: paa_bag[i]) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLATED_PASSAGE' IN TYPEOF(sar.related_shape_aspect))) AND (sar.related_shape_aspect\shape_aspect.description IN [ 'bonded conductive base blind via',
 'buried via',
 'interfacial connection',
 'non conductive base blind via',
 'plated conductive base blind via' ]));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN pp_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pp_bag := pp_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE junction_vertex_allocation_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'junction vertex allocation') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sar.related_shape_aspect)) AND (sar.related_shape_aspect\shape_aspect.description = 'explicitly located') OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect)) AND (sar.related_shape_aspect\shape_aspect.name = 'inter stratum join')))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'junction vertex allocation') AND NOT (sar.relating_shape_aspect\shape_aspect.description = 'topological junction'))) = 0;
   END_RULE;



   RULE junction_vertex_allocation_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      jva : BAG OF shape_aspect_relationship := QUERY (sar <* shape_aspect_relationship| sar\shape_aspect_relationship.name = 'junction vertex allocation');
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(jva) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF EXISTS(jva[i].relating_shape_aspect) THEN
            IF jva[i].relating_shape_aspect\shape_aspect.description = 'topological junction' THEN
               IF jva[i].relating_shape_aspect IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + jva[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE land_physical_template_unique_constraint FOR (land_physical_template );
   LOCAL
      adr_bag : BAG OF applied_document_reference;
      duc : BAG OF document_usage_constraint;
      pass : BOOLEAN := TRUE;
      duc_bag : BAG OF document_usage_constraint := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(land_physical_template) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         adr_bag := USEDIN(land_physical_template[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
         REPEAT j := 1 TO SIZEOF(adr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            duc := QUERY (r <* USEDIN(adr_bag[j].assigned_document,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| r\document_usage_constraint.subject_element = 'predefined classification code');
            REPEAT k := 1 TO SIZEOF(duc) BY 1;
               IF EXISTS(duc[k]) THEN
                  IF duc[k] IN duc_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     duc_bag := duc_bag + duc[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE land_template_terminal_unique_constraint FOR (land_template_terminal );
   LOCAL
      ltt : BAG OF land_template_terminal := QUERY (sa <* land_template_terminal| sa\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ]);
      name_bag : BAG OF STRING := [];
      ltt_bag : BAG OF land_template_terminal;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      lpt_bag : BAG OF land_physical_template;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ltt) BY 1;
         IF EXISTS(ltt[i]\shape_aspect.name) THEN
            IF NOT (ltt[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + ltt[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         lpt_bag := [];
         ltt_bag := QUERY (sa <* ltt| sa\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(ltt_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(ltt_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN lpt_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     lpt_bag := lpt_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE layout_spacing_requirement_non_conforming_design_object_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'layout spacing requirement violation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(sar.related_shape_aspect)) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'layout spacing requirement violation') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE') ] * TYPEOF(sar.relating_shape_aspect)) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'layout spacing requirement violation') AND NOT (SIZEOF(QUERY (grp <* USEDIN(sar,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP' IN TYPEOF(grp)) AND (grp\group.name = 'layout spacing requirements property'))) = 1))) = 0;
   END_RULE;



   RULE layout_spacing_requirement_occurrence_unique_constraint FOR (grouped_requirements_property,
 characterized_object );
   LOCAL
      lsro : BAG OF grouped_requirements_property := QUERY (grp <* grouped_requirements_property| grp\group.name = 'layout spacing requirements property');
      ddo : BAG OF characterized_object := QUERY (co <* characterized_object| co\characterized_object.description = 'dependent design object category');
      ga_bag : BAG OF group_assignment;
      ddname_bag : BAG OF STRING := [];
      co_bag : BAG OF characterized_object;
      pdb : BAG OF property_definition := [];
      pd_bag : BAG OF property_definition;
      grp_bag : BAG OF grouped_requirements_property;
      rga_bag : BAG OF group_assignment;
      pass : BOOLEAN := TRUE;
      rdname_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(lsro) BY 1;
         ga_bag := QUERY (aga <* USEDIN(lsro[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga));
         REPEAT j := 1 TO SIZEOF(ga_bag) BY 1;
            REPEAT k := 1 TO SIZEOF(ga_bag[j].items) BY 1;
               IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(ga_bag[j].items[k]) THEN
                  pdb[1] := ga_bag[j].items[k];
               ELSE
                  pdb := [];
               END_IF;
               IF ((pdb :<>: []) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(pdb[1]\property_definition.definition))) AND (pdb[1]\property_definition.definition\characterized_object.description = 'dependent design object category') THEN
                  IF EXISTS(pdb[1]\property_definition.definition\characterized_object.name) THEN
                     IF NOT (pdb[1]\property_definition.definition\characterized_object.name IN ddname_bag) THEN
                        ddname_bag := ddname_bag + pdb[1]\property_definition.definition\characterized_object.name;
                     END_IF;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ddname_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         rdname_bag := [];
         co_bag := QUERY (co <* ddo| co\characterized_object.name = ddname_bag[i]);
         REPEAT j := 1 TO SIZEOF(co_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pd_bag := USEDIN(co_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION');
            REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               ga_bag := QUERY (ga <* USEDIN(pd_bag[k],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(ga.assigned_group));
               REPEAT l := 1 TO SIZEOF(ga_bag) BY 1;
                  IF NOT pass THEN
                     ESCAPE;
                  END_IF;
                  IF NOT (ga_bag[l].assigned_group IN grp_bag) THEN
                     grp_bag := grp_bag + ga_bag[l].assigned_group;
                  END_IF;
               END_REPEAT;
               REPEAT l := 1 TO SIZEOF(grp_bag) BY 1;
                  IF NOT pass THEN
                     ESCAPE;
                  END_IF;
                  rga_bag := USEDIN(grp_bag[l],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP');
                  REPEAT m := 1 TO SIZEOF(rga_bag) BY 1;
                     IF NOT pass THEN
                        ESCAPE;
                     END_IF;
                     REPEAT n := 1 TO SIZEOF(rga_bag[m].items) BY 1;
                        IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION' IN TYPEOF(rga_bag[n].items[m]) THEN
                           pdb[1] := rga_bag[n].items[m];
                        ELSE
                           pdb := [];
                        END_IF;
                        IF ((pdb :<>: []) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(pdb[1]\property_definition.definition))) AND (pdb[1]\property_definition.definition\characterized_object.description = 'reference design object category') THEN
                           IF EXISTS(pdb[1]\property_definition.definition\characterized_object.name) THEN
                              IF pdb[1]\property_definition.definition\characterized_object.name IN rdname_bag THEN
                                 pass := FALSE;
                                 ESCAPE;
                              ELSE
                                 rdname_bag := rdname_bag + pdb[1]\property_definition.definition\characterized_object.name;
                              END_IF;
                           END_IF;
                        END_IF;
                     END_REPEAT;
                  END_REPEAT;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE located_interconnect_module_thickness_requirement_unique_constraint FOR (property_definition_representation );
   LOCAL
      limrt : BAG OF property_definition_representation := QUERY (pdr <* property_definition_representation| (pdr.definition\property_definition.name = 'located interconnect module thickness') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)));
      pu_bag : BAG OF physical_unit := [];
      pdr_bag : BAG OF property_definition_representation;
      rr_bag : BAG OF representation_relationship;
      pass : BOOLEAN := TRUE;
      ri_bag : BAG OF representation_item;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(limrt) BY 1;
         IF EXISTS(limrt[i].definition.definition.of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(limrt[i].definition.definition.of_shape.definition) THEN
               IF NOT (limrt[i].definition.definition.of_shape.definition IN pu_bag) THEN
                  pu_bag := pu_bag + limrt[i].definition.definition.of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ri_bag := [];
         pdr_bag := QUERY (pdr <* limrt| pdr.definition.definition.of_shape.definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rr_bag := QUERY (rr <* USEDIN(pdr_bag[j].used_representation,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| rr\representation_relationship.name = 'reference location');
            REPEAT k := 1 TO SIZEOF(rr_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(rr_bag[k].rep_1.items) BY 1;
                  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(rr_bag[k].rep_1.items[l])) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(rr_bag[k].rep_1.items[l])) THEN
                     IF EXISTS(rr_bag[k].rep_1.items[l]) THEN
                        IF rr_bag[k].rep_1.items[l] IN ri_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           ri_bag := ri_bag + rr_bag[k].rep_1.items[l];
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE marking_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| ((rep\representation.name = 'marking') AND (SIZEOF(QUERY (pdr <* USEDIN(rep,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition)))) > 0)) AND NOT (SIZEOF(QUERY (place <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLACEMENT' IN TYPEOF(place)) AND (place\representation_item.name = 'marking location'))) = 1))) = 0;
   END_RULE;



   RULE mating_connector_placement_relationship_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'mating connector placement') AND (SIZEOF(QUERY (p <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PLACEMENT' IN TYPEOF(p)) AND (p\representation_item.name = 'connector placement'))) = 0))) = 0;
   END_RULE;



   RULE mating_connector_termination_constraint FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| (sa\shape_aspect.description = 'mating connector termination') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(sa.of_shape.definition)) AND (sa.of_shape.definition\product_definition.description = 'mating connector')))) = 0;
   END_RULE;



   RULE mating_connector_termination_unique_constraint FOR (shape_aspect );
   LOCAL
      mct : BAG OF shape_aspect := QUERY (sa <* shape_aspect| sa\shape_aspect.description = 'mating connector termination');
      cd_bag : BAG OF component_definition := [];
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      ppt_bag : BAG OF packaged_part_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(mct) BY 1;
         IF EXISTS(mct[i].of_shape.definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF(mct[i].of_shape.definition)) AND (mct[i].of_shape.definition\product_definition.description = 'mating connector') THEN
               IF NOT (mct[i].of_shape.definition IN cd_bag) THEN
                  cd_bag := cd_bag + mct[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(cd_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ppt_bag := [];
         sa_bag := QUERY (sa <* mct| sa.of_shape.definition :=: cd_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'instantiated terminal') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN ppt_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     ppt_bag := ppt_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE model_parameter_unique_constraint FOR (model_parameter );
   LOCAL
      name_bag : BAG OF STRING := [];
      mp_bag : BAG OF model_parameter;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      d_bag : BAG OF document;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(model_parameter) BY 1;
         IF EXISTS(model_parameter[i]\representation_item.name) THEN
            IF NOT (model_parameter[i]\representation_item.name IN name_bag) THEN
               name_bag := name_bag + model_parameter[i]\representation_item.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         mp_bag := QUERY (mp <* model_parameter| mp\representation_item.name = name_bag[i]);
         d_bag := [];
         REPEAT j := 1 TO SIZEOF(mp_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := USEDIN(mp_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN d_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     d_bag := d_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE next_higher_assembly_interface_requirement_constraint FOR (specified_higher_usage_occurrence );
   WHERE
      WR1:
         SIZEOF(QUERY (shuo <* specified_higher_usage_occurrence| NOT (SIZEOF(QUERY (pd <* USEDIN(shuo,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND (pdr.used_representation\representation.name = '3d bound volume shape'))) = 0))) = 0))) = 0;
   END_RULE;



   RULE next_higher_assembly_relationship_unique_constraint FOR (next_assembly_usage_occurrence );
   LOCAL
      pu_bag : BAG OF physical_unit := [];
      nauo_bag : BAG OF next_assembly_usage_occurrence;
      pass : BOOLEAN := TRUE;
      refdes_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(next_assembly_usage_occurrence) BY 1;
         IF EXISTS(next_assembly_usage_occurrence[i].relating_product_definition) THEN
            IF (next_assembly_usage_occurrence[i].relating_product_definition.frame_of_reference.name = 'physical design') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(next_assembly_usage_occurrence[i].relating_product_definition)) THEN
               IF NOT (next_assembly_usage_occurrence[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + next_assembly_usage_occurrence[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         refdes_bag := [];
         nauo_bag := QUERY (nauo <* next_assembly_usage_occurrence| nauo.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(nauo_bag) BY 1;
            IF EXISTS(nauo_bag[j].reference_designator) THEN
               IF nauo_bag[j].reference_designator IN refdes_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  refdes_bag := refdes_bag + nauo_bag[j].reference_designator;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE no_shape_for_make_from FOR (make_from_usage_option );
   WHERE
      WR1:
         SIZEOF(QUERY (mfuo <* make_from_usage_option| NOT (SIZEOF(QUERY (pd <* USEDIN(mfuo,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)))) = 0))) = 0;
   END_RULE;



   RULE operational_requirement_occurrence_relationship_constraint FOR (property_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_relationship| ((pdr\property_definition_relationship.name = 'and operation') OR (pdr\property_definition_relationship.name = 'or operation')) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* property_definition_relationship| ((pdr\property_definition_relationship.name = 'and operation') OR (pdr\property_definition_relationship.name = 'or operation')) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition)))) = 0;
   END_RULE;



   RULE organization_unique_constraint FOR (organization );
   LOCAL
      r : BAG OF organization := QUERY (r <* organization| TRUE);
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].id) THEN
            IF r[i]\organization.id IN id_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               id_bag := id_bag + r[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE package_external_reference_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'design owner')))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'part number')))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'revision code')))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'package external reference') AND (SIZEOF(QUERY (dri <* rep.items| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND (dri\representation_item.name = 'product definition id')))) = 1))) = 0;
   END_RULE;



   RULE package_terminal_external_reference_constraint FOR (descriptive_representation_item );
   WHERE
      WR1:
         SIZEOF(QUERY (dri <* descriptive_representation_item| (dri\representation_item.name = 'package terminal external reference') AND (SIZEOF(QUERY (rep <* USEDIN(dri,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| (rep\representation.name = 'package external reference'))) = 0))) = 0;
   END_RULE;



   RULE package_terminal_external_reference_unique_constraint FOR (descriptive_representation_item );
   LOCAL
      pter : BAG OF descriptive_representation_item := QUERY (dri <* descriptive_representation_item| dri\representation_item.name = 'package terminal external reference');
      desc_bag : BAG OF STRING := [];
      dri_bag : BAG OF descriptive_representation_item;
      rep_bag : BAG OF representation;
      pass : BOOLEAN := TRUE;
      r_bag : BAG OF representation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pter) BY 1;
         IF EXISTS(pter[i]\descriptive_representation_item.description) THEN
            IF NOT (pter[i]\descriptive_representation_item.description IN desc_bag) THEN
               desc_bag := desc_bag + pter[i]\descriptive_representation_item.description;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(desc_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         r_bag := [];
         dri_bag := QUERY (dri <* pter| dri\descriptive_representation_item.description = desc_bag[i]);
         REPEAT j := 1 TO SIZEOF(dri_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            rep_bag := QUERY (r <* USEDIN(dri_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS')| r\representation.name = 'package external reference');
            REPEAT k := 1 TO SIZEOF(rep_bag) BY 1;
               IF EXISTS(rep_bag[k]) THEN
                  IF rep_bag[k] IN r_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     r_bag := r_bag + rep_bag[k];
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE package_unique_constraint FOR (package,
 externally_defined_package,
 library_defined_package );
   LOCAL
      p : BAG OF physical_unit := QUERY (r <* package| r.frame_of_reference.name = 'physical design usage');
      edp : BAG OF physical_unit := QUERY (r <* externally_defined_package| r.frame_of_reference.name = 'physical design usage');
      ldp : BAG OF physical_unit := QUERY (r <* library_defined_package| r.frame_of_reference.name = 'physical design usage');
      pu : BAG OF physical_unit;
      pd_bag : BAG OF property_definition;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      r_bag : BAG OF representation := [];
   END_LOCAL;
      pu := p + edp + ldp;
      REPEAT i := 1 TO SIZEOF(pu) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pd_bag := USEDIN(pu[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION');
         REPEAT j := 1 TO SIZEOF(pd_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pdr_bag := QUERY (pdr <* USEDIN(pd_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation\representation.name = 'registered case style');
            REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
               IF EXISTS(pdr_bag[k].used_representation) THEN
                  IF pdr_bag[k].used_representation IN r_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     r_bag := r_bag + pdr_bag[k].used_representation;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE packaged_connector_terminal_relationship_unique_constraint FOR (packaged_connector_terminal_relationship );
   LOCAL
      pu_bag : BAG OF physical_unit := [];
      pctr_bag : BAG OF packaged_connector_terminal_relationship;
      it_bag : BAG OF packaged_part_terminal;
      jt_bag : BAG OF packaged_part_terminal;
      pass1 : BOOLEAN := TRUE;
      pass2 : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(packaged_connector_terminal_relationship) BY 1;
         IF EXISTS(packaged_connector_terminal_relationship[i].of_shape.definition) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(packaged_connector_terminal_relationship[i].of_shape.definition) THEN
               IF NOT (packaged_connector_terminal_relationship[i].of_shape.definition IN pu_bag) THEN
                  pu_bag := pu_bag + packaged_connector_terminal_relationship[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT (pass1 OR pass2) THEN
            ESCAPE;
         END_IF;
         it_bag := [];
         jt_bag := [];
         pctr_bag := QUERY (r <* packaged_connector_terminal_relationship| r.of_shape.definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(pctr_bag) BY 1;
            IF NOT (pass1 OR pass2) THEN
               ESCAPE;
            END_IF;
            IF (pass1 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].relating_shape_aspect))) AND (pctr_bag[j].relating_shape_aspect\shape_aspect.description = 'join terminal') THEN
               IF EXISTS(pctr_bag[j].relating_shape_aspect) THEN
                  IF pctr_bag[j].relating_shape_aspect IN jt_bag THEN
                     pass1 := FALSE;
                     ESCAPE;
                  ELSE
                     jt_bag := jt_bag + pctr_bag[j].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
            IF (pass2 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].related_shape_aspect))) AND (pctr_bag[j].related_shape_aspect\shape_aspect.description = 'interface terminal') THEN
               IF EXISTS(pctr_bag[j].related_shape_aspect) THEN
                  IF pctr_bag[j].related_shape_aspect IN it_bag THEN
                     pass2 := FALSE;
                     ESCAPE;
                  ELSE
                     it_bag := it_bag + pctr_bag[j].related_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE packaged_part_unique_constraint FOR (packaged_part,
 externally_defined_packaged_part,
 library_defined_packaged_part );
   LOCAL
      pp : SET OF physical_unit := packaged_part + externally_defined_packaged_part + library_defined_packaged_part;
      pdr_bag : BAG OF product_definition_relationship;
      pdf_bag : BAG OF product_definition_formation := [];
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pp) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdf_bag := [];
         pdr_bag := QUERY (pdr <* USEDIN(pp[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (pdr\product_definition_relationship.name = 'used package') AND ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE' IN TYPEOF(pdr.relating_product_definition)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition))) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition))));
         pdf_bag := pdf_bag + pdr_bag[1].relating_product_definition.formation;
         REPEAT k := 1 TO SIZEOF(pdr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF EXISTS(pdr_bag[k].relating_product_definition.formation) THEN
               IF NOT (pdr_bag[k].relating_product_definition.formation IN pdf_bag) THEN
                  pass := FALSE;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_device_terminal_model_port_assignment_unique_constraint FOR (property_definition_representation );
   LOCAL
      amp_bag : BAG OF analytical_model_port := [];
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      sa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(property_definition_representation) BY 1;
         IF EXISTS(property_definition_representation[i].used_representation) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(property_definition_representation[i].used_representation) THEN
               IF NOT (property_definition_representation[i].used_representation IN amp_bag) THEN
                  amp_bag := amp_bag + property_definition_representation[i].used_representation;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(amp_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sa_bag := [];
         pdr_bag := QUERY (pdr <* property_definition_representation| pdr.used_representation :=: amp_bag[i]);
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j].definition.definition) THEN
               IF pdr_bag[j].definition.definition IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + pdr_bag[j].definition.definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_device_terminal_unique_constraint FOR (shape_aspect );
   LOCAL
      pdr_bag : BAG OF product_definition_relationship := [];
      sa_bag : BAG OF shape_aspect;
      pd_bag : BAG OF property_definition;
      sa : BAG OF bare_die_terminal;
      pass : BOOLEAN := TRUE;
      bdt_bag : BAG OF bare_die_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(shape_aspect) BY 1;
         IF EXISTS(shape_aspect[i].of_shape.definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(shape_aspect[i].of_shape.definition)) AND (shape_aspect[i].of_shape.definition.description = 'part device') THEN
               IF NOT (shape_aspect[i].of_shape.definition IN pdr_bag) THEN
                  pdr_bag := pdr_bag + shape_aspect[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdr_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         bdt_bag := [];
         sa_bag := QUERY (sa <* shape_aspect| sa.of_shape.definition :=: pdr_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            pd_bag := QUERY (pd <* USEDIN(sa_bag[j].of_shape.definition.related_product_definition,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE') ] * TYPEOF(pd.definition)) > 0);
            REPEAT k := 1 TO SIZEOF(pd_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               sa := QUERY (bdt <* USEDIN(pd_bag[k],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT.OF_SHAPE')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BARE_DIE_TERMINAL' IN TYPEOF(bdt));
               REPEAT l := 1 TO SIZEOF(sa) BY 1;
                  IF EXISTS(sa[l]) THEN
                     IF sa[l] IN bdt_bag THEN
                        pass := FALSE;
                        ESCAPE;
                     ELSE
                        bdt_bag := bdt_bag + sa[l];
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_device_unique_constraint FOR (product_definition_relationship );
   LOCAL
      pd : BAG OF product_definition_relationship := QUERY (pdr <* product_definition_relationship| pdr\product_definition_relationship.description = 'part device');
      pu_bag : BAG OF physical_unit := [];
      pdr_bag : BAG OF product_definition_relationship;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pd) BY 1;
         IF EXISTS(pd[i].relating_product_definition) THEN
            IF (pd[i].relating_product_definition.frame_of_reference.name = 'physical design usage') AND (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART') ] * TYPEOF(pd[i].relating_product_definition)) > 0) THEN
               IF NOT (pd[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + pd[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         pdr_bag := QUERY (pdr <* pd| pdr.relating_product_definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(pdr_bag) BY 1;
            IF EXISTS(pdr_bag[j]\product_definition_relationship.name) THEN
               IF pdr_bag[j]\product_definition_relationship.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + pdr_bag[j]\product_definition_relationship.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_feature_constraint FOR (shape_aspect,
 product_definition,
 shape_aspect_relationship );
   LOCAL
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
      sa : BAG OF shape_aspect := [];
      pd : BAG OF product_definition := QUERY (pd <* product_definition| pd.frame_of_reference\application_context_element.name = 'physical design usage');
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pd) BY 1;
         name_bag := [];
         sa := QUERY (sa <* shape_aspect| ((sa.of_shape\property_definition.definition = pd[i]) AND sa.product_definitional) AND NOT (sa\shape_aspect.description = 'connection zone'));
         REPEAT j := 1 TO SIZEOF(sa) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF sa[j]\shape_aspect.name IN name_bag THEN
               pass := FALSE;
            ELSE
               name_bag := name_bag + sa[j]\shape_aspect.name;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'precedent feature') AND (sar.related_shape_aspect = sar.relating_shape_aspect))) = 0;
      WR3:
         SIZEOF(QUERY (sa <* shape_aspect| (((sa\shape_aspect.description = 'part group feature') OR (sa\shape_aspect.description = 'part generic feature')) OR (sa\shape_aspect.description = 'polarity indication feature')) AND (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feature'))) > 1))) = 0;
      WR4:
         SIZEOF(QUERY (sa <* shape_aspect| (((((((sa\shape_aspect.description = 'interconnect module edge segment surface') OR (sa\shape_aspect.description = 'interconnect module cavity surface')) OR (sa\shape_aspect.description = 'interconnect module cutout surface')) OR (sa\shape_aspect.description = 'interconnect module edge surface')) OR (sa\shape_aspect.description = 'interconnect module primary surface')) OR (sa\shape_aspect.description = 'interconnect module secondary surface')) OR (sa\shape_aspect.description = 'interconnect module surface feature')) AND (SIZEOF(QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'precedent feature'))) > 0))) = 0;
   END_RULE;



   RULE part_feature_unique_constraint FOR (composite_shape_aspect,
 shape_aspect,
 primary_orientation_feature,
 tertiary_orientation_feature,
 secondary_orientation_feature,
 package_body,
 part_tooling_feature,
 thermal_feature,
 part_mounting_feature,
 package_terminal,
 assembly_module_terminal,
 bare_die_terminal,
 interconnect_module_terminal,
 minimally_defined_bare_die_terminal,
 packaged_part_terminal,
 package_body_surface );
   LOCAL
      csa : BAG OF shape_aspect := QUERY (r <* composite_shape_aspect| r\shape_aspect.description = 'part group feature');
      sa : BAG OF shape_aspect := QUERY (r <* shape_aspect| r\shape_aspect.description IN [ 'part generic feature',
 'polarity indication feature',
 'interconnect module edge segment surface',
 'interconnect module cavity surface',
 'interconnect module cutout surface',
 'interconnect module edge surface',
 'interconnect module primary surface',
 'interconnect module secondary surface',
 'interconnect module surface feature' ]);
      pof : BAG OF shape_aspect := QUERY (r <* primary_orientation_feature| TRUE);
      sof : BAG OF shape_aspect := QUERY (r <* secondary_orientation_feature| TRUE);
      tof : BAG OF shape_aspect := QUERY (r <* tertiary_orientation_feature| TRUE);
      pb : BAG OF shape_aspect := QUERY (r <* package_body| TRUE);
      ptf : BAG OF shape_aspect := QUERY (r <* part_tooling_feature| TRUE);
      tf : BAG OF shape_aspect := QUERY (r <* thermal_feature| TRUE);
      pmf : BAG OF shape_aspect := QUERY (r <* part_mounting_feature| TRUE);
      pt : BAG OF shape_aspect := QUERY (r <* package_terminal| TRUE);
      amt : BAG OF shape_aspect := QUERY (r <* assembly_module_terminal| TRUE);
      bdt : BAG OF shape_aspect := QUERY (r <* bare_die_terminal| TRUE);
      imt : BAG OF shape_aspect := QUERY (r <* interconnect_module_terminal| TRUE);
      mdbdt : BAG OF shape_aspect := QUERY (r <* minimally_defined_bare_die_terminal| TRUE);
      ppt : BAG OF shape_aspect := QUERY (r <* packaged_part_terminal| TRUE);
      pbs : BAG OF shape_aspect := QUERY (r <* package_body_surface| TRUE);
      pf : BAG OF shape_aspect := [];
      pu_bag : BAG OF physical_unit := [];
      sa_bag : BAG OF shape_aspect;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      sa := csa + sa + pof + sof + tof + pb + ptf + tf + pmf + pt + amt + bdt + imt + mdbdt + ppt + pbs;
      REPEAT i := 1 TO SIZEOF(sa) BY 1;
         IF EXISTS(sa[i]) THEN
            IF NOT (sa[i] IN pf) THEN
               pf := pf + sa[i];
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pf) BY 1;
         IF EXISTS(pf[i].of_shape.definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(pf[i].of_shape.definition)) AND (pf[i].of_shape.definition.frame_of_reference.name = 'physical design usage') THEN
               IF NOT (pf[i].of_shape.definition IN pu_bag) THEN
                  pu_bag := pu_bag + pf[i].of_shape.definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         name_bag := [];
         sa_bag := QUERY (sa <* pf| sa.of_shape.definition :=: pu_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF EXISTS(sa_bag[j]\shape_aspect.name) THEN
               IF sa_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sa_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE part_template_non_planar_2d_shape_constraint FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name = 'part template non planar 2d shape') AND NOT (SIZEOF(QUERY (a2p3d <* mssr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(a2p3d)))) = 1))) = 0;
   END_RULE;



   RULE part_terminal_external_reference_unique_constraint FOR (representation );
   LOCAL
      pter : BAG OF representation := QUERY (r <* representation| r\representation.name = 'part terminal external reference');
      fn_bag : BAG OF STRING := [];
      ft_bag : BAG OF STRING := [];
      r_bag : BAG OF representation;
      pdr_bag : BAG OF property_definition_representation;
      pass : BOOLEAN := TRUE;
      ptd_bag : BAG OF part_template_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pter) BY 1;
         REPEAT j := 1 TO SIZEOF(pter[i].items) BY 1;
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(pter[i].items[j]) THEN
               IF (pter[i].items[j]\representation_item.name = 'feature name') AND NOT (pter[i].items[j]\descriptive_representation_item.description IN fn_bag) THEN
                  fn_bag := fn_bag + pter[i].items[j]\descriptive_representation_item.description;
               END_IF;
               IF (pter[i].items[j]\representation_item.name = 'feature type') AND NOT (pter[i].items[j]\descriptive_representation_item.description IN ft_bag) THEN
                  ft_bag := ft_bag + pter[i].items[j]\descriptive_representation_item.description;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(fn_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         REPEAT j := 1 TO SIZEOF(ft_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            r_bag := QUERY (r <* pter| (SIZEOF(QUERY (ri <* r.items| (ri\descriptive_representation_item.description = ft_bag[j]) AND (ri\representation_item.name = 'feature type'))) > 0) AND (SIZEOF(QUERY (ri <* r.items| (ri\descriptive_representation_item.description = fn_bag[i]) AND (ri\representation_item.name = 'feature name'))) > 0));
            ptd_bag := [];
            REPEAT k := 1 TO SIZEOF(r_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               pdr_bag := USEDIN(r_bag[k],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
               REPEAT l := 1 TO SIZEOF(pdr_bag) BY 1;
                  IF EXISTS(pdr_bag[l].definition.definition) THEN
                     IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(pdr_bag[l].definition.definition) THEN
                        IF pdr_bag[l].definition.definition IN ptd_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           ptd_bag := ptd_bag + pdr_bag[l].definition.definition;
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE person_and_organization_unique_constraint FOR (person_and_organization );
   LOCAL
      p_bag : BAG OF person := [];
      pao_bag : BAG OF person_and_organization;
      pass : BOOLEAN := TRUE;
      o_bag : BAG OF organization;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(person_and_organization) BY 1;
         IF EXISTS(person_and_organization[i].the_person) THEN
            IF NOT (person_and_organization[i].the_person IN p_bag) THEN
               p_bag := p_bag + person_and_organization[i].the_person;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(p_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         o_bag := [];
         pao_bag := QUERY (pao <* person_and_organization| pao.the_person :=: p_bag[i]);
         REPEAT j := 1 TO SIZEOF(pao_bag) BY 1;
            IF EXISTS(pao_bag[j].the_organization) THEN
               IF pao_bag[j].the_organization IN o_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  o_bag := o_bag + pao_bag[j].the_organization;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE physical_connectivity_abstraction_map_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      pcam : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'physical to topological abstraction map');
      pce_bag : BAG OF physical_connectivity_element := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      csa_bag : BAG OF component_shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pcam) BY 1;
         IF EXISTS(pcam[i].related_shape_aspect) THEN
            IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT' IN TYPEOF(pcam[i].related_shape_aspect) THEN
               IF NOT (pcam[i].related_shape_aspect IN pce_bag) THEN
                  pce_bag := pce_bag + pcam[i].related_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pce_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         csa_bag := [];
         sar_bag := QUERY (sar <* pcam| sar.related_shape_aspect :=: pce_bag[i]);
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar_bag[j].relating_shape_aspect)) AND (sar_bag[j].relating_shape_aspect\shape_aspect.description IN [ 'conductive interconnect element with pre defined transitions',
 'conductive interconnect element with user defined single transition' ]) THEN
               IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
                  IF sar_bag[j].relating_shape_aspect IN csa_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     csa_bag := csa_bag + sar_bag[j].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE physical_connectivity_definition_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'physical connectivity definition change') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'physical connectivity definition change') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
      WR3:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'physical connectivity definition change') AND (SIZEOF(QUERY (rpd <* USEDIN(sar,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rpd)))) = 0))) = 0;
   END_RULE;



   RULE physical_connectivity_element_unique_constraint FOR (physical_connectivity_element );
   LOCAL
      name_bag : BAG OF STRING := [];
      pce_bag : BAG OF physical_connectivity_element;
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pcd_bag : BAG OF physical_connectivity_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(physical_connectivity_element) BY 1;
         IF EXISTS(physical_connectivity_element[i]\shape_aspect.name) THEN
            IF NOT (physical_connectivity_element[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + physical_connectivity_element[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pcd_bag := [];
         pce_bag := QUERY (pce <* physical_connectivity_element| pce\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(pce_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(pce_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'structure element') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
                  IF sar_bag[j].relating_shape_aspect IN pcd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     pcd_bag := pcd_bag + sar_bag[j].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE placement_group_area_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) OR ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name = 'design requirement')))) = 0;
   END_RULE;



   RULE placement_group_volume_assignment_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) OR ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))) AND (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name = 'design requirement')))) = 0;
   END_RULE;



   RULE planar_curve_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (NOT (sr\representation.name IN [ 'planar projected shape',
 'bevel edge feature shape',
 'step edge feature shape',
 'radius edge feature shape' ]) OR (sr\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2)))) = 0;
   END_RULE;



   RULE planned_effectivity_constraint FOR (configuration_effectivity );
   WHERE
      WR1:
         SIZEOF(QUERY (ce <* configuration_effectivity| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage)) AND (ce.usage\product_definition_relationship.name = 'assembly composition')))) = 0;
      WR2:
         SIZEOF(QUERY (ce <* configuration_effectivity| (SIZEOF(USEDIN(ce,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0))) = 0;
   END_RULE;



   RULE planned_effectivity_unique_constraint FOR (configuration_effectivity );
   LOCAL
      ce_bag : BAG OF configuration_effectivity;
      ci_bag : BAG OF configuration_item := [];
      pass : BOOLEAN := TRUE;
      acu_bag : BAG OF assembly_component_usage;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(configuration_effectivity) BY 1;
         IF EXISTS(configuration_effectivity[i].configuration.configuration) THEN
            IF NOT (configuration_effectivity[i].configuration.configuration IN ci_bag) THEN
               ci_bag := ci_bag + configuration_effectivity[i].configuration.configuration;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ci_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ce_bag := QUERY (r <* configuration_effectivity| ((r.configuration.configuration :=: ci_bag[i]) AND (r.usage\product_definition_relationship.name = 'assembly composition')) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(r.usage)));
         acu_bag := [];
         REPEAT j := 1 TO SIZEOF(ce_bag) BY 1;
            IF EXISTS(ce_bag[j].usage) THEN
               IF ce_bag[j].usage IN acu_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  acu_bag := acu_bag + ce_bag[j].usage;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE plus_minus_tolerance_range_representation_constraint FOR (shape_dimension_representation,
 plus_minus_tolerance );
   WHERE
      WR1:
         SIZEOF(QUERY (pmt <* plus_minus_tolerance| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_VALUE' IN TYPEOF(pmt.range)))) = 0;
   END_RULE;



   RULE polarity_indication_feature_constraint FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (NOT (sa\shape_aspect.description = 'polarity indication feature') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1)))) = 0;
      WR2:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (NOT (sa\shape_aspect.description = 'polarity indication feature') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated body vertical extent'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect)))) <= 1)))) = 0;
      WR3:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (NOT (sa\shape_aspect.description = 'polarity indication feature') OR (SIZEOF(QUERY (it <* QUERY (sar <* USEDIN(sa,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated terminal'))| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL' IN TYPEOF(it.relating_shape_aspect)))) = 1)))) = 0;
   END_RULE;



   RULE positional_boundary_member_definition_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary member property') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition)))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary member property') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'boundary member associated dimension'))) = 1))) = 0;
   END_RULE;



   RULE positional_boundary_offset_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary offset') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(pd.definition)) AND (pd.definition\shape_aspect_relationship.name = 'positional boundary and profile boundary member')))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'positional boundary offset') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| (pdr\property_definition_relationship.name = 'boundary offset') AND (pdr.relating_property_definition\property_definition.name = 'profile related positional boundary property'))) = 1))) = 0;
   END_RULE;



   RULE printed_connector_template_terminal_relationship_unique_constraint FOR (printed_connector_template_terminal_relationship );
   LOCAL
      ptd_bag : BAG OF part_template_definition := [];
      pcttr_bag : BAG OF printed_connector_template_terminal_relationship;
      sar_bag : BAG OF shape_aspect_relationship;
      pass1 : BOOLEAN := TRUE;
      jt_bag : BAG OF printed_part_template_terminal;
      pass2 : BOOLEAN := TRUE;
      it_bag : BAG OF printed_part_template_terminal;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(printed_connector_template_terminal_relationship) BY 1;
         sar_bag := QUERY (sar <* USEDIN(printed_connector_template_terminal_relationship[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| ((sar\shape_aspect_relationship.name = 'connector') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))) AND (sar.relating_shape_aspect\shape_aspect.description = 'printed connector template'));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
               IF NOT (sar_bag[j].relating_shape_aspect IN ptd_bag) THEN
                  ptd_bag := ptd_bag + sar_bag[j].relating_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ptd_bag) BY 1;
         IF NOT (pass1 OR pass2) THEN
            ESCAPE;
         END_IF;
         it_bag := [];
         jt_bag := [];
         sar_bag := QUERY (sar <* USEDIN(ptd_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'connector');
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF NOT (pass1 OR pass2) THEN
               ESCAPE;
            END_IF;
            pcttr_bag := QUERY (pcttr <* printed_connector_template_terminal_relationship| pcttr :=: sar_bag[j].related_shape_aspect);
            REPEAT k := 1 TO SIZEOF(pcttr_bag) BY 1;
               IF NOT (pass1 OR pass2) THEN
                  ESCAPE;
               END_IF;
               IF (pass1 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(pcttr_bag[k].relating_shape_aspect))) AND (pcttr_bag[k].relating_shape_aspect\shape_aspect.description = 'join terminal') THEN
                  IF EXISTS(pcttr_bag[k].relating_shape_aspect) THEN
                     IF pcttr_bag[k].relating_shape_aspect IN jt_bag THEN
                        pass1 := FALSE;
                        ESCAPE;
                     ELSE
                        jt_bag := jt_bag + pcttr_bag[k].relating_shape_aspect;
                     END_IF;
                  END_IF;
               END_IF;
               IF (pass2 AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(pcttr_bag[k].related_shape_aspect))) AND (pcttr_bag[k].related_shape_aspect\shape_aspect.description = 'interface terminal') THEN
                  IF EXISTS(pcttr_bag[k].related_shape_aspect) THEN
                     IF pcttr_bag[k].related_shape_aspect IN it_bag THEN
                        pass2 := FALSE;
                        ESCAPE;
                     ELSE
                        it_bag := it_bag + pcttr_bag[k].related_shape_aspect;
                     END_IF;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE printed_part_template_terminal_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'printed part template terminal relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect)))) = 0;
      WR2:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'printed part template terminal relationship') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
   END_RULE;



   RULE printed_part_template_terminal_unique_constraint FOR (printed_part_template_terminal );
   LOCAL
      pptt : BAG OF printed_part_template_terminal := QUERY (r <* printed_part_template_terminal| r\shape_aspect.description IN [ 'interface terminal',
 'join terminal' ]);
      name_bag : BAG OF STRING := [];
      sar_bag : BAG OF shape_aspect_relationship;
      sa_bag : BAG OF shape_aspect;
      pass : BOOLEAN := TRUE;
      ptd_bag : BAG OF part_template_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pptt) BY 1;
         IF EXISTS(pptt[i]\shape_aspect.name) THEN
            IF NOT (pptt[i]\shape_aspect.name IN name_bag) THEN
               name_bag := name_bag + pptt[i]\shape_aspect.name;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(name_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ptd_bag := [];
         sa_bag := QUERY (sa <* pptt| sa\shape_aspect.name = name_bag[i]);
         REPEAT j := 1 TO SIZEOF(sa_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            sar_bag := QUERY (sar <* USEDIN(sa_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'associated definition') AND (sar.relating_shape_aspect\shape_aspect.description = 'printed part template'));
            REPEAT k := 1 TO SIZEOF(sar_bag) BY 1;
               IF EXISTS(sar_bag[k].relating_shape_aspect) THEN
                  IF sar_bag[k].relating_shape_aspect IN ptd_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE product_association_constraint FOR (product_definition_formation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdfr <* product_definition_formation_relationship| (pdfr\product_definition_formation_relationship.name = 'product association') AND (SIZEOF(QUERY (adr <* USEDIN(pdfr,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document)))) = 0))) = 0;
   END_RULE;



   RULE product_association_unique_constraint FOR (product_definition_formation_relationship );
   LOCAL
      pdfr : BAG OF product_definition_formation_relationship := QUERY (r <* product_definition_formation_relationship| r\product_definition_formation_relationship.name = 'product association');
      pdf_bag : BAG OF product_definition_formation := [];
      pdfr_bag : BAG OF product_definition_formation_relationship;
      pass : BOOLEAN := TRUE;
      adr_bag : BAG OF applied_document_reference;
      es_bag : BAG OF ee_specification;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(pdfr) BY 1;
         IF EXISTS(pdfr[i].relating_product_definition_formation) THEN
            IF NOT (pdfr[i].relating_product_definition_formation IN pdf_bag) THEN
               pdf_bag := pdf_bag + pdfr[i].relating_product_definition_formation;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pdf_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdfr_bag := QUERY (r <* pdfr| r.relating_product_definition_formation :=: pdf_bag[i]);
         es_bag := [];
         REPEAT j := 1 TO SIZEOF(pdfr_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            adr_bag := QUERY (adr <* USEDIN(pdfr_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document));
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN es_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     es_bag := es_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE product_concept_requires_configuration_item FOR (product_concept,
 configuration_item );
   WHERE
      WR1:
         SIZEOF(QUERY (pc <* product_concept| NOT (SIZEOF(QUERY (ci <* configuration_item| (pc :=: ci.item_concept))) >= 1))) = 0;
   END_RULE;



   RULE product_definition_formation_requires_approval FOR (product_definition,
 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd)) AND NOT (SIZEOF(QUERY (aaa <* applied_approval_assignment| (pd.formation IN aaa.items))) = 1))) = 0;
   END_RULE;



   RULE product_definition_formation_requires_person_organization FOR (product_definition,
 applied_person_and_organization_assignment,
 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd)) AND NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (pd.formation IN apaoa.items) AND (apaoa.role\person_and_organization_role.name = 'creator'))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (pd.formation IN aoa.items) AND (aoa.role\organization_role.name = 'creator'))) = 1)))) = 0;
   END_RULE;



   RULE product_definition_requires_date_or_date_and_time FOR (product_definition,
 applied_date_and_time_assignment,
 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT (NOT is_ee_product_definition(pd) OR ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (pd IN adata.items))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (pd IN ada.items))) = 1))))) = 0;
   END_RULE;



   RULE product_definition_requires_person_organization FOR (product_definition,
 applied_person_and_organization_assignment,
 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT (NOT is_ee_product_definition(pd) OR ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (pd IN apaoa.items))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (pd IN aoa.items))) = 1))))) = 0;
   END_RULE;



   RULE product_requires_person_organization FOR (product,
 applied_person_and_organization_assignment,
 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (prod <* product| NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (prod IN apaoa.items))) = 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (prod IN aoa.items))) = 1)))) = 0;
   END_RULE;



   RULE product_requires_product_definition_formation FOR (product,
 product_definition_formation );
   WHERE
      WR1:
         SIZEOF(QUERY (prod <* product| NOT (SIZEOF(QUERY (pdf <* product_definition_formation| (prod :=: pdf.of_product))) >= 1))) = 0;
   END_RULE;



   RULE profile_boundary_definition_with_offsets_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| ((pd\property_definition.description = 'boundary zone definition with specified size') AND (pd\property_definition.name = 'profile boundary with offsets')) AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(pd.definition)))) = 0;
   END_RULE;



   RULE profile_related_positional_boundary_definition_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'profile related positional boundary property') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition)) AND (pd.definition\shape_aspect.description = 'profile related positional boundary')))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* property_definition| (pd\property_definition.description = 'profile related positional boundary property') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| (pdr.related_property_definition\property_definition.description = 'positional boundary offset') AND (pdr\property_definition_relationship.name = 'boundary offset'))) = 1))) = 0;
   END_RULE;



   RULE projected_zone_and_base_relationship_constraint FOR (projected_zone_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pzd <* projected_zone_definition| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end)) OR (pzd.projection_end.product_definitional = TRUE)))) = 0;
   END_RULE;



   RULE projected_zone_height_characteristic_constraint FOR (projected_zone_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pzd <* projected_zone_definition| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length)))) = 0;
   END_RULE;



   RULE promissory_usage_relationship_constraint FOR (promissory_usage_occurrence );
   WHERE
      WR1:
         SIZEOF(QUERY (puo <* promissory_usage_occurrence| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(puo.relating_product_definition)) AND (puo.relating_product_definition.frame_of_reference.name = 'physical design'))) = 0;
      WR2:
         SIZEOF(QUERY (puo <* promissory_usage_occurrence| (SIZEOF(USEDIN(puo,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 0))) = 0;
   END_RULE;



   RULE promissory_usage_relationship_unique_constraint FOR (promissory_usage_occurrence );
   LOCAL
      pu_bag : BAG OF physical_unit := [];
      puo_bag : BAG OF promissory_usage_occurrence;
      pass : BOOLEAN := TRUE;
      comp_bag : BAG OF physical_unit;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(promissory_usage_occurrence) BY 1;
         IF EXISTS(promissory_usage_occurrence[i].relating_product_definition) THEN
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(promissory_usage_occurrence[i].relating_product_definition)) AND (promissory_usage_occurrence[i].relating_product_definition.frame_of_reference.name = 'physical design') THEN
               IF NOT (promissory_usage_occurrence[i].relating_product_definition IN pu_bag) THEN
                  pu_bag := pu_bag + promissory_usage_occurrence[i].relating_product_definition;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pu_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         puo_bag := QUERY (puo <* promissory_usage_occurrence| puo.relating_product_definition :=: pu_bag[i]);
         comp_bag := [];
         REPEAT j := 1 TO SIZEOF(puo_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF(puo_bag[j].related_product_definition)) AND (puo_bag[j].related_product_definition.frame_of_reference.name IN [ 'physical design',
 'physical design usage' ]) THEN
               IF EXISTS(puo_bag[j].related_product_definition) THEN
                  IF puo_bag[j].related_product_definition IN comp_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     comp_bag := comp_bag + puo_bag[j].related_product_definition;
                  END_IF;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE radius_edge_feature_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'radius edge feature shape') AND (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum radius length'))) = 0))) = 0;
      WR2:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'radius edge feature shape') AND (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum radius length'))) = 0))) = 0;
   END_RULE;



   RULE reference_composition_path_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference composition path') AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND (pdr.relating_product_definition\product_definition.description = 'reference definition path')) AND (pdr.relating_product_definition.frame_of_reference.name = 'functional occurrence')))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference composition path') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.related_product_definition)) AND (pdr.related_product_definition.frame_of_reference.name = 'functional occurrence')))) = 0;
   END_RULE;



   RULE reference_functional_unit_assignment_to_part_constraint FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference functional unit assignment to part') AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.related_product_definition)) AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLICATION_CONTEXT_ELEMENT' IN TYPEOF(pdr.related_product_definition.frame_of_reference))) AND ((pdr.relating_product_definition.frame_of_reference.name = 'physical design') OR (pdr.relating_product_definition.frame_of_reference.name = 'physical design usage'))))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* product_definition_relationship| (pdr\product_definition_relationship.name = 'reference functional unit assignment to part') AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition)) AND (pdr.relating_product_definition\product_definition.description = 'design definition path')) AND (pdr.relating_product_definition.id = 'reference composition path')))) = 0;
   END_RULE;



   RULE reference_functional_unit_assignment_to_part_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      sar : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'reference functional unit assignment to part');
      d_bag : BAG OF STRING := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      pd_bag : BAG OF product_definition;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         IF EXISTS(sar[i]\shape_aspect_relationship.description) THEN
            IF NOT (sar[i]\shape_aspect_relationship.description IN d_bag) THEN
               d_bag := d_bag + sar[i]\shape_aspect_relationship.description;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(d_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (r <* sar| r\shape_aspect_relationship.description = d_bag[i]);
         pd_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect.of_shape.definition) THEN
               IF sar_bag[j].related_shape_aspect.of_shape.definition IN pd_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  pd_bag := pd_bag + sar_bag[j].related_shape_aspect.of_shape.definition;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE registered_font_constraint FOR (externally_defined_text_font );
   WHERE
      WR1:
         SIZEOF(QUERY (edtf <* externally_defined_text_font| (SIZEOF(QUERY (adr <* USEDIN(edtf,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.kind\document_type.product_data_type = 'font registration document'))) = 0))) = 0;
   END_RULE;



   RULE registered_font_unique_constraint FOR (externally_defined_text_font );
   LOCAL
      ii_bag : BAG OF STRING := [];
      edtf_bag : BAG OF externally_defined_text_font;
      adr_bag : BAG OF applied_document_reference;
      pass : BOOLEAN := TRUE;
      es_bag : BAG OF ee_specification;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(externally_defined_text_font) BY 1;
         IF EXISTS(externally_defined_text_font[i].item_id) THEN
            IF NOT (externally_defined_text_font[i].item_id IN ii_bag) THEN
               ii_bag := ii_bag + externally_defined_text_font[i].item_id;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ii_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         edtf_bag := QUERY (edtf <* externally_defined_text_font| edtf.item_id = ii_bag[i]);
         REPEAT j := 1 TO SIZEOF(edtf_bag) BY 1;
            adr_bag := QUERY (adr <* USEDIN(edtf_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| adr.assigned_document.kind\document_type.product_data_type = 'font registration document');
            es_bag := [];
            REPEAT k := 1 TO SIZEOF(adr_bag) BY 1;
               IF EXISTS(adr_bag[k].assigned_document) THEN
                  IF adr_bag[k].assigned_document IN es_bag THEN
                     pass := FALSE;
                     ESCAPE;
                  ELSE
                     es_bag := es_bag + adr_bag[k].assigned_document;
                  END_IF;
               END_IF;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE requirement_composition_constraint FOR (property_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'requirements property composition') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)))) = 0;
      WR2:
         SIZEOF(QUERY (pdr <* property_definition_relationship| (pdr\property_definition_relationship.name = 'requirements property composition') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY_GROUP' IN TYPEOF(pdr.relating_property_definition)))) = 0;
   END_RULE;



   RULE requirements_property_constraint FOR (product_definition,
 descriptive_representation_item,
 requirements_property );
   LOCAL
      ri : BAG OF descriptive_representation_item := QUERY (dri <* descriptive_representation_item| dri\representation_item.name = 'requirements name');
      pd : BAG OF product_definition := QUERY (tpd <* product_definition| (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLICATION_CONTEXT_ELEMENT' IN TYPEOF(tpd.frame_of_reference)) AND (tpd.frame_of_reference.name IN [ 'requirement',
 'design requirement',
 'assembly requirement' ])) AND (tpd.name = 'requirements model'));
      r : BAG OF representation := [];
      pdr : BAG OF property_definition_representation := [];
      pass1 : BOOLEAN := TRUE;
      rp : BAG OF property_definition := [];
      pass2 : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(ri) BY 1;
         r := [];
         pdr := [];
         r := USEDIN(ri[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REPRESENTATION.ITEMS');
         pass1 := SIZEOF(r) = 1;
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         pdr := USEDIN(r[1],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
         pass1 := SIZEOF(pdr) = 1;
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         pass1 := 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr[1].definition);
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(pd) BY 1;
         rp := [];
         IF NOT pass2 THEN
            ESCAPE;
         END_IF;
         rp := QUERY (rp <* USEDIN(pd[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
         pass2 := SIZEOF(rp) = 1;
      END_REPEAT;
   WHERE
      WR1:
         pass1;
      WR2:
         pass2;
   END_RULE;



   RULE requirements_property_unique_constraint FOR (descriptive_representation_item,
 requirements_property );
   LOCAL
      desc_bag : BAG OF STRING := [];
      pass1 : BOOLEAN := TRUE;
      pdr : BAG OF property_definition_representation := [];
      rep : BAG OF representation := [];
      pd : BAG OF product_definition := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(requirements_property) BY 1;
         IF NOT pass1 THEN
            ESCAPE;
         END_IF;
         IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF(requirements_property[i].definition) THEN
            pd := pd + requirements_property[i].definition;
         END_IF;
      END_REPEAT;
      IF instance_unique(pd) = FALSE THEN
         pass1 := FALSE;
      END_IF;
   WHERE
      WR1:
         pass1;
   END_RULE;



   RULE restraint_condition_constraint FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| ((pd\property_definition.description = 'restraint') OR (pd\property_definition.description = 'tolerance specific restraint')) AND (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition)) AND (pdr\property_definition_relationship.name = 'restraint description'))) = 0))) = 0;
   END_RULE;



   RULE restrict_action_request_status FOR (action_request_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ars <* action_request_status| NOT (ars\action_request_status.status IN [ 'proposed',
 'in work',
 'issued',
 'hold' ]))) = 0;
   END_RULE;



   RULE restrict_approval_status FOR (approval_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ast <* approval_status| NOT (ast\approval_status.name IN [ 'approved',
 'not yet approved',
 'disapproved',
 'withdrawn' ]))) = 0;
   END_RULE;



   RULE restrict_date_role FOR (date_role );
   WHERE
      WR1:
         SIZEOF(QUERY (dr <* date_role| NOT (dr\date_role.name IN [ 'creation date',
 'request date',
 'release date',
 'start date',
 'contract date',
 'certification date',
 'sign off date',
 'classification date',
 'declassification date' ]))) = 0;
   END_RULE;



   RULE restrict_manifold_surface_shape_representation FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name IN [ 'stratum feature non planar 2d shape',
 'open shell based surface',
 'design intent modification non planar 2d shape',
 'part template non planar 2d shape' ]) AND NOT (SIZEOF(QUERY (sbsm <* mssr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHELL_BASED_SURFACE_MODEL' IN TYPEOF(sbsm)) AND (SIZEOF(QUERY (os <* sbsm\shell_based_surface_model.sbsm_boundary| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'OPEN_SHELL' IN TYPEOF(os)))) = 1))) = 1))) = 0;
   END_RULE;



   RULE rule_action_unique_constraint FOR (rule_action );
   LOCAL
      adta : BAG OF applied_date_and_time_assignment;
      adta_bag : BAG OF applied_date_and_time_assignment := [];
      ra_bag : BAG OF rule_action;
      aaa_bag : BAG OF applied_action_assignment;
      pass : BOOLEAN := TRUE;
      rd_bag : BAG OF product_definition_formation;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(rule_action) BY 1;
         adta := USEDIN(rule_action[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS');
         REPEAT j := 1 TO SIZEOF(adta) BY 1;
            IF EXISTS(adta[j]) THEN
               IF NOT (adta[j] IN adta_bag) THEN
                  adta_bag := adta_bag + adta[j];
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(adta_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ra_bag := QUERY (r <* rule_action| r IN adta_bag[i].items);
         rd_bag := [];
         REPEAT j := 1 TO SIZEOF(ra_bag) BY 1;
            IF NOT pass THEN
               ESCAPE;
            END_IF;
            aaa_bag := QUERY (aa <* USEDIN(ra_bag[j],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ACTION_ASSIGNMENT' IN TYPEOF(aa));
            REPEAT k := 1 TO SIZEOF(aaa_bag) BY 1;
               IF NOT pass THEN
                  ESCAPE;
               END_IF;
               REPEAT l := 1 TO SIZEOF(aaa_bag[k].items) BY 1;
                  IF EXISTS(aaa_bag[k].items[l]) THEN
                     IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(aaa_bag[k].items[l])) AND (aaa_bag[k].items[l]\product_definition_formation.description = 'rule version') THEN
                        IF aaa_bag[k].items[l] IN rd_bag THEN
                           pass := FALSE;
                           ESCAPE;
                        ELSE
                           rd_bag := rd_bag + aaa_bag[k].items[l];
                        END_IF;
                     END_IF;
                  END_IF;
               END_REPEAT;
            END_REPEAT;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE security_classification_constraint FOR (security_classification,
 applied_date_and_time_assignment,
 applied_date_assignment,
 applied_person_and_organization_assignment,
 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (sc <* security_classification| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (sc IN adata.items) AND ('classification date' = adata.role\date_time_role.name))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (sc IN ada.items) AND ('classification date' = ada.role\date_role.name))) = 1)))) = 0;
      WR2:
         SIZEOF(QUERY (sc <* security_classification| (SIZEOF(QUERY (apa <* applied_person_and_organization_assignment| (sc IN apa.items) AND (apa.role\person_and_organization_role.name = 'classification officer'))) = 0))) = 0;
      WR3:
         SIZEOF(QUERY (sc <* security_classification| (SIZEOF(QUERY (aaa <* applied_approval_assignment| (sc IN aaa.items))) = 0))) = 0;
   END_RULE;



   RULE shape_dimension_representation_constraint FOR (shape_dimension_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| NOT (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| (mq\measure_qualification.name = 'dimension value qualifier'))) <= 1))) >= 1))) = 0;
      WR2:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| (mq\measure_qualification.name = 'dimension value qualifier') AND (SIZEOF(QUERY (q <* mq.qualifiers| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TYPE_QUALIFIER' IN TYPEOF(q)))) <> 1))) > 0))) > 0))) = 0;
      WR3:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| (mq\measure_qualification.name = 'dimension value qualifier') AND (SIZEOF(QUERY (q <* mq.qualifiers| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TYPE_QUALIFIER' IN TYPEOF(q)) AND NOT (q\type_qualifier.name IN [ 'theoretically exact',
 'maximum dimension',
 'minumum dimersion',
 'lower value',
 'upper value',
 'basic value' ]))) > 0))) > 0))) > 0))) = 0;
      WR4:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| (SIZEOF(QUERY (i <* sdr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_WITH_UNIT' IN TYPEOF(i)) AND (SIZEOF(QUERY (mq <* USEDIN(i,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')| NOT (mq\measure_qualification.name IN [ 'dimension value qualifier',
 'predefined dimension qualifier',
 'user defined dimension qualifier' ]))) > 0))) > 0))) = 0;
      WR5:
         SIZEOF(QUERY (sdr <* shape_dimension_representation| NOT (SIZEOF(USEDIN(sdr,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.' + 'REPRESENTATION')) >= 1))) = 0;
   END_RULE;



   RULE shape_element_composing_relationship_constraint FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| (sar\shape_aspect_relationship.name = 'composing') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect)))) = 0;
   END_RULE;



   RULE shape_element_constituent_relationship_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      sar : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name IN [ 'constituent',
 'composing',
 'bare die terminal surface constituent relationship',
 'interconnect module terminal surface constituent relationship',
 'package terminal surface constituent relationship' ]);
      sa_bag : BAG OF shape_aspect := [];
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(sar) BY 1;
         IF EXISTS(sar[i].relating_shape_aspect) THEN
            IF NOT (sar[i].relating_shape_aspect IN sa_bag) THEN
               sa_bag := sa_bag + sar[i].relating_shape_aspect;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (r <* sar| r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]);
         rsa_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN rsa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_element_deriving_relationship_unique_constraint FOR (shape_aspect_deriving_relationship );
   LOCAL
      sa_bag : BAG OF shape_aspect := [];
      sadr_bag : BAG OF shape_aspect_deriving_relationship;
      pass : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(shape_aspect_deriving_relationship) BY 1;
         IF EXISTS(shape_aspect_deriving_relationship[i].relating_shape_aspect) THEN
            IF NOT (shape_aspect_deriving_relationship[i].relating_shape_aspect IN sa_bag) THEN
               sa_bag := sa_bag + shape_aspect_deriving_relationship[i].relating_shape_aspect;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sadr_bag := QUERY (r <* shape_aspect_deriving_relationship| r.relating_shape_aspect :=: sa_bag[i]);
         rsa_bag := [];
         REPEAT j := 1 TO SIZEOF(sadr_bag) BY 1;
            IF EXISTS(sadr_bag[j].related_shape_aspect) THEN
               IF sadr_bag[j].related_shape_aspect IN rsa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  rsa_bag := rsa_bag + sadr_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_element_locating_relationship_unique_constraint FOR (dimensional_location );
   LOCAL
      sa_bag : BAG OF shape_aspect := [];
      dl_bag : BAG OF dimensional_location;
      pass : BOOLEAN := TRUE;
      rsa_bag : BAG OF shape_aspect;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(dimensional_location) BY 1;
         IF EXISTS(dimensional_location[i].relating_shape_aspect) THEN
            IF NOT (dimensional_location[i].relating_shape_aspect IN sa_bag) THEN
               sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(sa_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         dl_bag := QUERY (r <* dimensional_location| r.relating_shape_aspect :=: sa_bag[i]);
         rsa_bag := [];
         REPEAT j := 1 TO SIZEOF(dl_bag) BY 1;
            IF EXISTS(dl_bag[j].related_shape_aspect) THEN
               IF dl_bag[j].related_shape_aspect IN rsa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_element_unique_constraint FOR (representation,
 representation_item,
 property_definition_representation );
   LOCAL
      r : BAG OF representation := QUERY (r <* representation| r\representation.name = 'shape element name');
      ri : BAG OF representation_item := [];
      pass : BOOLEAN := TRUE;
      description_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pass := SIZEOF(QUERY (pdr <* USEDIN(r[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| (pdr.definition\property_definition.description = 'shape element characterization'))) = 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ri := QUERY (ri <* representation_item| ri IN r[i].items);
         pass := SIZEOF(ri) = 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         IF NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(ri)) THEN
            pass := FALSE;
            ESCAPE;
         END_IF;
         REPEAT j := 1 TO SIZEOF(ri) BY 1;
            IF EXISTS(ri[j]\descriptive_representation_item.description) THEN
               IF ri[j]\descriptive_representation_item.description IN description_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  description_bag := description_bag + ri[j]\descriptive_representation_item.description;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE shape_representation_requires_origin FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (((SIZEOF(QUERY (it <* sr\representation.items| ((it\representation_item.name = 'origin') OR (it\representation_item.name = 'orientation')) AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(it)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(it))))) = 1) OR (SIZEOF(QUERY (it <* sr\representation.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STYLED_ITEM' IN TYPEOF(it)))) >= 1)) OR (SIZEOF(QUERY (it <* sr\representation.items| ((it\representation_item.name = 'origin') OR (it\representation_item.name = 'orientation')) AND ((sr\representation.name = 'zone shape') OR (sr.context_of_items\representation_context.context_type = 'connection zone colour')))) = 0)))) = 0;
   END_RULE;



   RULE step_edge_feature_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum step depth'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum step width'))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum step depth'))) = 1))) = 0;
      WR4:
         SIZEOF(QUERY (sr <* shape_representation| (sr\representation.name = 'step edge feature shape') AND NOT (SIZEOF(QUERY (lmwu <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'minimum step width'))) = 1))) = 0;
   END_RULE;



   RULE stratum_average_surface_shape_constraint FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name = 'stratum average surface shape') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(mssr,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE' IN TYPEOF(pdr.definition.definition)) AND (pdr.definition.definition\shape_aspect.description = 'average surface'))) = 1))) = 0;
   END_RULE;



   RULE stratum_feature_non_planar_2d_shape_constraint FOR (manifold_surface_shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (mssr <* manifold_surface_shape_representation| (mssr\representation.name = 'stratum feature non planar 2d shape') AND NOT (SIZEOF(QUERY (pdr <* USEDIN(mssr,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE' IN TYPEOF(pdr.definition.definition)))) = 1))) = 0;
   END_RULE;



   RULE stratum_feature_shape_stratum_average_surface_shape_relationship_constraint FOR (representation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum average surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2)) AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')))) = 0;
      WR2:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum average surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1)) AND (rr.rep_1\representation.name = 'stratum average surface shape')))) = 0;
   END_RULE;



   RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR (representation_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2)) AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')))) = 0;
      WR2:
         SIZEOF(QUERY (rr <* representation_relationship| (rr\representation_relationship.name = 'stratum feature shape stratum surface shape relationship') AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1)) AND (rr.rep_1\representation.name = 'stratum surface shape')))) = 0;
   END_RULE;



   RULE stratum_feature_unique_constraint FOR (stratum_feature );
   LOCAL
      sf_bag : BAG OF stratum_feature;
      s_bag : BAG OF stratum := [];
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(stratum_feature) BY 1;
         IF EXISTS(stratum_feature[i].of_shape.definition) THEN
            IF NOT (stratum_feature[i].of_shape.definition IN s_bag) THEN
               s_bag := s_bag + stratum_feature[i].of_shape.definition;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sf_bag := QUERY (r <* stratum_feature| r.of_shape.definition :=: s_bag[i]);
         name_bag := [];
         REPEAT j := 1 TO SIZEOF(sf_bag) BY 1;
            IF EXISTS(sf_bag[j]\shape_aspect.name) THEN
               IF sf_bag[j]\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sf_bag[j]\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = '3d positioned stratum shape in interconnect module') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE stratum_interconnect_module_planar_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'planar positioned stratum shape in interconnect module') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE stratum_make_from_relationship_constraint FOR (make_from_usage_option );
   WHERE
      WR1:
         SIZEOF(QUERY (mfuo <* make_from_usage_option| (mfuo\product_definition_relationship.name = 'stratum make from') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(mfuo.related_product_definition)))) = 0;
      WR2:
         SIZEOF(QUERY (mfuo <* make_from_usage_option| (mfuo\product_definition_relationship.name = 'stratum make from') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(mfuo.relating_product_definition)))) = 0;
   END_RULE;



   RULE stratum_planar_shape_constraint FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (NOT ((sr\representation.name = 'planar projected shape') AND (SIZEOF(QUERY (pdr <* USEDIN(sr,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM' IN TYPEOF(pdr.definition.definition)))) = 1)) OR (SIZEOF(QUERY (a2p2d <* sr.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(a2p2d)))) >= 0)))) = 0;
   END_RULE;



   RULE stratum_surface_in_stratum_3d_position_constraint FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| (mi\representation_item.name = 'stratum surface in stratum 3d position') AND NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
   END_RULE;



   RULE stratum_surface_unique_constraint FOR (stratum_surface );
   LOCAL
      ss_bag : BAG OF stratum_surface;
      s_bag : BAG OF stratum := [];
      pass : BOOLEAN := TRUE;
      desc_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(stratum_surface) BY 1;
         IF EXISTS(stratum_surface[i].of_shape.definition) THEN
            IF NOT (stratum_surface[i].of_shape.definition IN s_bag) THEN
               s_bag := s_bag + stratum_surface[i].of_shape.definition;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         ss_bag := QUERY (r <* stratum_surface| r.of_shape.definition :=: s_bag[i]);
         desc_bag := [];
         REPEAT j := 1 TO SIZEOF(ss_bag) BY 1;
            IF EXISTS(ss_bag[j]\shape_aspect.description) THEN
               IF ss_bag[j]\shape_aspect.description IN desc_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  desc_bag := desc_bag + ss_bag[j]\shape_aspect.description;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE stratum_technology_line_width_tolerance_assignment_constraint FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'stratum technology line width tolerance assignment') AND NOT (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum positive deviation'))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'stratum technology line width tolerance assignment') AND NOT (SIZEOF(QUERY (si <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STYLED_ITEM' IN TYPEOF(si)))) = 1))) = 0;
      WR3:
         SIZEOF(QUERY (rep <* representation| (rep\representation.name = 'stratum technology line width tolerance assignment') AND NOT (SIZEOF(QUERY (lmwu <* rep.items| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu)) AND (lmwu\representation_item.name = 'maximum negative deviation'))) = 1))) = 0;
   END_RULE;



   RULE substitute_product_constraint FOR (product,
 assembly_component_usage_substitute );
   WHERE
      WR1:
         SIZEOF(QUERY (acus <* assembly_component_usage_substitute| EXISTS(acus.substitute.reference_designator))) = 0;
   END_RULE;



   RULE subtype_combination_shape_aspect FOR (shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MINIMALLY_DEFINED_BARE_DIE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DERIVED_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_BOUNDARY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE') ] * TYPEOF(sa)) <= 1))) = 0;
      WR2:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MINIMALLY_DEFINED_BARE_DIE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERCONNECT_MODULE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_PART_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_BOUNDARY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE') ] * TYPEOF(sa)) <= 1))) = 0;
      WR3:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_BOND_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_INTERFACE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_REFERENCE_FRAME'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATUM_SYSTEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DERIVED_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FABRICATION_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'JOIN_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAND_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LAYER_CONNECTION_POINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MOUNTING_RESTRICTION_AREA'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGE_BODY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_CONNECTED_TERMINALS_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PASSAGE_TECHNOLOGY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_NETWORK'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'POSITIONAL_BOUNDARY_MEMBER'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRINTED_PART_TEMPLATE_TERMINAL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_MODIFICATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_SURFACE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TOLERANCE_ZONE_BOUNDARY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'VIEWING_PLANE') ] * TYPEOF(sa)) <= 1))) = 0;
      WR4:
         SIZEOF(QUERY (sa <* shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_FEATURE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM_TARGET'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_DATUM') ] * TYPEOF(sa)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_action_request_assignment FOR (action_request_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ara <* action_request_assignment| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_REQUEST') ] * TYPEOF(ara)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_dimensional_location FOR (dimensional_location );
   WHERE
      WR1:
         SIZEOF(QUERY (dl <* dimensional_location| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANGULAR_DIMENSION_WITH_ORIENTATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_LOCATION_WITH_DIRECTION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_LOCATION_WITH_PATH') ] * TYPEOF(dl)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_dimensional_size FOR (dimensional_size );
   WHERE
      WR1:
         SIZEOF(QUERY (ds <* dimensional_size| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CURVE_DIMENSION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANGULAR_SIZE') ] * TYPEOF(ds)) <= 1) OR NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CURVE_DIMENSION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE') ] * TYPEOF(ds)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_mapped_item FOR (mapped_item );
   WHERE
      WR1:
         SIZEOF(QUERY (mi <* mapped_item| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_TEXT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_MODULE_USAGE_VIEW_CONNECTOR_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANNOTATION_SYMBOL') ] * TYPEOF(mi)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_product_definition FOR (product_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* product_definition| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BUS_STRUCTURAL_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_FUNCTIONAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'FUNCTIONAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'NETWORK_NODE_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM') ] * TYPEOF(pd)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_product_definition_relationship FOR (product_definition_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* product_definition_relationship| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_USAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SUPPLIED_PART_RELATIONSHIP') ] * TYPEOF(pdr)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_property_definition FOR (property_definition );
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* property_definition| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_SIZE_PROPERTY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_TOLERANCE_GROUP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_PROPERTY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_SHAPE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'REQUIREMENTS_PROPERTY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SIGNAL') ] * TYPEOF(pd)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_property_definition_representation FOR (property_definition_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (pdr <* property_definition_representation| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_DEFINITION_REPRESENTATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_PROPERTY_REPRESENTATION') ] * TYPEOF(pdr)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_representation FOR (representation );
   WHERE
      WR1:
         SIZEOF(QUERY (rep <* representation| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ANALYTICAL_MODEL_PORT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_FUNCTION_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_STRING_REPRESENTATION') ] * TYPEOF(rep)) <= 1))) = 0;
   END_RULE;



   RULE subtype_exclusive_representation_context FOR (representation_context );
   LOCAL
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(representation_context) BY 1;
         pass := ((NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRUCTURED_TEXT_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i])) OR (SIZEOF(TYPEOF(representation_context[i])) <= 2)) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i])) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETRIC_REPRESENTATION_CONTEXT') ] * TYPEOF(representation_context[i])) <= 2))) AND (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i])) OR (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GEOMETRIC_REPRESENTATION_CONTEXT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PARAMETRIC_REPRESENTATION_CONTEXT') ] * TYPEOF(representation_context[i])) <= 2));
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE subtype_exclusive_shape_aspect_relationship FOR (shape_aspect_relationship );
   WHERE
      WR1:
         SIZEOF(QUERY (sar <* shape_aspect_relationship| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_JOINT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DEVICE_TERMINAL_MAP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIMENSIONAL_LOCATION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'INTERFACE_MOUNTED_JOIN'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_CONNECTIVITY_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_FEATURE_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_ELEMENT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_DERIVING_RELATIONSHIP'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'STRATUM_CONCEPT_RELATIONSHIP') ] * TYPEOF(sar)) <= 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_action FOR (action );
   WHERE
      WR1:
         SIZEOF(QUERY (act <* action| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DIRECTED_ACTION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXECUTED_ACTION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_ACTION') ] * TYPEOF(act)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_address FOR (address );
   WHERE
      WR1:
         SIZEOF(QUERY (add <* address| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERSONAL_ADDRESS'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ORGANIZATIONAL_ADDRESS') ] * TYPEOF(add)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_colour FOR (colour );
   WHERE
      WR1:
         SIZEOF(QUERY (c <* colour| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COLOUR_RGB' IN TYPEOF(c)))) = 0;
   END_RULE;



   RULE subtype_mandatory_composite_shape_aspect FOR (composite_shape_aspect );
   WHERE
      WR1:
         SIZEOF(QUERY (csa <* composite_shape_aspect| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_GROUP_SHAPE_ASPECT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPOSITE_UNIT_SHAPE_ASPECT') ] * TYPEOF(csa)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_compound_representation_item FOR (compound_representation_item );
   WHERE
      WR1:
         SIZEOF(QUERY (tl <* compound_representation_item| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DATA_SET_REPRESENTATION_ITEM' IN TYPEOF(tl)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TABLE_REPRESENTATION_ITEM' IN TYPEOF(tl))))) = 0;
   END_RULE;



   RULE subtype_mandatory_date FOR (date );
   WHERE
      WR1:
         SIZEOF(QUERY (d <* date| NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CALENDAR_DATE' IN TYPEOF(d)))) = 0;
   END_RULE;



   RULE subtype_mandatory_externally_defined_item FOR (externally_defined_item );
   WHERE
      WR1:
         SIZEOF(QUERY (edi <* externally_defined_item| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'BOND_CATEGORY'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_CURVE_FONT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_FUNCTIONAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_HATCH_STYLE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_REPRESENTATION_ITEM'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_SYMBOL'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_TEXT_FONT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_TILE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_TILE_STYLE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PART_TEMPLATE_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RULE_DEFINITION'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SIGNAL_CATEGORY') ] * TYPEOF(edi)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_geometric_tolerance FOR (geometric_tolerance );
   WHERE
      WR1:
         SIZEOF(QUERY (gt <* geometric_tolerance| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE') ] * TYPEOF(gt)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item );
   WHERE
      WR1:
         SIZEOF(QUERY (pdi <* pre_defined_item| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_TEXT_FONT'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRE_DEFINED_CURVE_FONT') ] * TYPEOF(pdi)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_product_definition_usage FOR (product_definition_usage );
   WHERE
      WR1:
         SIZEOF(QUERY (pdu <* product_definition_usage| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE'),
 ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_USAGE_OPTION') ] * TYPEOF(pdu)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_runout_zone_orientation FOR (runout_zone_orientation );
   WHERE
      WR1:
         SIZEOF(QUERY (rzo <* runout_zone_orientation| NOT (SIZEOF([ ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION') ] * TYPEOF(rzo)) = 1))) = 0;
   END_RULE;



   RULE subtype_mandatory_text_literal FOR (text_literal );
   WHERE
      WR1:
         SIZEOF(QUERY (tl <* text_literal| NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_LITERAL_WITH_EXTENT' IN TYPEOF(tl)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN TYPEOF(tl))))) = 0;
   END_RULE;



   RULE supplied_product_version_unique_constraint FOR (product_definition_formation_with_specified_source );
   LOCAL
      spv : BAG OF product_definition_formation_with_specified_source := QUERY (r <* product_definition_formation_with_specified_source| SIZEOF(QUERY (pd <* USEDIN(r,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION.FORMATION')| (SIZEOF(QUERY (pdr <* USEDIN(pd,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SUPPLIED_PART_RELATIONSHIP' IN TYPEOF(pdr)))) > 0))) > 0);
      aoa_bag : BAG OF applied_organization_assignment;
      o_bag : BAG OF organization := [];
      pdf_bag : BAG OF product_definition_formation_with_specified_source;
      spn_bag : BAG OF STRING;
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(spv) BY 1;
         aoa_bag := QUERY (aoa <* USEDIN(spv[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| aoa.role\organization_role.name = 'supplier');
         REPEAT j := 1 TO SIZEOF(aoa_bag) BY 1;
            IF EXISTS(aoa_bag[j].assigned_organization) THEN
               IF NOT (aoa_bag[j].assigned_organization IN o_bag) THEN
                  o_bag := o_bag + aoa_bag[j].assigned_organization;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(o_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         pdf_bag := QUERY (pdf <* spv| SIZEOF(QUERY (aoa <* USEDIN(pdf,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| (aoa.role\organization_role.name = 'supplier') AND (aoa.assigned_organization :=: o_bag[i]))) > 0);
         spn_bag := [];
         REPEAT j := 1 TO SIZEOF(pdf_bag) BY 1;
            IF EXISTS(pdf_bag[j].of_product.id) THEN
               IF pdf_bag[j].of_product.id IN spn_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  spn_bag := spn_bag + pdf_bag[j].of_product.id;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE topological_junction_unique_constraint FOR (shape_aspect );
   LOCAL
      tj : BAG OF shape_aspect := QUERY (r <* shape_aspect| r\shape_aspect.description = 'topological junction');
      sar_bag : BAG OF shape_aspect_relationship;
      s_bag : BAG OF shape_aspect := [];
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(tj) BY 1;
         sar_bag := QUERY (sar <* USEDIN(tj[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'topological junction scope') AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)));
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].relating_shape_aspect) THEN
               IF NOT (sar_bag[j].relating_shape_aspect IN s_bag) THEN
                  s_bag := s_bag + sar_bag[j].relating_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(s_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* USEDIN(s_bag[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar\shape_aspect_relationship.name = 'topological junction scope');
         name_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect\shape_aspect.name) THEN
               IF sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE transmission_line_functional_unit_terminal_allocation_unique_constraint FOR (shape_aspect_relationship );
   LOCAL
      tlfuta : BAG OF shape_aspect_relationship := QUERY (r <* shape_aspect_relationship| r\shape_aspect_relationship.name = 'transmission line functional terminal allocation');
      sa_bag : BAG OF shape_aspect;
      sar_bag : BAG OF shape_aspect_relationship;
      ut_bag : BAG OF shape_aspect := [];
      pass : BOOLEAN := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(tlfuta) BY 1;
         IF EXISTS(tlfuta[i].relating_shape_aspect) THEN
            IF tlfuta[i].relating_shape_aspect\shape_aspect.description = 'unit terminal' THEN
               IF NOT (tlfuta[i].relating_shape_aspect IN ut_bag) THEN
                  ut_bag := ut_bag + tlfuta[i].relating_shape_aspect;
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT;
      REPEAT i := 1 TO SIZEOF(ut_bag) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* tlfuta| (sar.related_shape_aspect\shape_aspect.description = 'printed component join terminal') AND (sar.relating_shape_aspect :=: ut_bag[i]));
         sa_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect) THEN
               IF sar_bag[j].related_shape_aspect IN sa_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE versioned_action_request_requires_approval FOR (versioned_action_request,
 applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (varq <* versioned_action_request| NOT (SIZEOF(QUERY (aaa <* applied_approval_assignment| (varq IN aaa.items))) = 1))) = 0;
   END_RULE;



   RULE versioned_action_request_requires_date_or_date_and_time FOR (versioned_action_request,
 applied_date_and_time_assignment,
 applied_date_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (varq <* versioned_action_request| NOT ((SIZEOF(QUERY (adata <* applied_date_and_time_assignment| (varq IN adata.items))) = 1) OR (SIZEOF(QUERY (ada <* applied_date_assignment| (varq IN ada.items))) = 1)))) = 0;
   END_RULE;



   RULE versioned_action_request_requires_person_organization FOR (versioned_action_request,
 applied_person_and_organization_assignment,
 applied_organization_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (varq <* versioned_action_request| NOT ((SIZEOF(QUERY (apaoa <* applied_person_and_organization_assignment| (varq IN apaoa.items))) >= 1) OR (SIZEOF(QUERY (aoa <* applied_organization_assignment| (varq IN aoa.items))) >= 1)))) = 0;
   END_RULE;



   RULE versioned_action_request_requires_status FOR (versioned_action_request,
 action_request_status );
   WHERE
      WR1:
         SIZEOF(QUERY (ar <* versioned_action_request| NOT (SIZEOF(QUERY (ars <* action_request_status| (ar :=: ars.assigned_request))) = 1))) = 0;
   END_RULE;



   RULE via_template_terminal_unique_constraint FOR (shape_aspect );
   LOCAL
      vt : BAG OF shape_aspect := QUERY (r <* shape_aspect| r\shape_aspect.description = 'via template');
      sar_bag : BAG OF shape_aspect_relationship;
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING;
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(vt) BY 1;
         IF NOT pass THEN
            ESCAPE;
         END_IF;
         sar_bag := QUERY (sar <* USEDIN(vt[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar\shape_aspect_relationship.name = 'access mechanism') AND (sar.related_shape_aspect\shape_aspect.description = 'via template terminal'));
         name_bag := [];
         REPEAT j := 1 TO SIZEOF(sar_bag) BY 1;
            IF EXISTS(sar_bag[j].related_shape_aspect\shape_aspect.name) THEN
               IF sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag THEN
                  pass := FALSE;
                  ESCAPE;
               ELSE
                  name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
               END_IF;
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE work_order_unique_constraint FOR (directed_action );
   LOCAL
      r : BAG OF directed_action := QUERY (r <* directed_action| SIZEOF(QUERY (aa <* USEDIN(r,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE' IN TYPEOF(aa)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_WORK' IN TYPEOF(aa)))) > 0);
      pass : BOOLEAN := TRUE;
      name_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].directive\action_directive.name) THEN
            IF r[i].directive\action_directive.name IN name_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               name_bag := name_bag + r[i].directive\action_directive.name;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;



   RULE work_request_unique_constraint FOR (versioned_action_request );
   LOCAL
      r : BAG OF versioned_action_request := QUERY (r <* versioned_action_request| SIZEOF(QUERY (ara <* USEDIN(r,
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST' IN TYPEOF(ara)) OR ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_REQUEST' IN TYPEOF(ara)))) > 0);
      pass : BOOLEAN := TRUE;
      id_bag : BAG OF STRING := [];
   END_LOCAL;
      REPEAT i := 1 TO SIZEOF(r) BY 1;
         IF EXISTS(r[i].id) THEN
            IF r[i].id IN id_bag THEN
               pass := FALSE;
               ESCAPE;
            ELSE
               id_bag := id_bag + r[i].id;
            END_IF;
         END_IF;
      END_REPEAT;
   WHERE
      WR1:
         pass;
   END_RULE;


(* *********************************** *)


END_SCHEMA;


(* ************************************************************************** *)
