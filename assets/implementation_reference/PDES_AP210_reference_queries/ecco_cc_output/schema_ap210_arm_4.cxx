// GENERATED BY ECCO V3.1.2
// - debug
#include "schema_ap210_arm.hh"
static EX_ENV* env=&SCHEMA::env;
static const char* lDegree_of_freedomS18_Type[]={
"X","Y","Z","U","V","W"}

;
tvtbl_entry Degree_of_freedomS18_Type[]={
0,"DEGREE_OF_FREEDOM",&SCHEMA::env,0,(void*)232,0,lDegree_of_freedomS18_Type,(void*)6,0,0,0
}

;
Type*& gDegree_of_freedomS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Degree_of_freedomS18_Type))->ref()),t->vtbl=Degree_of_freedomS18_Type,t);
}

static const char* lMeasure_orientationS18_Type[]={
"REVERSED","NORMAL"}

;
tvtbl_entry Measure_orientationS18_Type[]={
0,"MEASURE_ORIENTATION",&SCHEMA::env,0,(void*)706,0,lMeasure_orientationS18_Type,(void*)2,0,0,
Descriptive_or_geometric_orientationS18_Type,0
}

;
Type*& gMeasure_orientationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Measure_orientationS18_Type))->ref()),t->vtbl=Measure_orientationS18_Type,t);
}

tvtbl_entry Descriptive_or_geometric_orientationS18_Type[]={
0,"DESCRIPTIVE_OR_GEOMETRIC_ORIENTATION",&SCHEMA::env,0,(void*)246,0,0,0,0,0,0
}

;
Type*& gDescriptive_or_geometric_orientationS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gMeasure_orientationS18_Type(),
Entity_Type::get(DirectionS18_Impl),0)->ref(),t)),t->vtbl=Descriptive_or_geometric_orientationS18_Type,t);
}

tvtbl_entry Design_composition_path_or_rootS18_Type[]={
0,"DESIGN_COMPOSITION_PATH_OR_ROOT",&SCHEMA::env,0,(void*)252,0,0,0,0,0,0
}

;
Type*& gDesign_composition_path_or_rootS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Design_composition_pathS18_Impl),
Entity_Type::get(Functional_unit_network_definitionS18_Impl),0)->ref(),t)),t->vtbl=Design_composition_path_or_rootS18_Type,t);
}

tvtbl_entry Design_intent_modification_3d_shape_selectS18_Type[]={
0,"DESIGN_INTENT_MODIFICATION_3D_SHAPE_SELECT",&SCHEMA::env,0,(void*)258,0,0,0,0,0,0
}

;
Type*& gDesign_intent_modification_3d_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Design_intent_modification_non_planar_2d_shapeS18_Impl),
Entity_Type::get(Design_intent_modification_3d_shapeS18_Impl),0)->ref(),t)),t->vtbl=Design_intent_modification_3d_shape_selectS18_Type,t);
}

tvtbl_entry Design_intent_modification_planar_shape_selectS18_Type[]={
0,"DESIGN_INTENT_MODIFICATION_PLANAR_SHAPE_SELECT",&SCHEMA::env,0,(void*)264,0,0,0,0,0,0
}

;
Type*& gDesign_intent_modification_planar_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Design_intent_modification_styled_area_representationS18_Impl),
Entity_Type::get(Design_intent_modification_planar_shapeS18_Impl),0)->ref(),t)),t->vtbl=Design_intent_modification_planar_shape_selectS18_Type,t);
}

tvtbl_entry Design_intent_modification_or_material_removal_componentS18_Type[]={
0,"DESIGN_INTENT_MODIFICATION_OR_MATERIAL_REMOVAL_COMPONENT",&SCHEMA::env,0,(void*)270,0,0,0,0,0,0
}

;
Type*& gDesign_intent_modification_or_material_removal_componentS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Design_intent_modificationS18_Impl),
Entity_Type::get(Material_removal_laminate_componentS18_Impl),0)->ref(),t)),t->vtbl=Design_intent_modification_or_material_removal_componentS18_Type,t);
}

tvtbl_entry Design_object_management_relationship_or_descriptionS18_Type[]={
0,"DESIGN_OBJECT_MANAGEMENT_RELATIONSHIP_OR_DESCRIPTION",&SCHEMA::env,0,(void*)276,0,0,0,0,0,0
}

;
Type*& gDesign_object_management_relationship_or_descriptionS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Ee_textS18_Impl),
Entity_Type::get(Design_object_management_relationshipS18_Impl),0)->ref(),t)),t->vtbl=Design_object_management_relationship_or_descriptionS18_Type,t);
}

static const char* lDimension_qualifiersS18_Type[]={
"FREE_STATE","AVERAGE"}

;
tvtbl_entry Dimension_qualifiersS18_Type[]={
0,"DIMENSION_QUALIFIERS",&SCHEMA::env,0,(void*)282,0,lDimension_qualifiersS18_Type,(void*)2,0,0,0
}

;
Type*& gDimension_qualifiersS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Dimension_qualifiersS18_Type))->ref()),t->vtbl=Dimension_qualifiersS18_Type,t);
}

tvtbl_entry Dimensional_location_or_dimensional_sizeS18_Type[]={
0,"DIMENSIONAL_LOCATION_OR_DIMENSIONAL_SIZE",&SCHEMA::env,0,(void*)288,0,0,0,0,0,0
}

;
Type*& gDimensional_location_or_dimensional_sizeS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Dimensional_sizeS18_Impl),
Entity_Type::get(Dimensional_locationS18_Impl),0)->ref(),t)),t->vtbl=Dimensional_location_or_dimensional_sizeS18_Type,t);
}

static const char* lDimensional_typesS18_Type[]={
"ANGULAR","RADIUS","ARC_LENGTH","DIAMETER","LINEAR","CONTROLLED_RADIUS"}

;
tvtbl_entry Dimensional_typesS18_Type[]={
0,"DIMENSIONAL_TYPES",&SCHEMA::env,0,(void*)294,0,lDimensional_typesS18_Type,(void*)6,0,0,0
}

;
Type*& gDimensional_typesS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Dimensional_typesS18_Type))->ref()),t->vtbl=Dimensional_typesS18_Type,t);
}

tvtbl_entry Document_or_organizationS18_Type[]={
0,"DOCUMENT_OR_ORGANIZATION",&SCHEMA::env,0,(void*)308,0,0,0,0,0,0
}

;
Type*& gDocument_or_organizationS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Ee_documentS18_Impl),
Entity_Type::get(OrganizationS18_Impl),0)->ref(),t)),t->vtbl=Document_or_organizationS18_Type,t);
}

static const char* lPredefined_documentation_layer_purposeS18_Type[]={
"SOLDERMASK","SOLDERPASTE","SILKSCREEN","GENERIC_LAYER","GLUE","GLUEMASK","PASTEMASK"}

;
tvtbl_entry Predefined_documentation_layer_purposeS18_Type[]={
0,"PREDEFINED_DOCUMENTATION_LAYER_PURPOSE",&SCHEMA::env,0,(void*)1151,0,lPredefined_documentation_layer_purposeS18_Type,(void*)7,0,0,
Documentation_layer_purposeS18_Type,0
}

;
Type*& gPredefined_documentation_layer_purposeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Predefined_documentation_layer_purposeS18_Type))->ref()),t->vtbl=Predefined_documentation_layer_purposeS18_Type,t);
}

tvtbl_entry Documentation_layer_purposeS18_Type[]={
0,"DOCUMENTATION_LAYER_PURPOSE",&SCHEMA::env,0,(void*)314,0,0,0,0,0,0
}

;
Type*& gDocumentation_layer_purposeS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gPredefined_documentation_layer_purposeS18_Type(),
Entity_Type::get(External_definitionS18_Impl),0)->ref(),t)),t->vtbl=Documentation_layer_purposeS18_Type,t);
}

tvtbl_entry LabelS18_Type[]={
0,"LABEL",&SCHEMA::env,0,(void*)557,0,0,0,0,0,0
}

;
Type*& gLabelS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new String_Type())->ref()
#undef local
),t->vtbl=LabelS18_Type,t);
}
tvtbl_entry Ee_nameS18_Type[]={
LabelS18_Type,"EE_NAME",&SCHEMA::env,0,(void*)320,0,0,0,0,0,0
}
;
Type*& gEe_nameS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new String_Type())->ref()
#undef local
),t->vtbl=Ee_nameS18_Type,t);
}
tvtbl_entry Ee_product_definition_with_annotation_elementsS18_Type[]={
0,"EE_PRODUCT_DEFINITION_WITH_ANNOTATION_ELEMENTS",&SCHEMA::env,0,(void*)323,0,0,0,0,0,0
}
;
Type*& gEe_product_definition_with_annotation_elementsS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Footprint_definitionS18_Impl),
Entity_Type::get(Padstack_definitionS18_Impl),
Entity_Type::get(Physical_unitS18_Impl),
Entity_Type::get(StratumS18_Impl),
Entity_Type::get(Template_definitionS18_Impl),0)->ref(),t)),t->vtbl=Ee_product_definition_with_annotation_elementsS18_Type,t);
}
tvtbl_entry Evaluated_characteristic_or_descriptionS18_Type[]={
0,"EVALUATED_CHARACTERISTIC_OR_DESCRIPTION",&SCHEMA::env,0,(void*)335,0,0,0,0,0,0
}
;
Type*& gEvaluated_characteristic_or_descriptionS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Evaluated_characteristicS18_Impl),
Entity_Type::get(Ee_textS18_Impl),0)->ref(),t)),t->vtbl=Evaluated_characteristic_or_descriptionS18_Type,t);
}
static const char* lEvaluation_result_valueS18_Type[]={
"PASS","FAIL","UNDEFINED"}
;
tvtbl_entry Evaluation_result_valueS18_Type[]={
0,"EVALUATION_RESULT_VALUE",&SCHEMA::env,0,(void*)341,0,lEvaluation_result_valueS18_Type,(void*)3,0,0,0
}
;
Type*& gEvaluation_result_valueS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Evaluation_result_valueS18_Type))->ref()),t->vtbl=Evaluation_result_valueS18_Type,t);
}
static const char* lEvaluation_typeS18_Type[]={
"NOT_EVALUATABLE","INVALID","VALID","TO_BE_EVALUATED"}
;
tvtbl_entry Evaluation_typeS18_Type[]={
0,"EVALUATION_TYPE",&SCHEMA::env,0,(void*)349,0,lEvaluation_typeS18_Type,(void*)4,0,0,0
}
;
Type*& gEvaluation_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Evaluation_typeS18_Type))->ref()),t->vtbl=Evaluation_typeS18_Type,t);
}
static const char* lExtend_or_chord_2_extend_or_truncate_or_roundS18_Type[]={
"TRUNCATE","CHORD_2_EXTEND","ROUND","EXTEND"}
;
tvtbl_entry Extend_or_chord_2_extend_or_truncate_or_roundS18_Type[]={
0,"EXTEND_OR_CHORD_2_EXTEND_OR_TRUNCATE_OR_ROUND",&SCHEMA::env,0,(void*)359,0,lExtend_or_chord_2_extend_or_truncate_or_roundS18_Type,(void*)4,0,0,0
}
;
Type*& gExtend_or_chord_2_extend_or_truncate_or_roundS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Extend_or_chord_2_extend_or_truncate_or_roundS18_Type))->ref()),t->vtbl=Extend_or_chord_2_extend_or_truncate_or_roundS18_Type,t);
}
static const char* lExtend_or_truncateS18_Type[]={
"TRUNCATE","EXTEND"}
;
tvtbl_entry Extend_or_truncateS18_Type[]={
0,"EXTEND_OR_TRUNCATE",&SCHEMA::env,0,(void*)369,0,lExtend_or_truncateS18_Type,(void*)2,0,0,0
}
;
Type*& gExtend_or_truncateS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Extend_or_truncateS18_Type))->ref()),t->vtbl=Extend_or_truncateS18_Type,t);
}
tvtbl_entry Fabricated_feature_selectS18_Type[]={
0,"FABRICATED_FEATURE_SELECT",&SCHEMA::env,0,(void*)375,0,0,0,0,0,0
}
;
Type*& gFabricated_feature_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Component_termination_passage_join_terminalS18_Impl),
Entity_Type::get(Via_terminalS18_Impl),
Entity_Type::get(Printed_component_join_terminalS18_Impl),
Entity_Type::get(Conductive_interconnect_element_terminalS18_Impl),
Entity_Type::get(Embedded_component_terminalS18_Impl),
Entity_Type::get(Land_join_terminalS18_Impl),
Entity_Type::get(Non_functional_land_join_terminalS18_Impl),0)->ref(),t)),t->vtbl=Fabricated_feature_selectS18_Type,t);
}
tvtbl_entry Part_template_or_physical_unit_2d_shape_selectS18_Type[]={
0,"PART_TEMPLATE_OR_PHYSICAL_UNIT_2D_SHAPE_SELECT",&SCHEMA::env,0,(void*)849,0,0,0,0,0,
Part_template_or_physical_unit_shape_selectS18_Type,0
}
;
Type*& gPart_template_or_physical_unit_2d_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Part_template_planar_shapeS18_Impl),
Entity_Type::get(Physical_unit_planar_shapeS18_Impl),0)->ref(),t)),t->vtbl=Part_template_or_physical_unit_2d_shape_selectS18_Type,t);
}
tvtbl_entry Part_template_or_physical_unit_3d_shape_selectS18_Type[]={
0,"PART_TEMPLATE_OR_PHYSICAL_UNIT_3D_SHAPE_SELECT",&SCHEMA::env,0,(void*)855,0,0,0,0,0,
Part_template_or_physical_unit_shape_selectS18_Type,0
}
;
Type*& gPart_template_or_physical_unit_3d_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Part_template_3d_shapeS18_Impl),
Entity_Type::get(Part_template_non_planar_2d_shapeS18_Impl),
Entity_Type::get(Physical_unit_3d_shapeS18_Impl),0)->ref(),t)),t->vtbl=Part_template_or_physical_unit_3d_shape_selectS18_Type,t);
}
tvtbl_entry Part_template_or_physical_unit_shape_selectS18_Type[]={
0,"PART_TEMPLATE_OR_PHYSICAL_UNIT_SHAPE_SELECT",&SCHEMA::env,0,(void*)863,0,0,0,0,0,
Feature_or_non_feature_usageS18_Type,0
}
;
Type*& gPart_template_or_physical_unit_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gPart_template_or_physical_unit_2d_shape_selectS18_Type(),
gPart_template_or_physical_unit_3d_shape_selectS18_Type(),0)->ref(),t)),t->vtbl=Part_template_or_physical_unit_shape_selectS18_Type,t);
}
tvtbl_entry Feature_or_non_feature_usageS18_Type[]={
0,"FEATURE_OR_NON_FEATURE_USAGE",&SCHEMA::env,0,(void*)391,0,0,0,0,0,0
}
;
Type*& gFeature_or_non_feature_usageS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(View_level_non_feature_shape_definitionS18_Impl),
gPart_template_or_physical_unit_shape_selectS18_Type(),0)->ref(),t)),t->vtbl=Feature_or_non_feature_usageS18_Type,t);
}
tvtbl_entry Fill_area_style_tile_shape_selectS18_Type[]={
0,"FILL_AREA_STYLE_TILE_SHAPE_SELECT",&SCHEMA::env,0,(void*)397,0,0,0,0,0,0
}
;
Type*& gFill_area_style_tile_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Externally_defined_tileS18_Impl),
Entity_Type::get(Fill_area_style_tile_symbol_with_styleS18_Impl),
Entity_Type::get(Fill_area_style_tile_solid_regionS18_Impl),
Entity_Type::get(Fill_area_style_tile_curve_with_styleS18_Impl),0)->ref(),t)),t->vtbl=Fill_area_style_tile_shape_selectS18_Type,t);
}
tvtbl_entry Fill_style_selectS18_Type[]={
0,"FILL_STYLE_SELECT",&SCHEMA::env,0,(void*)407,0,0,0,0,0,0
}
;
Type*& gFill_style_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Solid_fill_styleS18_Impl),
Entity_Type::get(Fill_area_style_tileS18_Impl),
Entity_Type::get(Externally_defined_tile_styleS18_Impl),
Entity_Type::get(Externally_defined_hatch_styleS18_Impl),
Entity_Type::get(Fill_area_style_hatchingS18_Impl),0)->ref(),t)),t->vtbl=Fill_style_selectS18_Type,t);
}
tvtbl_entry Font_selectS18_Type[]={
0,"FONT_SELECT",&SCHEMA::env,0,(void*)419,0,0,0,0,0,0
}
;
Type*& gFont_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Registered_fontS18_Impl),
Entity_Type::get(Font_definitionS18_Impl),0)->ref(),t)),t->vtbl=Font_selectS18_Type,t);
}
tvtbl_entry Geometric_or_dimension_selectS18_Type[]={
0,"GEOMETRIC_OR_DIMENSION_SELECT",&SCHEMA::env,0,(void*)425,0,0,0,0,0,0
}
;
Type*& gGeometric_or_dimension_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Geometric_toleranceS18_Impl),
Entity_Type::get(Dimensional_characteristicS18_Impl),0)->ref(),t)),t->vtbl=Geometric_or_dimension_selectS18_Type,t);
}
static const char* lPredefined_geometric_statusS18_Type[]={
"UNDEFINED","STANDARD_DATUM_CONDITION","PERPENDICULAR_PRIMARY_DATUM_AXIS","PERPENDICULAR_PRIMARY_DATUM_PLANE"}
;
tvtbl_entry Predefined_geometric_statusS18_Type[]={
0,"PREDEFINED_GEOMETRIC_STATUS",&SCHEMA::env,0,(void*)1167,0,lPredefined_geometric_statusS18_Type,(void*)4,0,0,
Geometric_statusS18_Type,0
}
;
Type*& gPredefined_geometric_statusS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Predefined_geometric_statusS18_Type))->ref()),t->vtbl=Predefined_geometric_statusS18_Type,t);
}
tvtbl_entry Geometric_statusS18_Type[]={
0,"GEOMETRIC_STATUS",&SCHEMA::env,0,(void*)431,0,0,0,0,0,0
}
;
Type*& gGeometric_statusS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gPredefined_geometric_statusS18_Type(),
Entity_Type::get(External_definitionS18_Impl),0)->ref(),t)),t->vtbl=Geometric_statusS18_Type,t);
}
static const char* lGeometric_tolerance_qualifiersS18_Type[]={
"PITCH_DIAMETER","MINOR_DIAMETER","EACH_ELEMENT","MAJOR_DIAMETER","EACH_RADIAL_ELEMENT","NOT_CONCAVE","NOT_CONVEX","FREE_STATE"}
;
tvtbl_entry Geometric_tolerance_qualifiersS18_Type[]={
0,"GEOMETRIC_TOLERANCE_QUALIFIERS",&SCHEMA::env,0,(void*)437,0,lGeometric_tolerance_qualifiersS18_Type,(void*)8,0,0,0
}
;
Type*& gGeometric_tolerance_qualifiersS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Geometric_tolerance_qualifiersS18_Type))->ref()),t->vtbl=Geometric_tolerance_qualifiersS18_Type,t);
}
static const char* lHorizontal_justificationS18_Type[]={
"RIGHT","CENTRE","LEFT"}
;
tvtbl_entry Horizontal_justificationS18_Type[]={
0,"HORIZONTAL_JUSTIFICATION",&SCHEMA::env,0,(void*)455,0,lHorizontal_justificationS18_Type,(void*)3,0,0,0
}
;
Type*& gHorizontal_justificationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Horizontal_justificationS18_Type))->ref()),t->vtbl=Horizontal_justificationS18_Type,t);
}
static const char* lInterconnect_module_design_object_categoryS18_Type[]={
"INTERCONNECT_MODULE_VIA","INTERCONNECT_MODULE_INTER_STRATUM_FEATURE","INTERCONNECT_MODULE_CUTOUT","INTERCONNECT_MODULE_FILL_AREA","INTERCONNECT_MODULE_STRATUM_FEATURE"}
;
tvtbl_entry Interconnect_module_design_object_categoryS18_Type[]={
0,"INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY",&SCHEMA::env,0,(void*)463,0,lInterconnect_module_design_object_categoryS18_Type,(void*)5,0,0,0
}
;
Type*& gInterconnect_module_design_object_categoryS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Interconnect_module_design_object_categoryS18_Type))->ref()),t->vtbl=Interconnect_module_design_object_categoryS18_Type,t);
}
tvtbl_entry Template_selectS18_Type[]={
0,"TEMPLATE_SELECT",&SCHEMA::env,0,(void*)497,0,0,0,0,0,0
}
;
Type*& gTemplate_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Stratum_feature_templateS18_Impl),
Entity_Type::get(Material_addition_feature_templateS18_Impl),
Entity_Type::get(Material_removal_feature_templateS18_Impl),0)->ref(),t)),t->vtbl=Template_selectS18_Type,t);
}
tvtbl_entry Terminal_or_inter_stratum_featureS18_Type[]={
0,"TERMINAL_OR_INTER_STRATUM_FEATURE",&SCHEMA::env,0,(void*)505,0,0,0,0,0,0
}
;
Type*& gTerminal_or_inter_stratum_featureS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Inter_stratum_featureS18_Impl),
Entity_Type::get(Embedded_component_terminalS18_Impl),
Entity_Type::get(Interconnect_module_macro_component_join_terminalS18_Impl),
Entity_Type::get(Interconnect_module_terminalS18_Impl),
Entity_Type::get(Printed_component_join_terminalS18_Impl),0)->ref(),t)),t->vtbl=Terminal_or_inter_stratum_featureS18_Type,t);
}
tvtbl_entry Interconnect_or_assembly_module_selectS18_Type[]={
0,"INTERCONNECT_OR_ASSEMBLY_MODULE_SELECT",&SCHEMA::env,0,(void*)517,0,0,0,0,0,0
}
;
Type*& gInterconnect_or_assembly_module_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Component_termination_passage_interface_terminalS18_Impl),
Entity_Type::get(Printed_connector_component_interface_terminalS18_Impl),
Entity_Type::get(Non_functional_land_interface_terminalS18_Impl),
Entity_Type::get(Land_interface_terminalS18_Impl),0)->ref(),t)),t->vtbl=Interconnect_or_assembly_module_selectS18_Type,t);
}
static const char* lKeepout_product_design_object_categoryS18_Type[]={
"ASSEMBLY_MODULE_ASSEMBLY_COMPONENT","ASSEMBLY_MODULE_COMPONENT_FEATURE","ASSEMBLY_EE_MATERIAL","INTERCONNECT_EE_MATERIAL","INTERCONNECT_MODULE_ASSEMBLY_COMPONENT","INTERCONNECT_MODULE_VIA","INTERCONNECT_MODULE_INTER_STRATUM_FEATURE","INTERCONNECT_MODULE_CUTOUT","INTERCONNECT_MODULE_FILL_AREA","INTERCONNECT_MODULE_LAMINATE_COMPONENT"
,"INTERCONNECT_MODULE_STRATUM_FEATURE"}
;
tvtbl_entry Keepout_product_design_object_categoryS18_Type[]={
0,"KEEPOUT_PRODUCT_DESIGN_OBJECT_CATEGORY",&SCHEMA::env,0,(void*)527,0,lKeepout_product_design_object_categoryS18_Type,(void*)11,0,0,0
}
;
Type*& gKeepout_product_design_object_categoryS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Keepout_product_design_object_categoryS18_Type))->ref()),t->vtbl=Keepout_product_design_object_categoryS18_Type,t);
}
static const char* lPredefined_keepout_purposeS18_Type[]={
"THERMAL","GENERIC_CLEARANCE","SHOCK","VIBRATION","ELECTROMAGNETIC_COMPATIBILITY"}
;
tvtbl_entry Predefined_keepout_purposeS18_Type[]={
0,"PREDEFINED_KEEPOUT_PURPOSE",&SCHEMA::env,0,(void*)1193,0,lPredefined_keepout_purposeS18_Type,(void*)5,0,0,
Keepout_purposeS18_Type,0
}
;
Type*& gPredefined_keepout_purposeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Predefined_keepout_purposeS18_Type))->ref()),t->vtbl=Predefined_keepout_purposeS18_Type,t);
}
tvtbl_entry Keepout_purposeS18_Type[]={
0,"KEEPOUT_PURPOSE",&SCHEMA::env,0,(void*)551,0,0,0,0,0,0
}
;
Type*& gKeepout_purposeS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gPredefined_keepout_purposeS18_Type(),
Entity_Type::get(External_definitionS18_Impl),0)->ref(),t)),t->vtbl=Keepout_purposeS18_Type,t);
}
static const char* lLand_template_terminal_classS18_Type[]={
"SURFACE_POINT_CLASS","EDGE_CURVE_CLASS","EDGE_POINT_CLASS","SURFACE_AREA_CLASS"}
;
tvtbl_entry Land_template_terminal_classS18_Type[]={
0,"LAND_TEMPLATE_TERMINAL_CLASS",&SCHEMA::env,0,(void*)560,0,lLand_template_terminal_classS18_Type,(void*)4,0,0,0
}
;
Type*& gLand_template_terminal_classS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Land_template_terminal_classS18_Type))->ref()),t->vtbl=Land_template_terminal_classS18_Type,t);
}
static const char* lLayer_position_typeS18_Type[]={
"SECONDARY","ALL","EXTERNAL","PRIMARY","INTERNAL"}
;
tvtbl_entry Layer_position_typeS18_Type[]={
0,"LAYER_POSITION_TYPE",&SCHEMA::env,0,(void*)570,0,lLayer_position_typeS18_Type,(void*)5,0,0,0
}
;
Type*& gLayer_position_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Layer_position_typeS18_Type))->ref()),t->vtbl=Layer_position_typeS18_Type,t);
}
static const char* lLayer_purposeS18_Type[]={
"OTHER_SIGNAL","LANDS_ONLY","POWER_OR_GROUND"}
;
tvtbl_entry Layer_purposeS18_Type[]={
0,"LAYER_PURPOSE",&SCHEMA::env,0,(void*)582,0,lLayer_purposeS18_Type,(void*)3,0,0,0
}
;
Type*& gLayer_purposeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Layer_purposeS18_Type))->ref()),t->vtbl=Layer_purposeS18_Type,t);
}
static const char* lPredefined_lead_formS18_Type[]={
"GULL_WING","J_LEAD","REVERSED_J_LEAD","INTEGRAL_TERMINAL","UNDEFINED","BALL","STRAIGHT"}
;
tvtbl_entry Predefined_lead_formS18_Type[]={
0,"PREDEFINED_LEAD_FORM",&SCHEMA::env,0,(void*)1177,0,lPredefined_lead_formS18_Type,(void*)7,0,0,
Lead_form_typeS18_Type,0
}
;
Type*& gPredefined_lead_formS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Predefined_lead_formS18_Type))->ref()),t->vtbl=Predefined_lead_formS18_Type,t);
}
tvtbl_entry Lead_form_typeS18_Type[]={
0,"LEAD_FORM_TYPE",&SCHEMA::env,0,(void*)590,0,0,0,0,0,0
}
;
Type*& gLead_form_typeS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gPredefined_lead_formS18_Type(),
Entity_Type::get(External_definitionS18_Impl),0)->ref(),t)),t->vtbl=Lead_form_typeS18_Type,t);
}
static const char* lLife_cycle_stageS18_Type[]={
"CONCEPTUAL_DESIGN","FINAL_DESIGN","DETAILED_DESIGN","PRELIMINARY_DESIGN"}
;
tvtbl_entry Life_cycle_stageS18_Type[]={
0,"LIFE_CYCLE_STAGE",&SCHEMA::env,0,(void*)596,0,lLife_cycle_stageS18_Type,(void*)4,0,0,0
}
;
Type*& gLife_cycle_stageS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Life_cycle_stageS18_Type))->ref()),t->vtbl=Life_cycle_stageS18_Type,t);
}
tvtbl_entry Locating_or_refinement_linear_profile_toleranceS18_Type[]={
0,"LOCATING_OR_REFINEMENT_LINEAR_PROFILE_TOLERANCE",&SCHEMA::env,0,(void*)609,0,0,0,0,0,0
}
;
Type*& gLocating_or_refinement_linear_profile_toleranceS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Composite_linear_profile_locating_toleranceS18_Impl),
Entity_Type::get(Composite_linear_profile_refinement_toleranceS18_Impl),0)->ref(),t)),t->vtbl=Locating_or_refinement_linear_profile_toleranceS18_Type,t);
}
tvtbl_entry Locating_or_refinement_surface_profile_toleranceS18_Type[]={
0,"LOCATING_OR_REFINEMENT_SURFACE_PROFILE_TOLERANCE",&SCHEMA::env,0,(void*)615,0,0,0,0,0,0
}
;
Type*& gLocating_or_refinement_surface_profile_toleranceS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Composite_surface_profile_locating_toleranceS18_Impl),
Entity_Type::get(Composite_surface_profile_refinement_toleranceS18_Impl),0)->ref(),t)),t->vtbl=Locating_or_refinement_surface_profile_toleranceS18_Type,t);
}
tvtbl_entry Locating_or_relating_position_toleranceS18_Type[]={
0,"LOCATING_OR_RELATING_POSITION_TOLERANCE",&SCHEMA::env,0,(void*)621,0,0,0,0,0,0
}
;
Type*& gLocating_or_relating_position_toleranceS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Composite_feature_locating_position_toleranceS18_Impl),
Entity_Type::get(Composite_feature_relating_position_toleranceS18_Impl),0)->ref(),t)),t->vtbl=Locating_or_relating_position_toleranceS18_Type,t);
}
tvtbl_entry Markable_itemS18_Type[]={
0,"MARKABLE_ITEM",&SCHEMA::env,0,(void*)630,0,0,0,0,0,0
}
;
Type*& gMarkable_itemS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Assembly_moduleS18_Impl),
Entity_Type::get(Bare_dieS18_Impl),
Entity_Type::get(Interconnect_moduleS18_Impl),
Entity_Type::get(PackageS18_Impl),
Entity_Type::get(PcaS18_Impl),
Entity_Type::get(PcbS18_Impl),
Entity_Type::get(Packaged_partS18_Impl),0)->ref(),t)),t->vtbl=Markable_itemS18_Type,t);
}
tvtbl_entry Marked_message_selectS18_Type[]={
0,"MARKED_MESSAGE_SELECT",&SCHEMA::env,0,(void*)646,0,0,0,0,0,0
}
;
Type*& gMarked_message_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Configuration_controlled_messageS18_Impl),
Entity_Type::get(Ee_textS18_Impl),0)->ref(),t)),t->vtbl=Marked_message_selectS18_Type,t);
}
static const char* lMass_property_qualityS18_Type[]={
"HIGH","MEDIUM","LOW","IS_UNKNOWN"}
;
tvtbl_entry Mass_property_qualityS18_Type[]={
0,"MASS_PROPERTY_QUALITY",&SCHEMA::env,0,(void*)652,0,lMass_property_qualityS18_Type,(void*)4,0,0,0
}
;
Type*& gMass_property_qualityS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Mass_property_qualityS18_Type))->ref()),t->vtbl=Mass_property_qualityS18_Type,t);
}
static const char* lMaterial_conditionS18_Type[]={
"NOMINAL_MATERIAL_CONDITION","MINIMUM_MATERIAL_CONDITION","MAXIMUM_MATERIAL_CONDITION"}
;
tvtbl_entry Material_conditionS18_Type[]={
0,"MATERIAL_CONDITION",&SCHEMA::env,0,(void*)662,0,lMaterial_conditionS18_Type,(void*)3,0,0,0
}
;
Type*& gMaterial_conditionS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Material_conditionS18_Type))->ref()),t->vtbl=Material_conditionS18_Type,t);
}
static const char* lMaterial_condition_property_namesS18_Type[]={
"MAXIMUM_MATERIAL_PRINCIPLE","LEAST_MATERIAL_REQUIREMENT"}
;
tvtbl_entry Material_condition_property_namesS18_Type[]={
0,"MATERIAL_CONDITION_PROPERTY_NAMES",&SCHEMA::env,0,(void*)670,0,lMaterial_condition_property_namesS18_Type,(void*)2,0,0,0
}
;
Type*& gMaterial_condition_property_namesS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Material_condition_property_namesS18_Type))->ref()),t->vtbl=Material_condition_property_namesS18_Type,t);
}
static const char* lMaterial_conductivity_classificationS18_Type[]={
"CONDUCTIVE","RESISTIVE","SEMI_CONDUCTIVE","NON_CONDUCTIVE"}
;
tvtbl_entry Material_conductivity_classificationS18_Type[]={
0,"MATERIAL_CONDUCTIVITY_CLASSIFICATION",&SCHEMA::env,0,(void*)676,0,lMaterial_conductivity_classificationS18_Type,(void*)4,0,0,0
}
;
Type*& gMaterial_conductivity_classificationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Material_conductivity_classificationS18_Type))->ref()),t->vtbl=Material_conductivity_classificationS18_Type,t);
}
static const char* lMaterial_state_change_enumerationS18_Type[]={
"MATERIAL_ADDITION","MATERIAL_REMOVAL"}
;
tvtbl_entry Material_state_change_enumerationS18_Type[]={
0,"MATERIAL_STATE_CHANGE_ENUMERATION",&SCHEMA::env,0,(void*)686,0,lMaterial_state_change_enumerationS18_Type,(void*)2,0,0,0
}
;
Type*& gMaterial_state_change_enumerationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Material_state_change_enumerationS18_Type))->ref()),t->vtbl=Material_state_change_enumerationS18_Type,t);
}
tvtbl_entry Material_or_specificationS18_Type[]={
0,"MATERIAL_OR_SPECIFICATION",&SCHEMA::env,0,(void*)692,0,0,0,0,0,0
}
;
Type*& gMaterial_or_specificationS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Ee_requirement_occurrenceS18_Impl),
Entity_Type::get(Ee_materialS18_Impl),0)->ref(),t)),t->vtbl=Material_or_specificationS18_Type,t);
}
tvtbl_entry Mating_connector_partS18_Type[]={
0,"MATING_CONNECTOR_PART",&SCHEMA::env,0,(void*)698,0,0,0,0,0,0
}
;
Type*& gMating_connector_partS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Ee_specificationS18_Impl),
Entity_Type::get(Printed_connector_templateS18_Impl),
Entity_Type::get(Packaged_connectorS18_Impl),0)->ref(),t)),t->vtbl=Mating_connector_partS18_Type,t);
}
tvtbl_entry Message_contentS18_Type[]={
0,"MESSAGE_CONTENT",&SCHEMA::env,0,(void*)712,0,0,0,0,0,0
}
;
Type*& gMessage_contentS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new String_Type())->ref()
#undef local
),t->vtbl=Message_contentS18_Type,t);
}
tvtbl_entry Message_source_selectS18_Type[]={
0,"MESSAGE_SOURCE_SELECT",&SCHEMA::env,0,(void*)715,0,0,0,0,0,0
}
;
Type*& gMessage_source_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(OrganizationS18_Impl),
Entity_Type::get(Ee_approvalS18_Impl),
Entity_Type::get(Ee_product_versionS18_Impl),0)->ref(),t)),t->vtbl=Message_source_selectS18_Type,t);
}
static const char* lMessage_typeS18_Type[]={
"PART_NUMBER","MANUFACTURER_CODE","REVISION_IDENTIFIER","APPROVAL_DATE"}
;
tvtbl_entry Message_typeS18_Type[]={
0,"MESSAGE_TYPE",&SCHEMA::env,0,(void*)723,0,lMessage_typeS18_Type,(void*)4,0,0,0
}
;
Type*& gMessage_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Message_typeS18_Type))->ref()),t->vtbl=Message_typeS18_Type,t);
}
static const char* lMetal_or_dielectricS18_Type[]={
"OVER_FINISHED_CONDUCTOR","OVER_FINISHED_DIELECTRIC"}
;
tvtbl_entry Metal_or_dielectricS18_Type[]={
0,"METAL_OR_DIELECTRIC",&SCHEMA::env,0,(void*)733,0,lMetal_or_dielectricS18_Type,(void*)2,0,0,0
}
;
Type*& gMetal_or_dielectricS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Metal_or_dielectricS18_Type))->ref()),t->vtbl=Metal_or_dielectricS18_Type,t);
}
static const char* lModel_parameter_typeS18_Type[]={
"STRING_PROPERTY_TYPE","BOOLEAN_PROPERTY_TYPE","LOGICAL_PROPERTY_TYPE","NUMERIC_PROPERTY_TYPE","PHYSICAL_PROPERTY_TYPE"}
;
tvtbl_entry Model_parameter_typeS18_Type[]={
0,"MODEL_PARAMETER_TYPE",&SCHEMA::env,0,(void*)739,0,lModel_parameter_typeS18_Type,(void*)5,0,0,0
}
;
Type*& gModel_parameter_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Model_parameter_typeS18_Type))->ref()),t->vtbl=Model_parameter_typeS18_Type,t);
}
tvtbl_entry Month_representationS18_Type[]={
0,"MONTH_REPRESENTATION",&SCHEMA::env,0,(void*)751,0,0,0,0,0,0
}
;
Type*& gMonth_representationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new Integer_Type)->ref()
#undef local
),t->vtbl=Month_representationS18_Type,t);
}
static const char* lMounting_technology_typeS18_Type[]={
"SURFACE_MOUNT","THROUGH_HOLE"}
;
tvtbl_entry Mounting_technology_typeS18_Type[]={
0,"MOUNTING_TECHNOLOGY_TYPE",&SCHEMA::env,0,(void*)754,0,lMounting_technology_typeS18_Type,(void*)2,0,0,0
}
;
Type*& gMounting_technology_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Mounting_technology_typeS18_Type))->ref()),t->vtbl=Mounting_technology_typeS18_Type,t);
}
tvtbl_entry NomenclatureS18_Type[]={
0,"NOMENCLATURE",&SCHEMA::env,0,(void*)760,0,0,0,0,0,0
}
;
Type*& gNomenclatureS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new List_Type(String_Type::get(),1, -2))->ref()
#undef local
),t->vtbl=NomenclatureS18_Type,t);
}
static const char* lOffset_typesS18_Type[]={
"TOWARDS_MATERIAL","AWAY_FROM_MATERIAL"}
;
tvtbl_entry Offset_typesS18_Type[]={
0,"OFFSET_TYPES",&SCHEMA::env,0,(void*)781,0,lOffset_typesS18_Type,(void*)2,0,0,0
}
;
Type*& gOffset_typesS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Offset_typesS18_Type))->ref()),t->vtbl=Offset_typesS18_Type,t);
}
tvtbl_entry Open_shell_or_subsurfaceS18_Type[]={
0,"OPEN_SHELL_OR_SUBSURFACE",&SCHEMA::env,0,(void*)787,0,0,0,0,0,0
}
;
Type*& gOpen_shell_or_subsurfaceS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Open_shell_based_surfaceS18_Impl),
Entity_Type::get(Manifold_subsurface_shapeS18_Impl),0)->ref(),t)),t->vtbl=Open_shell_or_subsurfaceS18_Type,t);
}
tvtbl_entry Orientation_selectS18_Type[]={
0,"ORIENTATION_SELECT",&SCHEMA::env,0,(void*)793,0,0,0,0,0,0
}
;
Type*& gOrientation_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Datum_axis_related_orientationS18_Impl),
Entity_Type::get(Viewing_plane_based_orientationS18_Impl),
Entity_Type::get(Datum_based_vector_orientationS18_Impl),0)->ref(),t)),t->vtbl=Orientation_selectS18_Type,t);
}
static const char* lOrientation_typeS18_Type[]={
"PARALLEL","UNDEFINED","PERPENDICULAR"}
;
tvtbl_entry Orientation_typeS18_Type[]={
0,"ORIENTATION_TYPE",&SCHEMA::env,0,(void*)801,0,lOrientation_typeS18_Type,(void*)3,0,0,0
}
;
Type*& gOrientation_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Orientation_typeS18_Type))->ref()),t->vtbl=Orientation_typeS18_Type,t);
}
tvtbl_entry Package_or_package_external_referenceS18_Type[]={
0,"PACKAGE_OR_PACKAGE_EXTERNAL_REFERENCE",&SCHEMA::env,0,(void*)809,0,0,0,0,0,0
}
;
Type*& gPackage_or_package_external_referenceS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(PackageS18_Impl),
Entity_Type::get(Package_external_referenceS18_Impl),0)->ref(),t)),t->vtbl=Package_or_package_external_referenceS18_Type,t);
}
tvtbl_entry Package_terminal_or_package_terminal_external_referenceS18_Type[]={
0,"PACKAGE_TERMINAL_OR_PACKAGE_TERMINAL_EXTERNAL_REFERENCE",&SCHEMA::env,0,(void*)815,0,0,0,0,0,0
}
;
Type*& gPackage_terminal_or_package_terminal_external_referenceS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Package_terminalS18_Impl),
Entity_Type::get(Package_terminal_external_referenceS18_Impl),0)->ref(),t)),t->vtbl=Package_terminal_or_package_terminal_external_referenceS18_Type,t);
}
tvtbl_entry Packaged_or_printed_terminalS18_Type[]={
0,"PACKAGED_OR_PRINTED_TERMINAL",&SCHEMA::env,0,(void*)821,0,0,0,0,0,0
}
;
Type*& gPackaged_or_printed_terminalS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Packaged_part_terminalS18_Impl),
Entity_Type::get(Printed_part_template_terminalS18_Impl),0)->ref(),t)),t->vtbl=Packaged_or_printed_terminalS18_Type,t);
}
static const char* lPadstack_arrangementS18_Type[]={
"TOP","BOTTOM","SYMMETRICAL"}
;
tvtbl_entry Padstack_arrangementS18_Type[]={
0,"PADSTACK_ARRANGEMENT",&SCHEMA::env,0,(void*)827,0,lPadstack_arrangementS18_Type,(void*)3,0,0,0
}
;
Type*& gPadstack_arrangementS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Padstack_arrangementS18_Type))->ref()),t->vtbl=Padstack_arrangementS18_Type,t);
}
tvtbl_entry Part_feature_or_template_featureS18_Type[]={
0,"PART_FEATURE_OR_TEMPLATE_FEATURE",&SCHEMA::env,0,(void*)835,0,0,0,0,0,0
}
;
Type*& gPart_feature_or_template_featureS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Land_template_terminalS18_Impl),
Entity_Type::get(Component_termination_passage_template_terminalS18_Impl),
Entity_Type::get(Part_featureS18_Impl),
Entity_Type::get(Printed_part_template_terminalS18_Impl),
Entity_Type::get(Part_terminal_external_referenceS18_Impl),
Entity_Type::get(Via_template_terminalS18_Impl),0)->ref(),t)),t->vtbl=Part_feature_or_template_featureS18_Type,t);
}
tvtbl_entry Parameter_assignment_or_rule_general_clauseS18_Type[]={
0,"PARAMETER_ASSIGNMENT_OR_RULE_GENERAL_CLAUSE",&SCHEMA::env,0,(void*)869,0,0,0,0,0,0
}
;
Type*& gParameter_assignment_or_rule_general_clauseS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Parameter_assignmentS18_Impl),
Entity_Type::get(Rule_general_clauseS18_Impl),0)->ref(),t)),t->vtbl=Parameter_assignment_or_rule_general_clauseS18_Type,t);
}
tvtbl_entry Pca_interface_selectS18_Type[]={
0,"PCA_INTERFACE_SELECT",&SCHEMA::env,0,(void*)875,0,0,0,0,0,0
}
;
Type*& gPca_interface_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Interconnect_module_component_terminalS18_Impl),
Entity_Type::get(Component_interface_terminalS18_Impl),
Entity_Type::get(Assembly_module_component_terminalS18_Impl),0)->ref(),t)),t->vtbl=Pca_interface_selectS18_Type,t);
}
static const char* lPca_product_design_object_categoryS18_Type[]={
"ASSEMBLY_COMPONENT_CATEGORY","ASSEMBLY_MODULE_CATEGORY","ASSEMBLY_MODULE_COMPONENT_CATEGORY","ASSEMBLY_MODULE_COMPONENT_TERMINAL_CATEGORY","ASSEMBLY_MODULE_MACRO_COMPONENT_CATEGORY","ASSEMBLY_MODULE_MACRO_COMPONENT_JOIN_TERMINAL_CATEGORY","BARE_DIE_COMPONENT_CATEGORY","BARE_DIE_COMPONENT_TERMINAL_CATEGORY","BONDED_CONDUCTIVE_BASE_BLIND_VIA_CATEGORY","BURIED_VIA_CATEGORY"
,"CABLE_COMPONENT_CATEGORY","COMPONENT_FEATURE_CATEGORY","COMPONENT_MOUNTING_FEATURE_CATEGORY","COMPONENT_TERMINATION_PASSAGE_CATEGORY","COMPONENT_TERMINATION_PASSAGE_AND_CONTACT_SIZE_DEPENDENT_LAND_CATEGORY","COMPONENT_TERMINATION_PASSAGE_AND_CONTACT_SIZE_DEPENDENT_NON_FUNCTIONAL_LAND_CATEGORY","COMPONENT_TERMINATION_PASSAGE_DEPENDENT_LAND_CATEGORY","COMPONENT_TERMINATION_PASSAGE_DEPENDENT_NON_FUNCTIONAL_LAND_CATEGORY","COMPONENT_TERMINATION_PASSAGE_INTERFACE_TERMINAL_CATEGORY","COMPONENT_TERMINATION_PASSAGE_JOIN_TERMINAL_CATEGORY"
,"CONDUCTIVE_INTERCONNECT_ELEMENT_TERMINAL_CATEGORY","CONDUCTIVE_INTERCONNECT_ELEMENT_WITH_PRE_DEFINED_TRANSITIONS_CATEGORY","CONDUCTIVE_INTERCONNECT_ELEMENT_WITH_USER_DEFINED_SINGLE_TRANSITION_CATEGORY","CONNECTED_AREA_COMPONENT_CATEGORY","CONTACT_SIZE_DEPENDENT_LAND_CATEGORY","CONTACT_SIZE_DEPENDENT_NON_FUNCTIONAL_LAND_CATEGORY","CUTOUT_CATEGORY","CUTOUT_EDGE_SEGMENT_CATEGORY","DIELECTRIC_MATERIAL_PASSAGE_CATEGORY","ELECTRICAL_ISOLATION_LAMINATE_COMPONENT_CATEGORY"
,"EMBEDDED_COMPONENT_TERMINAL_CATEGORY","FIDUCIAL_CATEGORY","FILL_AREA_CATEGORY","FILLED_AREA_MATERIAL_REMOVAL_LAMINATE_COMPONENT_CATEGORY","INTER_STRATUM_FEATURE_CATEGORY","INTERCONNECT_COMPONENT_INTERFACE_TERMINAL_CATEGORY","INTERCONNECT_COMPONENT_JOIN_TERMINAL_CATEGORY","INTERCONNECT_MODULE_COMPONENT_CATEGORY","INTERCONNECT_MODULE_COMPONENT_STRATUM_BASED_TERMINAL_CATEGORY","INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE_CATEGORY"
,"INTERCONNECT_MODULE_COMPONENT_TERMINAL_CATEGORY","INTERCONNECT_MODULE_EDGE_CATEGORY","INTERCONNECT_MODULE_EDGE_SEGMENT_CATEGORY","INTERCONNECT_MODULE_MACRO_COMPONENT_CATEGORY","INTERCONNECT_MODULE_MACRO_COMPONENT_JOIN_TERMINAL_CATEGORY","INTERFACE_ACCESS_MATERIAL_REMOVAL_LAMINATE_COMPONENT_CATEGORY","INTERFACE_ACCESS_STRATUM_FEATURE_TEMPLATE_COMPONENT_CATEGORY","INTERFACE_COMPONENT_CATEGORY","INTERFACIAL_CONNECTION_CATEGORY","INTERNAL_PROBE_ACCESS_AREA_CATEGORY"
,"JOIN_TWO_PHYSICAL_CONNECTIVITY_DEFINITION_SUPPORTING_INTER_STRATUM_FEATURE_CATEGORY","JOIN_TWO_PHYSICAL_CONNECTIVITY_DEFINITION_SUPPORTING_PRINTED_COMPONENT_CATEGORY","LAMINATE_COMPONENT_CATEGORY","LAMINATE_TEXT_COMPONENT_CATEGORY","LAMINATE_TEXT_STRING_COMPONENT_CATEGORY","LAND_CATEGORY","LAND_INTERFACE_TERMINAL_CATEGORY","LAND_JOIN_TERMINAL_CATEGORY","MATERIAL_REMOVAL_LAMINATE_COMPONENT_CATEGORY","MINIMALLY_DEFINED_COMPONENT_TERMINAL_CATEGORY"
,"MOVABLE_PACKAGED_COMPONENT_JOIN_TERMINAL_CATEGORY","MULTI_LAYER_MATERIAL_REMOVAL_LAMINATE_COMPONENT_CATEGORY","MULTI_LAYER_STRATUM_FEATURE_TEMPLATE_COMPONENT_CATEGORY","NON_CONDUCTIVE_BASE_BLIND_VIA_CATEGORY","NON_FUNCTIONAL_LAND_CATEGORY","NON_FUNCTIONAL_LAND_INTERFACE_TERMINAL_CATEGORY","NON_FUNCTIONAL_LAND_JOIN_TERMINAL_CATEGORY","PACKAGED_COMPONENT_CATEGORY","PACKAGED_COMPONENT_JOIN_TERMINAL_CATEGORY","PACKAGED_CONNECTOR_COMPONENT_CATEGORY"
,"PACKAGED_CONNECTOR_COMPONENT_INTERFACE_TERMINAL_CATEGORY","PARTIALLY_PLATED_CUTOUT_CATEGORY","PARTIALLY_PLATED_INTERCONNECT_MODULE_EDGE_CATEGORY","PHYSICAL_COMPONENT_CATEGORY","PHYSICAL_CONNECTIVITY_INTERRUPTING_CUTOUT_CATEGORY","PHYSICAL_LAMINATE_COMPONENT_CATEGORY","PHYSICAL_NETWORK_SUPPORTING_INTER_STRATUM_FEATURE_CATEGORY","PLATED_CONDUCTIVE_BASE_BLIND_VIA_CATEGORY","PLATED_CUTOUT_CATEGORY","PLATED_CUTOUT_EDGE_SEGMENT_CATEGORY"
,"PLATED_INTERCONNECT_MODULE_EDGE_CATEGORY","PLATED_INTERCONNECT_MODULE_EDGE_SEGMENT_CATEGORY","PLATED_PASSAGE_CATEGORY","PLATED_PASSAGE_OR_UNSUPPORTED_PASSAGE_CATEGORY","PRIMARY_STRATUM_INDICATOR_SYMBOL_CATEGORY","PRINTED_COMPONENT_JOIN_TERMINAL_CATEGORY","PRINTED_CONNECTOR_COMPONENT_INTERFACE_TERMINAL_CATEGORY","PROBE_ACCESS_AREA_CATEGORY","ROUTED_INTERCONNECT_COMPONENT_CATEGORY","ROUTED_PHYSICAL_COMPONENT_CATEGORY"
,"SPECIAL_SYMBOL_LAMINATE_COMPONENT_CATEGORY","STRATUM_FEATURE_CATEGORY","STRATUM_FEATURE_TEMPLATE_COMPONENT_CATEGORY","THERMAL_ISOLATION_LAMINATE_COMPONENT_CATEGORY","UNROUTED_CONDUCTIVE_INTERCONNECT_ELEMENT_CATEGORY","UNSUPPORTED_PASSAGE_CATEGORY","UNSUPPORTED_PASSAGE_DEPENDENT_NON_FUNCTIONAL_LAND_CATEGORY","VIA_CATEGORY","VIA_AND_CONTACT_SIZE_DEPENDENT_LAND_CATEGORY","VIA_AND_CONTACT_SIZE_DEPENDENT_NON_FUNCTIONAL_LAND_CATEGORY"
,"VIA_DEPENDENT_LAND_CATEGORY","VIA_DEPENDENT_NON_FUNCTIONAL_LAND_CATEGORY","VIA_TERMINAL_CATEGORY"}
;
tvtbl_entry Pca_product_design_object_categoryS18_Type[]={
0,"PCA_PRODUCT_DESIGN_OBJECT_CATEGORY",&SCHEMA::env,0,(void*)883,0,lPca_product_design_object_categoryS18_Type,(void*)103,0,0,0
}
;
Type*& gPca_product_design_object_categoryS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Pca_product_design_object_categoryS18_Type))->ref()),t->vtbl=Pca_product_design_object_categoryS18_Type,t);
}
tvtbl_entry Person_organizationS18_Type[]={
0,"PERSON_ORGANIZATION",&SCHEMA::env,0,(void*)1091,0,0,0,0,0,0
}
;
Type*& gPerson_organizationS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Person_and_organizationS18_Impl),
Entity_Type::get(OrganizationS18_Impl),0)->ref(),t)),t->vtbl=Person_organizationS18_Type,t);
}
tvtbl_entry Physical_unit_or_part_templateS18_Type[]={
0,"PHYSICAL_UNIT_OR_PART_TEMPLATE",&SCHEMA::env,0,(void*)1097,0,0,0,0,0,0
}
;
Type*& gPhysical_unit_or_part_templateS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Part_templateS18_Impl),
Entity_Type::get(Physical_unitS18_Impl),0)->ref(),t)),t->vtbl=Physical_unit_or_part_templateS18_Type,t);
}
tvtbl_entry Physical_unit_or_part_template_or_fp_or_pdS18_Type[]={
0,"PHYSICAL_UNIT_OR_PART_TEMPLATE_OR_FP_OR_PD",&SCHEMA::env,0,(void*)1103,0,0,0,0,0,0
}
;
Type*& gPhysical_unit_or_part_template_or_fp_or_pdS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Part_templateS18_Impl),
Entity_Type::get(Physical_unitS18_Impl),
Entity_Type::get(Footprint_definitionS18_Impl),
Entity_Type::get(Padstack_definitionS18_Impl),0)->ref(),t)),t->vtbl=Physical_unit_or_part_template_or_fp_or_pdS18_Type,t);
}
tvtbl_entry Physical_unit_or_pundS18_Type[]={
0,"PHYSICAL_UNIT_OR_PUND",&SCHEMA::env,0,(void*)1113,0,0,0,0,0,0
}
;
Type*& gPhysical_unit_or_pundS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Physical_unit_network_definitionS18_Impl),
Entity_Type::get(Physical_unitS18_Impl),0)->ref(),t)),t->vtbl=Physical_unit_or_pundS18_Type,t);
}
tvtbl_entry Physical_unit_shape_selectS18_Type[]={
0,"PHYSICAL_UNIT_SHAPE_SELECT",&SCHEMA::env,0,(void*)1119,0,0,0,0,0,0
}
;
Type*& gPhysical_unit_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Physical_unit_3d_shapeS18_Impl),
Entity_Type::get(Physical_unit_planar_shapeS18_Impl),0)->ref(),t)),t->vtbl=Physical_unit_shape_selectS18_Type,t);
}
tvtbl_entry Placement_selectS18_Type[]={
0,"PLACEMENT_SELECT",&SCHEMA::env,0,(void*)1125,0,0,0,0,0,0
}
;
Type*& gPlacement_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Axis_placement_2dS18_Impl),
Entity_Type::get(Axis_placement_3dS18_Impl),0)->ref(),t)),t->vtbl=Placement_selectS18_Type,t);
}
static const char* lPredefined_planar_purposeS18_Type[]={
"ANALYSIS_INPUT","ANALYSIS_OUTPUT","SHOCK_ANALYSIS_INPUT","SHOCK_ANALYSIS_OUTPUT","ASSEMBLY_SYMBOL","DESIGN","DESIGN_PROFILE","VIBRATION_ANALYSIS_INPUT","VIBRATION_ANALYSIS_OUTPUT","ELECTROMAGNETIC_COMPATIBILITY_ANALYSIS_INPUT"
,"ELECTROMAGNETIC_COMPATIBILITY_ANALYSIS_OUTPUT","PHYSICAL_EXTENT","THERMAL_ANALYSIS_INPUT","THERMAL_ANALYSIS_OUTPUT"}
;
tvtbl_entry Predefined_planar_purposeS18_Type[]={
0,"PREDEFINED_PLANAR_PURPOSE",&SCHEMA::env,0,(void*)1205,0,lPredefined_planar_purposeS18_Type,(void*)14,0,0,
Planar_purposeS18_Type,0
}
;
Type*& gPredefined_planar_purposeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Predefined_planar_purposeS18_Type))->ref()),t->vtbl=Predefined_planar_purposeS18_Type,t);
}
tvtbl_entry Planar_purposeS18_Type[]={
0,"PLANAR_PURPOSE",&SCHEMA::env,0,(void*)1131,0,0,0,0,0,0
}
;
Type*& gPlanar_purposeS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gPredefined_planar_purposeS18_Type(),
Entity_Type::get(External_definitionS18_Impl),0)->ref(),t)),t->vtbl=Planar_purposeS18_Type,t);
}
tvtbl_entry Positive_integerS18_Type[]={
0,"POSITIVE_INTEGER",&SCHEMA::env,0,(void*)1137,0,0,0,0,0,0
}
;
Type*& gPositive_integerS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new Integer_Type)->ref()
#undef local
),t->vtbl=Positive_integerS18_Type,t);
}
tvtbl_entry Positive_ratio_measureS18_Type[]={
0,"POSITIVE_RATIO_MEASURE",&SCHEMA::env,0,(void*)1140,0,0,0,0,0,0
}
;
Type*& gPositive_ratio_measureS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new Real_Type())->ref()
#undef local
),t->vtbl=Positive_ratio_measureS18_Type,t);
}
static const char* lPrecedence_typeS18_Type[]={
"SECONDARY","TERTIARY","PRIMARY"}
;
tvtbl_entry Precedence_typeS18_Type[]={
0,"PRECEDENCE_TYPE",&SCHEMA::env,0,(void*)1143,0,lPrecedence_typeS18_Type,(void*)3,0,0,0
}
;
Type*& gPrecedence_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Precedence_typeS18_Type))->ref()),t->vtbl=Precedence_typeS18_Type,t);
}
static const char* lPredefined_3d_purposeS18_Type[]={
"ANALYSIS_INPUT","ANALYSIS_OUTPUT","SHOCK_ANALYSIS_INPUT","SHOCK_ANALYSIS_OUTPUT","DESIGN","VIBRATION_ANALYSIS_INPUT","VIBRATION_ANALYSIS_OUTPUT","ELECTROMAGNETIC_COMPATIBILITY_ANALYSIS_INPUT","ELECTROMAGNETIC_COMPATIBILITY_ANALYSIS_OUTPUT","THERMAL_ANALYSIS_INPUT"
,"THERMAL_ANALYSIS_OUTPUT"}
;
tvtbl_entry Predefined_3d_purposeS18_Type[]={
0,"PREDEFINED_3D_PURPOSE",&SCHEMA::env,0,(void*)1235,0,lPredefined_3d_purposeS18_Type,(void*)11,0,0,
Three_d_purposeS18_Type,0
}
;
Type*& gPredefined_3d_purposeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Predefined_3d_purposeS18_Type))->ref()),t->vtbl=Predefined_3d_purposeS18_Type,t);
}
tvtbl_entry Three_d_purposeS18_Type[]={
0,"THREE_D_PURPOSE",&SCHEMA::env,0,(void*)1579,0,0,0,0,0,0
}
;
Type*& gThree_d_purposeS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
gPredefined_3d_purposeS18_Type(),
Entity_Type::get(External_definitionS18_Impl),0)->ref(),t)),t->vtbl=Three_d_purposeS18_Type,t);
}
tvtbl_entry Printed_part_template_or_printed_part_cross_section_templateS18_Type[]={
0,"PRINTED_PART_TEMPLATE_OR_PRINTED_PART_CROSS_SECTION_TEMPLATE",&SCHEMA::env,0,(void*)1259,0,0,0,0,0,0
}
;
Type*& gPrinted_part_template_or_printed_part_cross_section_templateS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Printed_part_templateS18_Impl),
Entity_Type::get(Printed_part_cross_section_templateS18_Impl),0)->ref(),t)),t->vtbl=Printed_part_template_or_printed_part_cross_section_templateS18_Type,t);
}
static const char* lPrinted_part_template_terminal_classS18_Type[]={
"CURVE_EDGE_SEGMENT","SURFACE_POINT","AREA_EDGE_SEGMENT","SURFACE_AREA"}
;
tvtbl_entry Printed_part_template_terminal_classS18_Type[]={
0,"PRINTED_PART_TEMPLATE_TERMINAL_CLASS",&SCHEMA::env,0,(void*)1265,0,lPrinted_part_template_terminal_classS18_Type,(void*)4,0,0,0
}
;
Type*& gPrinted_part_template_terminal_classS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Printed_part_template_terminal_classS18_Type))->ref()),t->vtbl=Printed_part_template_terminal_classS18_Type,t);
}
static const char* lRange_classS18_Type[]={
"CLOSED","LOWER_OPEN","UPPER_OPEN","OPEN"}
;
tvtbl_entry Range_classS18_Type[]={
0,"RANGE_CLASS",&SCHEMA::env,0,(void*)1299,0,lRange_classS18_Type,(void*)4,0,0,0
}
;
Type*& gRange_classS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Range_classS18_Type))->ref()),t->vtbl=Range_classS18_Type,t);
}
static const char* lRelationship_operationS18_Type[]={
"AND_OPERATION","DERIVED_FROM","OR_OPERATION"}
;
tvtbl_entry Relationship_operationS18_Type[]={
0,"RELATIONSHIP_OPERATION",&SCHEMA::env,0,(void*)1309,0,lRelationship_operationS18_Type,(void*)3,0,0,0
}
;
Type*& gRelationship_operationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Relationship_operationS18_Type))->ref()),t->vtbl=Relationship_operationS18_Type,t);
}
tvtbl_entry Requirement_allocation_selectS18_Type[]={
0,"REQUIREMENT_ALLOCATION_SELECT",&SCHEMA::env,0,(void*)1317,0,0,0,0,0,0
}
;
Type*& gRequirement_allocation_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Assembly_requirement_allocationS18_Impl),
Entity_Type::get(Requirement_allocationS18_Impl),
Entity_Type::get(Functional_unit_requirement_allocationS18_Impl),0)->ref(),t)),t->vtbl=Requirement_allocation_selectS18_Type,t);
}
tvtbl_entry Restrained_item_selectS18_Type[]={
0,"RESTRAINED_ITEM_SELECT",&SCHEMA::env,0,(void*)1325,0,0,0,0,0,0
}
;
Type*& gRestrained_item_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Datum_feature_usage_in_datum_relationshipS18_Impl),
Entity_Type::get(Physical_feature_or_part_templateS18_Impl),0)->ref(),t)),t->vtbl=Restrained_item_selectS18_Type,t);
}
tvtbl_entry Rule_complex_or_simpleS18_Type[]={
0,"RULE_COMPLEX_OR_SIMPLE",&SCHEMA::env,0,(void*)1343,0,0,0,0,0,0
}
;
Type*& gRule_complex_or_simpleS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Rule_complex_clauseS18_Impl),
Entity_Type::get(Rule_simple_clauseS18_Impl),0)->ref(),t)),t->vtbl=Rule_complex_or_simpleS18_Type,t);
}
tvtbl_entry Scalar_or_coordinated_characteristicsS18_Type[]={
0,"SCALAR_OR_COORDINATED_CHARACTERISTICS",&SCHEMA::env,0,(void*)1349,0,0,0,0,0,0
}
;
Type*& gScalar_or_coordinated_characteristicsS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Coordinated_characteristicS18_Impl),
Entity_Type::get(CharacteristicS18_Impl),0)->ref(),t)),t->vtbl=Scalar_or_coordinated_characteristicsS18_Type,t);
}
static const char* lSeating_plane_intersection_typeS18_Type[]={
"SURFACE_INTERSECTION","THROUGH_INTERSECTION","DOES_NOT_INTERSECT"}
;
tvtbl_entry Seating_plane_intersection_typeS18_Type[]={
0,"SEATING_PLANE_INTERSECTION_TYPE",&SCHEMA::env,0,(void*)1355,0,lSeating_plane_intersection_typeS18_Type,(void*)3,0,0,0
}
;
Type*& gSeating_plane_intersection_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Seating_plane_intersection_typeS18_Type))->ref()),t->vtbl=Seating_plane_intersection_typeS18_Type,t);
}
static const char* lShape_approximation_levelS18_Type[]={
"COARSE","DETAILED","IS_UNKNOWN"}
;
tvtbl_entry Shape_approximation_levelS18_Type[]={
0,"SHAPE_APPROXIMATION_LEVEL",&SCHEMA::env,0,(void*)1366,0,lShape_approximation_levelS18_Type,(void*)3,0,0,0
}
;
Type*& gShape_approximation_levelS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Shape_approximation_levelS18_Type))->ref()),t->vtbl=Shape_approximation_levelS18_Type,t);
}
static const char* lShape_classS18_Type[]={
"EXTRUSION","MANHATTAN_BLOCK","OTHER","IS_UNKNOWN"}
;
tvtbl_entry Shape_classS18_Type[]={
0,"SHAPE_CLASS",&SCHEMA::env,0,(void*)1374,0,lShape_classS18_Type,(void*)4,0,0,0
}
;
Type*& gShape_classS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Shape_classS18_Type))->ref()),t->vtbl=Shape_classS18_Type,t);
}
static const char* lShape_extentS18_Type[]={
"ENVELOPE","OVER_BODY","OVER_LANDS","OVER_BREAKOUT"}
;
tvtbl_entry Shape_extentS18_Type[]={
0,"SHAPE_EXTENT",&SCHEMA::env,0,(void*)1384,0,lShape_extentS18_Type,(void*)4,0,0,0
}
;
Type*& gShape_extentS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Shape_extentS18_Type))->ref()),t->vtbl=Shape_extentS18_Type,t);
}
static const char* lShape_locationS18_Type[]={
"ABOVE","BELOW","CONGRUENT"}
;
tvtbl_entry Shape_locationS18_Type[]={
0,"SHAPE_LOCATION",&SCHEMA::env,0,(void*)1394,0,lShape_locationS18_Type,(void*)3,0,0,0
}
;
Type*& gShape_locationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Shape_locationS18_Type))->ref()),t->vtbl=Shape_locationS18_Type,t);
}
tvtbl_entry Shieldable_itemS18_Type[]={
0,"SHIELDABLE_ITEM",&SCHEMA::env,0,(void*)1402,0,0,0,0,0,0
}
;
Type*& gShieldable_itemS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Assembly_componentS18_Impl),
Entity_Type::get(Component_featureS18_Impl),
Entity_Type::get(Physical_connectivity_definitionS18_Impl),0)->ref(),t)),t->vtbl=Shieldable_itemS18_Type,t);
}
static const char* lSi_prefixS18_Type[]={
"EXA","PETA","TERA","GIGA","MEGA","KILO","HECTO","DECA","DECI","CENTI"
,"MILLI","MICRO","NANO","PICO","FEMTO","ATTO"}
;
tvtbl_entry Si_prefixS18_Type[]={
0,"SI_PREFIX",&SCHEMA::env,0,(void*)1410,0,lSi_prefixS18_Type,(void*)16,0,0,0
}
;
Type*& gSi_prefixS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Si_prefixS18_Type))->ref()),t->vtbl=Si_prefixS18_Type,t);
}
static const char* lSignal_flow_directionS18_Type[]={
"UNKNOWN_DIRECTION","NOT_APPLICABLE","OUTPUT_DIRECTION","INPUT_DIRECTION","BIDIRECTIONAL"}
;
tvtbl_entry Signal_flow_directionS18_Type[]={
0,"SIGNAL_FLOW_DIRECTION",&SCHEMA::env,0,(void*)1444,0,lSignal_flow_directionS18_Type,(void*)5,0,0,0
}
;
Type*& gSignal_flow_directionS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Signal_flow_directionS18_Type))->ref()),t->vtbl=Signal_flow_directionS18_Type,t);
}
static const char* lSquare_or_roundS18_Type[]={
"SQUARE","ROUND"}
;
tvtbl_entry Square_or_roundS18_Type[]={
0,"SQUARE_OR_ROUND",&SCHEMA::env,0,(void*)1456,0,lSquare_or_roundS18_Type,(void*)2,0,0,0
}
;
Type*& gSquare_or_roundS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Square_or_roundS18_Type))->ref()),t->vtbl=Square_or_roundS18_Type,t);
}
static const char* lSpacing_typeS18_Type[]={
"NEAREST_BOUNDARY","CENTROID","FURTHEST_BOUNDARY"}
;
tvtbl_entry Spacing_typeS18_Type[]={
0,"SPACING_TYPE",&SCHEMA::env,0,(void*)1462,0,lSpacing_typeS18_Type,(void*)3,0,0,0
}
;
Type*& gSpacing_typeS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Spacing_typeS18_Type))->ref()),t->vtbl=Spacing_typeS18_Type,t);
}
tvtbl_entry Standard_document_identification_stringS18_Type[]={
0,"STANDARD_DOCUMENT_IDENTIFICATION_STRING",&SCHEMA::env,0,(void*)1492,0,0,0,0,0,
Standard_or_reference_documentS18_Type,0
}
;
Type*& gStandard_document_identification_stringS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new String_Type())->ref()
#undef local
),t->vtbl=Standard_document_identification_stringS18_Type,t);
}
tvtbl_entry Standard_or_reference_documentS18_Type[]={
0,"STANDARD_OR_REFERENCE_DOCUMENT",&SCHEMA::env,0,(void*)1495,0,0,0,0,0,0
}
;
Type*& gStandard_or_reference_documentS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Ee_documentS18_Impl),
gStandard_document_identification_stringS18_Type(),0)->ref(),t)),t->vtbl=Standard_or_reference_documentS18_Type,t);
}
static const char* lStatusS18_Type[]={
"DISAPPROVED","WITHDRAWN","NOT_YET_APPROVED","APPROVED"}
;
tvtbl_entry StatusS18_Type[]={
0,"STATUS",&SCHEMA::env,0,(void*)1501,0,lStatusS18_Type,(void*)4,0,0,0
}
;
Type*& gStatusS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(StatusS18_Type))->ref()),t->vtbl=StatusS18_Type,t);
}
static const char* lStiffness_classS18_Type[]={
"FLUID_LIKE","CONFORMAL_COAT","STIFF_LAMINATE"}
;
tvtbl_entry Stiffness_classS18_Type[]={
0,"STIFFNESS_CLASS",&SCHEMA::env,0,(void*)1511,0,lStiffness_classS18_Type,(void*)3,0,0,0
}
;
Type*& gStiffness_classS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Stiffness_classS18_Type))->ref()),t->vtbl=Stiffness_classS18_Type,t);
}
tvtbl_entry Stratum_feature_3d_shape_selectS18_Type[]={
0,"STRATUM_FEATURE_3D_SHAPE_SELECT",&SCHEMA::env,0,(void*)1531,0,0,0,0,0,0
}
;
Type*& gStratum_feature_3d_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Stratum_feature_non_planar_2d_shapeS18_Impl),
Entity_Type::get(Stratum_feature_3d_shapeS18_Impl),0)->ref(),t)),t->vtbl=Stratum_feature_3d_shape_selectS18_Type,t);
}
tvtbl_entry Stratum_feature_planar_representation_selectS18_Type[]={
0,"STRATUM_FEATURE_PLANAR_REPRESENTATION_SELECT",&SCHEMA::env,0,(void*)1537,0,0,0,0,0,0
}
;
Type*& gStratum_feature_planar_representation_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Stratum_feature_styled_area_representationS18_Impl),
Entity_Type::get(Stratum_feature_planar_shapeS18_Impl),0)->ref(),t)),t->vtbl=Stratum_feature_planar_representation_selectS18_Type,t);
}
static const char* lStratum_surface_designationS18_Type[]={
"PRIMARY_SURFACE","SECONDARY_SURFACE"}
;
tvtbl_entry Stratum_surface_designationS18_Type[]={
0,"STRATUM_SURFACE_DESIGNATION",&SCHEMA::env,0,(void*)1543,0,lStratum_surface_designationS18_Type,(void*)2,0,0,0
}
;
Type*& gStratum_surface_designationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Stratum_surface_designationS18_Type))->ref()),t->vtbl=Stratum_surface_designationS18_Type,t);
}
tvtbl_entry Stratum_surface_shape_selectS18_Type[]={
0,"STRATUM_SURFACE_SHAPE_SELECT",&SCHEMA::env,0,(void*)1549,0,0,0,0,0,0
}
;
Type*& gStratum_surface_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Stratum_surface_shapeS18_Impl),
Entity_Type::get(Stratum_average_surface_shapeS18_Impl),0)->ref(),t)),t->vtbl=Stratum_surface_shape_selectS18_Type,t);
}
tvtbl_entry Styled_area_representationS18_Type[]={
0,"STYLED_AREA_REPRESENTATION",&SCHEMA::env,0,(void*)1558,0,0,0,0,0,0
}
;
Type*& gStyled_area_representationS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Fill_area_occurrenceS18_Impl),
Entity_Type::get(Styled_curve_occurrenceS18_Impl),0)->ref(),t)),t->vtbl=Styled_area_representationS18_Type,t);
}
tvtbl_entry Termination_or_junctionS18_Type[]={
0,"TERMINATION_OR_JUNCTION",&SCHEMA::env,0,(void*)1564,0,0,0,0,0,0
}
;
Type*& gTermination_or_junctionS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Component_terminalS18_Impl),
Entity_Type::get(Topological_junctionS18_Impl),0)->ref(),t)),t->vtbl=Termination_or_junctionS18_Type,t);
}
tvtbl_entry TextS18_Type[]={
0,"TEXT",&SCHEMA::env,0,(void*)1570,0,0,0,0,0,0
}
;
Type*& gTextS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=
#define local SCHEMA::env
(new String_Type())->ref()
#undef local
),t->vtbl=TextS18_Type,t);
}
tvtbl_entry Thermal_isolation_removal_structure_or_templateS18_Type[]={
0,"THERMAL_ISOLATION_REMOVAL_STRUCTURE_OR_TEMPLATE",&SCHEMA::env,0,(void*)1573,0,0,0,0,0,0
}
;
Type*& gThermal_isolation_removal_structure_or_templateS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Thermal_isolation_removal_structureS18_Impl),
Entity_Type::get(Thermal_isolation_removal_templateS18_Impl),0)->ref(),t)),t->vtbl=Thermal_isolation_removal_structure_or_templateS18_Type,t);
}
tvtbl_entry Toleranceable_shape_elementS18_Type[]={
0,"TOLERANCEABLE_SHAPE_ELEMENT",&SCHEMA::env,0,(void*)1585,0,0,0,0,0,0
}
;
Type*& gToleranceable_shape_elementS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Centre_axisS18_Impl),
Entity_Type::get(Centre_planeS18_Impl),
Entity_Type::get(Centre_pointS18_Impl),
Entity_Type::get(Tangent_planeS18_Impl),
Entity_Type::get(Physical_feature_or_part_templateS18_Impl),0)->ref(),t)),t->vtbl=Toleranceable_shape_elementS18_Type,t);
}
tvtbl_entry Trace_junction_or_viaS18_Type[]={
0,"TRACE_JUNCTION_OR_VIA",&SCHEMA::env,0,(void*)1597,0,0,0,0,0,0
}
;
Type*& gTrace_junction_or_viaS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Inter_stratum_join_relationshipS18_Impl),
Entity_Type::get(Explicitly_located_layer_connection_pointS18_Impl),0)->ref(),t)),t->vtbl=Trace_junction_or_viaS18_Type,t);
}
tvtbl_entry Trimmed_or_bounding_curveS18_Type[]={
0,"TRIMMED_OR_BOUNDING_CURVE",&SCHEMA::env,0,(void*)1603,0,0,0,0,0,0
}
;
Type*& gTrimmed_or_bounding_curveS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Bounding_curveS18_Impl),
Entity_Type::get(Trimmed_lineS18_Impl),0)->ref(),t)),t->vtbl=Trimmed_or_bounding_curveS18_Type,t);
}
tvtbl_entry True_profile_representationsS18_Type[]={
0,"TRUE_PROFILE_REPRESENTATIONS",&SCHEMA::env,0,(void*)1609,0,0,0,0,0,0
}
;
Type*& gTrue_profile_representationsS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Dimension_setS18_Impl),
Entity_Type::get(Ee_documentS18_Impl),
Entity_Type::get(Rule_functionS18_Impl),
Entity_Type::get(Bound_volume_shapeS18_Impl),0)->ref(),t)),t->vtbl=True_profile_representationsS18_Type,t);
}
static const char* lTwo_or_three_dimensionalS18_Type[]={
"THREE_DIMENSIONAL","TWO_DIMENSIONAL"}
;
tvtbl_entry Two_or_three_dimensionalS18_Type[]={
0,"TWO_OR_THREE_DIMENSIONAL",&SCHEMA::env,0,(void*)1619,0,lTwo_or_three_dimensionalS18_Type,(void*)2,0,0,0
}
;
Type*& gTwo_or_three_dimensionalS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Two_or_three_dimensionalS18_Type))->ref()),t->vtbl=Two_or_three_dimensionalS18_Type,t);
}
tvtbl_entry Usage_conceptS18_Type[]={
0,"USAGE_CONCEPT",&SCHEMA::env,0,(void*)1625,0,0,0,0,0,0
}
;
Type*& gUsage_conceptS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Land_template_terminalS18_Impl),
Entity_Type::get(Component_termination_passage_template_terminalS18_Impl),
Entity_Type::get(Via_template_terminalS18_Impl),
Entity_Type::get(Non_feature_shape_elementS18_Impl),
Entity_Type::get(Part_featureS18_Impl),
Entity_Type::get(Printed_part_template_terminalS18_Impl),0)->ref(),t)),t->vtbl=Usage_conceptS18_Type,t);
}
tvtbl_entry Usage_view_terminalS18_Type[]={
0,"USAGE_VIEW_TERMINAL",&SCHEMA::env,0,(void*)1639,0,0,0,0,0,0
}
;
Type*& gUsage_view_terminalS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Assembly_module_terminalS18_Impl),
Entity_Type::get(Bare_die_terminalS18_Impl),
Entity_Type::get(Component_termination_passage_template_terminalS18_Impl),
Entity_Type::get(Interconnect_module_terminalS18_Impl),
Entity_Type::get(Land_template_terminalS18_Impl),
Entity_Type::get(Package_terminalS18_Impl),
Entity_Type::get(Printed_part_template_terminalS18_Impl),
Entity_Type::get(Via_template_terminalS18_Impl),
Entity_Type::get(Part_mounting_featureS18_Impl),0)->ref(),t)),t->vtbl=Usage_view_terminalS18_Type,t);
}
tvtbl_entry Value_qualifierS18_Type[]={
0,"VALUE_QUALIFIER",&SCHEMA::env,0,(void*)1659,0,0,0,0,0,0
}
;
Type*& gValue_qualifierS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Precision_qualifierS18_Impl),
Entity_Type::get(Type_qualifierS18_Impl),
Entity_Type::get(Uncertainty_qualifierS18_Impl),0)->ref(),t)),t->vtbl=Value_qualifierS18_Type,t);
}
static const char* lVertical_justificationS18_Type[]={
"CENTRE","TOP","BOTTOM"}
;
tvtbl_entry Vertical_justificationS18_Type[]={
0,"VERTICAL_JUSTIFICATION",&SCHEMA::env,0,(void*)1667,0,lVertical_justificationS18_Type,(void*)3,0,0,0
}
;
Type*& gVertical_justificationS18_Type(short c) {
static Type* t;
return (t || !c ) ? t : ((t=(new Enumeration_Type(Vertical_justificationS18_Type))->ref()),t->vtbl=Vertical_justificationS18_Type,t);
}
tvtbl_entry View_shape_selectS18_Type[]={
0,"VIEW_SHAPE_SELECT",&SCHEMA::env,0,(void*)1675,0,0,0,0,0,0
}
;
Type*& gView_shape_selectS18_Type(short c) {
Select_Type* st;
static Type* t;
return (t || !c ) ? t : (((t=st=new Select_Type, st->init(0,
Entity_Type::get(Part_template_3d_shapeS18_Impl),
Entity_Type::get(Physical_unit_3d_shapeS18_Impl),
Entity_Type::get(Part_template_non_planar_2d_shapeS18_Impl),
Entity_Type::get(Part_template_planar_shapeS18_Impl),
Entity_Type::get(Physical_unit_planar_shapeS18_Impl),0)->ref(),t)),t->vtbl=View_shape_selectS18_Type,t);
}
EX_ALGORITHM Generic Add_data_elementS18(const Generic& par_ex_input1, const Generic& par_ex_input2, Env* env) {
ex_restore _res(9994);
Generic l[2];
EX_ENV local(l,env,2);
l[0].ct_init(Entity_Type::get(Length_data_elementS18_Impl), ExStd, "input1", par_ex_input1);
l[1].ct_init(Entity_Type::get(Length_data_elementS18_Impl), ExStd, "input2", par_ex_input2);
Generic result(Entity_Type::get(Length_data_elementS18_Impl),ExNoInit,"_result");
_SL(9999)
result.assign(l[0]);
goto lS18_10000_3;
lS18_10000_3: _SL(10000)
return result;
}
EX_ALGORITHM Generic Consistent_bus_structural_definitionS18(const Generic& par_ex_input, Env* env) {
ex_restore _res(10002);
Generic l[5];
EX_ENV local(l,env,5);
l[0].ct_init(new Set_Type(Entity_Type::get(Bus_element_linkS18_Impl),0, -2), ExStd, "input", par_ex_input);
_SL(10007)
l[1].ct_init(new Set_Type(Entity_Type::get(Managed_design_objectS18_Impl),0, -2),ExStd,"vertex",(const Generic*)0);
_SL(10008)
l[2].ct_init(Type::integer,ExStd,"edge",::SizeOf(l[0]));
_SL(10009)
l[3].ct_init(Type::integer,ExStd,"vc",const_zero);
_SL(10010)
l[4].ct_init(Type::integer,ExStd,"vertex_degree",const_zero);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10013)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[0]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10014)
env->l[1] += env->l[0].rindex(l[0]).attr(0,"precedent_element",0);
_SL(10015)
env->l[1] += env->l[0].rindex(l[0]).attr(0,"subsequent_element",0);
_SL(10013)
}
while (EX_TRUE);
}
}

_SL(10017)
l[3].assign(::SizeOf(l[1]));
_SL(10018)
if ((l[3].ne((l[2]+const_one))).get_long()==EX_TRUE) {
_SL(10019)
result.assign(ex_false);
goto lS18_10036_3;
}

_SL(10021)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = l[3].get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10022)
env->l[4].assign(const_zero);
_SL(10023)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(env->l[0]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"j", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10024)
if ((env->env->l[0].rindex(l[0]).attr(0,"precedent_element",0).eq(env->env->l[1].rindex(env->l[0]))).get_long()==EX_TRUE) {
_SL(10025)
env->env->l[4] += const_one;
}
_SL(10027)
if ((env->env->l[0].rindex(l[0]).attr(0,"subsequent_element",0).eq(env->env->l[1].rindex(env->l[0]))).get_long()==EX_TRUE) {
_SL(10028)
env->env->l[4] += const_one;
}
_SL(10023)
}
while (EX_TRUE);
}
}
_SL(10031)
if ((env->l[4].gt(const_two)).get_long()==EX_TRUE) {
_SL(10032)
result.assign(ex_false);
goto lS18_10036_3;
}
_SL(10021)
}
while (EX_TRUE);
}
}

_SL(10035)
result.assign(ex_true);
goto lS18_10036_3;
lS18_10036_3: _SL(10036)
return result;
}
EX_ALGORITHM Generic Consistent_stack_definitionS18(const Generic& par_ex_input1, const Generic& par_ex_input2, Env* env) {
ex_restore _res(10038);
Generic l[3];
EX_ENV local(l,env,3);
l[0].ct_init(Entity_Type::get(Printed_part_templateS18_Impl), ExStd, "input1", par_ex_input1);
l[1].ct_init(new Set_Type(Entity_Type::get(Printed_component_linkS18_Impl),0, -2), ExStd, "input2", par_ex_input2);
_SL(10044)
l[2].ct_init(Type::boolean,ExStd,"pass",ex_false);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10047)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[1]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10048)
env->l[2].assign((env->l[1].rindex(l[0]).attr(0,"definition",0).attr(0,"associated_printed_part_template",0).id(env->l[0])));
_SL(10047)
}
while (EX_TRUE);
}
}

_SL(10050)
result.assign(l[2]);
goto lS18_10051_3;
lS18_10051_3: _SL(10051)
return result;
}
EX_ALGORITHM Generic Correlated_terminalsS18(const Generic& par_ex_input1, const Generic& par_ex_input2, Env* env) {
ex_restore _res(10053);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(new Set_Type(Entity_Type::get(Conductive_interconnect_element_terminalS18_Impl),0, -2), ExStd, "input1", par_ex_input1);
l[1].ct_init(new Set_Type(Entity_Type::get(Conductive_interconnect_element_terminal_linkS18_Impl),0, -2), ExStd, "input2", par_ex_input2);
_SL(10059)
l[2].ct_init(Type::boolean,ExStd,"pass",ex_false);
_SL(10060)
l[3].ct_init(new Set_Type(Entity_Type::get(Conductive_interconnect_element_terminalS18_Impl),0, -2),ExStd,"ciet",(const Generic*)0);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10063)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[1]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10064)
env->l[3] += env->l[1].rindex(l[0]).attr(0,"precedent_point",0);
_SL(10065)
env->l[3] += env->l[1].rindex(l[0]).attr(0,"subsequent_point",0);
_SL(10063)
}
while (EX_TRUE);
}
}

_SL(10067)
l[2].assign((l[0].eq(l[3])));
_SL(10068)
result.assign(l[2]);
goto lS18_10069_3;
lS18_10069_3: _SL(10069)
return result;
}
EX_ALGORITHM Generic Derive_mirrorS18(const Generic& par_ex_cto2d, Env* env) {
ex_restore _res(10071);
Generic l[1];
EX_ENV local(l,env,1);
l[0].ct_init(Entity_Type::get(Cartesian_transformation_operator_2dS18_Impl), ExStd, "cto2d", par_ex_cto2d);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10075)
result.assign(ex_true);
goto lS18_10076_3;
lS18_10076_3: _SL(10076)
return result;
}
EX_ALGORITHM Generic Disjoint_package_terminalsS18(const Generic& par_ex_input, Env* env) {
ex_restore _res(10078);
Generic l[1];
EX_ENV local(l,env,1);
l[0].ct_init(Entity_Type::get(Packaged_part_terminalS18_Impl), ExStd, "input", par_ex_input);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10082)
result.assign(ex_true);
goto lS18_10083_3;
lS18_10083_3: _SL(10083)
return result;
}
EX_ALGORITHM Generic Get_citS18(const Generic& par_ex_ac, const Generic& par_ex_ajb, Env* env) {
ex_restore _res(10085);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(Entity_Type::get(Assembly_componentS18_Impl), ExStd, "ac", par_ex_ac);
l[1].ct_init(new Set_Type(Entity_Type::get(Assembly_jointS18_Impl),0, -2), ExStd, "ajb", par_ex_ajb);
_SL(10091)
l[2].ct_init(new List_Type(Entity_Type::get(Component_featureS18_Impl),1, -2),ExStd,"cf",(const Generic*)0);
_SL(10092)
l[3].ct_init(Entity_Type::get(Component_interface_terminalS18_Impl),ExStd,"cit",undef_value);
Generic result(Entity_Type::get(Component_interface_terminalS18_Impl),ExNoInit,"_result");
_SL(10095)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = const_two.get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10096)
env->l[2].lop(CmdAssign(env->l[1].rindex(const_one).attr(0,"assembly_features_1",0)),1,long(1));
_SL(10097)
env->l[2].lop(CmdAssign(env->l[1].rindex(const_one).attr(0,"assembly_features_2",0)),1,long(2));
_SL(10098)
if ((env->l[0].id(env->l[2].rindex(l[0]).attr(0,"associated_component",0))).get_long()==EX_TRUE) {
_SL(10099)
if ((SLIT("AP210_ARM.INTERFACE_COMPONENT").In(::TypeOf(env->l[2].rindex(l[0]).attr(0,"associated_component",0)))).get_long()==EX_TRUE) {
_SL(10100)
result.assign(env->l[2].rindex(l[0]));
goto lS18_10109_3;
}
else {
_SL(10102)
result.assign(undef_value);
goto lS18_10109_3;
}
}
else {
_SL(10105)
result.assign(undef_value);
goto lS18_10109_3;
}
_SL(10095)
}
while (EX_TRUE);
}
}

_SL(10108)
result.assign(undef_value);
goto lS18_10109_3;
lS18_10109_3: _SL(10109)
return result;
}
EX_ALGORITHM Generic Get_cosS18(const Generic& par_ex_sd, Env* env) {
ex_restore _res(10111);
Generic l[2];
EX_ENV local(l,env,2);
l[0].ct_init(new Set_Type(Entity_Type::get(Shape_definitionS18_Impl),0, -2), ExStd, "sd", par_ex_sd);
_SL(10116)
l[1].ct_init(new Set_Type(Entity_Type::get(Cartesian_coordinate_systemS18_Impl),0, -2),ExStd,"gc",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Cartesian_coordinate_systemS18_Impl),0, -2),ExNoInit,"_result");
_SL(10119)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[0]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10120)
env->l[1] += env->l[0].rindex(l[0]).attr(0,"geometric_context",0);
_SL(10119)
}
while (EX_TRUE);
}
}

_SL(10122)
result.assign(l[1]);
goto lS18_10123_3;
lS18_10123_3: _SL(10123)
return result;
}
EX_ALGORITHM Generic Get_pctdS18(const Generic& par_ex_ac, const Generic& par_ex_ajb, Env* env) {
ex_restore _res(10125);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(Entity_Type::get(Assembly_componentS18_Impl), ExStd, "ac", par_ex_ac);
l[1].ct_init(new Set_Type(Entity_Type::get(Assembly_jointS18_Impl),0, -2), ExStd, "ajb", par_ex_ajb);
_SL(10131)
l[2].ct_init(new List_Type(Entity_Type::get(Component_featureS18_Impl),1, -2),ExStd,"cf",undef_value);
_SL(10132)
l[3].ct_init(new Set_Type(Entity_Type::get(Part_connected_terminals_definitionS18_Impl),0, -2),ExStd,"pctd",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Part_connected_terminals_definitionS18_Impl),0, -2),ExNoInit,"_result");
_SL(10135)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = const_two.get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10136)
env->l[2].lop(CmdAssign(env->l[1].rindex(const_one).attr(0,"assembly_features_1",0)),1,long(1));
_SL(10137)
env->l[2].lop(CmdAssign(env->l[1].rindex(const_one).attr(0,"assembly_features_2",0)),1,long(2));
_SL(10138)
if ((env->l[0].id(env->l[2].rindex(l[0]).attr(0,"associated_component",0))).get_long()==EX_TRUE) {
_SL(10139)
if ((SLIT("AP210_ARM.PART_TERMINAL").In(::TypeOf(env->l[2].rindex(l[0]).attr(0,"definition",0)))).get_long()==EX_TRUE) {
_SL(10140)
env->l[3].assign(env->l[2].rindex(l[0]).attr(0,"definition",0).attr(0,"connection_requirement",0));
_SL(10141)
result.assign(env->l[3]);
goto lS18_10150_3;
}
else {
_SL(10143)
result.assign(env->l[3]);
goto lS18_10150_3;
}
}
else {
_SL(10146)
result.assign(env->l[3]);
goto lS18_10150_3;
}
_SL(10135)
}
while (EX_TRUE);
}
}

_SL(10149)
result.assign(undef_value);
goto lS18_10150_3;
lS18_10150_3: _SL(10150)
return result;
}
EX_ALGORITHM Generic Get_pctrS18(const Generic& par_ex_ac, const Generic& par_ex_imjb, Env* env) {
ex_restore _res(10152);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(Entity_Type::get(Assembly_componentS18_Impl), ExStd, "ac", par_ex_ac);
l[1].ct_init(new Set_Type(Entity_Type::get(Interface_mounted_joinS18_Impl),0, -2), ExStd, "imjb", par_ex_imjb);
_SL(10158)
l[2].ct_init(Entity_Type::get(Component_featureS18_Impl),ExStd,"cf",undef_value);
_SL(10159)
l[3].ct_init(new Set_Type(Entity_Type::get(Packaged_connector_terminal_relationshipS18_Impl),0, -2),ExStd,"pctr",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Packaged_connector_terminal_relationshipS18_Impl),0, -2),ExNoInit,"_result");
_SL(10162)
l[2].assign(l[1].rindex(const_one).attr(0,"connection_to_interconnect_module_component",0));
_SL(10163)
if ((l[0].id(l[2].attr(0,"associated_component",0))).get_long()==EX_TRUE) {
_SL(10164)
if ((SLIT("AP210_ARM.PACKAGED_PART_INTERFACE_TERMINAL").In(::TypeOf(l[2].attr(0,"definition",0)))).get_long()==EX_TRUE) {
_SL(10165)
l[3].assign(l[2].attr(0,"definition",0).attr(0,"external_connector_function",0));
_SL(10166)
result.assign(l[3]);
goto lS18_10174_3;
}
else {
_SL(10168)
result.assign(l[3]);
goto lS18_10174_3;
}
}

else {
_SL(10171)
result.assign(l[3]);
goto lS18_10174_3;
}

_SL(10173)
result.assign(undef_value);
goto lS18_10174_3;
lS18_10174_3: _SL(10174)
return result;
}
EX_ALGORITHM Generic Make_aggregate_joinS18(const Generic& par_ex_input1, const Generic& par_ex_input2, const Generic& par_ex_input3, Env* env) {
ex_restore _res(10176);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(new Set_Type(Entity_Type::get(Inter_stratum_join_relationshipS18_Impl),0, -2), ExStd, "input1", par_ex_input1);
l[1].ct_init(Entity_Type::get(Intra_stratum_join_relationshipS18_Impl), ExStd, "input2", par_ex_input2);
l[2].ct_init(new Set_Type(Entity_Type::get(Stratum_embedded_component_join_relationshipS18_Impl),0, -2), ExStd, "input3", par_ex_input3);
_SL(10183)
l[3].ct_init(new Set_Type(Entity_Type::get(Join_relationshipS18_Impl),0, -2),ExStd,"v1",l[0]);
Generic result(new Set_Type(Entity_Type::get(Join_relationshipS18_Impl),0, -2),ExNoInit,"_result");
_SL(10186)
l[3] += l[1];
_SL(10187)
l[3] += l[2];
_SL(10188)
result.assign(l[3]);
goto lS18_10189_3;
lS18_10189_3: _SL(10189)
return result;
}
EX_ALGORITHM Generic Max_data_elementS18(const Generic& par_ex_input1, const Generic& par_ex_input2, Env* env) {
ex_restore _res(10191);
Generic l[2];
EX_ENV local(l,env,2);
l[0].ct_init(Entity_Type::get(Length_data_elementS18_Impl), ExStd, "input1", par_ex_input1);
l[1].ct_init(Entity_Type::get(Length_data_elementS18_Impl), ExStd, "input2", par_ex_input2);
Generic result(Entity_Type::get(Length_data_elementS18_Impl),ExNoInit,"_result");
_SL(10196)
result.assign(l[0]);
goto lS18_10197_3;
lS18_10197_3: _SL(10197)
return result;
}
EX_ALGORITHM Generic Single_package_versionS18(const Generic& par_ex_input, Env* env) {
ex_restore _res(10199);
Generic l[1];
EX_ENV local(l,env,1);
l[0].ct_init(Entity_Type::get(Packaged_partS18_Impl), ExStd, "input", par_ex_input);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10203)
result.assign(ex_true);
goto lS18_10204_3;
lS18_10204_3: _SL(10204)
return result;
}
EX_ALGORITHM Generic Substrate_in_assemblyS18(const Generic& par_ex_c2dl, Env* env) {
ex_restore _res(10206);
Generic l[1];
EX_ENV local(l,env,1);
l[0].ct_init(Entity_Type::get(Component_2d_locationS18_Impl), ExStd, "c2dl", par_ex_c2dl);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10210)
result.assign(ex_true);
goto lS18_10211_3;
lS18_10211_3: _SL(10211)
return result;
}
EX_ALGORITHM Generic Printed_component_access_mechanismsS18(const Generic& par_ex_input, Env* env) {
ex_restore _res(10213);
Generic l[2];
EX_ENV local(l,env,2);
l[0].ct_init(new Set_Type(Entity_Type::get(Printed_component_linkS18_Impl),0, -2), ExStd, "input", par_ex_input);
_SL(10218)
l[1].ct_init(new Set_Type(Entity_Type::get(Printed_component_join_terminalS18_Impl),0, -2),ExStd,"pcjt",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Printed_component_join_terminalS18_Impl),0, -2),ExNoInit,"_result");
_SL(10221)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[0]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10222)
env->l[1].assign((env->l[0].rindex(l[0]).attr(0,"precedent_printed_component",0).attr(0,"raw_access_mechanism",0)+env->l[1]));
_SL(10223)
env->l[1].assign((env->l[0].rindex(l[0]).attr(0,"subsequent_printed_component",0).attr(0,"raw_access_mechanism",0)+env->l[1]));
_SL(10221)
}
while (EX_TRUE);
}
}

_SL(10225)
result.assign(l[1]);
goto lS18_10226_3;
lS18_10226_3: _SL(10226)
return result;
}
EX_ALGORITHM Generic Printed_part_template_access_mechanismsS18(const Generic& par_ex_input, Env* env) {
ex_restore _res(10228);
Generic l[2];
EX_ENV local(l,env,2);
l[0].ct_init(new Set_Type(Entity_Type::get(Printed_part_template_linkS18_Impl),0, -2), ExStd, "input", par_ex_input);
_SL(10233)
l[1].ct_init(new Set_Type(Entity_Type::get(Printed_part_template_terminalS18_Impl),0, -2),ExStd,"pptt",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Printed_part_template_terminalS18_Impl),0, -2),ExNoInit,"_result");
_SL(10236)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[0]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10237)
env->l[1].assign((env->l[0].rindex(l[0]).attr(0,"precedent_printed_part_template",0).attr(0,"raw_access_mechanisms",0)+env->l[1]));
_SL(10238)
env->l[1].assign((env->l[0].rindex(l[0]).attr(0,"subsequent_printed_part_template",0).attr(0,"raw_access_mechanisms",0)+env->l[1]));
_SL(10236)
}
while (EX_TRUE);
}
}

_SL(10240)
result.assign(l[1]);
goto lS18_10241_3;
lS18_10241_3: _SL(10241)
return result;
}
EX_ALGORITHM Generic Same_stratumS18(const Generic& par_ex_input, Env* env) {
ex_restore _res(10243);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(new Set_Type(Entity_Type::get(Stratum_featureS18_Impl),0, -2), ExStd, "input", par_ex_input);
_SL(10248)
l[1].ct_init(Type::boolean,ExStd,"pass",ex_false);
_SL(10249)
l[2].ct_init(new Set_Type(Entity_Type::get(StratumS18_Impl),0, -2),ExStd,"s",(const Generic*)0);
_SL(10250)
l[3].ct_init(new Set_Type(Entity_Type::get(Printed_part_template_terminalS18_Impl),0, -2),ExStd,"pptt",(const Generic*)0);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10253)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[0]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10254)
env->l[2].assign((env->l[0].rindex(l[0]).attr(0,"resident_stratum",0)+env->l[2]));
_SL(10253)
}
while (EX_TRUE);
}
}

_SL(10256)
l[1].assign((::SizeOf(l[2]).eq(const_one)));
_SL(10257)
result.assign(l[1]);
goto lS18_10258_3;
lS18_10258_3: _SL(10258)
return result;
}
EX_ALGORITHM Generic Valid_constraining_shapeS18(const Generic& par_ex_sd, const Generic& par_ex_eepd, Env* env) {
ex_restore _res(10260);
Generic l[2];
EX_ENV local(l,env,2);
l[0].ct_init(new Set_Type(Entity_Type::get(Shape_definitionS18_Impl),0, -2), ExStd, "sd", par_ex_sd);
l[1].ct_init(Entity_Type::get(Ee_product_definitionS18_Impl), ExStd, "eepd", par_ex_eepd);
Generic result(Type::boolean,ExNoInit,"_result");
_SL(10265)
result.assign(ex_true);
goto lS18_10266_3;
lS18_10266_3: _SL(10266)
return result;
}
EX_ALGORITHM Generic Get_product_from_classificationS18(const Generic& par_ex_input1, const Generic& par_ex_input2, const Generic& par_ex_input3, Env* env) {
ex_restore _res(10273);
Generic l[9];
EX_ENV local(l,env,9);
l[0].ct_init(new Set_Type(Entity_Type::get(Model_parameterS18_Impl),0, -2), ExStd, "input1", par_ex_input1);
l[1].ct_init(Type::string, ExStd, "input2", par_ex_input2);
l[2].ct_init(Type::string, ExStd, "input3", par_ex_input3);
_SL(10293)
l[3].ct_init(new Set_Type(Entity_Type::get(Category_model_parameterS18_Impl),0, -2),ExStd,"cmp",Q76S16(&local));
_SL(10296)
l[4].ct_init(new Bag_Type(Entity_Type::get(Parameter_assignmentS18_Impl),0, -2),ExStd,"pa",(const Generic*)0);
_SL(10297)
l[5].ct_init(new Bag_Type(Entity_Type::get(Ee_product_categoryS18_Impl),0, -2),ExStd,"epc",(const Generic*)0);
_SL(10298)
l[6].ct_init(new Set_Type(Entity_Type::get(Ee_productS18_Impl),0, -2),ExStd,"pro",(const Generic*)0);
_SL(10300)
l[7].ct_init(new Set_Type(Entity_Type::get(Parameter_assignmentS18_Impl),0, -2),ExStd,"pas",undef_value);
_SL(10302)
l[8].ct_init(new Set_Type(Entity_Type::get(Ee_product_related_product_categoryS18_Impl),0, -2),ExStd,"eeprpcs",undef_value);
Generic result(new Set_Type(Entity_Type::get(Ee_productS18_Impl),0, -2),ExNoInit,"_result");
_SL(10307)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[3]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10308)
env->l[4] += Q77S16(&local);
_SL(10307)
}
while (EX_TRUE);
}
}

_SL(10316)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[4]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10317)
env->l[5] += Q78S16(&local);
_SL(10316)
}
while (EX_TRUE);
}
}

_SL(10322)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[5]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10323)
env->l[6] += env->l[5].rindex(l[0]).attr(0,"of_product",0);
_SL(10322)
}
while (EX_TRUE);
}
}

_SL(10326)
result.assign(l[6]);
goto lS18_10327_3;
lS18_10327_3: _SL(10327)
return result;
}
EX_ALGORITHM Generic Get_product_from_categoryS18(const Generic& par_ex_input1, const Generic& par_ex_input2, Env* env) {
ex_restore _res(10329);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(new Set_Type(Entity_Type::get(Ee_product_related_product_categoryS18_Impl),0, -2), ExStd, "input1", par_ex_input1);
l[1].ct_init(Type::string, ExStd, "input2", par_ex_input2);
_SL(10342)
l[2].ct_init(new Set_Type(Entity_Type::get(Ee_product_related_product_categoryS18_Impl),0, -2),ExStd,"eeprpcs",Q79S16(&local));
_SL(10345)
l[3].ct_init(new Set_Type(Entity_Type::get(Ee_productS18_Impl),0, -2),ExStd,"pro",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Ee_productS18_Impl),0, -2),ExNoInit,"_result");
_SL(10349)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[2]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10350)
env->l[3] += env->l[2].rindex(l[0]).attr(0,"of_product",0);
_SL(10349)
}
while (EX_TRUE);
}
}

_SL(10353)
result.assign(l[3]);
goto lS18_10354_3;
lS18_10354_3: _SL(10354)
return result;
}
EX_ALGORITHM Generic Get_product_definition_from_productS18(const Generic& par_ex_input1, const Generic& par_ex_input2, Env* env) {
ex_restore _res(10356);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(new Set_Type(Entity_Type::get(Ee_productS18_Impl),0, -2), ExStd, "input1", par_ex_input1);
l[1].ct_init(Type::string, ExStd, "input2", par_ex_input2);
_SL(10369)
l[2].ct_init(new Set_Type(Entity_Type::get(Ee_product_versionS18_Impl),0, -2),ExStd,"eepvs",(const Generic*)0);
_SL(10370)
l[3].ct_init(new Set_Type(Entity_Type::get(Ee_product_definitionS18_Impl),0, -2),ExStd,"eepds",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Ee_product_definitionS18_Impl),0, -2),ExNoInit,"_result");
_SL(10374)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[0]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10375)
env->l[2] += env->l[0].rindex(l[0]).attr(0,"product_version",0);
_SL(10374)
}
while (EX_TRUE);
}
}

_SL(10379)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[2]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10380)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(env->l[2].rindex(l[0]).attr(0,"product_definition",0)).get_long();
long _incr = 1;
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"j", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10381)
env->env->l[3] += Q80S16(&local);
_SL(10380)
}
while (EX_TRUE);
}
}
_SL(10379)
}
while (EX_TRUE);
}
}

_SL(10386)
result.assign(l[3]);
goto lS18_10387_3;
lS18_10387_3: _SL(10387)
return result;
}
EX_ALGORITHM Generic Get_fiducial_part_feature_shapeS18(const Generic& par_ex_input1, const Generic& par_ex_input2, Env* env) {
ex_restore _res(10389);
Generic l[7];
EX_ENV local(l,env,7);
l[0].ct_init(Entity_Type::get(Interconnect_module_usage_viewS18_Impl), ExStd, "input1", par_ex_input1);
l[1].ct_init(Entity_Type::get(Physical_unit_planar_shapeS18_Impl), ExStd, "input2", par_ex_input2);
_SL(10403)
l[2].ct_init(new Set_Type(Entity_Type::get(Usage_concept_usage_relationshipS18_Impl),0, -2),ExStd,"ucurs",(const Generic*)0);
_SL(10404)
l[3].ct_init(new Bag_Type(Entity_Type::get(Part_featureS18_Impl),0, -2),ExStd,"pfs",::UsedIn(l[0], SLIT("AP210_ARM.PART_FEATURE.ASSOCIATED_DEFINITION")));
_SL(10406)
l[4].ct_init(new Set_Type(Entity_Type::get(Fiducial_part_featureS18_Impl),0, -2),ExStd,"fpfs",(const Generic*)0);
_SL(10407)
l[5].ct_init(Type::boolean,ExStd,"pass",ex_false);
_SL(10408)
l[6].ct_init(new Set_Type(Entity_Type::get(Usage_concept_usage_relationshipS18_Impl),0, -2),ExStd,"tmp",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Usage_concept_usage_relationshipS18_Impl),0, -2),ExNoInit,"_result");
_SL(10412)
l[5].assign((l[1].attr(0,"shape_characterized_physical_unit",0).eq(l[0])));
_SL(10416)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[3]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10417)
if ((SLIT("AP210_ARM.FIDUCIAL_PART_FEATURE").In(::TypeOf(env->l[3].rindex(l[0])))).get_long()==EX_TRUE) {
_SL(10419)
env->l[4] += env->l[3].rindex(l[0]);
}
_SL(10416)
}
while (EX_TRUE);
}
}

_SL(10425)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[4]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10426)
env->l[2] += Q81S16(&local);
_SL(10425)
}
while (EX_TRUE);
}
}

_SL(10430)
result.assign(l[2]);
goto lS18_10431_3;
lS18_10431_3: _SL(10431)
return result;
}
EX_ALGORITHM Generic Get_interfacial_connection_from_interconnectS18(const Generic& par_ex_input1, Env* env) {
ex_restore _res(10435);
Generic l[4];
EX_ENV local(l,env,4);
l[0].ct_init(Entity_Type::get(Interconnect_moduleS18_Impl), ExStd, "input1", par_ex_input1);
_SL(10445)
l[1].ct_init(new Bag_Type(Entity_Type::get(Next_higher_assembly_relationshipS18_Impl),0, -2),ExStd,"nhar",::UsedIn(l[0], SLIT("AP210_ARM.NEXT_HIGHER_ASSEMBLY_RELATIONSHIP.ASSEMBLY")));
_SL(10447)
l[2].ct_init(new Set_Type(Entity_Type::get(Assembly_componentS18_Impl),0, -2),ExStd,"ac",(const Generic*)0);
_SL(10448)
l[3].ct_init(new Set_Type(Entity_Type::get(Interfacial_connectionS18_Impl),0, -2),ExStd,"ic",(const Generic*)0);
Generic result(new Set_Type(Entity_Type::get(Interfacial_connectionS18_Impl),0, -2),ExNoInit,"_result");
_SL(10452)
{
short _inc = 0;
long _bound_1 = const_one.get_long();
long _bound_2 = ::SizeOf(l[1]).get_long();
long _incr = const_one.get_long();
if (_bound_1 <= _bound_2 && _incr > 0 || _bound_1 >= _bound_2 && _incr < 0) {
Generic l[1];
l->ct_init(Type::number, ExNoInit,"i", ILIT(_bound_1));
EX_ENV* env=&local;
EX_ENV local(l,env,1);
do {
if (_inc==1) *l +=_incr;
else if (_inc==2) break;
else _inc=1;
long _idx=l->get_long()+_incr;
if (_idx > _bound_2 && _incr > 0 || _idx < _bound_2 && _incr < 0) _inc=2;
_SL(10453)
if ((SLIT("AP210_ARM.INTERFACIAL_CONNECTION").In(::TypeOf(env->l[1].rindex(l[0]).attr(0,"component",0)))).get_long()==EX_TRUE) {
_SL(10455)
env->l[2] += env->l[1].rindex(l[0]).attr(0,"component",0);
}
_SL(10452)
}
while (EX_TRUE);
}
}

_SL(10459)
result.assign(l[2]);
goto lS18_10460_1;
lS18_10460_1: _SL(10460)
return result;
}
